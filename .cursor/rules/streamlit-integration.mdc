---
description: Streamlit integration patterns and best practices
---

# Streamlit Integration Patterns

## Component Architecture

The library integrates with Streamlit through a custom component system:

- **Component Function**: [streamlit_lightweight_charts_pro/component.py](mdc:streamlit_lightweight_charts_pro/component.py) - Main component interface
- **Frontend**: React-based chart rendering with lightweight-charts
- **Communication**: JSON-based data exchange between Python and frontend

## Usage Patterns

### Basic Chart Rendering
```python
import streamlit as st
from streamlit_lightweight_charts_pro import Chart, LineSeries
from streamlit_lightweight_charts_pro.data import SingleValueData

# Create data
data = [SingleValueData("2024-01-01", 100), SingleValueData("2024-01-02", 105)]

# Create and render chart
chart = Chart(series=LineSeries(data, color="#ff0000"))
chart.render(key="my_chart")
```

### Fluent API Pattern
```python
# Method chaining for complex charts
chart = (Chart()
         .add_series(LineSeries(data, color="#ff0000"))
         .add_series(AreaSeries(data2, color="#00ff00"))
         .update_options(height=400, width=800)
         .add_annotation(create_text_annotation("2024-01-01", 100, "Start")))
chart.render(key="complex_chart")
```

### Pandas Integration
```python
import pandas as pd

# Load data from CSV
df = pd.read_csv('stock_data.csv', index_col='date', parse_dates=True)

# Create chart from DataFrame
chart = Chart(series=CandlestickSeries.from_dataframe(
    df=df,
    column_mapping={
        'time': 'date',
        'open': 'open',
        'high': 'high',
        'low': 'low',
        'close': 'close'
    }
))
chart.render(key="stock_chart")
```

## Component Lifecycle

1. **Initialization**: Component function created on first import
2. **Configuration**: Chart options and data serialized to JSON
3. **Rendering**: React component renders chart using lightweight-charts
4. **Updates**: Chart updates when data or options change
5. **Cleanup**: Resources cleaned up when component unmounts

## Key Integration Points

### Data Serialization
- **Python to JSON**: Chart configuration serialized for frontend
- **Type Safety**: Type hints ensure data integrity
- **Validation**: Input validation before serialization

### Event Handling
- **User Interactions**: Mouse clicks, zoom, pan events
- **Chart Events**: Data point selection, annotation clicks
- **State Management**: Chart state synchronized between Python and frontend

### Performance Considerations
- **Data Size**: Efficient serialization for large datasets
- **Rendering**: Optimized chart rendering for performance
- **Memory**: Proper cleanup of chart instances and event listeners
- **Caching**: Strategic caching of chart configurations and data
- **Lazy Loading**: Load chart components only when needed

## Best Practices

### Chart Keys
- **Unique Keys**: Always use unique keys for multiple charts
- **Stable Keys**: Use stable keys for chart persistence
- **Naming**: Use descriptive key names

### State Management
- **Session State**: Use Streamlit session state for chart persistence
- **Data Caching**: Cache expensive data operations
- **Update Optimization**: Only update charts when data changes

### Error Handling
- **Graceful Degradation**: Handle missing data gracefully
- **User Feedback**: Provide clear error messages
- **Logging**: Log errors for debugging

## Performance Optimization

### **1. Memory Management**
```python
# ✅ CORRECT: Efficient memory usage
import streamlit as st
from functools import lru_cache

# Cache expensive data processing
@lru_cache(maxsize=32)
def process_chart_data(raw_data: tuple) -> list:
    """Process and cache chart data."""
    return [SingleValueData(item[0], item[1]) for item in raw_data]

# Use session state for chart persistence
if 'chart_data' not in st.session_state:
    st.session_state.chart_data = load_large_dataset()

# Clean up unused charts
def cleanup_charts():
    """Remove charts that are no longer needed."""
    if 'old_charts' in st.session_state:
        del st.session_state.old_charts
```

### **2. Data Serialization Optimization**
```python
# ✅ CORRECT: Optimized data serialization
import json
from typing import Any, Dict

def serialize_chart_data(data: list) -> str:
    """Serialize chart data efficiently."""
    # Use compact JSON serialization
    return json.dumps(data, separators=(',', ':'), ensure_ascii=False)

# Batch data updates
def update_chart_data_batch(updates: Dict[str, Any]) -> None:
    """Update multiple chart properties in one operation."""
    chart_config = st.session_state.get('chart_config', {})
    chart_config.update(updates)
    st.session_state.chart_config = chart_config
```

### **3. Component Lifecycle Management**
```python
# ✅ CORRECT: Proper component lifecycle
import streamlit as st
from contextlib import contextmanager

@contextmanager
def chart_component(key: str):
    """Context manager for chart component lifecycle."""
    try:
        # Initialize chart
        chart = Chart(key=key)
        yield chart
    finally:
        # Cleanup resources
        if hasattr(chart, 'cleanup'):
            chart.cleanup()

# Usage
with chart_component("my_chart") as chart:
    chart.add_series(LineSeries(data))
    chart.render()
```

### **4. Caching Strategies**
```python
# ✅ CORRECT: Strategic caching
import streamlit as st
from functools import lru_cache
import hashlib

# Cache based on data hash
def get_data_hash(data: list) -> str:
    """Generate hash for data caching."""
    data_str = str(sorted(data, key=lambda x: x.time))
    return hashlib.md5(data_str.encode()).hexdigest()

@st.cache_data
def load_chart_data(file_path: str) -> list:
    """Load and cache chart data."""
    return load_data_from_file(file_path)

# Cache chart configurations
@st.cache_data
def get_chart_config(chart_type: str, options: dict) -> dict:
    """Cache chart configurations."""
    return create_chart_config(chart_type, options)
```

### **5. Lazy Loading Patterns**
```python
# ✅ CORRECT: Lazy loading for performance
import streamlit as st

def render_chart_on_demand(key: str, data: list) -> None:
    """Render chart only when needed."""
    if st.button(f"Show Chart {key}"):
        chart = Chart(series=LineSeries(data))
        chart.render(key=key)

# Conditional chart rendering
def render_conditional_charts(data: dict) -> None:
    """Render charts based on conditions."""
    for chart_name, chart_data in data.items():
        if st.checkbox(f"Show {chart_name}"):
            chart = Chart(series=LineSeries(chart_data))
            chart.render(key=chart_name)
```

### **6. Memory Profiling and Monitoring**
```python
# ✅ CORRECT: Memory monitoring
import psutil
import streamlit as st
import gc

def log_memory_usage(operation: str) -> None:
    """Log memory usage for monitoring."""
    process = psutil.Process()
    memory_mb = process.memory_info().rss / 1024 / 1024
    st.write(f"Memory after {operation}: {memory_mb:.1f} MB")

def cleanup_memory() -> None:
    """Force garbage collection."""
    gc.collect()
    log_memory_usage("cleanup")

# Monitor chart memory usage
def create_chart_with_monitoring(data: list, key: str) -> None:
    """Create chart with memory monitoring."""
    log_memory_usage("before chart creation")

    chart = Chart(series=LineSeries(data))
    chart.render(key=key)

    log_memory_usage("after chart creation")

    # Cleanup if memory usage is high
    if psutil.Process().memory_info().rss / 1024 / 1024 > 500:
        cleanup_memory()
```

## Development vs Production

- **Development**: Hot reloading and debugging support
- **Production**: Optimized builds and error handling
- **Configuration**: Environment-specific settings
- **Performance**: Memory monitoring and optimization
- **Caching**: Strategic data and configuration caching
