---
globs: *.tsx,*.ts
description: React integration patterns and best practices for Lightweight Charts wrapper components
---

# React Integration Patterns

## Overview

This document outlines the React integration patterns implemented in the LightweightCharts component, based on best practices from leading React wrapper libraries and React 19 optimizations.

## üéØ Core Patterns

### 1. Synchronous Initialization with useLayoutEffect

**Rule**: Always use `useLayoutEffect` for chart initialization to prevent visual flicker.

**Why**: `useEffect` runs after browser paint, causing a flash of empty/incorrect content. `useLayoutEffect` runs synchronously after DOM mutations but before browser paint, ensuring charts are initialized before the user sees them.

**Implementation**:
```typescript
// ‚úÖ CORRECT: useLayoutEffect for synchronous chart initialization
useLayoutEffect(() => {
  if (deferredConfig && deferredConfig.charts && deferredConfig.charts.length > 0) {
    // Call initializeCharts synchronously - do NOT wrap in startTransition
    // startTransition makes it async, which breaks timing for fitContent
    initializeCharts(true);
  }
}, [deferredConfig, initializeCharts]);
```

**‚ùå WRONG**: Using useEffect for chart initialization
```typescript
// This causes visual flicker
useEffect(() => {
  initializeCharts(true);
}, [deferredConfig]);
```

**‚ùå WRONG**: Wrapping useLayoutEffect in startTransition
```typescript
// This breaks synchronous timing and causes fitContent issues
useLayoutEffect(() => {
  startTransition(() => {
    initializeCharts(true); // ‚ùå Async execution defeats useLayoutEffect purpose
  });
}, [deferredConfig, initializeCharts, startTransition]);
```

**When to use**:
- Chart instance creation
- Canvas initialization
- DOM measurements that affect rendering
- Synchronous layout operations

**When NOT to use**:
- Data fetching (use useEffect)
- Event listener setup for user interactions (use useEffect)
- Analytics/logging (use useEffect)

**‚ö†Ô∏è CRITICAL**: Do NOT wrap useLayoutEffect content in `startTransition`
- `useLayoutEffect` is synchronous by design
- `startTransition` makes operations async, breaking the synchronous guarantee
- This causes timing issues with operations like `fitContent` that depend on charts being fully initialized
- If you need non-blocking updates, use them in separate `useEffect` hooks, not in `useLayoutEffect`

### 2. Imperative Handle Pattern

**Rule**: Expose imperative APIs via `forwardRef` and `useImperativeHandle` for programmatic control.

**Why**: React is declarative, but chart libraries often need imperative control (fit content, resize, get instances). The imperative handle pattern provides this without breaking React's paradigms.

**Implementation**:

```typescript
// 1. Define the imperative API interface
export interface LightweightChartsHandle {
  getChart(chartId: string): IChartApi | undefined;
  getCharts(): Record<string, IChartApi>;
  getSeries(chartId: string): ISeriesApi<any>[] | undefined;
  getAllSeries(): Record<string, ISeriesApi<any>[]>;
  fitContent(chartId?: string): void;
  resize(width: number, height: number, chartId?: string): void;
  reinitialize(): void;
  cleanup(): void;
}

// 2. Wrap component with forwardRef
const LightweightCharts = React.memo(
  forwardRef<LightweightChartsHandle, LightweightChartsProps>(
    ({ config, height, width, onChartsReady, configChange }, ref) => {
      // Component implementation...

      // 3. Expose imperative API with useImperativeHandle
      useImperativeHandle(
        ref,
        () => ({
          getChart(chartId: string): IChartApi | undefined {
            return chartRefs.current[chartId];
          },

          getCharts(): Record<string, IChartApi> {
            return { ...chartRefs.current };
          },

          fitContent(chartId?: string): void {
            if (chartId) {
              const chart = chartRefs.current[chartId];
              if (chart) {
                chart.timeScale().fitContent();
              }
            } else {
              Object.values(chartRefs.current).forEach(chart => {
                if (chart) {
                  chart.timeScale().fitContent();
                }
              });
            }
          },

          // ... other methods
        }),
        [initializeCharts]
      );

      return <div>{/* chart components */}</div>;
    }
  )
);
```

**Usage**:
```typescript
// Parent component
function ChartApp() {
  const chartRef = useRef<LightweightChartsHandle>(null);

  const handleFitContent = () => {
    chartRef.current?.fitContent();
  };

  const handleGetChart = () => {
    const chart = chartRef.current?.getChart('chart-0');
    console.log(chart?.timeScale().getVisibleRange());
  };

  return (
    <>
      <button onClick={handleFitContent}>Fit Content</button>
      <button onClick={handleGetChart}>Get Chart</button>
      <LightweightCharts ref={chartRef} config={config} />
    </>
  );
}
```

**Best Practices**:
- ‚úÖ Always define TypeScript interface for imperative handle
- ‚úÖ Document each method with JSDoc comments
- ‚úÖ Include usage examples in interface documentation
- ‚úÖ Memoize dependencies in useImperativeHandle second parameter
- ‚úÖ Return defensive copies of internal state (spread maps/arrays)
- ‚úÖ Handle optional parameters (e.g., chartId?) for batch operations
- ‚ùå Don't expose raw refs or internal state directly
- ‚ùå Don't include methods that could break React's control flow

### 3. Helper Hooks Pattern

**Rule**: Extract complex logic into custom hooks for reusability and testability.

**Why**: Large components become hard to maintain. Helper hooks:
- Improve code organization and readability
- Enable independent testing of logic
- Allow reuse across components
- Follow single responsibility principle

#### 3.1 useChartResize Hook

**Purpose**: Manage chart resize operations with debouncing and ResizeObserver.

**Location**: `src/hooks/useChartResize.ts`

**Implementation**:
```typescript
export interface UseChartResizeOptions {
  width: number | null;
  height: number | null;
  debounceMs?: number; // Default: 100ms
}

export function useChartResize(options: UseChartResizeOptions) {
  const { width, height, debounceMs = 100 } = options;

  const resizeObserverRef = useRef<ResizeObserver | null>(null);
  const debounceTimersRef = useRef<{ [key: string]: NodeJS.Timeout }>({});

  const getContainerDimensions = useCallback((container: HTMLElement) => {
    const rect = container.getBoundingClientRect();
    return { width: rect.width, height: rect.height };
  }, []);

  const setupAutoSizing = useCallback(
    (chart: IChartApi, container: HTMLElement, chartConfig: ChartConfig) => {
      if (chartConfig.autoSize || chartConfig.autoWidth || chartConfig.autoHeight) {
        const observer = new ResizeObserver(() => {
          debouncedResizeHandler(chartId, chart, container, chartConfig);
        });
        observer.observe(container);
        resizeObserverRef.current = observer;
      }
    },
    [debouncedResizeHandler]
  );

  const cleanup = useCallback(() => {
    if (resizeObserverRef.current) {
      resizeObserverRef.current.disconnect();
      resizeObserverRef.current = null;
    }
    Object.values(debounceTimersRef.current).forEach(timer => {
      clearTimeout(timer);
    });
    debounceTimersRef.current = {};
  }, []);

  return { getContainerDimensions, setupAutoSizing, resizeChart, cleanup };
}
```

**Usage**:
```typescript
const LightweightCharts = ({ config, width, height }) => {
  const { setupAutoSizing, cleanup } = useChartResize({ width, height });

  useLayoutEffect(() => {
    const chart = createChart(container, options);
    setupAutoSizing(chart, container, chartConfig);

    return cleanup;
  }, []);
};
```

**Best Practices**:
- ‚úÖ Use debouncing to prevent excessive resize calls (100ms default)
- ‚úÖ Use ResizeObserver for efficient dimension tracking
- ‚úÖ Clean up observers on unmount to prevent memory leaks
- ‚úÖ Use useCallback to memoize handlers
- ‚úÖ Use getBoundingClientRect() for accurate dimensions
- ‚ùå Don't use offsetWidth/offsetHeight (less accurate)
- ‚ùå Don't forget cleanup in unmount

#### 3.2 useSeriesUpdate Hook

**Purpose**: Manage series configuration updates with format mapping.

**Location**: `src/hooks/useSeriesUpdate.ts`

**Implementation**:
```typescript
export interface SeriesConfigPatch {
  visible?: boolean;
  last_value_visible?: boolean;
  price_line?: boolean;
  color?: string;
  line_width?: number;
  line_style?: number;
  markers?: boolean;
  title?: string;
}

export function useSeriesUpdate(options: UseSeriesUpdateOptions) {
  const { configChange, chartRefs, seriesRefs } = options;

  const mapDialogConfigToAPI = useCallback((configPatch: SeriesConfigPatch) => {
    const apiConfig: Record<string, any> = {};

    // Map snake_case to camelCase
    if ('visible' in configPatch) apiConfig.visible = configPatch.visible;
    if ('last_value_visible' in configPatch) {
      apiConfig.lastValueVisible = configPatch.last_value_visible;
    }
    if ('price_line' in configPatch) {
      apiConfig.priceLineVisible = configPatch.price_line;
    }

    return apiConfig;
  }, []);

  const applySeriesConfig = useCallback(
    (paneId: string, seriesId: string, configPatch: SeriesConfigPatch) => {
      Object.entries(chartRefs.current).forEach(([chartId, chart]) => {
        const chartSeries = seriesRefs.current[chartId] || [];
        chartSeries.forEach((series, index) => {
          const expectedSeriesId = `pane-${paneId}-series-${index}`;
          if (seriesId === expectedSeriesId) {
            const apiConfig = mapDialogConfigToAPI(configPatch);
            if (Object.keys(apiConfig).length > 0) {
              series.applyOptions(apiConfig);
            }
          }
        });
      });
    },
    [chartRefs, seriesRefs, mapDialogConfigToAPI]
  );

  // Auto-apply config changes
  useEffect(() => {
    if (!configChange) return;
    const { paneId, seriesId, configPatch } = configChange;
    applySeriesConfig(paneId, seriesId, configPatch);
  }, [configChange, applySeriesConfig]);

  return { applySeriesConfig, mapDialogConfigToAPI };
}
```

**Usage**:
```typescript
const LightweightCharts = ({ configChange, chartRefs, seriesRefs }) => {
  const { applySeriesConfig } = useSeriesUpdate({
    configChange,
    chartRefs,
    seriesRefs,
  });

  // Manual config application
  const handleUpdateSeries = () => {
    applySeriesConfig('pane-0', 'pane-0-series-0', {
      visible: true,
      color: '#2962FF',
    });
  };
};
```

**Best Practices**:
- ‚úÖ Batch configuration updates to minimize reflows
- ‚úÖ Map between different naming conventions (snake_case ‚Üî camelCase)
- ‚úÖ Only update changed properties (partial updates)
- ‚úÖ Use useEffect for automatic config application
- ‚úÖ Memoize handlers with useCallback
- ‚ùå Don't apply unchanged values
- ‚ùå Don't forget error handling

## üîß React 19 Optimizations

### 1. Concurrent Features

**useTransition**: Wrap heavy operations in transitions for non-blocking updates.

```typescript
const [isPending, startTransition] = useTransition();

useLayoutEffect(() => {
  if (deferredConfig && deferredConfig.charts && deferredConfig.charts.length > 0) {
    // Wrap heavy chart operations in startTransition
    startTransition(() => {
      initializeCharts(true);
    });
  }
}, [deferredConfig, initializeCharts, startTransition]);
```

**useDeferredValue**: Defer non-urgent updates to improve responsiveness.

```typescript
const deferredConfig = useDeferredValue(config);

// Use deferredConfig for rendering
const chartContainers = useMemo(() => {
  if (!deferredConfig) return [];
  return deferredConfig.charts.map(chartConfig => {
    // Render chart containers
  });
}, [deferredConfig]);
```

### 2. Performance Monitoring

**Integration with react19PerformanceMonitor**:

```typescript
import { react19Monitor } from './utils/react19PerformanceMonitor';

// Track transitions
const transitionId = react19Monitor.startTransition('ChartInit', 'chart');
// ... chart initialization
react19Monitor.endTransition(transitionId);

// Get performance report
const report = react19Monitor.getPerformanceReport();
console.log('Performance score:', report.score);
console.log('Recommendations:', report.recommendations);
```

## üìã Component Checklist

When creating or refactoring chart components:

### Initialization
- [ ] Use `useLayoutEffect` for chart initialization
- [ ] Wrap heavy operations in `startTransition`
- [ ] Use `useDeferredValue` for non-urgent updates
- [ ] Clean up resources on unmount

### Imperative API
- [ ] Define TypeScript interface for imperative handle
- [ ] Implement `forwardRef` wrapper
- [ ] Use `useImperativeHandle` to expose methods
- [ ] Document all methods with JSDoc
- [ ] Include usage examples in documentation

### Helper Hooks
- [ ] Extract resize logic into `useChartResize`
- [ ] Extract series update logic into `useSeriesUpdate`
- [ ] Memoize all callbacks with `useCallback`
- [ ] Clean up resources in hook cleanup functions

### Performance
- [ ] Memoize expensive computations with `useMemo`
- [ ] Use `React.memo` to prevent unnecessary re-renders
- [ ] Implement debouncing for rapid operations (resize, etc.)
- [ ] Use ResizeObserver instead of window resize events

### Memory Management
- [ ] Clean up chart instances on unmount
- [ ] Disconnect ResizeObservers
- [ ] Clear timers and intervals
- [ ] Remove event listeners
- [ ] Clean up refs

## üö´ Anti-Patterns to Avoid

### ‚ùå WRONG: useEffect for chart initialization
```typescript
// Causes visual flicker
useEffect(() => {
  const chart = createChart(container, options);
}, []);
```

### ‚ùå WRONG: No imperative handle
```typescript
// No way to programmatically control chart
const LightweightCharts = ({ config }) => {
  const chartRef = useRef<IChartApi>(null);
  return <div ref={chartRef} />;
};
```

### ‚ùå WRONG: Large monolithic component
```typescript
// All logic in one component (2000+ lines)
const LightweightCharts = ({ config }) => {
  // 500 lines of resize logic
  const handleResize = () => { /* ... */ };

  // 500 lines of series update logic
  const updateSeries = () => { /* ... */ };

  // 500 lines of initialization logic
  const initCharts = () => { /* ... */ };

  // ...
};
```

### ‚ùå WRONG: No debouncing on resize
```typescript
// Triggers hundreds of resize operations
window.addEventListener('resize', () => {
  chart.resize(window.innerWidth, window.innerHeight);
});
```

### ‚ùå WRONG: Exposing raw internal state
```typescript
// Exposes mutable refs directly
useImperativeHandle(ref, () => ({
  chartRefs: chartRefs.current, // ‚ùå Direct access to internal state
  seriesRefs: seriesRefs.current, // ‚ùå Can be mutated externally
}));
```

## ‚úÖ Complete Example

**src/components/LightweightCharts.tsx**:
```typescript
import React, {
  useEffect,
  useLayoutEffect,
  useRef,
  useCallback,
  useMemo,
  useTransition,
  useDeferredValue,
  forwardRef,
  useImperativeHandle,
} from 'react';
import { IChartApi, ISeriesApi } from 'lightweight-charts';
import { useChartResize } from '../hooks/useChartResize';
import { useSeriesUpdate } from '../hooks/useSeriesUpdate';

/**
 * Imperative API exposed via ref
 */
export interface LightweightChartsHandle {
  getChart(chartId: string): IChartApi | undefined;
  fitContent(chartId?: string): void;
  resize(width: number, height: number, chartId?: string): void;
}

interface LightweightChartsProps {
  config: ComponentConfig;
  height?: number;
  width?: number;
}

/**
 * LightweightCharts Component with React 19 Optimizations
 *
 * Performance Best Practices:
 * - Uses useLayoutEffect for synchronous chart initialization
 * - Memoized with React.memo
 * - Supports forwardRef for imperative control
 * - Uses useTransition for non-blocking updates
 */
const LightweightCharts = React.memo(
  forwardRef<LightweightChartsHandle, LightweightChartsProps>(
    ({ config, height = 400, width = null }, ref) => {
      // React 19 concurrent features
      const [isPending, startTransition] = useTransition();
      const deferredConfig = useDeferredValue(config);

      // Refs
      const chartRefs = useRef<{ [key: string]: IChartApi }>({});
      const seriesRefs = useRef<{ [key: string]: ISeriesApi<any>[] }>({});

      // Helper hooks
      const { setupAutoSizing, cleanup: cleanupResize } = useChartResize({
        width,
        height,
      });

      useSeriesUpdate({
        configChange: null,
        chartRefs,
        seriesRefs,
      });

      // Imperative API
      useImperativeHandle(
        ref,
        () => ({
          getChart(chartId: string): IChartApi | undefined {
            return chartRefs.current[chartId];
          },

          fitContent(chartId?: string): void {
            if (chartId) {
              chartRefs.current[chartId]?.timeScale().fitContent();
            } else {
              Object.values(chartRefs.current).forEach(chart => {
                chart?.timeScale().fitContent();
              });
            }
          },

          resize(width: number, height: number, chartId?: string): void {
            if (chartId) {
              chartRefs.current[chartId]?.resize(width, height);
            } else {
              Object.values(chartRefs.current).forEach(chart => {
                chart?.resize(width, height);
              });
            }
          },
        }),
        []
      );

      // Synchronous chart initialization
      useLayoutEffect(() => {
        if (deferredConfig?.charts?.length > 0) {
          startTransition(() => {
            // Initialize charts...
          });
        }
      }, [deferredConfig, startTransition]);

      // Cleanup on unmount
      useEffect(() => {
        return () => {
          cleanupResize();
          Object.values(chartRefs.current).forEach(chart => {
            chart.remove();
          });
        };
      }, [cleanupResize]);

      return <div>{/* chart containers */}</div>;
    }
  )
);

export default LightweightCharts;
```

## üìö References

### Official Documentation
- [TradingView Lightweight Charts](https://tradingview.github.io/lightweight-charts/)
- [React 19 Documentation](https://react.dev/)
- [React useLayoutEffect](https://react.dev/reference/react/useLayoutEffect)
- [React forwardRef](https://react.dev/reference/react/forwardRef)
- [React useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)

### Inspiration Sources
- [lightweight-charts-react-wrapper](https://github.com/trash-and-fire/lightweight-charts-react-wrapper)
- [lightweight-charts-react-components](https://github.com/ukorvl/lightweight-charts-react-components)
- [TradingView React Tutorial](https://tradingview.github.io/lightweight-charts/tutorials/react/advanced)

### Implementation Files
- [src/LightweightCharts.tsx](mdc:streamlit_lightweight_charts_pro/frontend/src/LightweightCharts.tsx) - Main component
- [src/hooks/useChartResize.ts](mdc:streamlit_lightweight_charts_pro/frontend/src/hooks/useChartResize.ts) - Resize hook
- [src/hooks/useSeriesUpdate.ts](mdc:streamlit_lightweight_charts_pro/frontend/src/hooks/useSeriesUpdate.ts) - Series update hook

---

**Status**: ‚úÖ **ACTIVE** - Phase 1 React integration patterns implemented
**Last Updated**: October 2024
**Next Phase**: Component-based API (Phase 2)
