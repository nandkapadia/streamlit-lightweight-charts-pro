---
description: Comprehensive architecture patterns including overall design principles and chart API patterns
---

# Architecture Patterns

## Overall Architecture

The project follows a clean architecture pattern with clear separation of concerns:

- **Python Backend**: Chart logic, data models, and Streamlit integration
- **React Frontend**: UI components and chart rendering
- **Component Bridge**: Streamlit component for Python-React communication

## Python Package Structure

### Core Components
- **Chart**: [streamlit_lightweight_charts_pro/charts/chart.py](mdc:streamlit_lightweight_charts_pro/charts/chart.py) - Main chart implementation
- **Series**: [streamlit_lightweight_charts_pro/charts/series/](mdc:streamlit_lightweight_charts_pro/charts/series/) - Chart series types
- **Options**: [streamlit_lightweight_charts_pro/charts/options/](mdc:streamlit_lightweight_charts_pro/charts/options/) - Configuration options
- **Data**: [streamlit_lightweight_charts_pro/data/](mdc:streamlit_lightweight_charts_pro/data/) - Data models and structures

### Design Patterns

#### Fluent API Pattern
```python
# Method chaining for intuitive API
chart = (Chart()
         .add_series(LineSeries(data))
         .update_options(height=400)
         .add_annotation(annotation))
```

#### Factory Pattern
```python
# Series factory for creating series from data
series = SeriesFactory.create_line_series(data, options)
```

#### Strategy Pattern
```python
# Different rendering strategies for different chart types
renderer = ChartRendererFactory.get_renderer(chart_type)
```

## Frontend Architecture

### Component Structure
- **Components**: [streamlit_lightweight_charts_pro/frontend/src/components/](mdc:streamlit_lightweight_charts_pro/frontend/src/components/) - React components
- **Services**: [streamlit_lightweight_charts_pro/frontend/src/services/](mdc:streamlit_lightweight_charts_pro/frontend/src/services/) - Business logic
- **Managers**: [streamlit_lightweight_charts_pro/frontend/src/managers/](mdc:streamlit_lightweight_charts_pro/frontend/src/managers/) - State management
- **Utils**: [streamlit_lightweight_charts_pro/frontend/src/utils/](mdc:streamlit_lightweight_charts_pro/frontend/src/utils/) - Utility functions

### Design Patterns

#### Component Composition
```typescript
// Composable chart components
<ChartContainer>
  <ChartSeriesManager />
  <ChartTradeManager />
  <RangeSwitcherPrimitive />
</ChartContainer>
```

#### Service Layer
```typescript
// Services handle business logic
const chartService = new ChartService()
const annotationService = new AnnotationService()
```

#### Manager Pattern
```typescript
// Managers handle state and coordination
const chartManager = new ChartManager()
const seriesManager = new SeriesManager()
```

## Data Flow

1. **Python**: User creates chart with data and options
2. **Serialization**: Chart configuration serialized to JSON
3. **Component**: Streamlit component passes data to React
4. **Rendering**: React renders chart using lightweight-charts library
5. **Events**: User interactions sent back to Python via component events

## Error Handling

- **Python**: Comprehensive error handling with logging
- **Frontend**: Error boundaries for React components
- **Validation**: Input validation at both Python and TypeScript levels

## Performance Optimizations

- **Lazy Loading**: Components loaded on demand
- **Memoization**: React.memo and useMemo for expensive operations
- **Data Virtualization**: Efficient handling of large datasets
- **Caching**: Caching for expensive computations

## ðŸŽ¯ Core API Principles

1. **Fluent Interface**: Every method returns self for chaining
2. **Immutable Defaults**: Default values never mutate
3. **Progressive Enhancement**: Start simple, add complexity as needed
4. **Type Safety**: Runtime validation matches type hints

## ðŸ”— Fluent API Examples

```python
# Simple: Direct instantiation
chart = Chart(series=LineSeries(data))
chart.render(key="simple")

# Intermediate: Method chaining
chart = (Chart()
    .add_series(LineSeries(data, color="#ff0000"))
    .update_options(height=400)
    .render(key="intermediate"))

# Advanced: Full fluent configuration
chart = (Chart()
    .add_series(
        LineSeries(data)
        .set_color("#ff0000")
        .set_line_width(2)
        .set_crosshair_marker_visible(True)
    )
    .add_series(
        AreaSeries(data2)
        .set_fill_color("rgba(0, 255, 0, 0.3)")
    )
    .update_options(
        height=500,
        layout=LayoutOptions(background_color="white"),
        time_scale=TimeScaleOptions(time_visible=True)
    )
    .add_annotation(
        create_text_annotation("2024-01-01", 100, "Start")
        .set_color("#0000ff")
        .set_font_size(14)
    )
    .add_trade(
        Trade(entry_time="2024-01-01", entry_price=100,
              exit_time="2024-01-05", exit_price=105)
    )
    .render(key="advanced"))
```

## Series Creation Patterns

- **Data Classes**: Use typed data classes from [streamlit_lightweight_charts_pro/data/](mdc:streamlit_lightweight_charts_pro/data/)
- **Series Types**: All series inherit from base [Series](mdc:streamlit_lightweight_charts_pro/charts/series/__init__.py) class
- **Method Chaining**: Series support fluent configuration
- **Mixin Patterns**: Use SerializableMixin and chainable_property for consistent behavior

```python
# Line series with method chaining
line_series = (LineSeries(data)
               .set_color("#ff0000")
               .set_line_width(2)
               .set_crosshair_marker_visible(True))

# Candlestick series with styling
candlestick_series = (CandlestickSeries(ohlc_data)
                     .set_up_color("#4CAF50")
                     .set_down_color("#F44336")
                     .set_border_visible(False))
```

## ðŸ§© Mixin Patterns

### SerializableMixin for Frontend Communication
```python
# âœ… CORRECT: Using SerializableMixin for consistent serialization
from dataclasses import dataclass
from streamlit_lightweight_charts_pro.utils.serialization import SerializableMixin

@dataclass
class ChartConfig(SerializableMixin):
    """Chart configuration with automatic serialization support."""
    title: str = "My Chart"
    is_visible: bool = True
    background_color: str = "#ffffff"

    def asdict(self) -> dict[str, Any]:
        """Serialize to dictionary with camelCase keys for frontend."""
        return self._serialize_to_dict()

# Usage
config = ChartConfig(title="My Chart", is_visible=True)
serialized = config.asdict()  # {"title": "My Chart", "isVisible": True}
```

### Chainable Property Mixin for Fluent API
```python
# âœ… CORRECT: Using chainable_property decorator for fluent API
from streamlit_lightweight_charts_pro.utils import chainable_property

@chainable_property("color", str, validator="color")
@chainable_property("width", int)
@chainable_property("line_options", LineOptions, allow_none=True)
@chainable_property("price_scale_id", top_level=True)
class LineSeries(Series):
    """Line series with chainable property configuration."""

    def __init__(self, data, **kwargs):
        # Initialize private attributes for chainable properties
        self._color = "#2196F3"
        self._width = 1
        self._line_options = None
        self._price_scale_id = "right"
        super().__init__(data, **kwargs)

# Usage - both patterns work with same validation
series = (LineSeries(data)
         .set_color("#ff0000")  # Method chaining
         .set_width(2))

series.color = "#00ff00"  # Property assignment (same validation)
```

### Options Mixin for Configuration Classes
```python
# âœ… CORRECT: Using Options mixin for configuration classes
from dataclasses import dataclass
from streamlit_lightweight_charts_pro.charts.options.base_options import Options

@dataclass
class LineOptions(Options):
    """Line styling options with automatic serialization."""
    color: str = "#2196F3"
    width: int = 1
    style: LineStyle = LineStyle.SOLID
    visible: bool = True

    def asdict(self) -> dict[str, Any]:
        """Serialize to dictionary with camelCase keys."""
        return self._serialize_to_dict()

# Usage
options = (LineOptions()
          .set_color("#ff0000")
          .set_width(2)
          .set_style(LineStyle.SOLID))

serialized = options.asdict()  # {"color": "#ff0000", "width": 2, "style": 0}
```

### Data Mixin for Chart Data Points
```python
# âœ… CORRECT: Using Data mixin for chart data points
from dataclasses import dataclass
from streamlit_lightweight_charts_pro.data.data import Data

@dataclass
class LineData(Data):
    """Single value data point for line charts."""
    value: float
    color: Optional[str] = None

    def asdict(self) -> dict[str, Any]:
        """Serialize to dictionary with camelCase keys."""
        return self._serialize_to_dict()

# Usage - automatic time normalization
data = LineData(time="2024-01-01T00:00:00", value=100.0)
serialized = data.asdict()  # {"time": 1704067200, "value": 100.0}
```

## Chart Configuration

- **Options**: Use typed option classes from [streamlit_lightweight_charts_pro/charts/options/](mdc:streamlit_lightweight_charts_pro/charts/options/)
- **Validation**: All options are validated with type hints
- **Defaults**: Sensible defaults for all configuration options

```python
# Chart options with validation
options = ChartOptions(
    height=500,
    width=800,
    layout=LayoutOptions(background_color="white"),
    grid=GridOptions(vert_lines_color="rgba(197, 203, 206, 0.5)")
)
```

## Data Integration Patterns

- **Pandas**: Seamless DataFrame integration with column mapping
- **CSV**: Direct CSV loading with custom column mapping
- **APIs**: Easy integration with financial data APIs

```python
# Pandas DataFrame integration
chart = Chart(series=CandlestickSeries.from_dataframe(
    df=df,
    column_mapping={
        'time': 'date',
        'open': 'open',
        'high': 'high',
        'low': 'low',
        'close': 'close'
    }
))
```

## Annotation System

- **Layers**: Use annotation layers for organization
- **Types**: Support for text, arrow, and shape annotations
- **Styling**: Comprehensive styling options for all annotation types

```python
# Annotation with layers
layer = AnnotationLayer("analysis", visible=True)
layer.add_annotation(create_text_annotation("2024-01-01", 100, "Support"))
chart.add_annotation_layer(layer)
```

## Error Handling

- **Validation**: Input validation with clear error messages
- **Type Safety**: Type hints prevent runtime errors
- **Logging**: Comprehensive logging for debugging

---

**Status**: âœ… **COMPLETE** - Comprehensive architecture patterns with API design principles
**Last Updated**: December 2024
**Next Review**: Quarterly review of architecture patterns
