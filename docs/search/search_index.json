{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Streamlit Lightweight Charts Pro","text":"<p>Professional-grade financial charting library for Streamlit that wraps TradingView's lightweight-charts with a fluent Python API.</p>"},{"location":"index.html#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create sample data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 103),\n]\n\n# Create and render chart\nchart = Chart(series=LineSeries(data))\nchart.render(key=\"my_chart\")\n</code></pre>"},{"location":"index.html#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Getting Started - Installation and basic usage</li> <li>Examples - Code examples and tutorials</li> </ul>"},{"location":"index.html#features","title":"\u2728 Features","text":"<ul> <li>Professional Charts - Line, candlestick, area, histogram, and more</li> <li>Fluent API - Method chaining for easy configuration</li> <li>Type Safety - Full type hints and validation</li> <li>Performance - Optimized for large datasets</li> <li>Customizable - Extensive styling and behavior options</li> </ul>"},{"location":"index.html#links","title":"\ud83d\udd17 Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issues &amp; Support</li> </ul>"},{"location":"api/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>streamlit_lightweight_charts_pro<ul> <li>charts<ul> <li>chart</li> <li>chart_manager</li> <li>managers<ul> <li>chart_renderer</li> <li>price_scale_manager</li> <li>series_manager</li> <li>session_state_manager</li> <li>trade_manager</li> </ul> </li> <li>options<ul> <li>base_options</li> <li>chart_options</li> <li>interaction_options</li> <li>layout_options</li> <li>line_options</li> <li>localization_options</li> <li>price_format_options</li> <li>price_line_options</li> <li>price_scale_options</li> <li>sync_options</li> <li>time_scale_options</li> <li>trade_visualization_options</li> <li>ui_options</li> </ul> </li> <li>series<ul> <li>area</li> <li>band</li> <li>bar_series</li> <li>base</li> <li>baseline</li> <li>candlestick</li> <li>defaults</li> <li>gradient_ribbon</li> <li>histogram</li> <li>line</li> <li>ribbon</li> <li>signal_series</li> <li>trend_fill</li> </ul> </li> <li>series_settings_api</li> <li>utils<ul> <li>price_scale_config</li> </ul> </li> <li>validators<ul> <li>price_scale_validator</li> </ul> </li> </ul> </li> <li>cli</li> <li>component</li> <li>constants</li> <li>data<ul> <li>annotation</li> <li>area_data</li> <li>band</li> <li>bar_data</li> <li>baseline_data</li> <li>candlestick_data</li> <li>data</li> <li>gradient_ribbon</li> <li>histogram_data</li> <li>line_data</li> <li>marker</li> <li>ohlc_data</li> <li>ohlcv_data</li> <li>ribbon</li> <li>signal_data</li> <li>single_value_data</li> <li>tooltip</li> <li>trade</li> <li>trend_fill</li> </ul> </li> <li>exceptions</li> <li>logging_config</li> <li>type_definitions<ul> <li>colors</li> <li>enums</li> </ul> </li> <li>types<ul> <li>series_config_types</li> </ul> </li> <li>utils<ul> <li>case_converter</li> <li>chainable</li> <li>color_utils</li> <li>data_utils</li> <li>profiler</li> <li>serialization</li> </ul> </li> </ul> </li> </ul>"},{"location":"api/streamlit_lightweight_charts_pro/index.html","title":"streamlit_lightweight_charts_pro","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro","title":"streamlit_lightweight_charts_pro","text":"<p>Streamlit Lightweight Charts Pro - Professional Financial Charting Library.</p> <p>A comprehensive Python library for creating interactive financial charts in Streamlit applications. Built on top of TradingView's Lightweight Charts library, this package provides a fluent API for building sophisticated financial visualizations with method chaining support.</p> Key Features <ul> <li>Multiple chart types: Line, Candlestick, Area, Bar, Histogram, Baseline</li> <li>Advanced series: Band, Ribbon, Gradient Ribbon, Trend Fill, Signal</li> <li>Comprehensive annotation system with text, arrows, and shapes</li> <li>Trade visualization with buy/sell markers and trade lines</li> <li>Multi-pane chart support with synchronized time scales</li> <li>Pandas DataFrame integration for easy data import</li> <li>Fluent API design for intuitive method chaining</li> <li>Type-safe data models with validation</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro import Chart, LineSeries, create_text_annotation\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create data\ndata = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\n\n# Method 1: Direct chart creation\nchart = Chart(series=LineSeries(data, color=\"#ff0000\"))\nchart.render(key=\"my_chart\")\n\n# Method 2: Fluent API with method chaining\nchart = (\n    Chart()\n    .add_series(LineSeries(data, color=\"#ff0000\"))\n    .update_options(height=400)\n    .add_annotation(create_text_annotation(\"2024-01-01\", 100, \"Start\"))\n)\nchart.render(key=\"my_chart\")\n</code></pre> <p>For detailed documentation and examples, visit: https://github.com/nandkapadia/streamlit-lightweight-charts-pro</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart","title":"Chart","text":"<p>Single pane chart for displaying financial data.</p> <p>This class represents a single pane chart that can display multiple series of financial data. It supports various chart types including candlestick, line, area, bar, and histogram series. The chart includes comprehensive annotation support, trade visualization, and method chaining for fluent API usage.</p> <p>The Chart class uses a manager-based architecture where each manager handles a specific aspect of chart functionality. This design provides clear separation of concerns and makes the codebase easier to maintain and extend.</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects to display in the chart. This is exposed for backward compatibility and delegates to SeriesManager internally.</p> <code>options</code> <code>ChartOptions</code> <p>Chart configuration options including layout, grid, time scale, price scale, etc.</p> <code>annotation_manager</code> <code>AnnotationManager</code> <p>Manager for chart annotations and layers. Handles text, arrows, shapes, and other visual elements.</p> <code>force_reinit</code> <code>bool</code> <p>Flag to force frontend re-initialization. Set to True when indicator parameters or other settings change that require the chart to be completely rebuilt on the frontend.</p> Private Attributes <p>_series_manager (SeriesManager): Manages all data series. _price_scale_manager (PriceScaleManager): Manages price scale config. _trade_manager (TradeManager): Manages trade visualization. _session_state_manager (SessionStateManager): Manages state persistence. _chart_renderer (ChartRenderer): Handles rendering pipeline. _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips. _chart_group_id (int): Group ID for chart synchronization. _chart_manager (Optional[Any]): Reference to parent ChartManager.</p> Example <p>Basic usage::</p> <pre><code># Create a simple line chart\nchart = Chart(series=LineSeries(data))\n\n# Configure options\nchart.update_options(height=400, width=800)\n\n# Render in Streamlit\nchart.render(key=\"my_chart\")\n</code></pre> <p>With method chaining::</p> <pre><code>chart = (\n    Chart(series=LineSeries(data))\n    .update_options(height=400)\n    .add_annotation(text_annotation)\n    .add_series(candlestick_series)\n)\nchart.render()\n</code></pre> <p>From DataFrame with price and volume::</p> <pre><code>chart = Chart.from_price_volume_dataframe(\n    df,\n    column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n    price_type=\"candlestick\"\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>class Chart:\n    \"\"\"Single pane chart for displaying financial data.\n\n    This class represents a single pane chart that can display multiple\n    series of financial data. It supports various chart types including\n    candlestick, line, area, bar, and histogram series. The chart includes\n    comprehensive annotation support, trade visualization, and method chaining\n    for fluent API usage.\n\n    The Chart class uses a manager-based architecture where each manager\n    handles a specific aspect of chart functionality. This design provides\n    clear separation of concerns and makes the codebase easier to maintain\n    and extend.\n\n    Attributes:\n        series (List[Series]): List of series objects to display in the chart.\n            This is exposed for backward compatibility and delegates to\n            SeriesManager internally.\n        options (ChartOptions): Chart configuration options including layout,\n            grid, time scale, price scale, etc.\n        annotation_manager (AnnotationManager): Manager for chart annotations\n            and layers. Handles text, arrows, shapes, and other visual elements.\n        force_reinit (bool): Flag to force frontend re-initialization. Set to\n            True when indicator parameters or other settings change that require\n            the chart to be completely rebuilt on the frontend.\n\n    Private Attributes:\n        _series_manager (SeriesManager): Manages all data series.\n        _price_scale_manager (PriceScaleManager): Manages price scale config.\n        _trade_manager (TradeManager): Manages trade visualization.\n        _session_state_manager (SessionStateManager): Manages state persistence.\n        _chart_renderer (ChartRenderer): Handles rendering pipeline.\n        _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips.\n        _chart_group_id (int): Group ID for chart synchronization.\n        _chart_manager (Optional[Any]): Reference to parent ChartManager.\n\n    Example:\n        Basic usage::\n\n            # Create a simple line chart\n            chart = Chart(series=LineSeries(data))\n\n            # Configure options\n            chart.update_options(height=400, width=800)\n\n            # Render in Streamlit\n            chart.render(key=\"my_chart\")\n\n        With method chaining::\n\n            chart = (\n                Chart(series=LineSeries(data))\n                .update_options(height=400)\n                .add_annotation(text_annotation)\n                .add_series(candlestick_series)\n            )\n            chart.render()\n\n        From DataFrame with price and volume::\n\n            chart = Chart.from_price_volume_dataframe(\n                df,\n                column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n                price_type=\"candlestick\"\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        series: Optional[Union[Series, List[Series]]] = None,\n        options: Optional[ChartOptions] = None,\n        annotations: Optional[List[Annotation]] = None,\n        chart_group_id: int = 0,\n        chart_manager: Optional[Any] = None,\n    ):\n        \"\"\"Initialize a single pane chart.\n\n        Creates a new Chart instance with optional series, configuration options,\n        and annotations. The chart can be configured with multiple series types\n        and supports method chaining for fluent API usage.\n\n        The initialization process:\n            1. Set up chart options (use defaults if not provided)\n            2. Initialize all managers for chart functionality\n            3. Set up annotation system\n            4. Configure chart synchronization\n            5. Process initial annotations if provided\n\n        Args:\n            series: Optional single series object or list of series objects to\n                display. Each series represents a different data visualization\n                (line, candlestick, area, etc.). If None, an empty chart is\n                created.\n            options: Optional chart configuration options. If not provided,\n                default options will be used.\n            annotations: Optional list of annotations to add to the chart.\n                Annotations can include text, arrows, shapes, etc.\n            chart_group_id: Group ID for synchronization. Charts with the same\n                group ID will be synchronized. Defaults to 0.\n            chart_manager: Reference to the ChartManager that owns this chart.\n                Used to access sync configuration when rendering individual charts.\n\n        Returns:\n            Chart: Initialized chart instance ready for configuration and rendering.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list, or if\n                annotations is not a list.\n            AnnotationItemsTypeError: If any item in annotations is not an Annotation\n                instance.\n\n        Example:\n            Create empty chart::\n\n                &gt;&gt;&gt; chart = Chart()\n\n            Create chart with single series::\n\n                &gt;&gt;&gt; chart = Chart(series=LineSeries(data))\n\n            Create chart with multiple series::\n\n                &gt;&gt;&gt; chart = Chart(series=[line_series, candlestick_series])\n\n            Create chart with custom options::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     options=ChartOptions(height=600, width=800)\n                ... )\n\n            Create chart with annotations::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     annotations=[text_ann, arrow_ann]\n                ... )\n        \"\"\"\n        # Step 1: Set up chart configuration\n        # Use provided options or create default ChartOptions instance\n        # ChartOptions contains all chart-level configuration like height,\n        # width, layout, grid, time scale, price scale, etc.\n        self.options = options or ChartOptions()\n\n        # Step 2: Initialize managers for different chart functionalities\n        # Each manager handles a specific aspect of chart behavior\n\n        # SeriesManager: Manages all data series (line, candlestick, etc.)\n        # Handles series validation, ordering, and serialization\n        self._series_manager = SeriesManager(series)\n\n        # PriceScaleManager: Manages price scale configuration\n        # Handles left/right price scales and overlay price scales\n        # Overlay scales are used for volume, indicators, etc.\n        self._price_scale_manager = PriceScaleManager(\n            left_price_scale=self.options.left_price_scale,\n            right_price_scale=self.options.right_price_scale,\n            overlay_price_scales=self.options.overlay_price_scales,\n        )\n\n        # TradeManager: Manages trade visualization\n        # Converts TradeData objects to visual elements (markers, rectangles, etc.)\n        self._trade_manager = TradeManager()\n\n        # SessionStateManager: Handles state persistence across renders\n        # Manages series configurations and user interactions\n        # Stores data in Streamlit session state for persistence\n        self._session_state_manager = SessionStateManager()\n\n        # ChartRenderer: Handles the rendering pipeline\n        # Converts chart configuration to frontend format\n        # Manages component rendering and response handling\n        # Takes reference to chart_manager for sync configuration\n        self._chart_renderer = ChartRenderer(chart_manager_ref=chart_manager)\n\n        # Step 3: Set up annotation system\n        # AnnotationManager handles layers and annotation lifecycle\n        # Supports multiple layers for organizing different annotation types\n        self.annotation_manager = AnnotationManager()\n\n        # Step 4: Initialize tooltip manager for lazy loading\n        # TooltipManager is created on-demand when tooltips are configured\n        # This avoids overhead for charts that don't use custom tooltips\n        self._tooltip_manager: Optional[TooltipManager] = None\n\n        # Step 5: Initialize chart synchronization support\n        # Charts with same group_id are synchronized (crosshair, time range)\n        # This is different from ChartManager's sync_group which manages\n        # multiple charts\n        self._chart_group_id = chart_group_id\n\n        # Store reference to parent ChartManager (if this chart is managed)\n        # Used to access sync configuration when rendering\n        self._chart_manager = chart_manager\n\n        # Step 6: Initialize force re-initialization flag\n        # When True, forces frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        # that can't be updated through normal data updates\n        self.force_reinit: bool = False\n\n        # Step 7: Expose series list for backward compatibility\n        # This allows direct access to series: chart.series[0]\n        # Internally delegates to SeriesManager\n        self.series = self._series_manager.series\n\n        # Step 8: Process initial annotations if provided\n        if annotations is not None:\n            # Validate that annotations is a list\n            if not isinstance(annotations, list):\n                raise TypeValidationError(\"annotations\", \"list\")\n\n            # Validate and add each annotation\n            for annotation in annotations:\n                # Ensure each item is an Annotation instance\n                if not isinstance(annotation, Annotation):\n                    raise AnnotationItemsTypeError()\n                # Add to default annotation layer\n                self.add_annotation(annotation)\n\n    def get_stored_series_config(\n        self,\n        key: str,\n        series_index: int = 0,\n        pane_id: int = 0,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get stored configuration for a specific series.\n\n        Retrieves the stored configuration for a series from session state.\n        This is useful for applying previously saved configurations when\n        creating new series instances, enabling persistence of user\n        customizations across renders.\n\n        The stored configuration includes user-modified settings like:\n            - Colors and styles\n            - Line widths and types\n            - Visibility settings\n            - Other series-specific options\n\n        Args:\n            key: Component key used to namespace the stored configs. This should\n                match the key used when rendering the chart.\n            series_index: Index of the series (0-based). Defaults to 0.\n            pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n                charts where the same series index may exist in different panes.\n\n        Returns:\n            Dictionary of stored configuration or empty dict if none found.\n            The dictionary keys match the series option property names.\n\n        Example:\n            Get and apply stored config::\n\n                &gt;&gt;&gt; # Get stored config for first series\n                &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Apply to new series\n                &gt;&gt;&gt; if config:\n                ...     line_series = LineSeries(data)\n                ...     if \"color\" in config:\n                ...         line_series.line_options.color = config[\"color\"]\n                ...     if \"lineWidth\" in config:\n                ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n            Restore all series configs::\n\n                &gt;&gt;&gt; for i, series in enumerate(chart.series):\n                ...     config = chart.get_stored_series_config(\"my_chart\", i)\n                ...     if config:\n                ...         apply_config_to_series(series, config)\n        \"\"\"\n        # Delegate to SessionStateManager which handles the actual storage\n        # SessionStateManager uses Streamlit's session_state for persistence\n        return self._session_state_manager.get_stored_series_config(\n            key, series_index, pane_id\n        )\n\n    def add_series(self, series: Series) -&gt; \"Chart\":\n        \"\"\"Add a series to the chart.\n\n        Adds a new series object to the chart's series list. The series will be\n        displayed according to its type (line, candlestick, area, etc.) and\n        configuration options. The method automatically handles price scale\n        configuration for custom price scale IDs.\n\n        When a series is added:\n            1. Series is validated to ensure it's a Series instance\n            2. SeriesManager adds it to the series list\n            3. If series has custom price_scale_id, PriceScaleManager is notified\n            4. Series is assigned a z-index for proper layering\n\n        Args:\n            series: Series object to add to the chart. Must be an instance of a\n                Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n\n        Example:\n            Add a candlestick series::\n\n                &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n            Add a line series with custom options::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n                &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n                &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n            Add series with custom price scale::\n\n                &gt;&gt;&gt; # Series with custom price scale ID\n                &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n                &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add overlay price scale configuration\n                &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add the series\n                &gt;&gt;&gt; chart.add_series(volume_series)\n        \"\"\"\n        # Delegate to SeriesManager which handles validation and storage\n        # Also pass PriceScaleManager reference so it can be notified of\n        # custom price scale IDs\n        self._series_manager.add_series(series, self._price_scale_manager)\n\n        # Return self to enable method chaining\n        return self\n\n    def update_options(self, **kwargs) -&gt; \"Chart\":\n        \"\"\"Update chart options.\n\n        Updates the chart's configuration options using keyword arguments.\n        Only valid ChartOptions attributes will be updated; invalid attributes\n        are silently ignored to support method chaining and forward compatibility.\n\n        The method performs type checking to ensure new values match the\n        expected types of the chart options. This prevents runtime errors\n        from invalid configurations.\n\n        Args:\n            **kwargs: Chart options to update. Valid options include:\n                - width (Optional[int]): Chart width in pixels\n                - height (int): Chart height in pixels (default: 400)\n                - auto_size (bool): Whether to auto-size the chart\n                - handle_scroll (bool): Whether to enable scroll interactions\n                - handle_scale (bool): Whether to enable scale interactions\n                - add_default_pane (bool): Whether to add a default pane\n                And many more options defined in ChartOptions class.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Update basic dimensions::\n\n                &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n            Update interaction options::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     handle_scroll=True,\n                ...     handle_scale=False,\n                ...     auto_size=True\n                ... )\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n            Update multiple options at once::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     height=600,\n                ...     width=1200,\n                ...     auto_size=False,\n                ...     handle_scroll=True\n                ... )\n        \"\"\"\n        # Process each keyword argument to update chart options\n        for key, value in kwargs.items():\n            # Step 1: Validate the option exists and value is not None\n            # Check that the attribute exists on ChartOptions instance\n            # and that the new value is not None (None values are ignored)\n            if value is not None and hasattr(self.options, key):\n                # Step 2: Get current attribute value for type checking\n                # This helps ensure type consistency\n                current_value = getattr(self.options, key)\n\n                # Step 3: Validate type compatibility\n                # Allow update if:\n                # - New value type matches current value type, OR\n                # - Current value is None and new value is not None\n                #   (allows setting previously unset options)\n                if isinstance(value, type(current_value)) or (\n                    current_value is None and value is not None\n                ):\n                    # Update the attribute with the validated value\n                    setattr(self.options, key, value)\n\n            # Note: Invalid attributes and None values are silently ignored\n            # This enables method chaining and forward compatibility\n\n        # Return self for method chaining\n        return self\n\n    def add_annotation(\n        self, annotation: Annotation, layer_name: str = \"default\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add an annotation to the chart.\n\n        Adds a single annotation to the specified annotation layer. If the layer\n        doesn't exist, it will be created automatically. Annotations are visual\n        elements like text, arrows, shapes, and lines that provide additional\n        information or highlight specific points on the chart.\n\n        Annotations are organized into layers for better management:\n            - Each layer can contain multiple annotations\n            - Layers can be shown/hidden independently\n            - Layers can be cleared without affecting other layers\n            - Default layer is used if no layer name is specified\n\n        Args:\n            annotation (Annotation): Annotation object to add to the chart.\n                Must be a valid Annotation instance with proper configuration.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". Layer will be created if it doesn't exist.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If annotation is None or layer_name is invalid.\n            TypeValidationError: If annotation is not an Annotation instance.\n\n        Example:\n            Add text annotation::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n                ...     create_text_annotation\n                ... )\n                &gt;&gt;&gt; text_ann = create_text_annotation(\n                ...     \"2024-01-01\", 100, \"Important Event\"\n                ... )\n                &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n            Add annotation to custom layer::\n\n                &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n                &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n            Organize annotations by layer::\n\n                &gt;&gt;&gt; # Technical analysis annotations\n                &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n                &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Trading signals\n                &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n                &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n        \"\"\"\n        # Step 1: Validate annotation is not None\n        if annotation is None:\n            raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n        # Step 2: Validate annotation is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n        # Step 3: Handle layer name validation\n        # Use default layer name if None is provided\n        if layer_name is None:\n            layer_name = \"default\"\n        # Validate layer_name is a non-empty string\n        elif not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Add annotation to the specified layer\n        # AnnotationManager will create the layer if it doesn't exist\n        self.annotation_manager.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def add_annotations(\n        self,\n        annotations: List[Annotation],\n        layer_name: str = \"default\",\n    ) -&gt; \"Chart\":\n        \"\"\"Add multiple annotations to the chart.\n\n        Adds multiple annotation objects to the specified annotation layer. This\n        is more efficient than calling add_annotation multiple times as it\n        processes all annotations in a single operation and provides better\n        performance for bulk annotation operations.\n\n        All annotations are added to the same layer, enabling consistent\n        management (show/hide/clear) of related annotations.\n\n        Args:\n            annotations (List[Annotation]): List of annotation objects to add\n                to the chart. All must be valid Annotation instances.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". All annotations will be added to this layer.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If annotations is not a list.\n            ValueValidationError: If layer_name is invalid.\n            AnnotationItemsTypeError: If any item in annotations is not an\n                Annotation instance.\n\n        Example:\n            Add multiple annotations at once::\n\n                &gt;&gt;&gt; annotations = [\n                ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n                ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n                ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n                ... ]\n                &gt;&gt;&gt; chart.add_annotations(annotations)\n\n            Add to custom layer::\n\n                &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n                &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n            Bulk operations with method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n                ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n                ...  .update_options(height=600))\n        \"\"\"\n        # Step 1: Validate annotations is not None\n        if annotations is None:\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 2: Validate annotations is a list\n        if not isinstance(annotations, list):\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 3: Validate layer_name\n        if not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Validate and add each annotation\n        for annotation in annotations:\n            # Ensure each item is an Annotation instance\n            if not isinstance(annotation, Annotation):\n                raise AnnotationItemsTypeError()\n\n            # Add the annotation to the specified layer\n            # Reuses add_annotation logic for consistency\n            self.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new annotation layer with the specified name. Annotation layers\n        allow you to organize and manage groups of annotations independently.\n        Each layer can be shown, hidden, or cleared separately, providing\n        flexible control over annotation visibility.\n\n        Common use cases for layers:\n            - Separate technical analysis from trading signals\n            - Organize annotations by timeframe or strategy\n            - Group annotations by type (text, arrows, shapes)\n            - Enable/disable different annotation sets dynamically\n\n        Args:\n            name (str): Name of the annotation layer to create. Must be a\n                non-empty string and should be unique.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If name is None.\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Create custom layers for different types of annotations::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .create_annotation_layer(\"layer1\")\n                ...  .create_annotation_layer(\"layer2\")\n                ...  .add_annotation(ann1, \"layer1\")\n                ...  .add_annotation(ann2, \"layer2\"))\n\n            Organize by strategy::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n                &gt;&gt;&gt; # Add annotations specific to each strategy\n        \"\"\"\n        # Step 1: Validate name is not None\n        if name is None:\n            raise TypeValidationError(\"name\", \"string\")\n\n        # Step 2: Validate name is a non-empty string\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 3: Create the layer in AnnotationManager\n        # If layer already exists, this operation is idempotent\n        self.annotation_manager.create_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Hide an annotation layer.\n\n        Hides the specified annotation layer, making all annotations in that\n        layer invisible on the chart. The layer and its annotations are preserved\n        and can be shown again using show_annotation_layer. This is useful for\n        temporarily hiding certain annotation groups without removing them.\n\n        Hidden layers:\n            - Remain in memory with all annotations intact\n            - Can be shown again without re-adding annotations\n            - Don't affect other layers' visibility\n            - Are persisted across chart updates\n\n        Args:\n            name (str): Name of the annotation layer to hide.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Hide specific layers::\n\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .hide_annotation_layer(\"layer1\")\n                ...  .hide_annotation_layer(\"layer2\")\n                ...  .show_annotation_layer(\"layer3\"))\n\n            Toggle layer visibility::\n\n                &gt;&gt;&gt; # Hide analysis layer temporarily\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; # ... show chart without analysis\n                &gt;&gt;&gt; # Show analysis layer again\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Hide the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.hide_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Show an annotation layer.\n\n        Makes the specified annotation layer visible on the chart. This will\n        display all annotations that were previously added to this layer.\n        If the layer doesn't exist or is already visible, this method will\n        have no effect.\n\n        This is the counterpart to hide_annotation_layer and enables dynamic\n        control over which annotation groups are visible.\n\n        Args:\n            name (str): Name of the annotation layer to show.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Show specific layers::\n\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .show_annotation_layer(\"layer1\")\n                ...  .show_annotation_layer(\"layer2\")\n                ...  .hide_annotation_layer(\"layer3\"))\n\n            Conditional visibility::\n\n                &gt;&gt;&gt; # Show different layers based on user selection\n                &gt;&gt;&gt; if show_technical_analysis:\n                ...     chart.show_annotation_layer(\"ta\")\n                &gt;&gt;&gt; if show_trading_signals:\n                ...     chart.show_annotation_layer(\"signals\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Show the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.show_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n        \"\"\"Clear annotations from the chart.\n\n        Removes all annotations from the specified layer or from all layers if\n        no layer name is provided. The layer itself is preserved and can be\n        reused for new annotations. This is useful for refreshing annotations\n        without recreating the entire chart.\n\n        Clearing behavior:\n            - With layer_name: Clears only that specific layer\n            - Without layer_name: Does nothing (for backward compatibility)\n            - Layer structure is preserved (can add new annotations)\n            - Does not affect hidden/shown state of layers\n\n        Args:\n            layer_name (Optional[str]): Name of the layer to clear. If None,\n                no action is taken. Defaults to None.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If layer_name is not None and invalid.\n\n        Example:\n            Clear specific layer::\n\n                &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n            Clear all layers (provide None)::\n\n                &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .clear_annotations(\"layer1\")\n                ...  .add_annotation(new_annotation, \"layer1\"))\n\n            Refresh annotations::\n\n                &gt;&gt;&gt; # Clear old annotations and add new ones\n                &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n                &gt;&gt;&gt; for signal in new_signals:\n                ...     chart.add_annotation(signal, \"signals\")\n        \"\"\"\n        # Step 1: Validate layer_name if provided\n        if layer_name is not None and (\n            not layer_name or not isinstance(layer_name, str)\n        ):\n            raise ValueValidationError(\n                \"layer_name\", \"must be None or a non-empty string\"\n            )\n\n        # Step 2: Clear the specified layer\n        if layer_name is not None:\n            # Clear only the specified layer through AnnotationManager\n            self.annotation_manager.clear_layer(layer_name)\n\n        # Note: If layer_name is None, no action is taken\n        # This maintains backward compatibility with existing code\n\n        # Return self for method chaining\n        return self\n\n    def add_overlay_price_scale(\n        self, scale_id: str, options: \"PriceScaleOptions\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Adds or updates an overlay price scale configuration for the chart.\n        Overlay price scales allow multiple series to share the same price axis\n        while maintaining independent scaling and positioning. This is commonly\n        used for volume bars, indicators, and other overlays.\n\n        Overlay price scales enable:\n            - Independent vertical positioning (scale margins)\n            - Separate auto-scaling behavior\n            - Different visibility settings\n            - Custom formatting and precision\n\n        Args:\n            scale_id (str): The unique identifier for the custom price scale\n                (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n                by series that use this price scale.\n            options (PriceScaleOptions): A PriceScaleOptions instance containing\n                the configuration for the overlay price scale.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            PriceScaleIdTypeError: If scale_id is not a string.\n            PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n        Example:\n            Add volume overlay price scale::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n                ...     PriceScaleOptions\n                ... )\n                &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n                ...     visible=False,  # Hide the price scale itself\n                ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n                ...     scale_margin_bottom=0,\n                ...     overlay=True,  # Mark as overlay\n                ...     auto_scale=True  # Auto-scale to data\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n            Add indicator overlay::\n\n                &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n                ...     visible=True,\n                ...     scale_margin_top=0.7,\n                ...     scale_margin_bottom=0.1,\n                ...     overlay=True\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_overlay_price_scale('volume', volume_scale)\n                ...  .add_series(volume_series))\n        \"\"\"\n        # Step 1: Add overlay scale through PriceScaleManager\n        # Manager validates scale_id and options internally\n        self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n        # Step 2: Sync back to options for backward compatibility\n        # This ensures options.overlay_price_scales is updated\n        # Some legacy code may access overlay scales directly from options\n        self.options.overlay_price_scales[scale_id] = options\n\n        # Return self for method chaining\n        return self\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series to the chart from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale positioned at the\n        bottom of the chart.\n\n        This is a convenience method that:\n            1. Configures the volume overlay price scale\n            2. Creates price series (candlestick or line)\n            3. Creates volume histogram series\n            4. Adds both series to the chart\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information. Can be a sequence of OhlcvData objects\n                or a pandas DataFrame.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n                Defaults to None (assumes standard column names).\n            price_type (str, optional): Type of price series to create. Options:\n                \"candlestick\" or \"line\". Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration (colors, line width, etc.). Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration (colors, transparency, etc.). Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0. Used in multi-pane charts.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If data type is invalid.\n            ValueError: If column_mapping is invalid or required columns are missing.\n\n        Example:\n            Add candlestick with volume::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n                ...     price_type=\"candlestick\"\n                ... )\n\n            Add line chart with custom volume colors::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     price_type=\"line\",\n                ...     volume_kwargs={\n                ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n                ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n                ...     }\n                ... )\n\n            From DataFrame::\n\n                &gt;&gt;&gt; df = pd.DataFrame({\n                ...     'timestamp': [...],\n                ...     'o': [...],\n                ...     'h': [...],\n                ...     'l': [...],\n                ...     'c': [...],\n                ...     'v': [...]\n                ... })\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     df,\n                ...     column_mapping={\n                ...         \"time\": \"timestamp\",\n                ...         \"open\": \"o\",\n                ...         \"high\": \"h\",\n                ...         \"low\": \"l\",\n                ...         \"close\": \"c\",\n                ...         \"volume\": \"v\"\n                ...     }\n                ... )\n        \"\"\"\n        # Step 1: Configure price scale manager for volume visualization\n        # This sets up the overlay price scale with proper margins\n        # Volume typically occupies the bottom 20% of the chart\n        self._price_scale_manager.configure_for_volume()\n\n        # Step 2: Delegate to series manager for actual series creation\n        # SeriesManager handles:\n        # - Data conversion (DataFrame to OhlcvData if needed)\n        # - Price series creation (candlestick or line)\n        # - Volume histogram series creation\n        # - Series configuration from kwargs\n        # - Adding both series to the chart\n        self._series_manager.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n            price_scale_manager=self._price_scale_manager,\n        )\n\n        # Return self for method chaining\n        return self\n\n    def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements and adds them to the chart\n        for visualization. Each trade is displayed with entry/exit markers,\n        connecting lines, profit/loss rectangles, or zones based on the\n        TradeVisualizationOptions.style configuration.\n\n        Trade visualization styles:\n            - \"markers\": Entry and exit markers only\n            - \"rectangle\": Filled rectangle between entry and exit\n            - \"line\": Simple line connecting entry to exit\n            - \"arrow\": Arrow from entry to exit\n            - \"zone\": Highlighted zone with transparency\n\n        The visualization automatically color-codes trades:\n            - Green/profit color for winning trades\n            - Red/loss color for losing trades\n            - Customizable through TradeVisualizationOptions\n\n        Args:\n            trades (List[TradeData]): List of TradeData objects to visualize\n                on the chart. Each trade must have entry_time, entry_price,\n                exit_time, exit_price, and trade_type.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Add basic trade visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                ...     TradeType\n                ... )\n                &gt;&gt;&gt; trades = [\n                ...     TradeData(\n                ...         entry_time=\"2024-01-01 10:00:00\",\n                ...         entry_price=100.0,\n                ...         exit_time=\"2024-01-01 15:00:00\",\n                ...         exit_price=105.0,\n                ...         quantity=100,\n                ...         trade_type=TradeType.LONG,\n                ...     )\n                ... ]\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            With custom visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n                ...     TradeVisualizationOptions\n                ... )\n                &gt;&gt;&gt; # Configure trade visualization\n                &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n                ...     style=\"rectangle\",\n                ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n                ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n                ... )\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_trades(trades)\n                ...  .update_options(height=600))\n        \"\"\"\n        # Delegate to TradeManager which handles:\n        # - Trade validation\n        # - Conversion to visual elements (markers, rectangles, etc.)\n        # - Profit/loss calculations\n        # - Color coding based on trade outcome\n        # - Annotation creation for visualization\n        self._trade_manager.add_trades(trades)\n\n        # Return self for method chaining\n        return self\n\n    def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n        \"\"\"Set the tooltip manager for the chart.\n\n        Assigns a TooltipManager instance to handle custom tooltip functionality.\n        Tooltips provide additional information when hovering over chart elements.\n\n        Args:\n            tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n        Example:\n            Set custom tooltip manager::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipManager\n                ... )\n                &gt;&gt;&gt; manager = TooltipManager()\n                &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n        \"\"\"\n        # Validate tooltip_manager is a TooltipManager instance\n        if not isinstance(tooltip_manager, TooltipManager):\n            raise TypeValidationError(\n                \"tooltip_manager\", \"TooltipManager instance\"\n            )\n\n        # Assign the tooltip manager\n        self._tooltip_manager = tooltip_manager\n\n        # Return self for method chaining\n        return self\n\n    def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n        \"\"\"Add a tooltip configuration to the chart.\n\n        Adds a named tooltip configuration that defines how tooltips should\n        be displayed for specific data points or series. Multiple tooltip\n        configurations can be registered and used selectively.\n\n        Args:\n            name: Name for the tooltip configuration (unique identifier).\n            config: TooltipConfig instance defining tooltip appearance and behavior.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If config is not a TooltipConfig instance.\n\n        Example:\n            Add custom tooltip configuration::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipConfig\n                ... )\n                &gt;&gt;&gt; config = TooltipConfig(\n                ...     title=\"Price Info\",\n                ...     show_time=True,\n                ...     show_value=True\n                ... )\n                &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n        \"\"\"\n        # Validate config is a TooltipConfig instance\n        if not isinstance(config, TooltipConfig):\n            raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n        # Lazy-load tooltip manager if not already set\n        # This avoids creating TooltipManager until actually needed\n        if self._tooltip_manager is None:\n            self._tooltip_manager = TooltipManager()\n\n        # Add the configuration to the tooltip manager\n        self._tooltip_manager.add_config(name, config)\n\n        # Return self for method chaining\n        return self\n\n    def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID which is used for synchronizing multiple charts.\n        Charts with the same group_id will be synchronized with each other,\n        sharing crosshair position and time range changes.\n\n        Note:\n            This is different from ChartManager's sync_group which manages\n            synchronization at a higher level. chart_group_id is used for\n            individual chart synchronization, while sync_group is used for\n            managing groups of charts in ChartManager.\n\n        Args:\n            group_id (int): Group ID for synchronization. Charts with the same\n                group_id will be synchronized.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID::\n\n                &gt;&gt;&gt; chart1.set_chart_group_id(1)\n                &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n            Disable synchronization::\n\n                &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n        \"\"\"\n        # Use property setter which includes validation\n        self.chart_group_id = group_id\n\n        # Return self for method chaining\n        return self\n\n    @property\n    def chart_group_id(self) -&gt; int:\n        \"\"\"Get the chart group ID for synchronization.\n\n        Returns the current chart group ID used for synchronization.\n\n        Returns:\n            int: The chart group ID.\n\n        Example:\n            Get chart group ID::\n\n                &gt;&gt;&gt; group_id = chart.chart_group_id\n                &gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n        \"\"\"\n        # Return the internal chart group ID\n        return self._chart_group_id\n\n    @chart_group_id.setter\n    def chart_group_id(self, group_id: int) -&gt; None:\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID with validation.\n\n        Args:\n            group_id (int): Group ID for synchronization.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID via property::\n\n                &gt;&gt;&gt; chart.chart_group_id = 1\n        \"\"\"\n        # Validate group_id is an integer\n        if not isinstance(group_id, int):\n            raise TypeValidationError(\"chart_group_id\", \"integer\")\n\n        # Set the internal chart group ID\n        self._chart_group_id = group_id\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert chart to frontend configuration dictionary.\n\n        Converts the chart and all its components (series, options, annotations,\n        trades, tooltips) to a dictionary format suitable for frontend consumption.\n        This method orchestrates the serialization of all chart elements.\n\n        The serialization process:\n            1. Get series configurations from SeriesManager\n            2. Get base chart options\n            3. Get price scale configuration from PriceScaleManager\n            4. Get annotations configuration from AnnotationManager\n            5. Get trades configuration from TradeManager\n            6. Get tooltip configurations from TooltipManager (if set)\n            7. Generate complete frontend config using ChartRenderer\n            8. Add force_reinit flag if set\n\n        Returns:\n            Dict[str, Any]: Complete chart configuration ready for frontend\n                rendering. The configuration includes:\n                - charts: List of chart objects with series and options\n                - syncConfig: Synchronization settings for multi-chart layouts\n                - annotations: Annotation layers and elements\n                - trades: Trade visualization elements\n                - tooltips: Custom tooltip configurations\n\n        Note:\n            Series are automatically ordered by z-index within each pane to ensure\n            proper layering in the frontend. Series with lower z-index values\n            render behind series with higher z-index values.\n\n        Example:\n            Get frontend configuration::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n            Access specific parts::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n                &gt;&gt;&gt; series_config = chart_config[\"series\"]\n                &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n        \"\"\"\n        # Step 1: Get series configurations from SeriesManager\n        # SeriesManager handles series ordering by z-index and pane\n        series_configs = self._series_manager.to_frontend_configs()\n\n        # Step 2: Get base chart configuration from ChartOptions\n        # Convert ChartOptions to dictionary for frontend\n        chart_config = (\n            self.options.asdict()\n            if self.options is not None\n            else ChartOptions().asdict()\n        )\n\n        # Step 3: Get price scale configuration from PriceScaleManager\n        # Manager validates scales and returns serialized configuration\n        price_scale_config = self._price_scale_manager.validate_and_serialize()\n        # Merge price scale config into chart config\n        chart_config.update(price_scale_config)\n\n        # Step 4: Get annotations configuration from AnnotationManager\n        # Converts all annotation layers to frontend format\n        annotations_config = self.annotation_manager.asdict()\n\n        # Step 5: Get trades configuration from TradeManager\n        # Converts TradeData objects to visual elements\n        # Uses trade_visualization options from chart options\n        trades_config = self._trade_manager.to_frontend_config(\n            self.options.trade_visualization if self.options else None\n        )\n\n        # Step 6: Get tooltip configurations from TooltipManager\n        tooltip_configs = None\n        if self._tooltip_manager:\n            # Convert each tooltip config to dictionary\n            tooltip_configs = {}\n            for name, tooltip_config in self._tooltip_manager.configs.items():\n                tooltip_configs[name] = tooltip_config.asdict()\n\n        # Step 7: Generate complete frontend configuration using ChartRenderer\n        # ChartRenderer assembles all components into final configuration\n        config = self._chart_renderer.generate_frontend_config(\n            chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n            chart_options=self.options,\n            series_configs=series_configs,\n            annotations_config=annotations_config,\n            trades_config=trades_config,\n            tooltip_configs=tooltip_configs,\n            chart_group_id=self.chart_group_id,\n            price_scale_config=price_scale_config,\n        )\n\n        # Step 8: Add force_reinit flag if set\n        # This tells frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Return the complete frontend configuration\n        return config\n\n    def render(self, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Converts the chart to frontend configuration and renders it using the\n        Streamlit component. This is the final step in the chart creation process\n        that displays the interactive chart in the Streamlit application.\n\n        The rendering process follows these steps:\n            1. Generate or validate component key\n            2. Reset config application flag for this render cycle\n            3. Load and apply stored series configurations from session state\n            4. Generate frontend configuration (after configs applied)\n            5. Render component using ChartRenderer\n            6. Handle component response and save updated series configs\n\n        The chart configuration is generated fresh on each render, allowing users\n        to control chart lifecycle and state management in their own code if needed.\n\n        Args:\n            key (Optional[str]): Optional unique key for the Streamlit component.\n                This key is used to identify the component instance and is useful\n                for debugging and component state management. If not provided,\n                a unique key will be generated automatically using timestamp and UUID.\n\n        Returns:\n            Any: The rendered Streamlit component that displays the interactive chart.\n                May contain user interaction data if the frontend sends responses.\n\n        Example:\n            Basic rendering::\n\n                &gt;&gt;&gt; chart.render()\n\n            Rendering with custom key::\n\n                &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n            Method chaining with rendering::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_series(line_series)\n                ...  .update_options(height=600)\n                ...  .render(key=\"chart1\"))\n\n            User-managed state (advanced)::\n\n                &gt;&gt;&gt; # Store chart in session state for persistence\n                &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n                ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Render the persisted chart\n                &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n            Dynamic key generation::\n\n                &gt;&gt;&gt; # Key includes timestamp for uniqueness\n                &gt;&gt;&gt; import time\n                &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n        \"\"\"\n        # STEP 1: Generate a unique key if none provided or if it's invalid\n        if key is None or not isinstance(key, str) or not key.strip():\n            # Create unique identifier using timestamp and UUID\n            unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n            timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n            key = f\"chart_{timestamp}_{unique_id}\"\n\n        # STEP 2: Reset config application flag for this render cycle\n        # This ensures configs are only applied once per render\n        # Prevents duplicate application of stored configurations\n        self._session_state_manager.reset_config_applied_flag()\n\n        # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n        # This is critical: we must apply user-modified configs BEFORE\n        # generating the frontend configuration, otherwise the configs\n        # won't be included in the serialized data\n        stored_configs = self._session_state_manager.load_series_configs(key)\n        if stored_configs:\n            # Apply stored configs to all series\n            # This updates series options with user-modified settings\n            self._session_state_manager.apply_stored_configs_to_series(\n                stored_configs,\n                self.series,  # Current series list\n            )\n\n        # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n        # This ensures the frontend config includes all user modifications\n        # The to_frontend_config() method serializes all chart components\n        config = self.to_frontend_config()\n\n        # STEP 5: Render component using ChartRenderer\n        # ChartRenderer handles:\n        # - Component function retrieval\n        # - Configuration serialization to JSON\n        # - Component rendering through Streamlit\n        # - Error handling if component is unavailable\n        result = self._chart_renderer.render(config, key, self.options)\n\n        # STEP 6: Handle component return value and save series configs\n        # The frontend may send back user interactions or config changes\n        if result:\n            # ChartRenderer processes the response and updates session state\n            # This includes saving any user-modified series configurations\n            self._chart_renderer.handle_response(\n                result,\n                key,\n                self._session_state_manager,\n            )\n\n        # Return the component result\n        # This may contain user interaction data or None\n        return result\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for the series settings dialog.\n\n        Retrieves information about all series in a specific pane. This is\n        used by the series settings dialog to display available series and\n        their current configurations.\n\n        Args:\n            _pane_id: The pane ID to get series info for (default: 0).\n\n        Returns:\n            List of series information dictionaries containing:\n                - series_index: Index of the series\n                - series_type: Type of series (line, candlestick, etc.)\n                - series_name: Display name of the series\n                - current_config: Current series configuration\n\n        Example:\n            Get series info::\n\n                &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n                &gt;&gt;&gt; for info in series_info:\n                ...     print(f\"{info['series_name']}: {info['series_type']}\")\n        \"\"\"\n        # Delegate to SeriesManager which has access to all series data\n        return self._series_manager.get_series_info_for_pane(_pane_id)\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        This method supports conversion from various time formats (datetime,\n        string, timestamp) to UNIX timestamp in seconds.\n\n        Args:\n            time_value: Time value in various formats (datetime, string, int, float).\n\n        Returns:\n            Timestamp in seconds or None if conversion fails.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's conversion logic\n        return self._chart_renderer._convert_time_to_timestamp(time_value)\n\n    def _calculate_data_timespan(self) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Calculates the total time range covered by all series data,\n        which is used for auto-ranging and time scale configuration.\n\n        Returns:\n            Timespan in seconds or None if unable to calculate.\n            None may be returned if:\n                - No series have data\n                - Time values are invalid\n                - Serialization fails\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        try:\n            # Get series configurations which include time data\n            series_configs = self._series_manager.to_frontend_configs()\n\n            # Delegate to ChartRenderer to calculate timespan\n            return self._chart_renderer._calculate_data_timespan(series_configs)\n        except Exception:\n            # Catch any error during serialization or calculation\n            # Return None if unable to calculate (invalid time values, etc.)\n            return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Converts a range configuration (e.g., {\"days\": 7}) to total seconds.\n\n        Args:\n            range_config: Range configuration dictionary with time units.\n                Example: {\"days\": 7, \"hours\": 12}\n\n        Returns:\n            Number of seconds in the range or None for \"ALL\" range.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's range calculation logic\n        return self._chart_renderer._get_range_seconds(range_config)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.chart_group_id","title":"chart_group_id  <code>property</code> <code>writable</code>","text":"<pre><code>chart_group_id: int\n</code></pre> <p>Get the chart group ID for synchronization.</p> <p>Returns the current chart group ID used for synchronization.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The chart group ID.</p> Example <p>Get chart group ID::</p> <pre><code>&gt;&gt;&gt; group_id = chart.chart_group_id\n&gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.get_stored_series_config","title":"get_stored_series_config","text":"<pre><code>get_stored_series_config(key: str, series_index: int = 0, pane_id: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Get stored configuration for a specific series.</p> <p>Retrieves the stored configuration for a series from session state. This is useful for applying previously saved configurations when creating new series instances, enabling persistence of user customizations across renders.</p> The stored configuration includes user-modified settings like <ul> <li>Colors and styles</li> <li>Line widths and types</li> <li>Visibility settings</li> <li>Other series-specific options</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs. This should match the key used when rendering the chart.</p> required <code>series_index</code> <code>int</code> <p>Index of the series (0-based). Defaults to 0.</p> <code>0</code> <code>pane_id</code> <code>int</code> <p>Pane ID for the series. Defaults to 0. Useful for multi-pane charts where the same series index may exist in different panes.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of stored configuration or empty dict if none found.</p> <code>Dict[str, Any]</code> <p>The dictionary keys match the series option property names.</p> Example <p>Get and apply stored config::</p> <pre><code>&gt;&gt;&gt; # Get stored config for first series\n&gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply to new series\n&gt;&gt;&gt; if config:\n...     line_series = LineSeries(data)\n...     if \"color\" in config:\n...         line_series.line_options.color = config[\"color\"]\n...     if \"lineWidth\" in config:\n...         line_series.line_options.line_width = config[\"lineWidth\"]\n</code></pre> <p>Restore all series configs::</p> <pre><code>&gt;&gt;&gt; for i, series in enumerate(chart.series):\n...     config = chart.get_stored_series_config(\"my_chart\", i)\n...     if config:\n...         apply_config_to_series(series, config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_stored_series_config(\n    self,\n    key: str,\n    series_index: int = 0,\n    pane_id: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get stored configuration for a specific series.\n\n    Retrieves the stored configuration for a series from session state.\n    This is useful for applying previously saved configurations when\n    creating new series instances, enabling persistence of user\n    customizations across renders.\n\n    The stored configuration includes user-modified settings like:\n        - Colors and styles\n        - Line widths and types\n        - Visibility settings\n        - Other series-specific options\n\n    Args:\n        key: Component key used to namespace the stored configs. This should\n            match the key used when rendering the chart.\n        series_index: Index of the series (0-based). Defaults to 0.\n        pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n            charts where the same series index may exist in different panes.\n\n    Returns:\n        Dictionary of stored configuration or empty dict if none found.\n        The dictionary keys match the series option property names.\n\n    Example:\n        Get and apply stored config::\n\n            &gt;&gt;&gt; # Get stored config for first series\n            &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Apply to new series\n            &gt;&gt;&gt; if config:\n            ...     line_series = LineSeries(data)\n            ...     if \"color\" in config:\n            ...         line_series.line_options.color = config[\"color\"]\n            ...     if \"lineWidth\" in config:\n            ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n        Restore all series configs::\n\n            &gt;&gt;&gt; for i, series in enumerate(chart.series):\n            ...     config = chart.get_stored_series_config(\"my_chart\", i)\n            ...     if config:\n            ...         apply_config_to_series(series, config)\n    \"\"\"\n    # Delegate to SessionStateManager which handles the actual storage\n    # SessionStateManager uses Streamlit's session_state for persistence\n    return self._session_state_manager.get_stored_series_config(\n        key, series_index, pane_id\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_series","title":"add_series","text":"<pre><code>add_series(series: Series) -&gt; Chart\n</code></pre> <p>Add a series to the chart.</p> <p>Adds a new series object to the chart's series list. The series will be displayed according to its type (line, candlestick, area, etc.) and configuration options. The method automatically handles price scale configuration for custom price scale IDs.</p> When a series is added <ol> <li>Series is validated to ensure it's a Series instance</li> <li>SeriesManager adds it to the series list</li> <li>If series has custom price_scale_id, PriceScaleManager is notified</li> <li>Series is assigned a z-index for proper layering</li> </ol> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add to the chart. Must be an instance of a Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Example <p>Add a candlestick series::</p> <pre><code>&gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n</code></pre> <p>Add a line series with custom options::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n&gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n&gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n</code></pre> <p>Add series with custom price scale::</p> <pre><code>&gt;&gt;&gt; # Series with custom price scale ID\n&gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n&gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add overlay price scale configuration\n&gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add the series\n&gt;&gt;&gt; chart.add_series(volume_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_series(self, series: Series) -&gt; \"Chart\":\n    \"\"\"Add a series to the chart.\n\n    Adds a new series object to the chart's series list. The series will be\n    displayed according to its type (line, candlestick, area, etc.) and\n    configuration options. The method automatically handles price scale\n    configuration for custom price scale IDs.\n\n    When a series is added:\n        1. Series is validated to ensure it's a Series instance\n        2. SeriesManager adds it to the series list\n        3. If series has custom price_scale_id, PriceScaleManager is notified\n        4. Series is assigned a z-index for proper layering\n\n    Args:\n        series: Series object to add to the chart. Must be an instance of a\n            Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n\n    Example:\n        Add a candlestick series::\n\n            &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n        Add a line series with custom options::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n            &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n            &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n        Add series with custom price scale::\n\n            &gt;&gt;&gt; # Series with custom price scale ID\n            &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n            &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add overlay price scale configuration\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add the series\n            &gt;&gt;&gt; chart.add_series(volume_series)\n    \"\"\"\n    # Delegate to SeriesManager which handles validation and storage\n    # Also pass PriceScaleManager reference so it can be notified of\n    # custom price scale IDs\n    self._series_manager.add_series(series, self._price_scale_manager)\n\n    # Return self to enable method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.update_options","title":"update_options","text":"<pre><code>update_options(**kwargs) -&gt; Chart\n</code></pre> <p>Update chart options.</p> <p>Updates the chart's configuration options using keyword arguments. Only valid ChartOptions attributes will be updated; invalid attributes are silently ignored to support method chaining and forward compatibility.</p> <p>The method performs type checking to ensure new values match the expected types of the chart options. This prevents runtime errors from invalid configurations.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Chart options to update. Valid options include: - width (Optional[int]): Chart width in pixels - height (int): Chart height in pixels (default: 400) - auto_size (bool): Whether to auto-size the chart - handle_scroll (bool): Whether to enable scroll interactions - handle_scale (bool): Whether to enable scale interactions - add_default_pane (bool): Whether to add a default pane And many more options defined in ChartOptions class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Update basic dimensions::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=600, width=800)\n</code></pre> <p>Update interaction options::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     handle_scroll=True,\n...     handle_scale=False,\n...     auto_size=True\n... )\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n</code></pre> <p>Update multiple options at once::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     height=600,\n...     width=1200,\n...     auto_size=False,\n...     handle_scroll=True\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def update_options(self, **kwargs) -&gt; \"Chart\":\n    \"\"\"Update chart options.\n\n    Updates the chart's configuration options using keyword arguments.\n    Only valid ChartOptions attributes will be updated; invalid attributes\n    are silently ignored to support method chaining and forward compatibility.\n\n    The method performs type checking to ensure new values match the\n    expected types of the chart options. This prevents runtime errors\n    from invalid configurations.\n\n    Args:\n        **kwargs: Chart options to update. Valid options include:\n            - width (Optional[int]): Chart width in pixels\n            - height (int): Chart height in pixels (default: 400)\n            - auto_size (bool): Whether to auto-size the chart\n            - handle_scroll (bool): Whether to enable scroll interactions\n            - handle_scale (bool): Whether to enable scale interactions\n            - add_default_pane (bool): Whether to add a default pane\n            And many more options defined in ChartOptions class.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Update basic dimensions::\n\n            &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n        Update interaction options::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     handle_scroll=True,\n            ...     handle_scale=False,\n            ...     auto_size=True\n            ... )\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n        Update multiple options at once::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     height=600,\n            ...     width=1200,\n            ...     auto_size=False,\n            ...     handle_scroll=True\n            ... )\n    \"\"\"\n    # Process each keyword argument to update chart options\n    for key, value in kwargs.items():\n        # Step 1: Validate the option exists and value is not None\n        # Check that the attribute exists on ChartOptions instance\n        # and that the new value is not None (None values are ignored)\n        if value is not None and hasattr(self.options, key):\n            # Step 2: Get current attribute value for type checking\n            # This helps ensure type consistency\n            current_value = getattr(self.options, key)\n\n            # Step 3: Validate type compatibility\n            # Allow update if:\n            # - New value type matches current value type, OR\n            # - Current value is None and new value is not None\n            #   (allows setting previously unset options)\n            if isinstance(value, type(current_value)) or (\n                current_value is None and value is not None\n            ):\n                # Update the attribute with the validated value\n                setattr(self.options, key, value)\n\n        # Note: Invalid attributes and None values are silently ignored\n        # This enables method chaining and forward compatibility\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add an annotation to the chart.</p> <p>Adds a single annotation to the specified annotation layer. If the layer doesn't exist, it will be created automatically. Annotations are visual elements like text, arrows, shapes, and lines that provide additional information or highlight specific points on the chart.</p> Annotations are organized into layers for better management <ul> <li>Each layer can contain multiple annotations</li> <li>Layers can be shown/hidden independently</li> <li>Layers can be cleared without affecting other layers</li> <li>Default layer is used if no layer name is specified</li> </ul> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the chart. Must be a valid Annotation instance with proper configuration.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". Layer will be created if it doesn't exist.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If annotation is None or layer_name is invalid.</p> <code>TypeValidationError</code> <p>If annotation is not an Annotation instance.</p> Example <p>Add text annotation::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n...     create_text_annotation\n... )\n&gt;&gt;&gt; text_ann = create_text_annotation(\n...     \"2024-01-01\", 100, \"Important Event\"\n... )\n&gt;&gt;&gt; chart.add_annotation(text_ann)\n</code></pre> <p>Add annotation to custom layer::</p> <pre><code>&gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n&gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n</code></pre> <p>Organize annotations by layer::</p> <pre><code>&gt;&gt;&gt; # Technical analysis annotations\n&gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n&gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Trading signals\n&gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n&gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotation(\n    self, annotation: Annotation, layer_name: str = \"default\"\n) -&gt; \"Chart\":\n    \"\"\"Add an annotation to the chart.\n\n    Adds a single annotation to the specified annotation layer. If the layer\n    doesn't exist, it will be created automatically. Annotations are visual\n    elements like text, arrows, shapes, and lines that provide additional\n    information or highlight specific points on the chart.\n\n    Annotations are organized into layers for better management:\n        - Each layer can contain multiple annotations\n        - Layers can be shown/hidden independently\n        - Layers can be cleared without affecting other layers\n        - Default layer is used if no layer name is specified\n\n    Args:\n        annotation (Annotation): Annotation object to add to the chart.\n            Must be a valid Annotation instance with proper configuration.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". Layer will be created if it doesn't exist.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If annotation is None or layer_name is invalid.\n        TypeValidationError: If annotation is not an Annotation instance.\n\n    Example:\n        Add text annotation::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n            ...     create_text_annotation\n            ... )\n            &gt;&gt;&gt; text_ann = create_text_annotation(\n            ...     \"2024-01-01\", 100, \"Important Event\"\n            ... )\n            &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n        Add annotation to custom layer::\n\n            &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n            &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n        Organize annotations by layer::\n\n            &gt;&gt;&gt; # Technical analysis annotations\n            &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n            &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Trading signals\n            &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n            &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n    \"\"\"\n    # Step 1: Validate annotation is not None\n    if annotation is None:\n        raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n    # Step 2: Validate annotation is an Annotation instance\n    if not isinstance(annotation, Annotation):\n        raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n    # Step 3: Handle layer name validation\n    # Use default layer name if None is provided\n    if layer_name is None:\n        layer_name = \"default\"\n    # Validate layer_name is a non-empty string\n    elif not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Add annotation to the specified layer\n    # AnnotationManager will create the layer if it doesn't exist\n    self.annotation_manager.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_annotations","title":"add_annotations","text":"<pre><code>add_annotations(annotations: List[Annotation], layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add multiple annotations to the chart.</p> <p>Adds multiple annotation objects to the specified annotation layer. This is more efficient than calling add_annotation multiple times as it processes all annotations in a single operation and provides better performance for bulk annotation operations.</p> <p>All annotations are added to the same layer, enabling consistent management (show/hide/clear) of related annotations.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects to add to the chart. All must be valid Annotation instances.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". All annotations will be added to this layer.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If annotations is not a list.</p> <code>ValueValidationError</code> <p>If layer_name is invalid.</p> <code>AnnotationItemsTypeError</code> <p>If any item in annotations is not an Annotation instance.</p> Example <p>Add multiple annotations at once::</p> <pre><code>&gt;&gt;&gt; annotations = [\n...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n... ]\n&gt;&gt;&gt; chart.add_annotations(annotations)\n</code></pre> <p>Add to custom layer::</p> <pre><code>&gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n&gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n</code></pre> <p>Bulk operations with method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_annotations(ta_annotations, layer_name=\"ta\")\n...  .add_annotations(signal_annotations, layer_name=\"signals\")\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotations(\n    self,\n    annotations: List[Annotation],\n    layer_name: str = \"default\",\n) -&gt; \"Chart\":\n    \"\"\"Add multiple annotations to the chart.\n\n    Adds multiple annotation objects to the specified annotation layer. This\n    is more efficient than calling add_annotation multiple times as it\n    processes all annotations in a single operation and provides better\n    performance for bulk annotation operations.\n\n    All annotations are added to the same layer, enabling consistent\n    management (show/hide/clear) of related annotations.\n\n    Args:\n        annotations (List[Annotation]): List of annotation objects to add\n            to the chart. All must be valid Annotation instances.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". All annotations will be added to this layer.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If annotations is not a list.\n        ValueValidationError: If layer_name is invalid.\n        AnnotationItemsTypeError: If any item in annotations is not an\n            Annotation instance.\n\n    Example:\n        Add multiple annotations at once::\n\n            &gt;&gt;&gt; annotations = [\n            ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n            ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n            ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n            ... ]\n            &gt;&gt;&gt; chart.add_annotations(annotations)\n\n        Add to custom layer::\n\n            &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n            &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n        Bulk operations with method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n            ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n            ...  .update_options(height=600))\n    \"\"\"\n    # Step 1: Validate annotations is not None\n    if annotations is None:\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 2: Validate annotations is a list\n    if not isinstance(annotations, list):\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 3: Validate layer_name\n    if not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Validate and add each annotation\n    for annotation in annotations:\n        # Ensure each item is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise AnnotationItemsTypeError()\n\n        # Add the annotation to the specified layer\n        # Reuses add_annotation logic for consistency\n        self.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.create_annotation_layer","title":"create_annotation_layer","text":"<pre><code>create_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new annotation layer with the specified name. Annotation layers allow you to organize and manage groups of annotations independently. Each layer can be shown, hidden, or cleared separately, providing flexible control over annotation visibility.</p> Common use cases for layers <ul> <li>Separate technical analysis from trading signals</li> <li>Organize annotations by timeframe or strategy</li> <li>Group annotations by type (text, arrows, shapes)</li> <li>Enable/disable different annotation sets dynamically</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to create. Must be a non-empty string and should be unique.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If name is None.</p> <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Create custom layers for different types of annotations::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .create_annotation_layer(\"layer1\")\n...  .create_annotation_layer(\"layer2\")\n...  .add_annotation(ann1, \"layer1\")\n...  .add_annotation(ann2, \"layer2\"))\n</code></pre> <p>Organize by strategy::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n&gt;&gt;&gt; # Add annotations specific to each strategy\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new annotation layer with the specified name. Annotation layers\n    allow you to organize and manage groups of annotations independently.\n    Each layer can be shown, hidden, or cleared separately, providing\n    flexible control over annotation visibility.\n\n    Common use cases for layers:\n        - Separate technical analysis from trading signals\n        - Organize annotations by timeframe or strategy\n        - Group annotations by type (text, arrows, shapes)\n        - Enable/disable different annotation sets dynamically\n\n    Args:\n        name (str): Name of the annotation layer to create. Must be a\n            non-empty string and should be unique.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If name is None.\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Create custom layers for different types of annotations::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .create_annotation_layer(\"layer1\")\n            ...  .create_annotation_layer(\"layer2\")\n            ...  .add_annotation(ann1, \"layer1\")\n            ...  .add_annotation(ann2, \"layer2\"))\n\n        Organize by strategy::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n            &gt;&gt;&gt; # Add annotations specific to each strategy\n    \"\"\"\n    # Step 1: Validate name is not None\n    if name is None:\n        raise TypeValidationError(\"name\", \"string\")\n\n    # Step 2: Validate name is a non-empty string\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 3: Create the layer in AnnotationManager\n    # If layer already exists, this operation is idempotent\n    self.annotation_manager.create_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.hide_annotation_layer","title":"hide_annotation_layer","text":"<pre><code>hide_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Hide an annotation layer.</p> <p>Hides the specified annotation layer, making all annotations in that layer invisible on the chart. The layer and its annotations are preserved and can be shown again using show_annotation_layer. This is useful for temporarily hiding certain annotation groups without removing them.</p> Hidden layers <ul> <li>Remain in memory with all annotations intact</li> <li>Can be shown again without re-adding annotations</li> <li>Don't affect other layers' visibility</li> <li>Are persisted across chart updates</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to hide.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Hide specific layers::</p> <pre><code>&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .hide_annotation_layer(\"layer1\")\n...  .hide_annotation_layer(\"layer2\")\n...  .show_annotation_layer(\"layer3\"))\n</code></pre> <p>Toggle layer visibility::</p> <pre><code>&gt;&gt;&gt; # Hide analysis layer temporarily\n&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; # ... show chart without analysis\n&gt;&gt;&gt; # Show analysis layer again\n&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Hide an annotation layer.\n\n    Hides the specified annotation layer, making all annotations in that\n    layer invisible on the chart. The layer and its annotations are preserved\n    and can be shown again using show_annotation_layer. This is useful for\n    temporarily hiding certain annotation groups without removing them.\n\n    Hidden layers:\n        - Remain in memory with all annotations intact\n        - Can be shown again without re-adding annotations\n        - Don't affect other layers' visibility\n        - Are persisted across chart updates\n\n    Args:\n        name (str): Name of the annotation layer to hide.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Hide specific layers::\n\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .hide_annotation_layer(\"layer1\")\n            ...  .hide_annotation_layer(\"layer2\")\n            ...  .show_annotation_layer(\"layer3\"))\n\n        Toggle layer visibility::\n\n            &gt;&gt;&gt; # Hide analysis layer temporarily\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; # ... show chart without analysis\n            &gt;&gt;&gt; # Show analysis layer again\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Hide the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.hide_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.show_annotation_layer","title":"show_annotation_layer","text":"<pre><code>show_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Show an annotation layer.</p> <p>Makes the specified annotation layer visible on the chart. This will display all annotations that were previously added to this layer. If the layer doesn't exist or is already visible, this method will have no effect.</p> <p>This is the counterpart to hide_annotation_layer and enables dynamic control over which annotation groups are visible.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to show.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Show specific layers::</p> <pre><code>&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .show_annotation_layer(\"layer1\")\n...  .show_annotation_layer(\"layer2\")\n...  .hide_annotation_layer(\"layer3\"))\n</code></pre> <p>Conditional visibility::</p> <pre><code>&gt;&gt;&gt; # Show different layers based on user selection\n&gt;&gt;&gt; if show_technical_analysis:\n...     chart.show_annotation_layer(\"ta\")\n&gt;&gt;&gt; if show_trading_signals:\n...     chart.show_annotation_layer(\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Show an annotation layer.\n\n    Makes the specified annotation layer visible on the chart. This will\n    display all annotations that were previously added to this layer.\n    If the layer doesn't exist or is already visible, this method will\n    have no effect.\n\n    This is the counterpart to hide_annotation_layer and enables dynamic\n    control over which annotation groups are visible.\n\n    Args:\n        name (str): Name of the annotation layer to show.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Show specific layers::\n\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .show_annotation_layer(\"layer1\")\n            ...  .show_annotation_layer(\"layer2\")\n            ...  .hide_annotation_layer(\"layer3\"))\n\n        Conditional visibility::\n\n            &gt;&gt;&gt; # Show different layers based on user selection\n            &gt;&gt;&gt; if show_technical_analysis:\n            ...     chart.show_annotation_layer(\"ta\")\n            &gt;&gt;&gt; if show_trading_signals:\n            ...     chart.show_annotation_layer(\"signals\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Show the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.show_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations(layer_name: Optional[str] = None) -&gt; Chart\n</code></pre> <p>Clear annotations from the chart.</p> <p>Removes all annotations from the specified layer or from all layers if no layer name is provided. The layer itself is preserved and can be reused for new annotations. This is useful for refreshing annotations without recreating the entire chart.</p> Clearing behavior <ul> <li>With layer_name: Clears only that specific layer</li> <li>Without layer_name: Does nothing (for backward compatibility)</li> <li>Layer structure is preserved (can add new annotations)</li> <li>Does not affect hidden/shown state of layers</li> </ul> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>Optional[str]</code> <p>Name of the layer to clear. If None, no action is taken. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If layer_name is not None and invalid.</p> Example <p>Clear specific layer::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n</code></pre> <p>Clear all layers (provide None)::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .clear_annotations(\"layer1\")\n...  .add_annotation(new_annotation, \"layer1\"))\n</code></pre> <p>Refresh annotations::</p> <pre><code>&gt;&gt;&gt; # Clear old annotations and add new ones\n&gt;&gt;&gt; chart.clear_annotations(\"signals\")\n&gt;&gt;&gt; for signal in new_signals:\n...     chart.add_annotation(signal, \"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n    \"\"\"Clear annotations from the chart.\n\n    Removes all annotations from the specified layer or from all layers if\n    no layer name is provided. The layer itself is preserved and can be\n    reused for new annotations. This is useful for refreshing annotations\n    without recreating the entire chart.\n\n    Clearing behavior:\n        - With layer_name: Clears only that specific layer\n        - Without layer_name: Does nothing (for backward compatibility)\n        - Layer structure is preserved (can add new annotations)\n        - Does not affect hidden/shown state of layers\n\n    Args:\n        layer_name (Optional[str]): Name of the layer to clear. If None,\n            no action is taken. Defaults to None.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If layer_name is not None and invalid.\n\n    Example:\n        Clear specific layer::\n\n            &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n        Clear all layers (provide None)::\n\n            &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .clear_annotations(\"layer1\")\n            ...  .add_annotation(new_annotation, \"layer1\"))\n\n        Refresh annotations::\n\n            &gt;&gt;&gt; # Clear old annotations and add new ones\n            &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n            &gt;&gt;&gt; for signal in new_signals:\n            ...     chart.add_annotation(signal, \"signals\")\n    \"\"\"\n    # Step 1: Validate layer_name if provided\n    if layer_name is not None and (\n        not layer_name or not isinstance(layer_name, str)\n    ):\n        raise ValueValidationError(\n            \"layer_name\", \"must be None or a non-empty string\"\n        )\n\n    # Step 2: Clear the specified layer\n    if layer_name is not None:\n        # Clear only the specified layer through AnnotationManager\n        self.annotation_manager.clear_layer(layer_name)\n\n    # Note: If layer_name is None, no action is taken\n    # This maintains backward compatibility with existing code\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_overlay_price_scale","title":"add_overlay_price_scale","text":"<pre><code>add_overlay_price_scale(scale_id: str, options: PriceScaleOptions) -&gt; Chart\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Adds or updates an overlay price scale configuration for the chart. Overlay price scales allow multiple series to share the same price axis while maintaining independent scaling and positioning. This is commonly used for volume bars, indicators, and other overlays.</p> Overlay price scales enable <ul> <li>Independent vertical positioning (scale margins)</li> <li>Separate auto-scaling behavior</li> <li>Different visibility settings</li> <li>Custom formatting and precision</li> </ul> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced by series that use this price scale.</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration for the overlay price scale.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>PriceScaleIdTypeError</code> <p>If scale_id is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If options is not a PriceScaleOptions instance.</p> Example <p>Add volume overlay price scale::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n...     PriceScaleOptions\n... )\n&gt;&gt;&gt; volume_scale = PriceScaleOptions(\n...     visible=False,  # Hide the price scale itself\n...     scale_margin_top=0.8,  # Volume takes bottom 20%\n...     scale_margin_bottom=0,\n...     overlay=True,  # Mark as overlay\n...     auto_scale=True  # Auto-scale to data\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n</code></pre> <p>Add indicator overlay::</p> <pre><code>&gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n...     visible=True,\n...     scale_margin_top=0.7,\n...     scale_margin_bottom=0.1,\n...     overlay=True\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_overlay_price_scale('volume', volume_scale)\n...  .add_series(volume_series))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_overlay_price_scale(\n    self, scale_id: str, options: \"PriceScaleOptions\"\n) -&gt; \"Chart\":\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Adds or updates an overlay price scale configuration for the chart.\n    Overlay price scales allow multiple series to share the same price axis\n    while maintaining independent scaling and positioning. This is commonly\n    used for volume bars, indicators, and other overlays.\n\n    Overlay price scales enable:\n        - Independent vertical positioning (scale margins)\n        - Separate auto-scaling behavior\n        - Different visibility settings\n        - Custom formatting and precision\n\n    Args:\n        scale_id (str): The unique identifier for the custom price scale\n            (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n            by series that use this price scale.\n        options (PriceScaleOptions): A PriceScaleOptions instance containing\n            the configuration for the overlay price scale.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        PriceScaleIdTypeError: If scale_id is not a string.\n        PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n    Example:\n        Add volume overlay price scale::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n            ...     PriceScaleOptions\n            ... )\n            &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n            ...     visible=False,  # Hide the price scale itself\n            ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n            ...     scale_margin_bottom=0,\n            ...     overlay=True,  # Mark as overlay\n            ...     auto_scale=True  # Auto-scale to data\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n        Add indicator overlay::\n\n            &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n            ...     visible=True,\n            ...     scale_margin_top=0.7,\n            ...     scale_margin_bottom=0.1,\n            ...     overlay=True\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_overlay_price_scale('volume', volume_scale)\n            ...  .add_series(volume_series))\n    \"\"\"\n    # Step 1: Add overlay scale through PriceScaleManager\n    # Manager validates scale_id and options internally\n    self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n    # Step 2: Sync back to options for backward compatibility\n    # This ensures options.overlay_price_scales is updated\n    # Some legacy code may access overlay scales directly from options\n    self.options.overlay_price_scales[scale_id] = options\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series to the chart from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale positioned at the bottom of the chart.</p> This is a convenience method that <ol> <li>Configures the volume overlay price scale</li> <li>Creates price series (candlestick or line)</li> <li>Creates volume histogram series</li> <li>Adds both series to the chart</li> </ol> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information. Can be a sequence of OhlcvData objects or a pandas DataFrame.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\". Defaults to None (assumes standard column names).</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series to create. Options: \"candlestick\" or \"line\". Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration (colors, line width, etc.). Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration (colors, transparency, etc.). Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0. Used in multi-pane charts.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If data type is invalid.</p> <code>ValueError</code> <p>If column_mapping is invalid or required columns are missing.</p> Example <p>Add candlestick with volume::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n...     price_type=\"candlestick\"\n... )\n</code></pre> <p>Add line chart with custom volume colors::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     price_type=\"line\",\n...     volume_kwargs={\n...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n...     }\n... )\n</code></pre> <p>From DataFrame::</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'timestamp': [...],\n...     'o': [...],\n...     'h': [...],\n...     'l': [...],\n...     'c': [...],\n...     'v': [...]\n... })\n&gt;&gt;&gt; chart.add_price_volume_series(\n...     df,\n...     column_mapping={\n...         \"time\": \"timestamp\",\n...         \"open\": \"o\",\n...         \"high\": \"h\",\n...         \"low\": \"l\",\n...         \"close\": \"c\",\n...         \"volume\": \"v\"\n...     }\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series to the chart from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale positioned at the\n    bottom of the chart.\n\n    This is a convenience method that:\n        1. Configures the volume overlay price scale\n        2. Creates price series (candlestick or line)\n        3. Creates volume histogram series\n        4. Adds both series to the chart\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information. Can be a sequence of OhlcvData objects\n            or a pandas DataFrame.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n            Defaults to None (assumes standard column names).\n        price_type (str, optional): Type of price series to create. Options:\n            \"candlestick\" or \"line\". Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration (colors, line width, etc.). Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration (colors, transparency, etc.). Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0. Used in multi-pane charts.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If data type is invalid.\n        ValueError: If column_mapping is invalid or required columns are missing.\n\n    Example:\n        Add candlestick with volume::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n            ...     price_type=\"candlestick\"\n            ... )\n\n        Add line chart with custom volume colors::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     price_type=\"line\",\n            ...     volume_kwargs={\n            ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n            ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n            ...     }\n            ... )\n\n        From DataFrame::\n\n            &gt;&gt;&gt; df = pd.DataFrame({\n            ...     'timestamp': [...],\n            ...     'o': [...],\n            ...     'h': [...],\n            ...     'l': [...],\n            ...     'c': [...],\n            ...     'v': [...]\n            ... })\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     df,\n            ...     column_mapping={\n            ...         \"time\": \"timestamp\",\n            ...         \"open\": \"o\",\n            ...         \"high\": \"h\",\n            ...         \"low\": \"l\",\n            ...         \"close\": \"c\",\n            ...         \"volume\": \"v\"\n            ...     }\n            ... )\n    \"\"\"\n    # Step 1: Configure price scale manager for volume visualization\n    # This sets up the overlay price scale with proper margins\n    # Volume typically occupies the bottom 20% of the chart\n    self._price_scale_manager.configure_for_volume()\n\n    # Step 2: Delegate to series manager for actual series creation\n    # SeriesManager handles:\n    # - Data conversion (DataFrame to OhlcvData if needed)\n    # - Price series creation (candlestick or line)\n    # - Volume histogram series creation\n    # - Series configuration from kwargs\n    # - Adding both series to the chart\n    self._series_manager.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n        price_scale_manager=self._price_scale_manager,\n    )\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; Chart\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements and adds them to the chart for visualization. Each trade is displayed with entry/exit markers, connecting lines, profit/loss rectangles, or zones based on the TradeVisualizationOptions.style configuration.</p> Trade visualization styles <ul> <li>\"markers\": Entry and exit markers only</li> <li>\"rectangle\": Filled rectangle between entry and exit</li> <li>\"line\": Simple line connecting entry to exit</li> <li>\"arrow\": Arrow from entry to exit</li> <li>\"zone\": Highlighted zone with transparency</li> </ul> The visualization automatically color-codes trades <ul> <li>Green/profit color for winning trades</li> <li>Red/loss color for losing trades</li> <li>Customizable through TradeVisualizationOptions</li> </ul> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart. Each trade must have entry_time, entry_price, exit_time, exit_price, and trade_type.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Add basic trade visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n&gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n...     TradeType\n... )\n&gt;&gt;&gt; trades = [\n...     TradeData(\n...         entry_time=\"2024-01-01 10:00:00\",\n...         entry_price=100.0,\n...         exit_time=\"2024-01-01 15:00:00\",\n...         exit_price=105.0,\n...         quantity=100,\n...         trade_type=TradeType.LONG,\n...     )\n... ]\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>With custom visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n...     TradeVisualizationOptions\n... )\n&gt;&gt;&gt; # Configure trade visualization\n&gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n...     style=\"rectangle\",\n...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n... )\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_trades(trades)\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements and adds them to the chart\n    for visualization. Each trade is displayed with entry/exit markers,\n    connecting lines, profit/loss rectangles, or zones based on the\n    TradeVisualizationOptions.style configuration.\n\n    Trade visualization styles:\n        - \"markers\": Entry and exit markers only\n        - \"rectangle\": Filled rectangle between entry and exit\n        - \"line\": Simple line connecting entry to exit\n        - \"arrow\": Arrow from entry to exit\n        - \"zone\": Highlighted zone with transparency\n\n    The visualization automatically color-codes trades:\n        - Green/profit color for winning trades\n        - Red/loss color for losing trades\n        - Customizable through TradeVisualizationOptions\n\n    Args:\n        trades (List[TradeData]): List of TradeData objects to visualize\n            on the chart. Each trade must have entry_time, entry_price,\n            exit_time, exit_price, and trade_type.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Add basic trade visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            ...     TradeType\n            ... )\n            &gt;&gt;&gt; trades = [\n            ...     TradeData(\n            ...         entry_time=\"2024-01-01 10:00:00\",\n            ...         entry_price=100.0,\n            ...         exit_time=\"2024-01-01 15:00:00\",\n            ...         exit_price=105.0,\n            ...         quantity=100,\n            ...         trade_type=TradeType.LONG,\n            ...     )\n            ... ]\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        With custom visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n            ...     TradeVisualizationOptions\n            ... )\n            &gt;&gt;&gt; # Configure trade visualization\n            &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n            ...     style=\"rectangle\",\n            ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n            ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n            ... )\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_trades(trades)\n            ...  .update_options(height=600))\n    \"\"\"\n    # Delegate to TradeManager which handles:\n    # - Trade validation\n    # - Conversion to visual elements (markers, rectangles, etc.)\n    # - Profit/loss calculations\n    # - Color coding based on trade outcome\n    # - Annotation creation for visualization\n    self._trade_manager.add_trades(trades)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.set_tooltip_manager","title":"set_tooltip_manager","text":"<pre><code>set_tooltip_manager(tooltip_manager) -&gt; Chart\n</code></pre> <p>Set the tooltip manager for the chart.</p> <p>Assigns a TooltipManager instance to handle custom tooltip functionality. Tooltips provide additional information when hovering over chart elements.</p> <p>Parameters:</p> Name Type Description Default <code>tooltip_manager</code> <p>TooltipManager instance to handle tooltip functionality.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If tooltip_manager is not a TooltipManager instance.</p> Example <p>Set custom tooltip manager::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipManager\n... )\n&gt;&gt;&gt; manager = TooltipManager()\n&gt;&gt;&gt; chart.set_tooltip_manager(manager)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n    \"\"\"Set the tooltip manager for the chart.\n\n    Assigns a TooltipManager instance to handle custom tooltip functionality.\n    Tooltips provide additional information when hovering over chart elements.\n\n    Args:\n        tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n    Example:\n        Set custom tooltip manager::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipManager\n            ... )\n            &gt;&gt;&gt; manager = TooltipManager()\n            &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n    \"\"\"\n    # Validate tooltip_manager is a TooltipManager instance\n    if not isinstance(tooltip_manager, TooltipManager):\n        raise TypeValidationError(\n            \"tooltip_manager\", \"TooltipManager instance\"\n        )\n\n    # Assign the tooltip manager\n    self._tooltip_manager = tooltip_manager\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.add_tooltip_config","title":"add_tooltip_config","text":"<pre><code>add_tooltip_config(name: str, config) -&gt; Chart\n</code></pre> <p>Add a tooltip configuration to the chart.</p> <p>Adds a named tooltip configuration that defines how tooltips should be displayed for specific data points or series. Multiple tooltip configurations can be registered and used selectively.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the tooltip configuration (unique identifier).</p> required <code>config</code> <p>TooltipConfig instance defining tooltip appearance and behavior.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If config is not a TooltipConfig instance.</p> Example <p>Add custom tooltip configuration::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipConfig\n... )\n&gt;&gt;&gt; config = TooltipConfig(\n...     title=\"Price Info\",\n...     show_time=True,\n...     show_value=True\n... )\n&gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n    \"\"\"Add a tooltip configuration to the chart.\n\n    Adds a named tooltip configuration that defines how tooltips should\n    be displayed for specific data points or series. Multiple tooltip\n    configurations can be registered and used selectively.\n\n    Args:\n        name: Name for the tooltip configuration (unique identifier).\n        config: TooltipConfig instance defining tooltip appearance and behavior.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If config is not a TooltipConfig instance.\n\n    Example:\n        Add custom tooltip configuration::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipConfig\n            ... )\n            &gt;&gt;&gt; config = TooltipConfig(\n            ...     title=\"Price Info\",\n            ...     show_time=True,\n            ...     show_value=True\n            ... )\n            &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n    \"\"\"\n    # Validate config is a TooltipConfig instance\n    if not isinstance(config, TooltipConfig):\n        raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n    # Lazy-load tooltip manager if not already set\n    # This avoids creating TooltipManager until actually needed\n    if self._tooltip_manager is None:\n        self._tooltip_manager = TooltipManager()\n\n    # Add the configuration to the tooltip manager\n    self._tooltip_manager.add_config(name, config)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.set_chart_group_id","title":"set_chart_group_id","text":"<pre><code>set_chart_group_id(group_id: int) -&gt; Chart\n</code></pre> <p>Set the chart group ID for synchronization.</p> <p>Sets the chart group ID which is used for synchronizing multiple charts. Charts with the same group_id will be synchronized with each other, sharing crosshair position and time range changes.</p> Note <p>This is different from ChartManager's sync_group which manages synchronization at a higher level. chart_group_id is used for individual chart synchronization, while sync_group is used for managing groups of charts in ChartManager.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>int</code> <p>Group ID for synchronization. Charts with the same group_id will be synchronized.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If group_id is not an integer.</p> Example <p>Set chart group ID::</p> <pre><code>&gt;&gt;&gt; chart1.set_chart_group_id(1)\n&gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n</code></pre> <p>Disable synchronization::</p> <pre><code>&gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n    \"\"\"Set the chart group ID for synchronization.\n\n    Sets the chart group ID which is used for synchronizing multiple charts.\n    Charts with the same group_id will be synchronized with each other,\n    sharing crosshair position and time range changes.\n\n    Note:\n        This is different from ChartManager's sync_group which manages\n        synchronization at a higher level. chart_group_id is used for\n        individual chart synchronization, while sync_group is used for\n        managing groups of charts in ChartManager.\n\n    Args:\n        group_id (int): Group ID for synchronization. Charts with the same\n            group_id will be synchronized.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If group_id is not an integer.\n\n    Example:\n        Set chart group ID::\n\n            &gt;&gt;&gt; chart1.set_chart_group_id(1)\n            &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n        Disable synchronization::\n\n            &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n    \"\"\"\n    # Use property setter which includes validation\n    self.chart_group_id = group_id\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert chart to frontend configuration dictionary.</p> <p>Converts the chart and all its components (series, options, annotations, trades, tooltips) to a dictionary format suitable for frontend consumption. This method orchestrates the serialization of all chart elements.</p> The serialization process <ol> <li>Get series configurations from SeriesManager</li> <li>Get base chart options</li> <li>Get price scale configuration from PriceScaleManager</li> <li>Get annotations configuration from AnnotationManager</li> <li>Get trades configuration from TradeManager</li> <li>Get tooltip configurations from TooltipManager (if set)</li> <li>Generate complete frontend config using ChartRenderer</li> <li>Add force_reinit flag if set</li> </ol> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Complete chart configuration ready for frontend rendering. The configuration includes: - charts: List of chart objects with series and options - syncConfig: Synchronization settings for multi-chart layouts - annotations: Annotation layers and elements - trades: Trade visualization elements - tooltips: Custom tooltip configurations</p> Note <p>Series are automatically ordered by z-index within each pane to ensure proper layering in the frontend. Series with lower z-index values render behind series with higher z-index values.</p> Example <p>Get frontend configuration::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; print(json.dumps(config, indent=2))\n</code></pre> <p>Access specific parts::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; chart_config = config[\"charts\"][0]\n&gt;&gt;&gt; series_config = chart_config[\"series\"]\n&gt;&gt;&gt; options_config = chart_config[\"chart\"]\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert chart to frontend configuration dictionary.\n\n    Converts the chart and all its components (series, options, annotations,\n    trades, tooltips) to a dictionary format suitable for frontend consumption.\n    This method orchestrates the serialization of all chart elements.\n\n    The serialization process:\n        1. Get series configurations from SeriesManager\n        2. Get base chart options\n        3. Get price scale configuration from PriceScaleManager\n        4. Get annotations configuration from AnnotationManager\n        5. Get trades configuration from TradeManager\n        6. Get tooltip configurations from TooltipManager (if set)\n        7. Generate complete frontend config using ChartRenderer\n        8. Add force_reinit flag if set\n\n    Returns:\n        Dict[str, Any]: Complete chart configuration ready for frontend\n            rendering. The configuration includes:\n            - charts: List of chart objects with series and options\n            - syncConfig: Synchronization settings for multi-chart layouts\n            - annotations: Annotation layers and elements\n            - trades: Trade visualization elements\n            - tooltips: Custom tooltip configurations\n\n    Note:\n        Series are automatically ordered by z-index within each pane to ensure\n        proper layering in the frontend. Series with lower z-index values\n        render behind series with higher z-index values.\n\n    Example:\n        Get frontend configuration::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n        Access specific parts::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n            &gt;&gt;&gt; series_config = chart_config[\"series\"]\n            &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n    \"\"\"\n    # Step 1: Get series configurations from SeriesManager\n    # SeriesManager handles series ordering by z-index and pane\n    series_configs = self._series_manager.to_frontend_configs()\n\n    # Step 2: Get base chart configuration from ChartOptions\n    # Convert ChartOptions to dictionary for frontend\n    chart_config = (\n        self.options.asdict()\n        if self.options is not None\n        else ChartOptions().asdict()\n    )\n\n    # Step 3: Get price scale configuration from PriceScaleManager\n    # Manager validates scales and returns serialized configuration\n    price_scale_config = self._price_scale_manager.validate_and_serialize()\n    # Merge price scale config into chart config\n    chart_config.update(price_scale_config)\n\n    # Step 4: Get annotations configuration from AnnotationManager\n    # Converts all annotation layers to frontend format\n    annotations_config = self.annotation_manager.asdict()\n\n    # Step 5: Get trades configuration from TradeManager\n    # Converts TradeData objects to visual elements\n    # Uses trade_visualization options from chart options\n    trades_config = self._trade_manager.to_frontend_config(\n        self.options.trade_visualization if self.options else None\n    )\n\n    # Step 6: Get tooltip configurations from TooltipManager\n    tooltip_configs = None\n    if self._tooltip_manager:\n        # Convert each tooltip config to dictionary\n        tooltip_configs = {}\n        for name, tooltip_config in self._tooltip_manager.configs.items():\n            tooltip_configs[name] = tooltip_config.asdict()\n\n    # Step 7: Generate complete frontend configuration using ChartRenderer\n    # ChartRenderer assembles all components into final configuration\n    config = self._chart_renderer.generate_frontend_config(\n        chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n        chart_options=self.options,\n        series_configs=series_configs,\n        annotations_config=annotations_config,\n        trades_config=trades_config,\n        tooltip_configs=tooltip_configs,\n        chart_group_id=self.chart_group_id,\n        price_scale_config=price_scale_config,\n    )\n\n    # Step 8: Add force_reinit flag if set\n    # This tells frontend to completely rebuild the chart\n    # Used when indicator parameters or other settings change\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Return the complete frontend configuration\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.render","title":"render","text":"<pre><code>render(key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Converts the chart to frontend configuration and renders it using the Streamlit component. This is the final step in the chart creation process that displays the interactive chart in the Streamlit application.</p> The rendering process follows these steps <ol> <li>Generate or validate component key</li> <li>Reset config application flag for this render cycle</li> <li>Load and apply stored series configurations from session state</li> <li>Generate frontend configuration (after configs applied)</li> <li>Render component using ChartRenderer</li> <li>Handle component response and save updated series configs</li> </ol> <p>The chart configuration is generated fresh on each render, allowing users to control chart lifecycle and state management in their own code if needed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional unique key for the Streamlit component. This key is used to identify the component instance and is useful for debugging and component state management. If not provided, a unique key will be generated automatically using timestamp and UUID.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The rendered Streamlit component that displays the interactive chart. May contain user interaction data if the frontend sends responses.</p> Example <p>Basic rendering::</p> <pre><code>&gt;&gt;&gt; chart.render()\n</code></pre> <p>Rendering with custom key::</p> <pre><code>&gt;&gt;&gt; chart.render(key=\"my_chart\")\n</code></pre> <p>Method chaining with rendering::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_series(line_series)\n...  .update_options(height=600)\n...  .render(key=\"chart1\"))\n</code></pre> <p>User-managed state (advanced)::</p> <pre><code>&gt;&gt;&gt; # Store chart in session state for persistence\n&gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n...     st.session_state.my_chart = Chart(series=LineSeries(data))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Render the persisted chart\n&gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n</code></pre> <p>Dynamic key generation::</p> <pre><code>&gt;&gt;&gt; # Key includes timestamp for uniqueness\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def render(self, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Converts the chart to frontend configuration and renders it using the\n    Streamlit component. This is the final step in the chart creation process\n    that displays the interactive chart in the Streamlit application.\n\n    The rendering process follows these steps:\n        1. Generate or validate component key\n        2. Reset config application flag for this render cycle\n        3. Load and apply stored series configurations from session state\n        4. Generate frontend configuration (after configs applied)\n        5. Render component using ChartRenderer\n        6. Handle component response and save updated series configs\n\n    The chart configuration is generated fresh on each render, allowing users\n    to control chart lifecycle and state management in their own code if needed.\n\n    Args:\n        key (Optional[str]): Optional unique key for the Streamlit component.\n            This key is used to identify the component instance and is useful\n            for debugging and component state management. If not provided,\n            a unique key will be generated automatically using timestamp and UUID.\n\n    Returns:\n        Any: The rendered Streamlit component that displays the interactive chart.\n            May contain user interaction data if the frontend sends responses.\n\n    Example:\n        Basic rendering::\n\n            &gt;&gt;&gt; chart.render()\n\n        Rendering with custom key::\n\n            &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n        Method chaining with rendering::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_series(line_series)\n            ...  .update_options(height=600)\n            ...  .render(key=\"chart1\"))\n\n        User-managed state (advanced)::\n\n            &gt;&gt;&gt; # Store chart in session state for persistence\n            &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n            ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Render the persisted chart\n            &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n        Dynamic key generation::\n\n            &gt;&gt;&gt; # Key includes timestamp for uniqueness\n            &gt;&gt;&gt; import time\n            &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n    \"\"\"\n    # STEP 1: Generate a unique key if none provided or if it's invalid\n    if key is None or not isinstance(key, str) or not key.strip():\n        # Create unique identifier using timestamp and UUID\n        unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n        timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n        key = f\"chart_{timestamp}_{unique_id}\"\n\n    # STEP 2: Reset config application flag for this render cycle\n    # This ensures configs are only applied once per render\n    # Prevents duplicate application of stored configurations\n    self._session_state_manager.reset_config_applied_flag()\n\n    # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n    # This is critical: we must apply user-modified configs BEFORE\n    # generating the frontend configuration, otherwise the configs\n    # won't be included in the serialized data\n    stored_configs = self._session_state_manager.load_series_configs(key)\n    if stored_configs:\n        # Apply stored configs to all series\n        # This updates series options with user-modified settings\n        self._session_state_manager.apply_stored_configs_to_series(\n            stored_configs,\n            self.series,  # Current series list\n        )\n\n    # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n    # This ensures the frontend config includes all user modifications\n    # The to_frontend_config() method serializes all chart components\n    config = self.to_frontend_config()\n\n    # STEP 5: Render component using ChartRenderer\n    # ChartRenderer handles:\n    # - Component function retrieval\n    # - Configuration serialization to JSON\n    # - Component rendering through Streamlit\n    # - Error handling if component is unavailable\n    result = self._chart_renderer.render(config, key, self.options)\n\n    # STEP 6: Handle component return value and save series configs\n    # The frontend may send back user interactions or config changes\n    if result:\n        # ChartRenderer processes the response and updates session state\n        # This includes saving any user-modified series configurations\n        self._chart_renderer.handle_response(\n            result,\n            key,\n            self._session_state_manager,\n        )\n\n    # Return the component result\n    # This may contain user interaction data or None\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Chart.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for the series settings dialog.</p> <p>Retrieves information about all series in a specific pane. This is used by the series settings dialog to display available series and their current configurations.</p> <p>Parameters:</p> Name Type Description Default <code>_pane_id</code> <code>int</code> <p>The pane ID to get series info for (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries containing: - series_index: Index of the series - series_type: Type of series (line, candlestick, etc.) - series_name: Display name of the series - current_config: Current series configuration</p> Example <p>Get series info::</p> <pre><code>&gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n&gt;&gt;&gt; for info in series_info:\n...     print(f\"{info['series_name']}: {info['series_type']}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for the series settings dialog.\n\n    Retrieves information about all series in a specific pane. This is\n    used by the series settings dialog to display available series and\n    their current configurations.\n\n    Args:\n        _pane_id: The pane ID to get series info for (default: 0).\n\n    Returns:\n        List of series information dictionaries containing:\n            - series_index: Index of the series\n            - series_type: Type of series (line, candlestick, etc.)\n            - series_name: Display name of the series\n            - current_config: Current series configuration\n\n    Example:\n        Get series info::\n\n            &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n            &gt;&gt;&gt; for info in series_info:\n            ...     print(f\"{info['series_name']}: {info['series_type']}\")\n    \"\"\"\n    # Delegate to SeriesManager which has access to all series data\n    return self._series_manager.get_series_info_for_pane(_pane_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager","title":"ChartManager","text":"<p>Manager for multiple synchronized charts.</p> <p>This class provides comprehensive functionality to manage multiple Chart instances with advanced synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> <p>The ChartManager maintains a registry of charts with unique identifiers and manages synchronization groups that allow charts to share crosshair position, time ranges, and other interactive states. This is particularly useful for creating multi-pane financial dashboards with coordinated chart behavior.</p> <p>Attributes:</p> Name Type Description <code>charts</code> <code>Dict[str, Chart]</code> <p>Dictionary mapping chart IDs to Chart instances.</p> <code>sync_groups</code> <code>Dict[str, SyncOptions]</code> <p>Dictionary mapping chart IDs to their synchronization group options.</p> <code>default_sync</code> <code>SyncOptions</code> <p>Default synchronization options applied to new charts when no specific group is assigned.</p> Example <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager\nmanager = ChartManager()\n\n# Add charts with unique IDs\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization groups\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render all charts with synchronization\nmanager.render_all_charts()\n</code></pre> Note <ul> <li>Charts must have unique IDs within the manager</li> <li>Synchronization groups allow coordinated behavior between charts</li> <li>Individual charts can be rendered or all charts can be rendered together</li> <li>The manager handles component lifecycle and state management</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>class ChartManager:\n    \"\"\"Manager for multiple synchronized charts.\n\n    This class provides comprehensive functionality to manage multiple Chart instances\n    with advanced synchronization capabilities. It enables coordinated display of\n    multiple charts with shared time ranges, crosshair synchronization, and group-based\n    configuration management.\n\n    The ChartManager maintains a registry of charts with unique identifiers and\n    manages synchronization groups that allow charts to share crosshair position,\n    time ranges, and other interactive states. This is particularly useful for\n    creating multi-pane financial dashboards with coordinated chart behavior.\n\n    Attributes:\n        charts (Dict[str, Chart]): Dictionary mapping chart IDs to Chart instances.\n        sync_groups (Dict[str, SyncOptions]): Dictionary mapping chart IDs to their\n            synchronization group options.\n        default_sync (SyncOptions): Default synchronization options applied to\n            new charts when no specific group is assigned.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create manager\n        manager = ChartManager()\n\n        # Add charts with unique IDs\n        manager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\n        manager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n        # Configure synchronization groups\n        manager.set_sync_group(\"price_chart\", \"main_group\")\n        manager.set_sync_group(\"volume_chart\", \"main_group\")\n\n        # Render all charts with synchronization\n        manager.render_all_charts()\n        ```\n\n    Note:\n        - Charts must have unique IDs within the manager\n        - Synchronization groups allow coordinated behavior between charts\n        - Individual charts can be rendered or all charts can be rendered together\n        - The manager handles component lifecycle and state management\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ChartManager.\n\n        Creates a new ChartManager with empty chart registry and default\n        synchronization settings. The manager starts with no charts and uses\n        default sync options for new charts.\n        \"\"\"\n        # Initialize chart registry - maps chart IDs to Chart instances\n        self.charts: Dict[str, Chart] = {}\n\n        # Initialize sync groups - maps chart IDs to their sync configuration\n        self.sync_groups: Dict[str, SyncOptions] = {}\n\n        # Set default sync options for new charts without specific group assignment\n        self.default_sync: SyncOptions = SyncOptions()\n\n        # Flag to force frontend re-initialization (for indicator/parameter changes)\n        self.force_reinit: bool = False\n\n        # Metadata for change detection (symbol/interval)\n        # These are used by frontend to detect when data context changes\n        self.symbol: Optional[str] = None\n        self.display_interval: Optional[str] = None\n\n    def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n        \"\"\"Add a chart to the manager.\n\n        Adds a Chart instance to the manager with a unique identifier. The chart\n        is registered in the manager's chart registry and can participate in\n        synchronization groups. If no chart ID is provided, one is automatically\n        generated.\n\n        Args:\n            chart (Chart): The Chart instance to add to the manager.\n            chart_id (Optional[str]): Optional unique identifier for the chart.\n                If not provided, an auto-generated ID in the format \"chart_N\"\n                will be assigned.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Raises:\n            DuplicateError: If a chart with the specified ID already exists.\n\n        Example:\n            ```python\n            manager = ChartManager()\n            chart = Chart(series=LineSeries(data))\n\n            # Add chart with auto-generated ID\n            manager.add_chart(chart)\n\n            # Add chart with custom ID\n            manager.add_chart(chart, \"price_chart\")\n            ```\n        \"\"\"\n        # Generate unique chart ID if not provided\n        if chart_id is None:\n            chart_id = f\"chart_{len(self.charts) + 1}\"\n\n        # Validate that chart ID is unique within the manager\n        if chart_id in self.charts:\n            raise DuplicateError(\"Chart\", chart_id)\n\n        # Set the ChartManager reference on the chart for bidirectional communication\n        # This allows the chart to access manager configuration and sync settings\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add chart to the registry with its unique identifier\n        self.charts[chart_id] = chart\n        return self\n\n    def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n        \"\"\"Remove a chart from the manager.\n\n        Args:\n            chart_id: ID of the chart to remove\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        del self.charts[chart_id]\n        return self\n\n    def get_chart(self, chart_id: str) -&gt; Chart:\n        \"\"\"Get a chart by ID.\n\n        Args:\n            chart_id: ID of the chart to retrieve\n\n        Returns:\n            The Chart instance\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        return self.charts[chart_id]\n\n    def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n        This method renders a single chart while preserving the ChartManager's\n        sync configuration and group settings. This ensures that individual\n        charts can still participate in group synchronization.\n\n        Args:\n            chart_id: The ID of the chart to render\n            key: Optional key for the Streamlit component\n\n        Returns:\n            The rendered component\n\n        Raises:\n            ValueError: If chart_id is not found\n\n        Example:\n            ```python\n            manager = ChartManager()\n            manager.add_chart(chart1, \"chart1\")\n            manager.add_chart(chart2, \"chart2\")\n\n            col1, col2 = st.columns(2)\n            with col1:\n                manager.render_chart(\"chart1\")\n            with col2:\n                manager.render_chart(\"chart2\")\n            ```\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        # Get the chart and render it (sync config is automatically included)\n        chart = self.charts[chart_id]\n        return chart.render(key=key)\n\n    def get_chart_ids(self) -&gt; List[str]:\n        \"\"\"Get all chart IDs.\n\n        Returns:\n            List of chart IDs\n        \"\"\"\n        return list(self.charts.keys())\n\n    def clear_charts(self) -&gt; \"ChartManager\":\n        \"\"\"Remove all charts from the manager.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self.charts.clear()\n        return self\n\n    def set_sync_group_config(\n        self,\n        group_id: Union[int, str],\n        sync_options: SyncOptions,\n    ) -&gt; \"ChartManager\":\n        \"\"\"Set synchronization configuration for a specific group.\n\n        This method allows you to configure synchronization options for a\n        specific group of charts. Groups enable you to have multiple independent\n        sets of synchronized charts within the same ChartManager.\n\n        For example, you might want to:\n        - Synchronize price and volume charts in one group\n        - Synchronize indicator charts in another group\n        - Keep some charts completely independent\n\n        Args:\n            group_id: The sync group ID (int or str). Charts with the same\n                group_id will be synchronized according to these options.\n            sync_options: The SyncOptions configuration object for this group,\n                specifying which synchronization features to enable.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n            manager = ChartManager()\n\n            # Configure group \"price_charts\" with full sync\n            price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n            manager.set_sync_group_config(\"price_charts\", price_sync)\n\n            # Configure group \"indicators\" with crosshair only\n            indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n            manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n            # Add charts to different groups\n            manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n            manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n            ```\n        \"\"\"\n        self.sync_groups[str(group_id)] = sync_options\n        return self\n\n    def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n        \"\"\"Get synchronization configuration for a specific group.\n\n        Retrieves the current synchronization options for a specified group.\n        This is useful for inspecting or modifying existing group configurations.\n\n        Args:\n            group_id: The sync group ID (int or str) to retrieve configuration for.\n\n        Returns:\n            SyncOptions: The sync configuration for the group, or None if the\n                group hasn't been configured yet.\n\n        Example:\n            ```python\n            # Get configuration for a group\n            config = manager.get_sync_group_config(\"price_charts\")\n            if config:\n                print(f\"Crosshair sync: {config.crosshair}\")\n                print(f\"Time range sync: {config.time_range}\")\n\n            # Check if group exists before modifying\n            if manager.get_sync_group_config(\"indicators\") is None:\n                manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n            ```\n        \"\"\"\n        return self.sync_groups.get(str(group_id))\n\n    def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable crosshair synchronization for linked charts.\n\n        When enabled, moving the crosshair on one chart will synchronize the\n        crosshair position across all charts in the same synchronization group.\n        This creates a coordinated viewing experience where users can see\n        corresponding data points across multiple charts simultaneously.\n\n        The synchronization uses a robust implementation with debouncing and\n        flag-based protection to prevent race conditions and feedback loops,\n        even during rapid user interactions.\n\n        Args:\n            group_id: Optional group ID to enable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n                Groups allow you to have multiple independent sets of\n                synchronized charts.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_crosshair_sync()\n\n            # Enable for specific group\n            manager.enable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_crosshair()\n        else:\n            self.default_sync.enable_crosshair()\n        return self\n\n    def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable crosshair synchronization for linked charts.\n\n        When disabled, crosshair movements will not be synchronized across\n        charts. Each chart will have an independent crosshair that only\n        responds to mouse movements over that specific chart.\n\n        Args:\n            group_id: Optional group ID to disable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_crosshair_sync()\n\n            # Disable for specific group\n            manager.disable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_crosshair()\n        else:\n            self.default_sync.disable_crosshair()\n        return self\n\n    def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n        When enabled, zooming or panning the time range on one chart will\n        synchronize the visible time range across all charts in the same\n        synchronization group. This allows users to maintain consistent\n        time alignment while analyzing multiple charts.\n\n        The synchronization includes:\n        - Zoom operations (pinch, scroll wheel, double-click)\n        - Pan/scroll operations (drag, arrow keys)\n        - Programmatic range changes\n\n        Implementation uses throttling (16ms ~60fps) to ensure smooth\n        performance and prevent race conditions during rapid interactions.\n\n        Args:\n            group_id: Optional group ID to enable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_time_range_sync()\n\n            # Enable for specific group\n            manager.enable_time_range_sync(group_id=\"indicators\")\n\n            # Enable both crosshair and time range\n            manager.enable_crosshair_sync().enable_time_range_sync()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_time_range()\n        else:\n            self.default_sync.enable_time_range()\n        return self\n\n    def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n        When disabled, zoom and pan operations will not be synchronized across\n        charts. Each chart can be zoomed and panned independently.\n\n        Args:\n            group_id: Optional group ID to disable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_time_range_sync()\n\n            # Disable for specific group\n            manager.disable_time_range_sync(group_id=\"indicators\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_time_range()\n        else:\n            self.default_sync.disable_time_range()\n        return self\n\n    def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable all synchronization features for linked charts.\n\n        This is a convenience method that enables both crosshair and time range\n        synchronization in a single call. It's the most common configuration for\n        creating fully synchronized multi-chart dashboards.\n\n        When all synchronization is enabled:\n        - Crosshair movements are synchronized across all charts\n        - Zoom/pan operations are synchronized across all charts\n        - Users get a fully coordinated viewing experience\n\n        Args:\n            group_id: Optional group ID to enable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable all sync for default group\n            manager.enable_all_sync()\n\n            # Enable all sync for specific group\n            manager.enable_all_sync(group_id=\"main_charts\")\n\n            # Create fully synchronized dashboard\n            manager = ChartManager()\n            manager.add_chart(price_chart, \"price\")\n            manager.add_chart(volume_chart, \"volume\")\n            manager.add_chart(indicator_chart, \"indicator\")\n            manager.enable_all_sync()\n            manager.render()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_all()\n        else:\n            self.default_sync.enable_all()\n        return self\n\n    def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable all synchronization features for linked charts.\n\n        This is a convenience method that disables both crosshair and time range\n        synchronization in a single call. Use this when you want charts to\n        operate completely independently.\n\n        When all synchronization is disabled:\n        - Each chart has its own independent crosshair\n        - Each chart can be zoomed/panned independently\n        - No coordination between charts\n\n        Args:\n            group_id: Optional group ID to disable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable all sync for default group\n            manager.disable_all_sync()\n\n            # Disable all sync for specific group\n            manager.disable_all_sync(group_id=\"main_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_all()\n        else:\n            self.default_sync.disable_all()\n        return self\n\n    def from_price_volume_dataframe(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        chart_id: str = \"main_chart\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Create a chart from OHLCV data with price and volume series.\n\n        Factory method that creates a new Chart instance with both price and volume\n        series from OHLCV data. This is a convenient way to create a complete\n        price-volume chart in a single operation.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Defaults to None.\n            price_type (str, optional): Type of price series ('candlestick' or 'line').\n                Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration. Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration. Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0.\n\n        Returns:\n            Chart: A new Chart instance with price and volume series.\n\n        Example:\n            ```python\n            # Create chart from DataFrame\n            chart = Chart.from_price_volume_dataframe(\n                df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n            )\n\n            # Create chart from OHLCV data\n            chart = Chart.from_price_volume_dataframe(\n                ohlcv_data,\n                price_type=\"line\",\n                volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n            )\n            ```\n        \"\"\"\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)):\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n        chart = Chart()\n        chart.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n        )\n\n        # Set the ChartManager reference on the chart\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add the chart to the manager with an ID\n        self.add_chart(chart, chart_id=chart_id)\n\n        return chart\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the chart manager to frontend configuration.\n\n        Returns:\n            Dictionary containing the frontend configuration\n        \"\"\"\n        if not self.charts:\n            return {\n                \"charts\": [],\n                \"syncConfig\": self.default_sync.asdict(),\n            }\n\n        chart_configs = []\n        for chart_id, chart in self.charts.items():\n            chart_config = chart.to_frontend_config()\n            if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n                chart_obj = chart_config[\"charts\"][0]\n                chart_obj[\"chartId\"] = chart_id\n                chart_configs.append(chart_obj)\n            else:\n                # Skip charts with invalid configuration\n                continue\n\n        # Build sync configuration\n        sync_config = self.default_sync.asdict()\n\n        # Add group-specific sync configurations\n        if self.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.sync_groups.items():\n                sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n        config = {\n            \"charts\": chart_configs,\n            \"syncConfig\": sync_config,\n        }\n\n        # Add force_reinit flag if set\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Add metadata for frontend change detection\n        # This allows frontend to detect symbol/interval changes\n        if self.symbol is not None:\n            config[\"symbol\"] = self.symbol\n        if self.display_interval is not None:\n            config[\"displayInterval\"] = str(self.display_interval)\n\n        return config\n\n    def _auto_detect_changes(self, key: str) -&gt; None:\n        \"\"\"\n        Automatically detect changes and set force_reinit if needed.\n\n        This is internal library logic - the user should never call this.\n        It compares current state with previous render to detect changes.\n\n        Args:\n            key: Component key for state storage\n        \"\"\"\n        import hashlib  # pylint: disable=import-outside-toplevel\n        import json  # pylint: disable=import-outside-toplevel\n\n        import streamlit as st  # pylint: disable=import-outside-toplevel\n\n        # Build state key for this chart\n        state_key = f\"_lwc_chart_state_{key}\"\n\n        # Get previous state\n        prev_state = st.session_state.get(state_key)\n\n        # Build current state signature\n        # Include: symbol, interval, chart count, series structure\n        current_state = {\n            \"symbol\": self.symbol,\n            \"interval\": self.display_interval,\n            \"chart_count\": len(self.charts),\n            \"series_structure\": [],\n        }\n\n        # Add series structure fingerprint (types, data length, and full data hash)\n        for chart in self.charts.values():\n            for _idx, series in enumerate(chart.series):\n                # Calculate hash of entire data array for 100% accurate change detection\n                # This is cheap (~1ms for 10K points) and catches ALL data changes\n                data_hash = None\n                if hasattr(series, \"data\") and series.data:\n                    try:\n                        # Hash the entire data array\n                        data_str = str(series.data)\n                        data_hash = hashlib.md5(data_str.encode()).hexdigest()[:8]  # noqa: S324\n                    except Exception:\n                        # Fallback to None if serialization fails\n                        data_hash = None\n\n                series_info = {\n                    \"type\": type(series).__name__,\n                    \"data_length\": len(series.data)\n                    if hasattr(series, \"data\") and series.data\n                    else 0,\n                    \"data_hash\": data_hash,  # Full data hash - catches ALL changes!\n                }\n                current_state[\"series_structure\"].append(series_info)\n\n        # Calculate hash for comparison\n        current_hash = hashlib.md5(  # noqa: S324\n            json.dumps(current_state, sort_keys=True, default=str).encode()\n        ).hexdigest()[:8]\n\n        # AUTO-DETECT if reinit needed\n        # Check if there's a pending reinit from previous run (handles Streamlit multiple reruns)\n        pending_reinit_key = f\"{state_key}_pending_reinit\"\n        pending_reinit = st.session_state.get(pending_reinit_key, False)\n\n        if prev_state is None:\n            # First render - no reinit needed\n            self.force_reinit = False\n            st.session_state[pending_reinit_key] = False\n        elif prev_state != current_hash:\n            # State changed - force reinit and mark as pending for next rerun\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = True\n        elif pending_reinit:\n            # Hash is same but there's a pending reinit from previous run\n            # This handles Streamlit's multiple reruns after a change\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = False  # Clear the flag\n        else:\n            # Same hash, no pending reinit - no changes detected\n            self.force_reinit = False\n\n        # Store current state for next render\n        st.session_state[state_key] = current_hash\n\n    def render(\n        self,\n        key: Optional[str] = None,\n        symbol: Optional[str] = None,\n        interval: Optional[str] = None,\n    ) -&gt; Any:\n        \"\"\"Render the chart manager with automatic change detection.\n\n        The library automatically detects changes in symbol, interval, series structure,\n        and data, and reinitializes the chart only when needed while preserving\n        customizations.\n\n        Args:\n            key: Optional key for the Streamlit component\n            symbol: Optional symbol name for automatic change detection and metadata\n            interval: Optional interval for automatic change detection and metadata\n\n        Returns:\n            The rendered component\n\n        Raises:\n            RuntimeError: If no charts have been added to the manager\n\n        Note:\n            The library handles change detection internally. You don't need to:\n            - Calculate hashes\n            - Track previous values\n            - Set force_reinit manually\n            - Clear caches\n\n            Just call render() with current symbol/interval and the library\n            handles the rest!\n        \"\"\"\n        if not self.charts:\n            raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n        # STEP 0: Set metadata if provided (before change detection)\n        if symbol is not None:\n            self.symbol = symbol\n        if interval is not None:\n            self.display_interval = interval\n\n        # STEP 1: Generate/validate key (same as Chart.render())\n        if key is None or not isinstance(key, str) or not key.strip():\n            unique_id = str(uuid.uuid4())[:8]\n            key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n        # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n        # This makes the library handle change detection instead of the user\n        self._auto_detect_changes(key)\n\n        # STEP 2: For each chart, reset config flag and load/apply stored configs\n        # This ensures user changes from series dialog persist across reruns\n        # Use the same key for loading/saving so customizations persist\n        for chart in self.charts.values():\n            # Reset config application flag for this render cycle\n            chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n            # Load stored configs from session state using the component key\n            stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n            # Apply configs to series objects BEFORE serialization\n            if stored_configs:\n                chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                    stored_configs,\n                    chart.series,\n                )\n\n        # STEP 3: Generate frontend configuration AFTER configs are applied\n        config = self.to_frontend_config()\n\n        # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n        # Get the first chart's renderer since they all use the same implementation\n        first_chart = next(iter(self.charts.values()))\n        result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n            config,\n            key,\n            None,  # ChartManager doesn't have global chart_options\n        )\n\n        # STEP 5: Handle component return value and save series configs\n        # This ensures changes from frontend are saved to session state\n        # Use same key for saving so configs persist\n        if result:\n            for chart in self.charts.values():\n                chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                    result,\n                    key,  # Use same key for consistency\n                    chart._session_state_manager,  # pylint: disable=protected-access\n                )\n\n        return result\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of charts in the manager.\"\"\"\n        return len(self.charts)\n\n    def __contains__(self, chart_id: str) -&gt; bool:\n        \"\"\"Check if a chart ID exists in the manager.\"\"\"\n        return chart_id in self.charts\n\n    def __iter__(self):\n        \"\"\"Iterate over chart IDs in the manager.\"\"\"\n        return iter(self.charts.keys())\n\n    def keys(self):\n        \"\"\"Return chart IDs in the manager.\"\"\"\n        return self.charts.keys()\n\n    def values(self):\n        \"\"\"Return chart instances in the manager.\"\"\"\n        return self.charts.values()\n\n    def items(self):\n        \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n        return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.add_chart","title":"add_chart","text":"<pre><code>add_chart(chart: Chart, chart_id: Optional[str] = None) -&gt; ChartManager\n</code></pre> <p>Add a chart to the manager.</p> <p>Adds a Chart instance to the manager with a unique identifier. The chart is registered in the manager's chart registry and can participate in synchronization groups. If no chart ID is provided, one is automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>Chart</code> <p>The Chart instance to add to the manager.</p> required <code>chart_id</code> <code>Optional[str]</code> <p>Optional unique identifier for the chart. If not provided, an auto-generated ID in the format \"chart_N\" will be assigned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>DuplicateError</code> <p>If a chart with the specified ID already exists.</p> Example <pre><code>manager = ChartManager()\nchart = Chart(series=LineSeries(data))\n\n# Add chart with auto-generated ID\nmanager.add_chart(chart)\n\n# Add chart with custom ID\nmanager.add_chart(chart, \"price_chart\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n    \"\"\"Add a chart to the manager.\n\n    Adds a Chart instance to the manager with a unique identifier. The chart\n    is registered in the manager's chart registry and can participate in\n    synchronization groups. If no chart ID is provided, one is automatically\n    generated.\n\n    Args:\n        chart (Chart): The Chart instance to add to the manager.\n        chart_id (Optional[str]): Optional unique identifier for the chart.\n            If not provided, an auto-generated ID in the format \"chart_N\"\n            will be assigned.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Raises:\n        DuplicateError: If a chart with the specified ID already exists.\n\n    Example:\n        ```python\n        manager = ChartManager()\n        chart = Chart(series=LineSeries(data))\n\n        # Add chart with auto-generated ID\n        manager.add_chart(chart)\n\n        # Add chart with custom ID\n        manager.add_chart(chart, \"price_chart\")\n        ```\n    \"\"\"\n    # Generate unique chart ID if not provided\n    if chart_id is None:\n        chart_id = f\"chart_{len(self.charts) + 1}\"\n\n    # Validate that chart ID is unique within the manager\n    if chart_id in self.charts:\n        raise DuplicateError(\"Chart\", chart_id)\n\n    # Set the ChartManager reference on the chart for bidirectional communication\n    # This allows the chart to access manager configuration and sync settings\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add chart to the registry with its unique identifier\n    self.charts[chart_id] = chart\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.remove_chart","title":"remove_chart","text":"<pre><code>remove_chart(chart_id: str) -&gt; ChartManager\n</code></pre> <p>Remove a chart from the manager.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to remove</p> required <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n    \"\"\"Remove a chart from the manager.\n\n    Args:\n        chart_id: ID of the chart to remove\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    del self.charts[chart_id]\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.get_chart","title":"get_chart","text":"<pre><code>get_chart(chart_id: str) -&gt; Chart\n</code></pre> <p>Get a chart by ID.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to retrieve</p> required <p>Returns:</p> Type Description <code>Chart</code> <p>The Chart instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart(self, chart_id: str) -&gt; Chart:\n    \"\"\"Get a chart by ID.\n\n    Args:\n        chart_id: ID of the chart to retrieve\n\n    Returns:\n        The Chart instance\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    return self.charts[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.render_chart","title":"render_chart","text":"<pre><code>render_chart(chart_id: str, key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render a specific chart from the manager with proper sync configuration.</p> <p>This method renders a single chart while preserving the ChartManager's sync configuration and group settings. This ensures that individual charts can still participate in group synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>The ID of the chart to render</p> required <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chart_id is not found</p> Example <pre><code>manager = ChartManager()\nmanager.add_chart(chart1, \"chart1\")\nmanager.add_chart(chart2, \"chart2\")\n\ncol1, col2 = st.columns(2)\nwith col1:\n    manager.render_chart(\"chart1\")\nwith col2:\n    manager.render_chart(\"chart2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n    This method renders a single chart while preserving the ChartManager's\n    sync configuration and group settings. This ensures that individual\n    charts can still participate in group synchronization.\n\n    Args:\n        chart_id: The ID of the chart to render\n        key: Optional key for the Streamlit component\n\n    Returns:\n        The rendered component\n\n    Raises:\n        ValueError: If chart_id is not found\n\n    Example:\n        ```python\n        manager = ChartManager()\n        manager.add_chart(chart1, \"chart1\")\n        manager.add_chart(chart2, \"chart2\")\n\n        col1, col2 = st.columns(2)\n        with col1:\n            manager.render_chart(\"chart1\")\n        with col2:\n            manager.render_chart(\"chart2\")\n        ```\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    # Get the chart and render it (sync config is automatically included)\n    chart = self.charts[chart_id]\n    return chart.render(key=key)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.get_chart_ids","title":"get_chart_ids","text":"<pre><code>get_chart_ids() -&gt; List[str]\n</code></pre> <p>Get all chart IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of chart IDs</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart_ids(self) -&gt; List[str]:\n    \"\"\"Get all chart IDs.\n\n    Returns:\n        List of chart IDs\n    \"\"\"\n    return list(self.charts.keys())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.clear_charts","title":"clear_charts","text":"<pre><code>clear_charts() -&gt; ChartManager\n</code></pre> <p>Remove all charts from the manager.</p> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def clear_charts(self) -&gt; \"ChartManager\":\n    \"\"\"Remove all charts from the manager.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.charts.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.set_sync_group_config","title":"set_sync_group_config","text":"<pre><code>set_sync_group_config(group_id: Union[int, str], sync_options: SyncOptions) -&gt; ChartManager\n</code></pre> <p>Set synchronization configuration for a specific group.</p> <p>This method allows you to configure synchronization options for a specific group of charts. Groups enable you to have multiple independent sets of synchronized charts within the same ChartManager.</p> <p>For example, you might want to: - Synchronize price and volume charts in one group - Synchronize indicator charts in another group - Keep some charts completely independent</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str). Charts with the same group_id will be synchronized according to these options.</p> required <code>sync_options</code> <code>SyncOptions</code> <p>The SyncOptions configuration object for this group, specifying which synchronization features to enable.</p> required <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\nmanager = ChartManager()\n\n# Configure group \"price_charts\" with full sync\nprice_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\nmanager.set_sync_group_config(\"price_charts\", price_sync)\n\n# Configure group \"indicators\" with crosshair only\nindicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\nmanager.set_sync_group_config(\"indicators\", indicator_sync)\n\n# Add charts to different groups\nmanager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\nmanager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def set_sync_group_config(\n    self,\n    group_id: Union[int, str],\n    sync_options: SyncOptions,\n) -&gt; \"ChartManager\":\n    \"\"\"Set synchronization configuration for a specific group.\n\n    This method allows you to configure synchronization options for a\n    specific group of charts. Groups enable you to have multiple independent\n    sets of synchronized charts within the same ChartManager.\n\n    For example, you might want to:\n    - Synchronize price and volume charts in one group\n    - Synchronize indicator charts in another group\n    - Keep some charts completely independent\n\n    Args:\n        group_id: The sync group ID (int or str). Charts with the same\n            group_id will be synchronized according to these options.\n        sync_options: The SyncOptions configuration object for this group,\n            specifying which synchronization features to enable.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n        manager = ChartManager()\n\n        # Configure group \"price_charts\" with full sync\n        price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n        manager.set_sync_group_config(\"price_charts\", price_sync)\n\n        # Configure group \"indicators\" with crosshair only\n        indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n        manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n        # Add charts to different groups\n        manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n        manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n        ```\n    \"\"\"\n    self.sync_groups[str(group_id)] = sync_options\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.get_sync_group_config","title":"get_sync_group_config","text":"<pre><code>get_sync_group_config(group_id: Union[int, str]) -&gt; Optional[SyncOptions]\n</code></pre> <p>Get synchronization configuration for a specific group.</p> <p>Retrieves the current synchronization options for a specified group. This is useful for inspecting or modifying existing group configurations.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str) to retrieve configuration for.</p> required <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>Optional[SyncOptions]</code> <p>The sync configuration for the group, or None if the group hasn't been configured yet.</p> Example <pre><code># Get configuration for a group\nconfig = manager.get_sync_group_config(\"price_charts\")\nif config:\n    print(f\"Crosshair sync: {config.crosshair}\")\n    print(f\"Time range sync: {config.time_range}\")\n\n# Check if group exists before modifying\nif manager.get_sync_group_config(\"indicators\") is None:\n    manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n    \"\"\"Get synchronization configuration for a specific group.\n\n    Retrieves the current synchronization options for a specified group.\n    This is useful for inspecting or modifying existing group configurations.\n\n    Args:\n        group_id: The sync group ID (int or str) to retrieve configuration for.\n\n    Returns:\n        SyncOptions: The sync configuration for the group, or None if the\n            group hasn't been configured yet.\n\n    Example:\n        ```python\n        # Get configuration for a group\n        config = manager.get_sync_group_config(\"price_charts\")\n        if config:\n            print(f\"Crosshair sync: {config.crosshair}\")\n            print(f\"Time range sync: {config.time_range}\")\n\n        # Check if group exists before modifying\n        if manager.get_sync_group_config(\"indicators\") is None:\n            manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n        ```\n    \"\"\"\n    return self.sync_groups.get(str(group_id))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.enable_crosshair_sync","title":"enable_crosshair_sync","text":"<pre><code>enable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable crosshair synchronization for linked charts.</p> <p>When enabled, moving the crosshair on one chart will synchronize the crosshair position across all charts in the same synchronization group. This creates a coordinated viewing experience where users can see corresponding data points across multiple charts simultaneously.</p> <p>The synchronization uses a robust implementation with debouncing and flag-based protection to prevent race conditions and feedback loops, even during rapid user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable crosshair sync for a specific group. If None, applies to the default synchronization group. Groups allow you to have multiple independent sets of synchronized charts.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_crosshair_sync()\n\n# Enable for specific group\nmanager.enable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable crosshair synchronization for linked charts.\n\n    When enabled, moving the crosshair on one chart will synchronize the\n    crosshair position across all charts in the same synchronization group.\n    This creates a coordinated viewing experience where users can see\n    corresponding data points across multiple charts simultaneously.\n\n    The synchronization uses a robust implementation with debouncing and\n    flag-based protection to prevent race conditions and feedback loops,\n    even during rapid user interactions.\n\n    Args:\n        group_id: Optional group ID to enable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n            Groups allow you to have multiple independent sets of\n            synchronized charts.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_crosshair_sync()\n\n        # Enable for specific group\n        manager.enable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_crosshair()\n    else:\n        self.default_sync.enable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.disable_crosshair_sync","title":"disable_crosshair_sync","text":"<pre><code>disable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable crosshair synchronization for linked charts.</p> <p>When disabled, crosshair movements will not be synchronized across charts. Each chart will have an independent crosshair that only responds to mouse movements over that specific chart.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable crosshair sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_crosshair_sync()\n\n# Disable for specific group\nmanager.disable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable crosshair synchronization for linked charts.\n\n    When disabled, crosshair movements will not be synchronized across\n    charts. Each chart will have an independent crosshair that only\n    responds to mouse movements over that specific chart.\n\n    Args:\n        group_id: Optional group ID to disable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_crosshair_sync()\n\n        # Disable for specific group\n        manager.disable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_crosshair()\n    else:\n        self.default_sync.disable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.enable_time_range_sync","title":"enable_time_range_sync","text":"<pre><code>enable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable time range (zoom/scroll) synchronization for linked charts.</p> <p>When enabled, zooming or panning the time range on one chart will synchronize the visible time range across all charts in the same synchronization group. This allows users to maintain consistent time alignment while analyzing multiple charts.</p> <p>The synchronization includes: - Zoom operations (pinch, scroll wheel, double-click) - Pan/scroll operations (drag, arrow keys) - Programmatic range changes</p> <p>Implementation uses throttling (16ms ~60fps) to ensure smooth performance and prevent race conditions during rapid interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_time_range_sync()\n\n# Enable for specific group\nmanager.enable_time_range_sync(group_id=\"indicators\")\n\n# Enable both crosshair and time range\nmanager.enable_crosshair_sync().enable_time_range_sync()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n    When enabled, zooming or panning the time range on one chart will\n    synchronize the visible time range across all charts in the same\n    synchronization group. This allows users to maintain consistent\n    time alignment while analyzing multiple charts.\n\n    The synchronization includes:\n    - Zoom operations (pinch, scroll wheel, double-click)\n    - Pan/scroll operations (drag, arrow keys)\n    - Programmatic range changes\n\n    Implementation uses throttling (16ms ~60fps) to ensure smooth\n    performance and prevent race conditions during rapid interactions.\n\n    Args:\n        group_id: Optional group ID to enable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_time_range_sync()\n\n        # Enable for specific group\n        manager.enable_time_range_sync(group_id=\"indicators\")\n\n        # Enable both crosshair and time range\n        manager.enable_crosshair_sync().enable_time_range_sync()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_time_range()\n    else:\n        self.default_sync.enable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.disable_time_range_sync","title":"disable_time_range_sync","text":"<pre><code>disable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable time range (zoom/scroll) synchronization for linked charts.</p> <p>When disabled, zoom and pan operations will not be synchronized across charts. Each chart can be zoomed and panned independently.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_time_range_sync()\n\n# Disable for specific group\nmanager.disable_time_range_sync(group_id=\"indicators\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n    When disabled, zoom and pan operations will not be synchronized across\n    charts. Each chart can be zoomed and panned independently.\n\n    Args:\n        group_id: Optional group ID to disable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_time_range_sync()\n\n        # Disable for specific group\n        manager.disable_time_range_sync(group_id=\"indicators\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_time_range()\n    else:\n        self.default_sync.disable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.enable_all_sync","title":"enable_all_sync","text":"<pre><code>enable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable all synchronization features for linked charts.</p> <p>This is a convenience method that enables both crosshair and time range synchronization in a single call. It's the most common configuration for creating fully synchronized multi-chart dashboards.</p> <p>When all synchronization is enabled: - Crosshair movements are synchronized across all charts - Zoom/pan operations are synchronized across all charts - Users get a fully coordinated viewing experience</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable all sync for default group\nmanager.enable_all_sync()\n\n# Enable all sync for specific group\nmanager.enable_all_sync(group_id=\"main_charts\")\n\n# Create fully synchronized dashboard\nmanager = ChartManager()\nmanager.add_chart(price_chart, \"price\")\nmanager.add_chart(volume_chart, \"volume\")\nmanager.add_chart(indicator_chart, \"indicator\")\nmanager.enable_all_sync()\nmanager.render()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable all synchronization features for linked charts.\n\n    This is a convenience method that enables both crosshair and time range\n    synchronization in a single call. It's the most common configuration for\n    creating fully synchronized multi-chart dashboards.\n\n    When all synchronization is enabled:\n    - Crosshair movements are synchronized across all charts\n    - Zoom/pan operations are synchronized across all charts\n    - Users get a fully coordinated viewing experience\n\n    Args:\n        group_id: Optional group ID to enable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable all sync for default group\n        manager.enable_all_sync()\n\n        # Enable all sync for specific group\n        manager.enable_all_sync(group_id=\"main_charts\")\n\n        # Create fully synchronized dashboard\n        manager = ChartManager()\n        manager.add_chart(price_chart, \"price\")\n        manager.add_chart(volume_chart, \"volume\")\n        manager.add_chart(indicator_chart, \"indicator\")\n        manager.enable_all_sync()\n        manager.render()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_all()\n    else:\n        self.default_sync.enable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.disable_all_sync","title":"disable_all_sync","text":"<pre><code>disable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable all synchronization features for linked charts.</p> <p>This is a convenience method that disables both crosshair and time range synchronization in a single call. Use this when you want charts to operate completely independently.</p> <p>When all synchronization is disabled: - Each chart has its own independent crosshair - Each chart can be zoomed/panned independently - No coordination between charts</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable all sync for default group\nmanager.disable_all_sync()\n\n# Disable all sync for specific group\nmanager.disable_all_sync(group_id=\"main_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable all synchronization features for linked charts.\n\n    This is a convenience method that disables both crosshair and time range\n    synchronization in a single call. Use this when you want charts to\n    operate completely independently.\n\n    When all synchronization is disabled:\n    - Each chart has its own independent crosshair\n    - Each chart can be zoomed/panned independently\n    - No coordination between charts\n\n    Args:\n        group_id: Optional group ID to disable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable all sync for default group\n        manager.disable_all_sync()\n\n        # Disable all sync for specific group\n        manager.disable_all_sync(group_id=\"main_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_all()\n    else:\n        self.default_sync.disable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.from_price_volume_dataframe","title":"from_price_volume_dataframe","text":"<pre><code>from_price_volume_dataframe(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', chart_id: str = 'main_chart', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Create a chart from OHLCV data with price and volume series.</p> <p>Factory method that creates a new Chart instance with both price and volume series from OHLCV data. This is a convenient way to create a complete price-volume chart in a single operation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Defaults to None.</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line'). Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration. Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration. Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>A new Chart instance with price and volume series.</p> Example <pre><code># Create chart from DataFrame\nchart = Chart.from_price_volume_dataframe(\n    df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n)\n\n# Create chart from OHLCV data\nchart = Chart.from_price_volume_dataframe(\n    ohlcv_data,\n    price_type=\"line\",\n    volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def from_price_volume_dataframe(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    chart_id: str = \"main_chart\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Create a chart from OHLCV data with price and volume series.\n\n    Factory method that creates a new Chart instance with both price and volume\n    series from OHLCV data. This is a convenient way to create a complete\n    price-volume chart in a single operation.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Defaults to None.\n        price_type (str, optional): Type of price series ('candlestick' or 'line').\n            Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration. Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration. Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0.\n\n    Returns:\n        Chart: A new Chart instance with price and volume series.\n\n    Example:\n        ```python\n        # Create chart from DataFrame\n        chart = Chart.from_price_volume_dataframe(\n            df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n        )\n\n        # Create chart from OHLCV data\n        chart = Chart.from_price_volume_dataframe(\n            ohlcv_data,\n            price_type=\"line\",\n            volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n        )\n        ```\n    \"\"\"\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)):\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n    chart = Chart()\n    chart.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n    )\n\n    # Set the ChartManager reference on the chart\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add the chart to the manager with an ID\n    self.add_chart(chart, chart_id=chart_id)\n\n    return chart\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert the chart manager to frontend configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing the frontend configuration</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the chart manager to frontend configuration.\n\n    Returns:\n        Dictionary containing the frontend configuration\n    \"\"\"\n    if not self.charts:\n        return {\n            \"charts\": [],\n            \"syncConfig\": self.default_sync.asdict(),\n        }\n\n    chart_configs = []\n    for chart_id, chart in self.charts.items():\n        chart_config = chart.to_frontend_config()\n        if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n            chart_obj = chart_config[\"charts\"][0]\n            chart_obj[\"chartId\"] = chart_id\n            chart_configs.append(chart_obj)\n        else:\n            # Skip charts with invalid configuration\n            continue\n\n    # Build sync configuration\n    sync_config = self.default_sync.asdict()\n\n    # Add group-specific sync configurations\n    if self.sync_groups:\n        sync_config[\"groups\"] = {}\n        for group_id, group_sync in self.sync_groups.items():\n            sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n    config = {\n        \"charts\": chart_configs,\n        \"syncConfig\": sync_config,\n    }\n\n    # Add force_reinit flag if set\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Add metadata for frontend change detection\n    # This allows frontend to detect symbol/interval changes\n    if self.symbol is not None:\n        config[\"symbol\"] = self.symbol\n    if self.display_interval is not None:\n        config[\"displayInterval\"] = str(self.display_interval)\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.render","title":"render","text":"<pre><code>render(key: Optional[str] = None, symbol: Optional[str] = None, interval: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart manager with automatic change detection.</p> <p>The library automatically detects changes in symbol, interval, series structure, and data, and reinitializes the chart only when needed while preserving customizations.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <code>symbol</code> <code>Optional[str]</code> <p>Optional symbol name for automatic change detection and metadata</p> <code>None</code> <code>interval</code> <code>Optional[str]</code> <p>Optional interval for automatic change detection and metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no charts have been added to the manager</p> Note <p>The library handles change detection internally. You don't need to: - Calculate hashes - Track previous values - Set force_reinit manually - Clear caches</p> <p>Just call render() with current symbol/interval and the library handles the rest!</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render(\n    self,\n    key: Optional[str] = None,\n    symbol: Optional[str] = None,\n    interval: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Render the chart manager with automatic change detection.\n\n    The library automatically detects changes in symbol, interval, series structure,\n    and data, and reinitializes the chart only when needed while preserving\n    customizations.\n\n    Args:\n        key: Optional key for the Streamlit component\n        symbol: Optional symbol name for automatic change detection and metadata\n        interval: Optional interval for automatic change detection and metadata\n\n    Returns:\n        The rendered component\n\n    Raises:\n        RuntimeError: If no charts have been added to the manager\n\n    Note:\n        The library handles change detection internally. You don't need to:\n        - Calculate hashes\n        - Track previous values\n        - Set force_reinit manually\n        - Clear caches\n\n        Just call render() with current symbol/interval and the library\n        handles the rest!\n    \"\"\"\n    if not self.charts:\n        raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n    # STEP 0: Set metadata if provided (before change detection)\n    if symbol is not None:\n        self.symbol = symbol\n    if interval is not None:\n        self.display_interval = interval\n\n    # STEP 1: Generate/validate key (same as Chart.render())\n    if key is None or not isinstance(key, str) or not key.strip():\n        unique_id = str(uuid.uuid4())[:8]\n        key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n    # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n    # This makes the library handle change detection instead of the user\n    self._auto_detect_changes(key)\n\n    # STEP 2: For each chart, reset config flag and load/apply stored configs\n    # This ensures user changes from series dialog persist across reruns\n    # Use the same key for loading/saving so customizations persist\n    for chart in self.charts.values():\n        # Reset config application flag for this render cycle\n        chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n        # Load stored configs from session state using the component key\n        stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n        # Apply configs to series objects BEFORE serialization\n        if stored_configs:\n            chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                stored_configs,\n                chart.series,\n            )\n\n    # STEP 3: Generate frontend configuration AFTER configs are applied\n    config = self.to_frontend_config()\n\n    # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n    # Get the first chart's renderer since they all use the same implementation\n    first_chart = next(iter(self.charts.values()))\n    result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n        config,\n        key,\n        None,  # ChartManager doesn't have global chart_options\n    )\n\n    # STEP 5: Handle component return value and save series configs\n    # This ensures changes from frontend are saved to session state\n    # Use same key for saving so configs persist\n    if result:\n        for chart in self.charts.values():\n            chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                result,\n                key,  # Use same key for consistency\n                chart._session_state_manager,  # pylint: disable=protected-access\n            )\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return chart IDs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def keys(self):\n    \"\"\"Return chart IDs in the manager.\"\"\"\n    return self.charts.keys()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return chart instances in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def values(self):\n    \"\"\"Return chart instances in the manager.\"\"\"\n    return self.charts.values()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartManager.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return chart ID and instance pairs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def items(self):\n    \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n    return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartOptions","title":"ChartOptions  <code>dataclass</code>","text":"<p>Configuration options for chart display and behavior in financial visualization.</p> <p>This class encapsulates all the configuration options that control how a chart is displayed, including its size, layout, grid settings, and various interactive features. It provides a comprehensive interface for customizing chart appearance and behavior across different chart types and use cases.</p> <p>The ChartOptions class serves as the central configuration container that combines layout, interaction, localization, and visualization settings into a unified configuration object that can be passed to chart instances.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Optional[int]</code> <p>Chart width in pixels. If None, uses 100% of container width. Defaults to None for automatic sizing.</p> <code>height</code> <code>int</code> <p>Chart height in pixels. Defaults to 400.</p> <code>auto_size</code> <code>bool</code> <p>Whether to automatically size the chart to fit its container. Defaults to False.</p> <code>layout</code> <code>LayoutOptions</code> <p>Chart layout configuration including background colors, text styling, and visual appearance settings.</p> <code>left_price_scale</code> <code>Optional[PriceScaleOptions]</code> <p>Left price scale configuration. If None, left price scale is disabled.</p> <code>right_price_scale</code> <code>PriceScaleOptions</code> <p>Right price scale configuration. Defaults to standard right price scale settings.</p> <code>overlay_price_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Overlay price scale configurations for multiple price scales on the same chart.</p> <code>time_scale</code> <code>TimeScaleOptions</code> <p>Time scale configuration including axis settings, time formatting, and time range controls.</p> <code>crosshair</code> <code>CrosshairOptions</code> <p>Crosshair configuration for mouse interactions and data point highlighting.</p> <code>grid</code> <code>GridOptions</code> <p>Grid configuration for horizontal and vertical grid lines.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to enable scroll interactions for time navigation. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to enable scale interactions for zooming. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to enable double-click interactions. Defaults to True.</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to False.</p> <code>kinetic_scroll</code> <code>Optional[KineticScrollOptions]</code> <p>Kinetic scroll options for momentum-based scrolling behavior.</p> <code>tracking_mode</code> <code>Optional[TrackingModeOptions]</code> <p>Mouse tracking mode for crosshair and tooltips. Controls how the chart responds to mouse movement.</p> <code>localization</code> <code>Optional[LocalizationOptions]</code> <p>Localization settings for date/time formatting and locale-specific display options.</p> <code>add_default_pane</code> <code>bool</code> <p>Whether to add a default pane to the chart. Defaults to True.</p> <code>trade_visualization</code> <code>Optional[TradeVisualizationOptions]</code> <p>Trade visualization configuration options for displaying trade markers and annotations.</p> <code>range_switcher</code> <code>Optional[RangeSwitcherOptions]</code> <p>Range switcher configuration for time range selection buttons and presets.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any attribute is assigned an invalid type during initialization.</p> <code>PriceScaleIdTypeError</code> <p>If price scale ID is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale options are not of correct type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800,\n    height=600,\n    layout=LayoutOptions(background_color=\"#ffffff\"),\n    handle_scroll=True,\n    handle_scale=True,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/chart_options.py</code> <pre><code>@dataclass\n@chainable_field(\"width\", int)\n@chainable_field(\"height\", int)\n@chainable_field(\"auto_size\", bool)\n@chainable_field(\"layout\", LayoutOptions)\n@chainable_field(\"left_price_scale\", PriceScaleOptions)\n@chainable_field(\"right_price_scale\", PriceScaleOptions)\n@chainable_field(\"overlay_price_scales\", dict)\n@chainable_field(\"time_scale\", TimeScaleOptions)\n@chainable_field(\"crosshair\", CrosshairOptions)\n@chainable_field(\"grid\", GridOptions)\n@chainable_field(\"handle_scroll\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"kinetic_scroll\", KineticScrollOptions)\n@chainable_field(\"tracking_mode\", TrackingModeOptions)\n@chainable_field(\"localization\", LocalizationOptions)\n@chainable_field(\"add_default_pane\", bool)\n@chainable_field(\"trade_visualization\", TradeVisualizationOptions)\n@chainable_field(\"range_switcher\", RangeSwitcherOptions)\nclass ChartOptions(Options):\n    \"\"\"Configuration options for chart display and behavior in financial visualization.\n\n    This class encapsulates all the configuration options that control how a chart\n    is displayed, including its size, layout, grid settings, and various interactive\n    features. It provides a comprehensive interface for customizing chart appearance\n    and behavior across different chart types and use cases.\n\n    The ChartOptions class serves as the central configuration container that combines\n    layout, interaction, localization, and visualization settings into a unified\n    configuration object that can be passed to chart instances.\n\n    Attributes:\n        width (Optional[int]): Chart width in pixels. If None, uses 100% of container width.\n            Defaults to None for automatic sizing.\n        height (int): Chart height in pixels. Defaults to 400.\n        auto_size (bool): Whether to automatically size the chart to fit its container.\n            Defaults to False.\n        layout (LayoutOptions): Chart layout configuration including background colors,\n            text styling, and visual appearance settings.\n        left_price_scale (Optional[PriceScaleOptions]): Left price scale configuration.\n            If None, left price scale is disabled.\n        right_price_scale (PriceScaleOptions): Right price scale configuration.\n            Defaults to standard right price scale settings.\n        overlay_price_scales (Dict[str, PriceScaleOptions]): Overlay price scale\n            configurations for multiple price scales on the same chart.\n        time_scale (TimeScaleOptions): Time scale configuration including axis settings,\n            time formatting, and time range controls.\n        crosshair (CrosshairOptions): Crosshair configuration for mouse interactions\n            and data point highlighting.\n        grid (GridOptions): Grid configuration for horizontal and vertical grid lines.\n        handle_scroll (bool): Whether to enable scroll interactions for time navigation.\n            Defaults to True.\n        handle_scale (bool): Whether to enable scale interactions for zooming.\n            Defaults to True.\n        handle_double_click (bool): Whether to enable double-click interactions.\n            Defaults to True.\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to False.\n        kinetic_scroll (Optional[KineticScrollOptions]): Kinetic scroll options for\n            momentum-based scrolling behavior.\n        tracking_mode (Optional[TrackingModeOptions]): Mouse tracking mode for crosshair\n            and tooltips. Controls how the chart responds to mouse movement.\n        localization (Optional[LocalizationOptions]): Localization settings for date/time\n            formatting and locale-specific display options.\n        add_default_pane (bool): Whether to add a default pane to the chart.\n            Defaults to True.\n        trade_visualization (Optional[TradeVisualizationOptions]): Trade visualization\n            configuration options for displaying trade markers and annotations.\n        range_switcher (Optional[RangeSwitcherOptions]): Range switcher configuration\n            for time range selection buttons and presets.\n\n    Raises:\n        TypeError: If any attribute is assigned an invalid type during initialization.\n        PriceScaleIdTypeError: If price scale ID is not a string.\n        PriceScaleOptionsTypeError: If price scale options are not of correct type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import ChartOptions\n        from streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n        # Create custom chart options\n        options = ChartOptions(\n            width=800,\n            height=600,\n            layout=LayoutOptions(background_color=\"#ffffff\"),\n            handle_scroll=True,\n            handle_scale=True,\n        )\n        ```\n    \"\"\"\n\n    # Size and layout options\n    width: Optional[int] = None\n    height: int = 400\n    auto_size: bool = True\n\n    # Layout and appearance\n    layout: LayoutOptions = field(default_factory=LayoutOptions)\n    left_price_scale: Optional[PriceScaleOptions] = None\n    right_price_scale: PriceScaleOptions = field(default_factory=PriceScaleOptions)\n    overlay_price_scales: Dict[str, PriceScaleOptions] = field(default_factory=dict)\n    time_scale: TimeScaleOptions = field(default_factory=TimeScaleOptions)\n\n    # Interaction options\n    crosshair: CrosshairOptions = field(default_factory=CrosshairOptions)\n    grid: GridOptions = field(default_factory=GridOptions)\n    handle_scroll: bool = True\n    handle_scale: bool = True\n    handle_double_click: bool = True\n    fit_content_on_load: bool = True\n    kinetic_scroll: Optional[KineticScrollOptions] = None\n    tracking_mode: Optional[TrackingModeOptions] = None\n\n    # Localization and UI\n    localization: Optional[LocalizationOptions] = None\n    add_default_pane: bool = True\n\n    # Trade visualization options\n    trade_visualization: Optional[TradeVisualizationOptions] = None\n\n    # UI options\n    range_switcher: Optional[RangeSwitcherOptions] = None\n\n    # Synchronization options\n\n    def __post_init__(self):\n        \"\"\"Validate chart options after initialization.\"\"\"\n        # Validate price scale types first before accessing attributes\n        if self.right_price_scale is not None and not isinstance(\n            self.right_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"right_price_scale\", type(self.right_price_scale))\n\n        if self.left_price_scale is not None and not isinstance(\n            self.left_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"left_price_scale\", type(self.left_price_scale))\n\n        # CRITICAL FIX: Ensure default price scales have their IDs set\n        # Without this, the empty string price_scale_id gets filtered out during serialization\n        # This causes the frontend to fail matching series to their price scales\n        if self.right_price_scale is not None and self.right_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"right\" if it's None\n            self.right_price_scale.price_scale_id = \"right\"\n\n        if self.left_price_scale is not None and self.left_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"left\" if it's None\n            self.left_price_scale.price_scale_id = \"left\"\n\n        # Validate price scale IDs are strings\n        if (\n            self.right_price_scale is not None\n            and self.right_price_scale.price_scale_id is not None\n            and not isinstance(self.right_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale.price_scale_id),\n            )\n\n        if (\n            self.left_price_scale is not None\n            and self.left_price_scale.price_scale_id is not None\n            and not isinstance(self.left_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale.price_scale_id),\n            )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LayoutOptions","title":"LayoutOptions  <code>dataclass</code>","text":"<p>Layout configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"background_options\", (BackgroundSolid, BackgroundGradient))\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"font_size\", int)\n@chainable_field(\"font_family\", str)\n@chainable_field(\"pane_options\", PaneOptions)\n@chainable_field(\"pane_heights\", Dict[int, PaneHeightOptions])\n@chainable_field(\"attribution_logo\", bool)\nclass LayoutOptions(Options):\n    \"\"\"Layout configuration for chart.\"\"\"\n\n    background_options: BackgroundSolid = field(\n        default_factory=lambda: BackgroundSolid(color=\"#ffffff\"),\n    )\n    text_color: str = \"#131722\"\n    font_size: int = 11\n    font_family: str = \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\"\n    pane_options: Optional[PaneOptions] = None\n    pane_heights: Optional[Dict[int, PaneHeightOptions]] = None\n    attribution_logo: bool = False\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ValueValidationError(property_name, \"Invalid color format\")\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PaneHeightOptions","title":"PaneHeightOptions  <code>dataclass</code>","text":"<p>Pane height configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"factor\", float)\nclass PaneHeightOptions(Options):\n    \"\"\"Pane height configuration for chart.\"\"\"\n\n    factor: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate factor value.\"\"\"\n        if self.factor &lt;= 0:\n            raise ValueValidationError.positive_value(\"Pane height factor\", self.factor)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeVisualizationOptions","title":"TradeVisualizationOptions  <code>dataclass</code>","text":"<p>Options for trade visualization.</p> <p>This class provides comprehensive configuration options for how trades are displayed on charts, including various visual styles and customization options for markers, rectangles, lines, arrows, and zones.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>TradeVisualization</code> <p>The visualization style to use (markers, rectangles, both, etc.)</p> <code>entry_marker_color_long</code> <code>str</code> <p>Color for long entry markers</p> <code>entry_marker_color_short</code> <code>str</code> <p>Color for short entry markers</p> <code>exit_marker_color_profit</code> <code>str</code> <p>Color for profitable exit markers</p> <code>exit_marker_color_loss</code> <code>str</code> <p>Color for loss exit markers</p> <code>marker_size</code> <code>int</code> <p>Size of markers in pixels</p> <code>show_pnl_in_markers</code> <code>bool</code> <p>Whether to show P&amp;L in marker text</p> <code>rectangle_fill_opacity</code> <code>float</code> <p>Opacity for rectangle fill (0.0 to 1.0)</p> <code>rectangle_border_width</code> <code>int</code> <p>Width of rectangle borders</p> <code>rectangle_color_profit</code> <code>str</code> <p>Color for profitable trade rectangles</p> <code>rectangle_color_loss</code> <code>str</code> <p>Color for loss trade rectangles</p> <code>rectangle_fill_color_profit</code> <code>str</code> <p>Fill color for profitable trade rectangles</p> <code>rectangle_border_color_profit</code> <code>str</code> <p>Border color for profitable trade rectangles</p> <code>rectangle_border_color_loss</code> <code>str</code> <p>Border color for loss trade rectangles</p> <code>line_width</code> <code>int</code> <p>Width of connecting lines</p> <code>line_style</code> <code>str</code> <p>Style of connecting lines (solid, dashed, etc.)</p> <code>line_color_profit</code> <code>str</code> <p>Color for profitable trade lines</p> <code>line_color_loss</code> <code>str</code> <p>Color for loss trade lines</p> <code>arrow_size</code> <code>int</code> <p>Size of arrows in pixels</p> <code>arrow_color_profit</code> <code>str</code> <p>Color for profitable trade arrows</p> <code>arrow_color_loss</code> <code>str</code> <p>Color for loss trade arrows</p> <code>zone_opacity</code> <code>float</code> <p>Opacity for zone fills (0.0 to 1.0)</p> <code>zone_color_long</code> <code>str</code> <p>Color for long trade zones</p> <code>zone_color_short</code> <code>str</code> <p>Color for short trade zones</p> <code>zone_extend_bars</code> <code>int</code> <p>Number of bars to extend zones</p> <code>show_trade_id</code> <code>bool</code> <p>Whether to show trade ID in annotations</p> <code>show_quantity</code> <code>bool</code> <p>Whether to show quantity in annotations</p> <code>show_trade_type</code> <code>bool</code> <p>Whether to show trade type in annotations</p> <code>annotation_font_size</code> <code>int</code> <p>Font size for annotations</p> <code>annotation_background</code> <code>str</code> <p>Background color for annotations</p> <code>rectangle_show_text</code> <code>bool</code> <p>Whether to show text on rectangles</p> <code>rectangle_text_position</code> <code>str</code> <p>Position of text on rectangles (inside, above, below)</p> <code>rectangle_text_font_size</code> <code>int</code> <p>Font size for rectangle text</p> <code>rectangle_text_color</code> <code>str</code> <p>Color for rectangle text</p> <code>rectangle_text_background</code> <code>str</code> <p>Background color for rectangle text</p> <code>tooltip_template</code> <code>str</code> <p>Custom HTML template for tooltips with placeholders</p> <code>marker_template</code> <code>str</code> <p>Deprecated - use entry_marker_template and exit_marker_template</p> <code>entry_marker_template</code> <code>str</code> <p>Custom HTML template for entry marker text</p> <code>exit_marker_template</code> <code>str</code> <p>Custom HTML template for exit marker text</p> <code>entry_marker_shape</code> <code>str</code> <p>Shape for entry markers (arrow_up, arrow_down, circle, square)</p> <code>exit_marker_shape</code> <code>str</code> <p>Shape for exit markers (arrow_up, arrow_down, circle, square)</p> <code>entry_marker_position</code> <code>str</code> <p>Position for entry markers (above, below)</p> <code>exit_marker_position</code> <code>str</code> <p>Position for exit markers (above, below)</p> <code>show_marker_text</code> <code>bool</code> <p>Whether to show text on markers</p> Template Placeholders <p>For tooltips and markers, you can use these placeholders in your HTML templates. All fields from TradeData.additional_data are also available: - \\(\\(id\\)\\): Trade ID - \\(\\(entry_price\\)\\): Entry price value - \\(\\(exit_price\\)\\): Exit price value - \\(\\(is_profitable\\)\\): Boolean profitability flag - \\(\\(pnl\\)\\): Profit/Loss amount - \\(\\(pnl_percentage\\)\\): Profit/Loss percentage - \\(\\(trade_type\\)\\): LONG or SHORT (from additional_data) - \\(\\(quantity\\)\\): Trade quantity (from additional_data) - \\(\\(notes\\)\\): Trade notes (from additional_data) - Any custom field from additional_data: \\(\\(strategy\\)\\), \\(\\(risk_level\\)\\), etc.</p> Example templates <p>tooltip_template: \"\\(\\(trade_type\\)\\)Entry: \\(\\(entry_price\\)\\)Exit: \\(\\(exit_price\\)\\)P&amp;L: \\(\\(pnl\\)\\) (\\(\\(pnl_percentage\\)\\)%)\" entry_marker_template: \"\u2191 \\(\\(trade_type\\)\\)\\((\\(entry_price\\)\\)\" exit_marker_template: \"\u2193 ((\\(exit_price\\)\\)&lt;br/&gt;(\\)\\)pnl_percentage$$%)\"</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", TradeVisualization)\n@chainable_field(\"entry_marker_color_long\", str, validator=\"color\")\n@chainable_field(\"entry_marker_color_short\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_profit\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_loss\", str, validator=\"color\")\n@chainable_field(\"marker_size\", int)\n@chainable_field(\"show_pnl_in_markers\", bool)\n@chainable_field(\"rectangle_fill_opacity\", float)\n@chainable_field(\"rectangle_border_width\", int)\n@chainable_field(\"rectangle_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_color_loss\", str, validator=\"color\")\n@chainable_field(\"rectangle_fill_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_loss\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"line_color_profit\", str, validator=\"color\")\n@chainable_field(\"line_color_loss\", str, validator=\"color\")\n@chainable_field(\"arrow_size\", int)\n@chainable_field(\"arrow_color_profit\", str, validator=\"color\")\n@chainable_field(\"arrow_color_loss\", str, validator=\"color\")\n@chainable_field(\"zone_opacity\", float)\n@chainable_field(\"zone_color_long\", str, validator=\"color\")\n@chainable_field(\"zone_color_short\", str, validator=\"color\")\n@chainable_field(\"zone_extend_bars\", int)\n@chainable_field(\"show_trade_id\", bool)\n@chainable_field(\"show_quantity\", bool)\n@chainable_field(\"show_trade_type\", bool)\n@chainable_field(\"annotation_font_size\", int)\n@chainable_field(\"annotation_background\", str, validator=\"color\")\n@chainable_field(\"rectangle_show_text\", bool)\n@chainable_field(\"rectangle_text_position\", str)\n@chainable_field(\"rectangle_text_font_size\", int)\n@chainable_field(\"rectangle_text_color\", str, validator=\"color\")\n@chainable_field(\"rectangle_text_background\", str, validator=\"color\")\n@chainable_field(\"tooltip_template\", str)\n@chainable_field(\"marker_template\", str)\n@chainable_field(\"entry_marker_template\", str)\n@chainable_field(\"exit_marker_template\", str)\n@chainable_field(\"entry_marker_shape\", str)\n@chainable_field(\"exit_marker_shape\", str)\n@chainable_field(\"entry_marker_position\", str)\n@chainable_field(\"exit_marker_position\", str)\n@chainable_field(\"show_marker_text\", bool)\nclass TradeVisualizationOptions(Options):\n    \"\"\"Options for trade visualization.\n\n    This class provides comprehensive configuration options for how trades\n    are displayed on charts, including various visual styles and customization\n    options for markers, rectangles, lines, arrows, and zones.\n\n    Attributes:\n        style: The visualization style to use (markers, rectangles, both, etc.)\n        entry_marker_color_long: Color for long entry markers\n        entry_marker_color_short: Color for short entry markers\n        exit_marker_color_profit: Color for profitable exit markers\n        exit_marker_color_loss: Color for loss exit markers\n        marker_size: Size of markers in pixels\n        show_pnl_in_markers: Whether to show P&amp;L in marker text\n        rectangle_fill_opacity: Opacity for rectangle fill (0.0 to 1.0)\n        rectangle_border_width: Width of rectangle borders\n        rectangle_color_profit: Color for profitable trade rectangles\n        rectangle_color_loss: Color for loss trade rectangles\n        rectangle_fill_color_profit: Fill color for profitable trade rectangles\n        rectangle_border_color_profit: Border color for profitable trade rectangles\n        rectangle_border_color_loss: Border color for loss trade rectangles\n        line_width: Width of connecting lines\n        line_style: Style of connecting lines (solid, dashed, etc.)\n        line_color_profit: Color for profitable trade lines\n        line_color_loss: Color for loss trade lines\n        arrow_size: Size of arrows in pixels\n        arrow_color_profit: Color for profitable trade arrows\n        arrow_color_loss: Color for loss trade arrows\n        zone_opacity: Opacity for zone fills (0.0 to 1.0)\n        zone_color_long: Color for long trade zones\n        zone_color_short: Color for short trade zones\n        zone_extend_bars: Number of bars to extend zones\n        show_trade_id: Whether to show trade ID in annotations\n        show_quantity: Whether to show quantity in annotations\n        show_trade_type: Whether to show trade type in annotations\n        annotation_font_size: Font size for annotations\n        annotation_background: Background color for annotations\n        rectangle_show_text: Whether to show text on rectangles\n        rectangle_text_position: Position of text on rectangles (inside, above, below)\n        rectangle_text_font_size: Font size for rectangle text\n        rectangle_text_color: Color for rectangle text\n        rectangle_text_background: Background color for rectangle text\n        tooltip_template: Custom HTML template for tooltips with placeholders\n        marker_template: Deprecated - use entry_marker_template and exit_marker_template\n        entry_marker_template: Custom HTML template for entry marker text\n        exit_marker_template: Custom HTML template for exit marker text\n        entry_marker_shape: Shape for entry markers (arrow_up, arrow_down, circle, square)\n        exit_marker_shape: Shape for exit markers (arrow_up, arrow_down, circle, square)\n        entry_marker_position: Position for entry markers (above, below)\n        exit_marker_position: Position for exit markers (above, below)\n        show_marker_text: Whether to show text on markers\n\n    Template Placeholders:\n        For tooltips and markers, you can use these placeholders in your HTML templates.\n        All fields from TradeData.additional_data are also available:\n        - $$id$$: Trade ID\n        - $$entry_price$$: Entry price value\n        - $$exit_price$$: Exit price value\n        - $$is_profitable$$: Boolean profitability flag\n        - $$pnl$$: Profit/Loss amount\n        - $$pnl_percentage$$: Profit/Loss percentage\n        - $$trade_type$$: LONG or SHORT (from additional_data)\n        - $$quantity$$: Trade quantity (from additional_data)\n        - $$notes$$: Trade notes (from additional_data)\n        - Any custom field from additional_data: $$strategy$$, $$risk_level$$, etc.\n\n    Example templates:\n        tooltip_template: \"&lt;div&gt;&lt;strong&gt;$$trade_type$$&lt;/strong&gt;&lt;br/&gt;Entry: $$entry_price$$&lt;br/&gt;Exit: $$exit_price$$&lt;br/&gt;P&amp;L: $$pnl$$ ($$pnl_percentage$$%)&lt;/div&gt;\"\n        entry_marker_template: \"\u2191 $$trade_type$$&lt;br/&gt;$$$entry_price$$\"\n        exit_marker_template: \"\u2193 $$$exit_price$$&lt;br/&gt;($$pnl_percentage$$%)\"\n    \"\"\"\n\n    style: TradeVisualization = TradeVisualization.RECTANGLES\n\n    # Marker options\n    entry_marker_color_long: str = \"#2196F3\"\n    entry_marker_color_short: str = \"#FF9800\"\n    exit_marker_color_profit: str = \"#4CAF50\"\n    exit_marker_color_loss: str = \"#F44336\"\n    marker_size: int = 5\n    show_pnl_in_markers: bool = False\n\n    # Rectangle options\n    rectangle_fill_opacity: float = 0.1\n    rectangle_border_width: int = 1\n    rectangle_color_profit: str = \"#4CAF50\"\n    rectangle_color_loss: str = \"#F44336\"\n    rectangle_fill_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_loss: str = \"#F44336\"\n\n    # Line options\n    line_width: int = 2\n    line_style: str = \"dashed\"\n    line_color_profit: str = \"#4CAF50\"\n    line_color_loss: str = \"#F44336\"\n\n    # Arrow options\n    arrow_size: int = 10\n    arrow_color_profit: str = \"#4CAF50\"\n    arrow_color_loss: str = \"#F44336\"\n\n    # Zone options\n    zone_opacity: float = 0.1\n    zone_color_long: str = \"#2196F3\"\n    zone_color_short: str = \"#FF9800\"\n    zone_extend_bars: int = 2  # Extend zone by this many bars\n\n    # Annotation options\n    show_trade_id: bool = False\n    show_quantity: bool = True\n    show_trade_type: bool = True\n    annotation_font_size: int = 12\n    annotation_background: str = \"rgba(255, 255, 255, 0.8)\"\n\n    # Rectangle text options\n    rectangle_show_text: bool = False\n    rectangle_text_position: str = \"inside\"  # inside, above, below\n    rectangle_text_font_size: int = 10\n    rectangle_text_color: str = \"#FFFFFF\"\n    rectangle_text_background: str = \"rgba(0, 0, 0, 0.7)\"\n\n    # Template options\n    tooltip_template: str = \"\"  # Custom HTML template for tooltips\n    marker_template: str = \"\"  # Deprecated - use entry/exit templates\n    entry_marker_template: str = \"\"  # Custom HTML template for entry markers\n    exit_marker_template: str = \"\"  # Custom HTML template for exit markers\n\n    # Marker shape and position options\n    entry_marker_shape: str = \"arrowUp\"  # arrowUp, arrowDown, circle, square\n    exit_marker_shape: str = \"arrowDown\"  # arrowUp, arrowDown, circle, square\n    entry_marker_position: str = \"belowBar\"  # belowBar, aboveBar\n    exit_marker_position: str = \"aboveBar\"  # belowBar, aboveBar\n    show_marker_text: bool = True  # Whether to show text on markers\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize options.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates all configuration values and sets defaults for invalid values.\n\n        Raises:\n            ValueError: If the style string cannot be converted to TradeVisualization enum.\n        \"\"\"\n        # Step 1: Convert style to enum if it's a string\n        # Allows users to pass \"rectangles\" instead of TradeVisualization.RECTANGLES\n        if isinstance(self.style, str):\n            self.style = TradeVisualization(self.style.lower())\n\n        # Step 2: Validate rectangle text position\n        # Ensures only valid positions are used (inside, above, below)\n        valid_positions = [\"inside\", \"above\", \"below\"]\n        if self.rectangle_text_position.lower() not in valid_positions:\n            # Default to \"inside\" if invalid position provided\n            self.rectangle_text_position = \"inside\"\n\n        # Step 3: Validate marker shapes\n        # Ensures only TradingView-supported shapes are used\n        valid_shapes = [\"arrowUp\", \"arrowDown\", \"circle\", \"square\"]\n        if self.entry_marker_shape not in valid_shapes:\n            # Default to arrowUp for entry if invalid shape provided\n            self.entry_marker_shape = \"arrowUp\"\n        if self.exit_marker_shape not in valid_shapes:\n            # Default to arrowDown for exit if invalid shape provided\n            self.exit_marker_shape = \"arrowDown\"\n\n        # Step 4: Validate marker positions\n        # Ensures only valid positions are used (belowBar, aboveBar)\n        valid_marker_positions = [\"belowBar\", \"aboveBar\"]\n        if self.entry_marker_position not in valid_marker_positions:\n            # Default to belowBar for entry (typical for long trades)\n            self.entry_marker_position = \"belowBar\"\n        if self.exit_marker_position not in valid_marker_positions:\n            # Default to aboveBar for exit (typical for long trades)\n            self.exit_marker_position = \"aboveBar\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LegendOptions","title":"LegendOptions  <code>dataclass</code>","text":"<p>Legend configuration with support for custom HTML templates and dynamic value display.</p> <p>The text supports a single placeholder that will be replaced by the frontend: - \\(\\(value\\)\\): Current value of the series at crosshair position</p> <p>Note: Title and color should be handled directly in your HTML template using the series title and color from your series configuration. This avoids conflicts with Python's f-string syntax and other templating systems.</p> <p>Dynamic Value Display: When show_values=True, the legend will automatically display current values at the crosshair position without needing to specify a custom template.</p> <p>Example templates: - \"MA20: \\(\\(value\\)\\)\" - \"PriceValue: \\(\\(value\\)\\)\" - \"RSI: \\(\\(value\\)\\)\"</p> <p>Example with dynamic values: LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"position\", str)\n@chainable_field(\"symbol_name\", str)\n@chainable_field(\"background_color\", str)\n@chainable_field(\"border_color\", str)\n@chainable_field(\"border_width\", int)\n@chainable_field(\"border_radius\", int)\n@chainable_field(\"padding\", int)\n@chainable_field(\"margin\", int)\n@chainable_field(\"z_index\", int)\n@chainable_field(\"price_format\", str)\n@chainable_field(\"text\", str)\n@chainable_field(\"show_values\", bool)\n@chainable_field(\"value_format\", str)\n@chainable_field(\"update_on_crosshair\", bool)\nclass LegendOptions(Options):\n    \"\"\"Legend configuration with support for custom HTML templates and dynamic value display.\n\n    The text supports a single placeholder that will be replaced by the frontend:\n    - $$value$$: Current value of the series at crosshair position\n\n    Note: Title and color should be handled directly in your HTML template using\n    the series title and color from your series configuration. This avoids\n    conflicts with Python's f-string syntax and other templating systems.\n\n    Dynamic Value Display:\n    When show_values=True, the legend will automatically display current values\n    at the crosshair position without needing to specify a custom template.\n\n    Example templates:\n    - \"&lt;span style='color: #2196f3'&gt;MA20: $$value$$&lt;/span&gt;\"\n    - \"&lt;div&gt;&lt;strong&gt;Price&lt;/strong&gt;&lt;br/&gt;Value: $$value$$&lt;/div&gt;\"\n    - \"&lt;span class='legend-item'&gt;RSI: $$value$$&lt;/span&gt;\"\n\n    Example with dynamic values:\n    LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)\n    \"\"\"\n\n    visible: bool = True\n    position: str = \"top-left\"\n    symbol_name: str = \"\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    margin: int = 0  # No margin - spacing handled by layout manager\n    z_index: int = 1000\n    price_format: str = \".2f\"\n    text: str = \"\"\n    show_values: bool = True\n    value_format: str = \".2f\"\n    update_on_crosshair: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AreaSeries","title":"AreaSeries","text":"<p>Area series for creating filled area charts in financial visualization.</p> <p>This class represents an area series that displays continuous data points with filled areas under the line. It's commonly used for price charts, technical indicators, and trend analysis where the area under the curve provides visual emphasis and context.</p> <p>The AreaSeries supports various styling options including area colors, line styling via LineOptions, and gradient effects for enhanced visual appeal and data interpretation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[AreaData], DataFrame, Series]</code> <p>Data points for the area series. Can be a list of AreaData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <code>LineOptions</code> <p>LineOptions instance for line styling. Provides comprehensive line customization including color, width, style, and animation effects.</p> <code>top_color</code> <code>str</code> <p>Color of the top part of the area fill. Defaults to \"#2196F3\" (blue). Can be hex or rgba format.</p> <code>bottom_color</code> <code>str</code> <p>Color of the bottom part of the area fill. Defaults to \"rgba(33, 150, 243, 0.0)\" (transparent blue).</p> <code>relative_gradient</code> <code>bool</code> <p>Whether gradient is relative to base value. Defaults to False for absolute gradient positioning.</p> <code>invert_filled_area</code> <code>bool</code> <p>Whether to invert the filled area direction. Defaults to False for normal area filling.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (AreaData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data with line colors\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with gradient styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n\n# Configure line options\nseries.line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre> See also <p>Series: Base class providing common series functionality. LineOptions: Configuration class for line styling options. AreaData: Data class for area chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/area.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"top_color\", str, validator=\"color\")\n@chainable_property(\"bottom_color\", str, validator=\"color\")\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"invert_filled_area\", bool)\nclass AreaSeries(Series):\n    \"\"\"Area series for creating filled area charts in financial visualization.\n\n    This class represents an area series that displays continuous data points\n    with filled areas under the line. It's commonly used for price charts,\n    technical indicators, and trend analysis where the area under the curve\n    provides visual emphasis and context.\n\n    The AreaSeries supports various styling options including area colors,\n    line styling via LineOptions, and gradient effects for enhanced\n    visual appeal and data interpretation.\n\n    Attributes:\n        data (Union[List[AreaData], pd.DataFrame, pd.Series]): Data points for\n            the area series. Can be a list of AreaData objects, a pandas\n            DataFrame, or a pandas Series.\n        line_options (LineOptions): LineOptions instance for line styling.\n            Provides comprehensive line customization including color, width,\n            style, and animation effects.\n        top_color (str): Color of the top part of the area fill. Defaults to\n            \"#2196F3\" (blue). Can be hex or rgba format.\n        bottom_color (str): Color of the bottom part of the area fill. Defaults\n            to \"rgba(33, 150, 243, 0.0)\" (transparent blue).\n        relative_gradient (bool): Whether gradient is relative to base value.\n            Defaults to False for absolute gradient positioning.\n        invert_filled_area (bool): Whether to invert the filled area direction.\n            Defaults to False for normal area filling.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (AreaData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import AreaSeries\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data with line colors\n        data = [\n            AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n        ]\n\n        # Create area series with gradient styling\n        series = AreaSeries(\n            data=data,\n            top_color=\"rgba(33, 150, 243, 0.4)\",\n            bottom_color=\"rgba(33, 150, 243, 0.0)\",\n            relative_gradient=False,\n            invert_filled_area=False,\n        )\n\n        # Configure line options\n        series.line_options.set_color(\"#2196F3\").set_width(2)\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        LineOptions: Configuration class for line styling options.\n        AreaData: Data class for area chart data points.\n    \"\"\"\n\n    DATA_CLASS = AreaData\n\n    def __init__(\n        self,\n        data: Union[List[AreaData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize AreaSeries with data and configuration options.\n\n        Creates a new area series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes area-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[AreaData], pd.DataFrame, pd.Series]): Area data as a list\n                of AreaData objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of AreaData objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of AreaData or its subclasses.\n\n        Example:\n            ```python\n            # Basic area series with list of data objects\n            data = [AreaData(\"2024-01-01\", 100)]\n            series = AreaSeries(data=data)\n\n            # Area series with DataFrame\n            series = AreaSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Area series with custom configuration\n            series = AreaSeries(data=data, visible=True, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize area-specific properties with default values\n        self._line_options = LineOptions()  # Line styling configuration\n        self._top_color = COLOR_BLUE_MATERIAL  # Top area color (blue)\n        self._bottom_color = AREA_BOTTOM_COLOR_DEFAULT  # Bottom area color (transparent)\n        self._relative_gradient = False  # Absolute gradient positioning\n        self._invert_filled_area = False  # Normal area filling direction\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as an area chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The area chart type identifier.\n\n        Example:\n            ```python\n            series = AreaSeries(data=data)\n            chart_type = series.chart_type  # ChartType.AREA\n            ```\n        \"\"\"\n        return ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AreaSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AreaSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as an area chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The area chart type identifier.</p> Example <pre><code>series = AreaSeries(data=data)\nchart_type = series.chart_type  # ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BandSeries","title":"BandSeries","text":"<p>Band series for lightweight charts (e.g., Bollinger Bands).</p> <p>This class represents a band series that displays upper, middle, and lower bands. It's commonly used for technical indicators like Bollinger Bands, Keltner Channels, and other envelope indicators.</p> <p>The BandSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>middle_line</code> <p>LineOptions instance for middle band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>upper_fill_color</code> <p>Fill color for upper band area.</p> <code>lower_fill_color</code> <p>Fill color for lower band area.</p> <code>upper_fill</code> <p>Whether to display the upper fill area.</p> <code>lower_fill</code> <p>Whether to display the lower fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/band.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"middle_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"upper_fill_color\", str, validator=\"color\")\n@chainable_property(\"lower_fill_color\", str, validator=\"color\")\n@chainable_property(\"upper_fill\", bool)\n@chainable_property(\"lower_fill\", bool)\nclass BandSeries(Series):\n    \"\"\"Band series for lightweight charts (e.g., Bollinger Bands).\n\n    This class represents a band series that displays upper, middle, and lower bands.\n    It's commonly used for technical indicators like Bollinger Bands, Keltner Channels,\n    and other envelope indicators.\n\n    The BandSeries supports various styling options including separate line styling\n    for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        middle_line: LineOptions instance for middle band styling.\n        lower_line: LineOptions instance for lower band styling.\n        upper_fill_color: Fill color for upper band area.\n        lower_fill_color: Fill color for lower band area.\n        upper_fill: Whether to display the upper fill area.\n        lower_fill: Whether to display the lower fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BandData\n\n    def __init__(\n        self,\n        data: Union[List[BandData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize BandSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._middle_line = create_middle_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill colors\n        self._upper_fill_color = BAND_UPPER_FILL_COLOR\n        self._lower_fill_color = BAND_LOWER_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._upper_fill = True\n        self._lower_fill = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAND\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BandSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BandSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BarSeries","title":"BarSeries","text":"<p>Bar series for lightweight charts.</p> <p>This class represents a bar series that displays data as bars. It's commonly used for price charts, volume overlays, and other bar-based visualizations.</p> <p>The BarSeries supports various styling options including bar colors, base value, and animation effects.</p> <p>Attributes:</p> Name Type Description <code>color</code> <p>Color of the bars (set via property).</p> <code>base</code> <p>Base value for the bars (set via property).</p> <code>up_color</code> <p>Color for up bars (set via property).</p> <code>down_color</code> <p>Color for down bars (set via property).</p> <code>open_visible</code> <p>Whether open values are visible (set via property).</p> <code>thin_bars</code> <p>Whether to use thin bars (set via property).</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/bar_series.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"open_visible\", bool)\n@chainable_property(\"thin_bars\", bool)\nclass BarSeries(Series):\n    \"\"\"Bar series for lightweight charts.\n\n    This class represents a bar series that displays data as bars.\n    It's commonly used for price charts, volume overlays, and other\n    bar-based visualizations.\n\n    The BarSeries supports various styling options including bar colors,\n    base value, and animation effects.\n\n    Attributes:\n        color: Color of the bars (set via property).\n        base: Base value for the bars (set via property).\n        up_color: Color for up bars (set via property).\n        down_color: Color for down bars (set via property).\n        open_visible: Whether open values are visible (set via property).\n        thin_bars: Whether to use thin bars (set via property).\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BarData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAR\n\n    def __init__(\n        self,\n        data: Union[List[BarData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize properties with default values\n        self._up_color = \"#26a69a\"\n        self._down_color = \"#ef5350\"\n        self._open_visible = True\n        self._thin_bars = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BarSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BarSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BaselineSeries","title":"BaselineSeries","text":"<p>Baseline series for lightweight charts.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/baseline.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=_validate_base_value_static)\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"top_fill_color1\", str, validator=\"color\")\n@chainable_property(\"top_fill_color2\", str, validator=\"color\")\n@chainable_property(\"top_line_color\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color1\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color2\", str, validator=\"color\")\n@chainable_property(\"bottom_line_color\", str, validator=\"color\")\nclass BaselineSeries(Series):\n    \"\"\"Baseline series for lightweight charts.\"\"\"\n\n    DATA_CLASS = BaselineData\n\n    def __init__(\n        self,\n        data: Union[List[BaselineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize LineOptions for common line properties\n        self._line_options = LineOptions()\n\n        # Baseline-specific properties (not in LineOptions) - set default values internally\n        self._base_value = self._validate_base_value({\"type\": \"price\", \"price\": 0})\n        self._relative_gradient = False\n        self._top_fill_color1 = BASELINE_TOP_FILL_COLOR1\n        self._top_fill_color2 = BASELINE_TOP_FILL_COLOR2\n        self._top_line_color = BASELINE_TOP_LINE_COLOR\n        self._bottom_fill_color1 = BASELINE_BOTTOM_FILL_COLOR1\n        self._bottom_fill_color2 = BASELINE_BOTTOM_FILL_COLOR2\n        self._bottom_line_color = BASELINE_BOTTOM_LINE_COLOR\n\n    def _validate_base_value(self, base_value: Union[int, float, Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate and normalize base_value.\"\"\"\n        if isinstance(base_value, (int, float)):\n            return {\"type\": \"price\", \"price\": float(base_value)}\n        if isinstance(base_value, dict):\n            if \"type\" not in base_value or \"price\" not in base_value:\n                raise BaseValueFormatError()\n            return {\"type\": str(base_value[\"type\"]), \"price\": float(base_value[\"price\"])}\n        raise BaseValueFormatError()\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BASELINE\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BaselineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BaselineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.CandlestickSeries","title":"CandlestickSeries","text":"<p>Candlestick series for creating OHLC candlestick charts in financial visualization.</p> <p>This class represents a candlestick series that displays OHLC (Open, High, Low, Close) data as candlestick bars. It's commonly used for price charts, technical analysis, and comprehensive price action visualization in financial applications.</p> <p>The CandlestickSeries extends the base Series class with candlestick-specific functionality and supports extensive styling options through chainable properties. It provides comprehensive color customization for bullish/bearish candles, wicks, borders, and other visual elements.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[CandlestickData], DataFrame, Series]</code> <p>Data points for the candlestick series. Can be a list of CandlestickData objects, a pandas DataFrame, or a pandas Series.</p> <code>up_color</code> <code>str</code> <p>Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).</p> <code>down_color</code> <code>str</code> <p>Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).</p> <code>wick_visible</code> <code>bool</code> <p>Whether wicks are visible. Defaults to True.</p> <code>border_visible</code> <code>bool</code> <p>Whether borders are visible. Defaults to False.</p> <code>border_color</code> <code>str</code> <p>General border color. Defaults to \"#378658\" (green).</p> <code>border_up_color</code> <code>str</code> <p>Border color for bullish candles. Defaults to \"#26a69a\".</p> <code>border_down_color</code> <code>str</code> <p>Border color for bearish candles. Defaults to \"#ef5350\".</p> <code>wick_color</code> <code>str</code> <p>General wick color. Defaults to \"#737375\" (gray).</p> <code>wick_up_color</code> <code>str</code> <p>Wick color for bullish candles. Defaults to \"#26a69a\".</p> <code>wick_down_color</code> <code>str</code> <p>Wick color for bearish candles. Defaults to \"#ef5350\".</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (CandlestickData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. CandlestickData: Data class for candlestick chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/candlestick.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"wick_visible\", bool)\n@chainable_property(\"border_visible\", bool)\n@chainable_property(\"border_color\", str, validator=\"color\")\n@chainable_property(\"border_up_color\", str, validator=\"color\")\n@chainable_property(\"border_down_color\", str, validator=\"color\")\n@chainable_property(\"wick_color\", str, validator=\"color\")\n@chainable_property(\"wick_up_color\", str, validator=\"color\")\n@chainable_property(\"wick_down_color\", str, validator=\"color\")\nclass CandlestickSeries(Series):\n    \"\"\"Candlestick series for creating OHLC candlestick charts in financial visualization.\n\n    This class represents a candlestick series that displays OHLC (Open, High, Low, Close)\n    data as candlestick bars. It's commonly used for price charts, technical analysis,\n    and comprehensive price action visualization in financial applications.\n\n    The CandlestickSeries extends the base Series class with candlestick-specific\n    functionality and supports extensive styling options through chainable properties.\n    It provides comprehensive color customization for bullish/bearish candles,\n    wicks, borders, and other visual elements.\n\n    Attributes:\n        data (Union[List[CandlestickData], pd.DataFrame, pd.Series]): Data points for\n            the candlestick series. Can be a list of CandlestickData objects,\n            a pandas DataFrame, or a pandas Series.\n        up_color (str): Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).\n        down_color (str): Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).\n        wick_visible (bool): Whether wicks are visible. Defaults to True.\n        border_visible (bool): Whether borders are visible. Defaults to False.\n        border_color (str): General border color. Defaults to \"#378658\" (green).\n        border_up_color (str): Border color for bullish candles. Defaults to \"#26a69a\".\n        border_down_color (str): Border color for bearish candles. Defaults to \"#ef5350\".\n        wick_color (str): General wick color. Defaults to \"#737375\" (gray).\n        wick_up_color (str): Wick color for bullish candles. Defaults to \"#26a69a\".\n        wick_down_color (str): Wick color for bearish candles. Defaults to \"#ef5350\".\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (CandlestickData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data\n        data = [\n            CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n            CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n        ]\n\n        # Create candlestick series with styling\n        series = (\n            CandlestickSeries(data=data)\n            .set_up_color(\"#4CAF50\")\n            .set_down_color(\"#F44336\")\n            .set_border_visible(True)\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        CandlestickData: Data class for candlestick chart data points.\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = CandlestickData\n\n    def __init__(\n        self,\n        data: Union[List[CandlestickData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a CandlestickSeries instance with data and configuration options.\n\n        This constructor initializes a candlestick series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes candlestick-specific styling properties with default values.\n\n        Args:\n            data: Data points for the candlestick series. Can be a list of\n                CandlestickData objects, a pandas DataFrame, or a pandas Series.\n                If DataFrame is provided, column_mapping can be used to specify\n                field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize candlestick-specific properties with default values\n        # Up color for bullish candles - defaults to teal\n        self._up_color = \"#26a69a\"\n        # Down color for bearish candles - defaults to red\n        self._down_color = \"#ef5350\"\n        # Wick visibility - defaults to True (wicks visible)\n        self._wick_visible = True\n        # Border visibility - defaults to False (borders hidden)\n        self._border_visible = False\n        # General border color - defaults to green\n        self._border_color = \"#378658\"\n        # Border color for bullish candles - defaults to teal\n        self._border_up_color = \"#26a69a\"\n        # Border color for bearish candles - defaults to red\n        self._border_down_color = \"#ef5350\"\n        # General wick color - defaults to gray\n        self._wick_color = \"#737375\"\n        # Wick color for bullish candles - defaults to teal\n        self._wick_up_color = \"#26a69a\"\n        # Wick color for bearish candles - defaults to red\n        self._wick_down_color = \"#ef5350\"\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format for candlestick styling properties.\n\n        This method validates that the provided color string is in a valid\n        format (hex or rgba) for use in candlestick styling. It's used\n        internally by the chainable property validators.\n\n        Args:\n            color: The color string to validate in hex or rgba format.\n            property_name: The name of the property being validated (for error messages).\n\n        Returns:\n            str: The validated color string.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for candlestick charts.\n        \"\"\"\n        return ChartType.CANDLESTICK\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.CandlestickSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.CandlestickSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for candlestick charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries","title":"GradientRibbonSeries","text":"<p>Gradient ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with gradient fill areas based on gradient values. It extends RibbonSeries with gradient fill capabilities, allowing for dynamic color transitions based on data values.</p> <p>The GradientRibbonSeries supports various styling options including separate line styling for each band via LineOptions, and gradient color effects based on data values.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>gradient_start_color</code> <p>Starting color for gradient fills (minimum value).</p> <code>gradient_end_color</code> <p>Ending color for gradient fills (maximum value).</p> <code>normalize_gradients</code> <p>Whether to normalize gradient values to 0-1 range.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>@chainable_property(\"gradient_start_color\", str, validator=\"color\")\n@chainable_property(\"gradient_end_color\", str, validator=\"color\")\n@chainable_property(\"normalize_gradients\", bool)\nclass GradientRibbonSeries(RibbonSeries):\n    \"\"\"Gradient ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with gradient fill areas based on gradient values. It extends RibbonSeries\n    with gradient fill capabilities, allowing for dynamic color transitions\n    based on data values.\n\n    The GradientRibbonSeries supports various styling options including separate\n    line styling for each band via LineOptions, and gradient color effects based\n    on data values.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_visible: Whether to display the fill area.\n        gradient_start_color: Starting color for gradient fills (minimum value).\n        gradient_end_color: Ending color for gradient fills (maximum value).\n        normalize_gradients: Whether to normalize gradient values to 0-1 range.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = GradientRibbonData\n\n    def __init__(\n        self,\n        data: Union[List[GradientRibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        gradient_start_color: str = \"#4CAF50\",\n        gradient_end_color: str = \"#F44336\",\n        normalize_gradients: bool = False,\n    ):\n        \"\"\"Initialize GradientRibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            gradient_start_color: Starting color for gradient fills\n            gradient_end_color: Ending color for gradient fills\n            normalize_gradients: Whether to normalize gradient values to 0-1 range\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize gradient-specific properties\n        self._gradient_start_color = gradient_start_color\n        self._gradient_end_color = gradient_end_color\n        self._normalize_gradients = normalize_gradients\n        self._gradient_bounds: Optional[tuple[float, float]] = None\n\n        # Performance optimization: cache normalized results\n        self._normalized_cache: Optional[dict] = None\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.GRADIENT_RIBBON\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate the normalized data cache.\n\n        This method should be called whenever the data changes to ensure\n        the cached normalized results are recalculated on the next asdict() call.\n        \"\"\"\n        self._normalized_cache = None\n        self._gradient_bounds = None\n\n    def update(self, updates: dict):\n        \"\"\"Override update to invalidate cache when data changes.\n\n        Args:\n            updates: Dictionary of updates to apply.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        # Invalidate cache before updating\n        self._invalidate_cache()\n        # Call parent update\n        return super().update(updates)\n\n    @property\n    def data(self):\n        \"\"\"Get the series data.\"\"\"\n        return self._data if hasattr(self, \"_data\") else []\n\n    @data.setter\n    def data(self, value):\n        \"\"\"Set the series data and invalidate cache.\n\n        Args:\n            value: New data to set.\n        \"\"\"\n        self._data = value\n        self._invalidate_cache()\n\n    def _calculate_gradient_bounds(self) -&gt; None:\n        \"\"\"Calculate min/max gradient values for normalization with optimized performance.\"\"\"\n        if not self.data:\n            self._gradient_bounds = None\n            return\n\n        # Ultra-optimized single-pass min/max tracking\n        min_grad = float(\"inf\")\n        max_grad = float(\"-inf\")\n        valid_count = 0\n\n        # Single pass with inline min/max tracking - no list building\n        for data_point in self.data:\n            # Type check: ensure data point has gradient attribute\n            if not hasattr(data_point, \"gradient\"):\n                continue\n            gradient = data_point.gradient  # type: ignore[attr-defined]\n            if (\n                gradient is not None\n                and isinstance(gradient, (int, float))\n                and not math.isnan(gradient)  # Not NaN\n                and gradient != float(\"inf\")\n                and gradient != float(\"-inf\")\n            ):\n                # Update min/max inline - no list operations\n                min_grad = min(min_grad, gradient)\n                max_grad = max(max_grad, gradient)\n                valid_count += 1\n                continue\n\n        # Set bounds efficiently - only if we found valid values\n        if valid_count &gt; 0:\n            self._gradient_bounds = (min_grad, max_grad)\n        else:\n            self._gradient_bounds = None\n\n    def _compute_normalized_dict(self) -&gt; dict:\n        \"\"\"Compute the normalized dictionary (expensive operation).\n\n        This method performs the actual gradient normalization computation.\n        It's called only when the cache is invalid.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        data_dict = super().asdict()\n\n        # Remove inherited fill_color property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n        data_dict.get(\"options\", {}).pop(\"fillColor\", None)\n\n        if self._normalize_gradients:\n            # Calculate bounds if not already calculated\n            if self._gradient_bounds is None:\n                self._calculate_gradient_bounds()\n\n            if self._gradient_bounds:\n                min_grad, max_grad = self._gradient_bounds\n                range_grad = max_grad - min_grad\n\n                if range_grad &gt; 0:  # Avoid division by zero\n                    # Ultra-optimized normalization with minimal function calls\n                    data_items = data_dict[\"data\"]\n                    range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                    for item in data_items:  # Remove enumerate for speed\n                        gradient = item.get(\"gradient\")\n                        if gradient is not None:\n                            # Since we already validated in _calculate_gradient_bounds,\n                            # we can trust the gradient values here\n                            try:\n                                # Use pre-calculated inverse for faster division\n                                normalized = (gradient - min_grad) * range_grad_inv\n                                # Fast clamping using conditional expression\n                                item[\"gradient\"] = (\n                                    0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                                )\n                            except (TypeError, ValueError):\n                                item.pop(\"gradient\", None)\n\n        return data_dict\n\n    def asdict(self):\n        \"\"\"Override to include normalized gradients with caching for performance.\n\n        Returns cached normalized results if available, otherwise computes and caches them.\n        This optimization prevents O(2n) iterations on every serialization call.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        # Return cached result if available\n        if self._normalized_cache is not None:\n            return self._normalized_cache\n\n        # Compute and cache the result\n        self._normalized_cache = self._compute_normalized_dict()\n        return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data\n</code></pre> <p>Get the series data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries.update","title":"update","text":"<pre><code>update(updates: dict)\n</code></pre> <p>Override update to invalidate cache when data changes.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict</code> <p>Dictionary of updates to apply.</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def update(self, updates: dict):\n    \"\"\"Override update to invalidate cache when data changes.\n\n    Args:\n        updates: Dictionary of updates to apply.\n\n    Returns:\n        Self for method chaining.\n    \"\"\"\n    # Invalidate cache before updating\n    self._invalidate_cache()\n    # Call parent update\n    return super().update(updates)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.GradientRibbonSeries.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Override to include normalized gradients with caching for performance.</p> <p>Returns cached normalized results if available, otherwise computes and caches them. This optimization prevents O(2n) iterations on every serialization call.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The serialized dictionary with normalized gradients.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def asdict(self):\n    \"\"\"Override to include normalized gradients with caching for performance.\n\n    Returns cached normalized results if available, otherwise computes and caches them.\n    This optimization prevents O(2n) iterations on every serialization call.\n\n    Returns:\n        dict: The serialized dictionary with normalized gradients.\n    \"\"\"\n    # Return cached result if available\n    if self._normalized_cache is not None:\n        return self._normalized_cache\n\n    # Compute and cache the result\n    self._normalized_cache = self._compute_normalized_dict()\n    return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramSeries","title":"HistogramSeries","text":"<p>Histogram series for creating bar-based charts in financial visualization.</p> <p>This class represents a histogram series that displays data as bars. It's commonly used for volume overlays, technical indicators, and other bar-based visualizations where individual data points are represented as vertical bars.</p> <p>The HistogramSeries supports various styling options including bar color, base value, and animation effects. It also provides a factory method for creating volume series with automatic bullish/bearish color coding.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for the histogram series. Can be a list of Data objects, a pandas DataFrame, or a pandas Series.</p> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to \"#26a69a\" (teal). Can be hex or rgba format.</p> <code>base</code> <code>Union[int, float]</code> <p>Base value for the histogram bars. Defaults to 0. This determines the baseline from which bars extend.</p> <code>scale_margins</code> <code>dict</code> <p>Scale margins for the histogram series. Controls the top and bottom margins of the price scale. Defaults to {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (HistogramData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. HistogramData: Data class for histogram chart data points. create_volume_series: Factory method for volume series with color coding.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"base\", (int, float))\n@chainable_property(\"scale_margins\", dict)\nclass HistogramSeries(Series):\n    \"\"\"Histogram series for creating bar-based charts in financial visualization.\n\n    This class represents a histogram series that displays data as bars.\n    It's commonly used for volume overlays, technical indicators, and other\n    bar-based visualizations where individual data points are represented\n    as vertical bars.\n\n    The HistogramSeries supports various styling options including bar color,\n    base value, and animation effects. It also provides a factory method\n    for creating volume series with automatic bullish/bearish color coding.\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for\n            the histogram series. Can be a list of Data objects, a pandas\n            DataFrame, or a pandas Series.\n        color (str): Color of the histogram bars. Defaults to \"#26a69a\" (teal).\n            Can be hex or rgba format.\n        base (Union[int, float]): Base value for the histogram bars. Defaults to 0.\n            This determines the baseline from which bars extend.\n        scale_margins (dict): Scale margins for the histogram series. Controls\n            the top and bottom margins of the price scale. Defaults to\n            {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (HistogramData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data\n        data = [\n            HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n            HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n        ]\n\n        # Create histogram series with styling\n        series = HistogramSeries(data=data)\n        series.set_color(\"#2196F3\").set_base(0)\n\n        # Create volume series with color coding\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n            up_color=\"rgba(38,166,154,0.5)\",\n            down_color=\"rgba(239,83,80,0.5)\",\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        HistogramData: Data class for histogram chart data points.\n        create_volume_series: Factory method for volume series with color coding.\n    \"\"\"\n\n    DATA_CLASS = HistogramData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as a histogram chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The histogram chart type identifier.\n\n        Example:\n            ```python\n            series = HistogramSeries(data=data)\n            chart_type = series.chart_type  # ChartType.HISTOGRAM\n            ```\n        \"\"\"\n        return ChartType.HISTOGRAM\n\n    @classmethod\n    def create_volume_series(\n        cls,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: dict,\n        up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n        down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n        **kwargs,\n    ) -&gt; \"HistogramSeries\":\n        \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n        This factory method processes OHLCV data and creates a HistogramSeries\n        with volume bars colored based on whether the candle is bullish (close &gt;= open)\n        or bearish (close &lt; open). This provides visual context for volume analysis\n        by showing whether volume occurred during price increases or decreases.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n                or sequence of OhlcvData objects containing price and volume information.\n            column_mapping (dict): Mapping of required fields to column names.\n                Must include \"open\", \"close\", and \"volume\" mappings.\n            up_color (str, optional): Color for bullish candles (close &gt;= open).\n                Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n            down_color (str, optional): Color for bearish candles (close &lt; open).\n                Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n            **kwargs: Additional arguments for HistogramSeries constructor.\n\n        Returns:\n            HistogramSeries: Configured histogram series for volume visualization\n                with color-coded bars based on price movement.\n\n        Raises:\n            ValueError: If required columns are missing from the data or column mapping.\n            KeyError: If column mapping doesn't include required fields.\n\n        Example:\n            ```python\n            # Create volume series with default colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping={\n                    \"time\": \"datetime\",\n                    \"open\": \"open_price\",\n                    \"close\": \"close_price\",\n                    \"volume\": \"trading_volume\",\n                },\n            )\n\n            # Create volume series with custom colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping=column_mapping,\n                up_color=\"#4CAF50\",  # Green for bullish\n                down_color=\"#F44336\",  # Red for bearish\n            )\n            ```\n\n        Note:\n            The method automatically sets _last_value_visible to False for volume series\n            as it's typically used as an overlay rather than a main price series.\n        \"\"\"\n        if isinstance(data, pd.DataFrame):\n            # Use vectorized operations for efficient color assignment on large datasets\n            volume_dataframe = data.copy()\n\n            # Extract column names for open and close prices from mapping\n            open_col = column_mapping.get(\"open\", \"open\")\n            close_col = column_mapping.get(\"close\", \"close\")\n\n            # Use NumPy vectorized operations to assign colors based on price movement\n            # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n            colors = np.where(\n                volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n                up_color,\n                down_color,\n            )\n\n            # Add color column to DataFrame for histogram visualization\n            volume_dataframe[\"color\"] = colors\n\n            # Update column mapping to include color field and map volume to value\n            volume_col = column_mapping.get(\"volume\", \"volume\")\n            updated_mapping = column_mapping.copy()\n            updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n            updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n            # Use from_dataframe factory method to create the series\n            return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n        # Handle sequence of OhlcvData objects (non-DataFrame input)\n        if data is None:\n            # Return empty series for None data input\n            return cls(data=[])\n\n        # Process each item in the sequence individually\n        processed_data = []\n        for item in data:\n            if isinstance(item, dict):\n                # Determine color based on price movement for dictionary input\n                color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n                processed_item = item.copy()\n                processed_item[\"color\"] = color  # Add color information\n                processed_data.append(processed_item)\n            else:\n                # For OhlcvData objects, convert to dict and add color\n                item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n                color = (\n                    up_color\n                    if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                    else down_color\n                )\n                item_dict[\"color\"] = color  # Add color information\n                processed_data.append(item_dict)\n\n        # Convert processed data to DataFrame and use from_dataframe factory method\n        processed_dataframe = pd.DataFrame(processed_data)\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n        # Map volume to value for HistogramSeries compatibility\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping[\"value\"] = volume_col\n\n        # Create the volume series using the factory method\n        volume_series = cls.from_dataframe(\n            processed_dataframe,\n            column_mapping=updated_mapping,\n            **kwargs,\n        )\n\n        # Disable last value visibility for volume series (typically used as overlay)\n        volume_series._last_value_visible = False\n\n        return volume_series  # type: ignore[return-value]\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize HistogramSeries with data and configuration options.\n\n        Creates a new histogram series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes histogram-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Histogram data as a list\n                of Data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"right\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic histogram series with list of data objects\n            data = [HistogramData(\"2024-01-01\", 1000)]\n            series = HistogramSeries(data=data)\n\n            # Histogram series with DataFrame\n            series = HistogramSeries(data=dataframe, column_mapping={\"time\": \"datetime\", \"value\": \"volume\"})\n\n            # Histogram series with Series\n            series = HistogramSeries(data=series_data, column_mapping={\"time\": \"index\", \"value\": \"values\"})\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize histogram-specific properties with default values\n        self._color = \"#26a69a\"  # Default teal color for histogram bars\n        self._base = 0  # Default base value (baseline for bars)\n        self._scale_margins = {\"top\": 0.75, \"bottom\": 0}  # Default scale margins\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as a histogram chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The histogram chart type identifier.</p> Example <pre><code>series = HistogramSeries(data=data)\nchart_type = series.chart_type  # ChartType.HISTOGRAM\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramSeries.create_volume_series","title":"create_volume_series  <code>classmethod</code>","text":"<pre><code>create_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: dict, up_color: str = HISTOGRAM_UP_COLOR_DEFAULT, down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT, **kwargs) -&gt; HistogramSeries\n</code></pre> <p>Create a histogram series for volume data with colors based on price movement.</p> <p>This factory method processes OHLCV data and creates a HistogramSeries with volume bars colored based on whether the candle is bullish (close &gt;= open) or bearish (close &lt; open). This provides visual context for volume analysis by showing whether volume occurred during price increases or decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data as DataFrame or sequence of OhlcvData objects containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields to column names. Must include \"open\", \"close\", and \"volume\" mappings.</p> required <code>up_color</code> <code>str</code> <p>Color for bullish candles (close &gt;= open). Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).</p> <code>HISTOGRAM_UP_COLOR_DEFAULT</code> <code>down_color</code> <code>str</code> <p>Color for bearish candles (close &lt; open). Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).</p> <code>HISTOGRAM_DOWN_COLOR_DEFAULT</code> <code>**kwargs</code> <p>Additional arguments for HistogramSeries constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HistogramSeries</code> <code>HistogramSeries</code> <p>Configured histogram series for volume visualization with color-coded bars based on price movement.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing from the data or column mapping.</p> <code>KeyError</code> <p>If column mapping doesn't include required fields.</p> Example <pre><code># Create volume series with default colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\n        \"time\": \"datetime\",\n        \"open\": \"open_price\",\n        \"close\": \"close_price\",\n        \"volume\": \"trading_volume\",\n    },\n)\n\n# Create volume series with custom colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping=column_mapping,\n    up_color=\"#4CAF50\",  # Green for bullish\n    down_color=\"#F44336\",  # Red for bearish\n)\n</code></pre> Note <p>The method automatically sets _last_value_visible to False for volume series as it's typically used as an overlay rather than a main price series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@classmethod\ndef create_volume_series(\n    cls,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: dict,\n    up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n    down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n    **kwargs,\n) -&gt; \"HistogramSeries\":\n    \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n    This factory method processes OHLCV data and creates a HistogramSeries\n    with volume bars colored based on whether the candle is bullish (close &gt;= open)\n    or bearish (close &lt; open). This provides visual context for volume analysis\n    by showing whether volume occurred during price increases or decreases.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n            or sequence of OhlcvData objects containing price and volume information.\n        column_mapping (dict): Mapping of required fields to column names.\n            Must include \"open\", \"close\", and \"volume\" mappings.\n        up_color (str, optional): Color for bullish candles (close &gt;= open).\n            Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n        down_color (str, optional): Color for bearish candles (close &lt; open).\n            Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n        **kwargs: Additional arguments for HistogramSeries constructor.\n\n    Returns:\n        HistogramSeries: Configured histogram series for volume visualization\n            with color-coded bars based on price movement.\n\n    Raises:\n        ValueError: If required columns are missing from the data or column mapping.\n        KeyError: If column mapping doesn't include required fields.\n\n    Example:\n        ```python\n        # Create volume series with default colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\n                \"time\": \"datetime\",\n                \"open\": \"open_price\",\n                \"close\": \"close_price\",\n                \"volume\": \"trading_volume\",\n            },\n        )\n\n        # Create volume series with custom colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping=column_mapping,\n            up_color=\"#4CAF50\",  # Green for bullish\n            down_color=\"#F44336\",  # Red for bearish\n        )\n        ```\n\n    Note:\n        The method automatically sets _last_value_visible to False for volume series\n        as it's typically used as an overlay rather than a main price series.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # Use vectorized operations for efficient color assignment on large datasets\n        volume_dataframe = data.copy()\n\n        # Extract column names for open and close prices from mapping\n        open_col = column_mapping.get(\"open\", \"open\")\n        close_col = column_mapping.get(\"close\", \"close\")\n\n        # Use NumPy vectorized operations to assign colors based on price movement\n        # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n        colors = np.where(\n            volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n            up_color,\n            down_color,\n        )\n\n        # Add color column to DataFrame for histogram visualization\n        volume_dataframe[\"color\"] = colors\n\n        # Update column mapping to include color field and map volume to value\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n        updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n        # Use from_dataframe factory method to create the series\n        return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n    # Handle sequence of OhlcvData objects (non-DataFrame input)\n    if data is None:\n        # Return empty series for None data input\n        return cls(data=[])\n\n    # Process each item in the sequence individually\n    processed_data = []\n    for item in data:\n        if isinstance(item, dict):\n            # Determine color based on price movement for dictionary input\n            color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n            processed_item = item.copy()\n            processed_item[\"color\"] = color  # Add color information\n            processed_data.append(processed_item)\n        else:\n            # For OhlcvData objects, convert to dict and add color\n            item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n            color = (\n                up_color\n                if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                else down_color\n            )\n            item_dict[\"color\"] = color  # Add color information\n            processed_data.append(item_dict)\n\n    # Convert processed data to DataFrame and use from_dataframe factory method\n    processed_dataframe = pd.DataFrame(processed_data)\n    updated_mapping = column_mapping.copy()\n    updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n    # Map volume to value for HistogramSeries compatibility\n    volume_col = column_mapping.get(\"volume\", \"volume\")\n    updated_mapping[\"value\"] = volume_col\n\n    # Create the volume series using the factory method\n    volume_series = cls.from_dataframe(\n        processed_dataframe,\n        column_mapping=updated_mapping,\n        **kwargs,\n    )\n\n    # Disable last value visibility for volume series (typically used as overlay)\n    volume_series._last_value_visible = False\n\n    return volume_series  # type: ignore[return-value]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LineSeries","title":"LineSeries","text":"<p>Line series for creating continuous line charts in financial visualization.</p> <p>This class represents a line series that displays continuous data points connected by lines. It's commonly used for price charts, technical indicators, trend analysis, and other time-series data visualization in financial applications.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Data points for the line series. Can be a list of LineData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <p>LineOptions instance for all line style options including color, width, style, and animation effects.</p> <code>column_mapping</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <p>The pane index this series belongs to. Defaults to 0.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data\ndata = [\n    LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n    LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n    LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n# Add to chart\nchart = Chart(series=series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/line.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\nclass LineSeries(Series):\n    \"\"\"Line series for creating continuous line charts in financial visualization.\n\n    This class represents a line series that displays continuous data points\n    connected by lines. It's commonly used for price charts, technical\n    indicators, trend analysis, and other time-series data visualization\n    in financial applications.\n\n    Attributes:\n        data: Data points for the line series. Can be a list of LineData\n            objects, a pandas DataFrame, or a pandas Series.\n        line_options: LineOptions instance for all line style options\n            including color, width, style, and animation effects.\n        column_mapping: Optional mapping for DataFrame columns to data fields.\n            Used when data is provided as a DataFrame.\n        visible: Whether the series is visible on the chart. Defaults to True.\n        price_scale_id: ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id: The pane index this series belongs to.\n            Defaults to 0.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data\n        data = [\n            LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n            LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n            LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n        ]\n\n        # Create line series with styling\n        series = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n        # Add to chart\n        chart = Chart(series=series)\n        ```\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = LineData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for line charts.\n        \"\"\"\n        return ChartType.LINE\n\n    def __init__(\n        self,\n        data: Union[List[LineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a LineSeries instance with data and configuration options.\n\n        This constructor initializes a line series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes line-specific styling options with default values.\n\n        Args:\n            data: Data points for the line series. Can be a list of LineData\n                objects, a pandas DataFrame, or a pandas Series. If DataFrame\n                is provided, column_mapping can be used to specify field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        # This sets up data validation, column mapping processing, and basic properties\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n        # Initialize line_options with default styling configuration\n        # This creates an empty LineOptions instance for future customization\n        self._line_options = LineOptions()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for line charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.RibbonSeries","title":"RibbonSeries","text":"<p>Ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with a fill area between them. It's commonly used for technical indicators like Bollinger Bands without the middle line, or other envelope indicators.</p> <p>The RibbonSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_color</code> <p>Fill color for the area between upper and lower bands.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/ribbon.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass RibbonSeries(Series):\n    \"\"\"Ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with a fill area between them. It's commonly used for technical indicators\n    like Bollinger Bands without the middle line, or other envelope indicators.\n\n    The RibbonSeries supports various styling options including separate line\n    styling for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_color: Fill color for the area between upper and lower bands.\n        fill_visible: Whether to display the fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = RibbonData\n\n    def __init__(\n        self,\n        data: Union[List[RibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize RibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill color\n        self._fill_color = RIBBON_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.RIBBON\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.RibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.RibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series","title":"Series","text":"<p>Abstract base class for all series types in financial chart visualization.</p> <p>This class defines the common interface and functionality that all series classes must implement. It provides core data handling, configuration methods, and frontend integration capabilities with comprehensive support for pandas DataFrame integration, markers, price lines, and formatting.</p> <p>All series classes should inherit from this base class and implement the required abstract methods. The class supports method chaining for fluent API usage and provides extensive customization options.</p> Key Features <ul> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line management for annotations</li> <li>Price scale and pane configuration for multi-pane charts</li> <li>Visibility and formatting controls for UI customization</li> <li>Comprehensive data validation and error handling</li> <li>Method chaining support for fluent API design</li> <li>Frontend serialization for React component integration</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for this series. Can be a list of Data objects, pandas DataFrame, or pandas Series.</p> <code>title</code> <code>Optional[str]</code> <p>Technical title displayed on axis/legend. Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").</p> <code>display_name</code> <code>Optional[str]</code> <p>User-friendly name for UI elements. Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").</p> <code>visible</code> <code>bool</code> <p>Whether the series is currently visible on the chart.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Common values are \"left\", \"right\", or custom scale IDs.</p> <code>price_format</code> <code>PriceFormatOptions</code> <p>Price formatting configuration for display.</p> <code>price_lines</code> <code>List[PriceLineOptions]</code> <p>List of price lines for horizontal markers.</p> <code>markers</code> <code>List[MarkerBase]</code> <p>List of markers to display on this series.</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to for multi-pane charts.</p> <code>z_index</code> <code>int</code> <p>Z-index for controlling series rendering order.</p> Class Attributes <p>DATA_CLASS (Type[Data]): The data class type used for this series.     Must be defined by subclasses for DataFrame conversion to work.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create series with list of data objects\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = LineSeries(data=data)\n\n# Add markers and price lines\nseries.add_marker(bar_marker).add_price_line(price_line)\n\n# Configure series properties\nseries.set_visible(True).set_price_scale_id(\"right\")\n</code></pre> Note <p>Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work. The data_class property will always pick the most-derived DATA_CLASS in the MRO.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@chainable_property(\"title\", top_level=True)\n@chainable_property(\"display_name\", top_level=True)\n@chainable_property(\"visible\", top_level=True)\n@chainable_property(\"z_index\", allow_none=True, top_level=True)\n@chainable_property(\"price_scale_id\", top_level=True)\n@chainable_property(\"price_scale\", allow_none=True, top_level=True)\n@chainable_property(\"price_format\")\n@chainable_property(\"price_lines\", top_level=True)\n@chainable_property(\"markers\", List[MarkerBase], allow_none=True, top_level=True)\n@chainable_property(\"pane_id\", top_level=True)\n@chainable_property(\"last_value_visible\", top_level=True)\n@chainable_property(\"price_line_visible\", top_level=True)\n@chainable_property(\"price_line_source\", top_level=True)\n@chainable_property(\"price_line_width\", top_level=True)\n@chainable_property(\"price_line_color\", top_level=True)\n@chainable_property(\"price_line_style\", top_level=True)\n@chainable_property(\"tooltip\", allow_none=True, top_level=True)\n@chainable_property(\"legend\", allow_none=True, top_level=True)\nclass Series(ABC):  # noqa: B024\n    \"\"\"Abstract base class for all series types in financial chart visualization.\n\n    This class defines the common interface and functionality that all series\n    classes must implement. It provides core data handling, configuration\n    methods, and frontend integration capabilities with comprehensive support\n    for pandas DataFrame integration, markers, price lines, and formatting.\n\n    All series classes should inherit from this base class and implement\n    the required abstract methods. The class supports method chaining for\n    fluent API usage and provides extensive customization options.\n\n    Key Features:\n        - DataFrame integration with automatic column mapping\n        - Marker and price line management for annotations\n        - Price scale and pane configuration for multi-pane charts\n        - Visibility and formatting controls for UI customization\n        - Comprehensive data validation and error handling\n        - Method chaining support for fluent API design\n        - Frontend serialization for React component integration\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for this series.\n            Can be a list of Data objects, pandas DataFrame, or pandas Series.\n        title (Optional[str]): Technical title displayed on axis/legend.\n            Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").\n        display_name (Optional[str]): User-friendly name for UI elements.\n            Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").\n        visible (bool): Whether the series is currently visible on the chart.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Common values are \"left\", \"right\", or custom scale IDs.\n        price_format (PriceFormatOptions): Price formatting configuration for display.\n        price_lines (List[PriceLineOptions]): List of price lines for horizontal markers.\n        markers (List[MarkerBase]): List of markers to display on this series.\n        pane_id (Optional[int]): The pane index this series belongs to for multi-pane charts.\n        z_index (int): Z-index for controlling series rendering order.\n\n    Class Attributes:\n        DATA_CLASS (Type[Data]): The data class type used for this series.\n            Must be defined by subclasses for DataFrame conversion to work.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create series with list of data objects\n        data = [SingleValueData(\"2024-01-01\", 100)]\n        series = LineSeries(data=data)\n\n        # Add markers and price lines\n        series.add_marker(bar_marker).add_price_line(price_line)\n\n        # Configure series properties\n        series.set_visible(True).set_price_scale_id(\"right\")\n        ```\n\n    Note:\n        Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work.\n        The data_class property will always pick the most-derived DATA_CLASS in the MRO.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a series with data and configuration.\n\n        Creates a new series instance with the provided data and configuration options.\n        The constructor supports multiple data input types including lists of Data\n        objects, pandas DataFrames, and pandas Series with automatic validation\n        and conversion.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Series data as a list\n                of data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic series with list of data objects\n            series = LineSeries(data=line_data)\n\n            # Series with DataFrame\n            series = LineSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Series with Series\n             series = LineSeries(\n                 data=series_data,\n                 column_mapping={\"time\": \"index\", \"value\": \"values\"}\n             )\n\n            # Series with custom configuration\n            series = LineSeries(data=line_data, visible=False, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Validate and process data input based on type\n        if data is None:\n            # Handle None input by creating empty data list\n            self.data = []\n        elif isinstance(data, (pd.DataFrame, pd.Series)):\n            # DataFrame/Series input requires column mapping for conversion\n            if column_mapping is None:\n                raise ColumnMappingRequiredError()\n            # Process DataFrame/Series using from_dataframe logic\n            self.data = self._process_dataframe_input(data, column_mapping)\n        elif isinstance(data, list):\n            # Validate that all items in list are Data instances\n            if data and not all(isinstance(item, Data) for item in data):\n                raise DataItemsTypeError()\n            self.data = data\n        else:\n            # Raise error for unsupported data types\n            raise DataFrameValidationError.invalid_data_type(type(data))\n\n        # Initialize series configuration properties with default values\n        self._title = None  # Optional series title for legends and tooltips\n        self._display_name = None  # User-friendly name for UI elements\n        self._visible = visible  # Series visibility flag\n        self._price_scale_id = price_scale_id  # Price scale attachment ID\n        self._price_scale = None  # Price scale configuration object\n        self._price_format = None  # Price formatting options\n        self._price_lines: List[PriceLineOptions] = []  # List of price line markers\n        self._markers: List[MarkerBase] = []  # List of chart markers for annotations\n        self._pane_id = pane_id  # Pane index for multi-pane charts\n        self._column_mapping = column_mapping  # DataFrame column mapping\n\n        # Initialize price line display properties\n        self._last_value_visible = True  # Show last value on price scale\n        self._price_line_visible = True  # Show price line by default\n        self._price_line_source = PriceLineSource.LAST_BAR  # Price line data source\n        self._price_line_width = 1  # Price line width in pixels\n        self._price_line_color = \"\"  # Price line color (empty for default)\n        self._price_line_style = LineStyle.DASHED  # Price line style\n\n        # Initialize optional UI components\n        self._tooltip = None  # Custom tooltip configuration\n        self._z_index = 100  # Z-index for rendering order\n        self._legend = None  # Legend configuration\n\n    @staticmethod\n    def prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n        \"\"\"Prepare index for column mapping.\n\n        Handles all index-related column mapping cases:\n        - Time column mapping with DatetimeIndex\n        - Level position mapping (e.g., \"0\", \"1\")\n        - \"index\" mapping (first unnamed level or level 0)\n        - Named level mapping (e.g., \"date\", \"symbol\")\n        - Single index reset for non-time columns\n\n        Args:\n            data_frame: DataFrame to prepare\n            column_mapping: Mapping of required fields to column names\n\n        Returns:\n            DataFrame with prepared index\n\n        Raises:\n            ValueError: If time column is not found and no DatetimeIndex is available\n        \"\"\"\n        # Handle time column mapping first (special case for DatetimeIndex)\n        if \"time\" in column_mapping:\n            time_col = column_mapping[\"time\"]\n            if time_col not in data_frame.columns:\n                # Handle single DatetimeIndex\n                if isinstance(data_frame.index, pd.DatetimeIndex):\n                    if data_frame.index.name is None:\n                        # Set name and reset index to make it a regular column\n                        data_frame.index.name = time_col\n                        data_frame = data_frame.reset_index()\n                    elif data_frame.index.name == time_col:\n                        # Index name already matches, just reset to make it a regular column\n                        data_frame = data_frame.reset_index()\n\n                # Handle MultiIndex with DatetimeIndex level\n                elif isinstance(data_frame.index, pd.MultiIndex):\n                    for i, level in enumerate(data_frame.index.levels):\n                        if isinstance(level, pd.DatetimeIndex):\n                            if data_frame.index.names[i] is None:\n                                # Set name for this level and reset it\n                                new_names = list(data_frame.index.names)\n                                new_names[i] = time_col\n                                data_frame.index.names = new_names\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                            if data_frame.index.names[i] == time_col:\n                                # Level name already matches, reset this level\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                    else:\n                        # No DatetimeIndex level found, check if any level name matches\n                        if time_col in data_frame.index.names or time_col == \"index\":\n                            # Reset the entire MultiIndex to get all levels as columns\n                            data_frame = data_frame.reset_index()\n                        else:\n                            # Check if time_col is an integer level position\n                            try:\n                                level_idx = int(time_col)\n                                if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                    # Reset the entire MultiIndex to get all levels as columns\n                                    data_frame = data_frame.reset_index()\n                                else:\n                                    # Invalid level position, just pass through\n                                    pass\n                            except ValueError:\n                                # Not an integer, just pass through\n                                pass\n                # No DatetimeIndex found\n                # Check if time_col is \"index\" and we have a regular index to reset\n                elif time_col == \"index\":\n                    # Reset the index to make it a regular column\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[\"time\"] = new_col_name\n                elif time_col == data_frame.index.name:\n                    # Time column matches index name, reset the index\n                    data_frame = data_frame.reset_index()\n                else:\n                    raise NotFoundError(\"Time Column\", time_col)\n\n        # Handle other index columns\n        for field, col_name in column_mapping.items():\n            if field == \"time\":\n                continue  # Already handled above\n\n            if col_name not in data_frame.columns:\n                if isinstance(data_frame.index, pd.MultiIndex):\n                    level_names = list(data_frame.index.names)\n\n                    # Integer string or int: treat as level position\n                    try:\n                        level_idx = int(col_name)\n                        if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                            data_frame = data_frame.reset_index(level=level_idx)\n                            level_name = level_names[level_idx]\n                            # Update column mapping to use actual column name\n                            new_col_name = (\n                                level_name if level_name is not None else f\"level_{level_idx}\"\n                            )\n                            column_mapping[field] = new_col_name\n                            continue\n                    except (ValueError, IndexError):\n                        pass\n\n                    # 'index': use first unnamed level if any, else first level\n                    if col_name == \"index\":\n                        unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                        level_idx = unnamed_levels[0] if unnamed_levels else 0\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n\n                    # Named level\n                    if col_name in level_names:\n                        level_idx = level_names.index(col_name)\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        continue\n\n                # Single index\n                elif col_name in (\"index\", data_frame.index.name):\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[field] = new_col_name\n                    continue\n\n        return data_frame\n\n    def _process_dataframe_input(\n        self,\n        data: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n    ) -&gt; List[Data]:\n        \"\"\"Process DataFrame or Series input into a list of Data objects.\n\n        This method duplicates the logic from from_dataframe to handle\n        DataFrame/Series input in the constructor. It validates the input\n        data structure and converts it to the appropriate Data objects\n        based on the series type.\n\n        Args:\n            data (Union[pd.DataFrame, pd.Series]): DataFrame or Series to process.\n            column_mapping (Dict[str, str]): Mapping of required fields to column names.\n\n        Returns:\n            List[Data]: List of processed data objects suitable for the series type.\n\n        Raises:\n            ValueError: If required columns are missing from the DataFrame/Series.\n            ValueError: If the data structure is invalid for the series type.\n            ValueError: If time column is not found and no DatetimeIndex is available.\n\n        Note:\n            This method uses the data_class property to determine the appropriate\n            Data class for conversion.\n        \"\"\"\n        # Convert Series to DataFrame if needed (do this first)\n        if isinstance(data, pd.Series):\n            data = data.to_frame()\n\n        data_class = self.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check if all required columns are mapped\n        # Normalize keys to handle both snake_case and camelCase\n        def normalize_key(key):\n            \"\"\"Convert snake_case to camelCase for comparison.\"\"\"\n            if \"_\" in key:\n                parts = key.split(\"_\")\n                return parts[0] + \"\".join(part.capitalize() for part in parts[1:])\n            return key\n\n        # Create normalized versions of both sets for comparison\n        normalized_required = {normalize_key(key) for key in required}\n        normalized_mapping_keys = {normalize_key(key) for key in column_mapping}\n\n        missing_required = normalized_required - normalized_mapping_keys\n        if missing_required:\n            # Convert back to original format for error message\n            missing_original = {key for key in required if normalize_key(key) in missing_required}\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column mapping: {missing_original}\",\n            )\n\n        # Prepare index for all column mappings\n        data_frame = self.prepare_index(data, column_mapping)\n\n        # Check if all required columns are present in the DataFrame\n        mapped_columns = set(column_mapping.values())\n        available_columns = set(data_frame.columns.tolist())\n        missing_columns = mapped_columns - available_columns\n\n        if missing_columns:\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column: {missing_columns}\",\n            )\n\n        # Create data objects\n        result = []\n        for _, row in data_frame.iterrows():\n            kwargs = {}\n            # Process both required and optional columns\n            for key in required.union(optional):\n                # Find the corresponding column mapping key (handle both snake_case and camelCase)\n                mapped_key = None\n                for mapping_key in column_mapping:\n                    if normalize_key(mapping_key) == normalize_key(key):\n                        mapped_key = mapping_key\n                        break\n\n                if mapped_key:\n                    col_name = column_mapping[mapped_key]\n                    if col_name in data_frame.columns:\n                        value = row[col_name]\n                        kwargs[key] = value\n            data_obj = data_class(**kwargs)\n            result.append(data_obj)\n\n        return result\n\n    @property\n    def data_dict(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the data in dictionary format.\n\n        Converts the series data to a list of dictionaries suitable for\n        frontend serialization. Handles various data formats including\n        dictionaries, lists of dictionaries, or lists of objects with\n        asdict() methods.\n\n        Returns:\n            List[Dict[str, Any]]: List of data dictionaries ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            # Get data as dictionaries\n            data_dicts = series.data_dict\n\n            # Access individual data points\n            for data_point in data_dicts:\n                # Data point contains time and value information\n                pass\n            ```\n        \"\"\"\n        if isinstance(self.data, dict):\n            return self.data  # type: ignore[return-value]\n        if isinstance(self.data, list):\n            if len(self.data) == 0:\n                return []\n            # If already list of dicts\n            if isinstance(self.data[0], dict):\n                return self.data  # type: ignore[return-value]\n                # If list of objects with asdict\n        if hasattr(self.data[0], \"asdict\"):\n            return [item.asdict() for item in self.data]\n        # Fallback: return as-is\n        return self.data  # type: ignore[return-value]\n\n    def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n        \"\"\"Add a marker to this series.\n\n        Adds a marker object to the series for highlighting specific data points\n        or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n        Args:\n            marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If the marker position is not valid for its type.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n             from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                 MarkerPosition, MarkerShape\n             )\n\n            # Add a bar marker\n            bar_marker = BarMarker(\n                time=\"2024-01-01 10:00:00\",\n                position=MarkerPosition.ABOVE_BAR,\n                color=\"red\",\n                shape=MarkerShape.CIRCLE,\n                text=\"Buy Signal\",\n            )\n            series.add_marker(bar_marker)\n\n            # Add a price marker\n            price_marker = PriceMarker(\n                time=1640995200,\n                position=MarkerPosition.AT_PRICE_TOP,\n                color=\"#00ff00\",\n                shape=MarkerShape.ARROW_UP,\n                price=100.50,\n                text=\"Resistance Level\",\n            )\n            series.add_marker(price_marker)\n\n            # Method chaining\n            series.add_marker(marker1).add_marker(marker2)\n            ```\n        \"\"\"\n        # Validate the marker position\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.append(marker)\n        return self\n\n    def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n        \"\"\"Add multiple markers to this series.\n\n        Adds a list of markers to the series. Returns self for method chaining.\n\n        Args:\n            markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If any marker position is not valid for its type.\n        \"\"\"\n        # Validate all markers before adding\n        for marker in markers:\n            if not marker.validate_position():\n                raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.extend(markers)\n        return self\n\n    def clear_markers(self) -&gt; \"Series\":\n        \"\"\"Clear all markers from this series.\n\n        Removes all markers from the series. Returns self for method chaining.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._markers.clear()\n        return self\n\n    def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n        \"\"\"Add a price line option to this series.\n\n        Args:\n            price_line (PriceLineOptions): The price line option to add.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.append(price_line)\n        return self\n\n    def clear_price_lines(self) -&gt; \"Series\":\n        \"\"\"Remove all price line options from this series.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.clear()\n        return self\n\n    def _validate_pane_config(self) -&gt; None:\n        \"\"\"Validate pane configuration for the series.\n\n        This method ensures that pane_id is properly set.\n        It should be called by subclasses in their asdict() method.\n\n        Raises:\n            ValueError: If pane_id is negative.\n        \"\"\"\n        if self._pane_id is not None and self._pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n        if self._pane_id is None:\n            self._pane_id = 0\n\n    def _get_attr_name(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get the attribute name for a given key.\"\"\"\n        # Convert camelCase to snake_case for attribute lookup\n        attr_name: Optional[str] = self._camel_to_snake(key)\n\n        # Check if attribute exists (try multiple variations)\n        # Need to check attr_name is not None before using hasattr\n        if attr_name is not None and not hasattr(self, attr_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                attr_name = key\n            # Try with _ prefix (for private attributes)\n            elif hasattr(self, f\"_{attr_name}\"):\n                attr_name = f\"_{attr_name}\"\n            # Try original key with _ prefix\n            elif hasattr(self, f\"_{key}\"):\n                attr_name = f\"_{key}\"\n            else:\n                # Ignore invalid attributes instead of raising an error\n\n                attr_name = None\n\n        return attr_name\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n        \"\"\"Update series configuration with a dictionary of values.\n\n        This method updates series properties using a configuration dictionary. It supports\n        updating simple attributes, nested options objects, and lists of options. Keys may be\n        in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n        Args:\n            updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n                or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            AttributeError: If an attribute cannot be set due to type or value errors.\n\n        Example:\n            ```python\n            series = LineSeries(data=data)\n            series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n            series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n            series.update(\n                {\n                    \"price_lines\": [\n                        {\"price\": 105, \"color\": \"#00ff00\"},\n                        {\"price\": 110, \"color\": \"#ff0000\"},\n                    ]\n                }\n            )\n            series.update({\"visible\": True}).update({\"pane_id\": 1})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            attr_name = self._get_attr_name(key)\n\n            if attr_name is None:\n                continue\n\n            try:\n                if isinstance(value, dict):\n                    self._update_dict_value(attr_name, value)\n                elif isinstance(value, list):\n                    self._update_list_value(attr_name, value)\n                else:\n                    setattr(self, attr_name, value)\n            except Exception:\n                logger.exception(\"Failed to update attribute '%s'\", attr_name)\n                raise\n\n        return self\n\n    def _update_dict_value(self, attr_name: str, value: dict) -&gt; None:\n        \"\"\"Update a nested options object attribute with a dictionary.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (dict): Dictionary of values to update the nested object.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        if current_value is not None and hasattr(current_value, \"update\"):\n            current_value.update(value)\n            return\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            return\n\n        # Handle Union types (e.g., Optional[T])\n        if getattr(attr_type, \"__origin__\", None) is Union:\n            for arg in attr_type.__args__:\n                if arg is not type(None):\n                    attr_type = arg\n                    break\n\n        if hasattr(attr_type, \"update\"):\n            try:\n                instance = attr_type()\n                setattr(self, attr_name, instance)\n                instance.update(value)\n            except Exception:\n                logger.exception(\"Failed to instantiate or update %s\", attr_name)\n                raise\n        else:\n            # No update method for this attribute\n            pass\n\n    def _update_list_value(self, attr_name: str, value: list) -&gt; None:\n        \"\"\"Update a list attribute, instantiating and updating items as needed.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (list): List of values or dicts to update the list attribute.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            setattr(self, attr_name, value)\n            return\n\n        if getattr(attr_type, \"__origin__\", None) is list:\n            item_type = attr_type.__args__[0]\n\n            if not hasattr(item_type, \"update\"):\n                setattr(self, attr_name, value)\n                return\n\n            if current_value is None:\n                current_value = []\n                setattr(self, attr_name, current_value)\n\n            for _i, item in enumerate(value):\n                if isinstance(item, dict):\n                    try:\n                        instance = item_type()\n                        instance.update(item)\n                        current_value.append(instance)\n                    except Exception:\n                        logger.exception(\n                            \"Failed to instantiate or update list item for %s\",\n                            attr_name,\n                        )\n                        raise\n                else:\n                    current_value.append(item)\n        else:\n            setattr(self, attr_name, value)\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n        \"\"\"\n        import re  # pylint: disable=import-outside-toplevel\n\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert series to dictionary representation.\n\n        This method creates a dictionary representation of the series\n        that can be consumed by the frontend React component.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing series configuration for the frontend.\n        \"\"\"\n        # Validate pane configuration\n        self._validate_pane_config()\n\n        # Get base configuration\n        config = {\n            \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n            \"data\": self.data_dict,\n        }\n\n        # Add options from chainable properties only\n        options = {}\n        for attr_name in dir(self):\n            if attr_name.startswith(\"_\"):\n                continue\n            # Skip data attribute as it's handled separately\n            if attr_name == \"data\":\n                continue\n            # Skip class attributes (like DATA_CLASS)\n            if attr_name.isupper():\n                continue\n            # Skip class properties (like data_class)\n            if attr_name == \"data_class\":\n                continue\n\n            # Rule 1: Only include attributes decorated with chainable_property\n            if not self._is_chainable_property(attr_name):\n                continue\n\n            attr_value = getattr(self, attr_name)\n\n            # Rule 2: Skip if None and allow_none is True\n            if attr_value is None and self._is_allow_none(attr_name):\n                continue\n\n            # Determine if this should go to top level or options\n            is_top_level = self._is_top_level(attr_name)\n\n            # Handle objects with asdict() method\n            if (\n                hasattr(attr_value, \"asdict\")\n                and callable(attr_value.asdict)\n                and not isinstance(attr_value, type)\n            ):\n                # Rule 3: Flatten LineOptions with property name prefix for consistency\n                # This ensures all LineOptions are serialized the same way:\n                # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n                # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n                from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n                if isinstance(attr_value, LineOptions):\n                    line_dict = attr_value.asdict()\n                    # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                    if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                        # Send lineOptions nested - let frontend handle flattening via descriptors\n                        # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                        # based on the series type's descriptor apiMapping\n                        options[\"lineOptions\"] = line_dict\n                    else:\n                        # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                        # Convert the property name to camelCase for the prefix\n                        prefix = snake_to_camel(attr_name)\n                        for line_key, line_value in line_dict.items():\n                            # Capitalize first letter of line property and append to prefix\n                            # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                            # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                            if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                                # Remove 'line' prefix from the key before appending\n                                # lineWidth -&gt; Width, lineStyle -&gt; Style\n                                key_without_line_prefix = line_key[4:]  # Remove 'line'\n                                flattened_key = prefix + key_without_line_prefix\n                            else:\n                                # Normal case: capitalize first letter and append\n                                # e.g., upperLine + color -&gt; upperLineColor\n                                flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                            if is_top_level:\n                                config[flattened_key] = line_value\n                            else:\n                                options[flattened_key] = line_value\n                elif attr_name.endswith(\"_options\"):\n                    # Other options objects (not LineOptions) - flatten without prefix\n                    options.update(attr_value.asdict())\n                else:\n                    # Other objects with asdict() - keep nested\n                    key = snake_to_camel(attr_name)\n                    if is_top_level:\n                        config[key] = attr_value.asdict()\n                    else:\n                        options[key] = attr_value.asdict()\n\n            # Handle lists of objects with asdict() method\n            elif (\n                isinstance(attr_value, list)\n                and attr_value\n                and hasattr(attr_value[0], \"asdict\")\n                and callable(attr_value[0].asdict)\n            ):\n                # Convert list of objects to list of dictionaries\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = [item.asdict() for item in attr_value]\n                else:\n                    options[key] = [item.asdict() for item in attr_value]\n\n            # Also include individual option attributes that are not None\n            elif (\n                not callable(attr_value)\n                and not isinstance(attr_value, type)\n                and attr_value is not None\n            ):\n                # Skip empty lists (they should not be included in configuration)\n                if isinstance(attr_value, list) and not attr_value:\n                    continue\n\n                # Convert snake_case to camelCase for the key\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    # Include empty strings for top-level properties (they are valid)\n                    config[key] = attr_value\n                # Skip empty strings for options (they are not meaningful)\n                elif attr_value != \"\":\n                    options[key] = attr_value\n\n        # Only include options field if it's not empty\n        if options:\n            config[\"options\"] = options\n\n        return config\n\n    def _is_chainable_property(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if an attribute is decorated with chainable_property.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute is a chainable property\n        \"\"\"\n        return (\n            hasattr(self.__class__, \"_chainable_properties\")\n            and attr_name in self.__class__._chainable_properties  # pylint: disable=protected-access\n        )\n\n    def _is_allow_none(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property allows None values.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the property allows None values\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"allow_none\"]  # type: ignore[attr-defined]\n        return False\n\n    def _is_top_level(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property should be output at the top level.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute should be at the top level\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"top_level\"]  # type: ignore[attr-defined]\n        return False\n\n    @classproperty\n    def data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n        \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n        for base in self.__mro__:  # type: ignore[attr-defined]\n            if hasattr(base, \"DATA_CLASS\"):\n                return base.DATA_CLASS\n        raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n\n    @classmethod\n    def from_dataframe(\n        cls,\n        df: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n        price_scale_id: str = \"\",\n        **kwargs,\n    ) -&gt; \"Series\":\n        \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n        Args:\n            df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n            column_mapping (dict): Mapping of required fields\n                (e.g., {'time': 'datetime', 'value': 'close', ...}).\n            price_scale_id (str): Price scale ID (default '').\n            **kwargs: Additional arguments for the Series constructor.\n\n        Returns:\n            Series: An instance of the Series (or subclass) with normalized data.\n\n        Raises:\n            NotImplementedError: If the subclass does not define DATA_CLASS.\n            ValueError: If required columns are missing in column_mapping or DataFrame.\n            AttributeError: If the data class does not define REQUIRED_COLUMNS.\n        \"\"\"\n        # Convert Series to DataFrame if needed\n        dataframe = df\n        if isinstance(dataframe, pd.Series):\n            dataframe = dataframe.to_frame()\n\n        data_class = cls.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check required columns in column_mapping\n        missing_mapping = [col for col in required if col not in column_mapping]\n        if missing_mapping:\n            raise ValueValidationError(\n                \"column_mapping\",\n                f\"missing required columns: {missing_mapping}\",\n            )\n        # Removed print\n\n        # Prepare index for all column mappings\n        data_frame = cls.prepare_index(dataframe, column_mapping)\n\n        # Check required columns in DataFrame (including index) - after processing\n        for key in required:\n            col = column_mapping[key]\n            if col not in data_frame.columns:\n                raise NotFoundError(\"Column\", col)\n            # Removed print\n\n        # Build data objects\n        data = []\n        for i in range(len(dataframe)):\n            kwargs_data = {}\n            for key in required.union(optional):\n                if key in column_mapping:\n                    col = column_mapping[key]\n                    if col in data_frame.columns:\n                        value = data_frame.iloc[i][col]\n                        kwargs_data[key] = value\n                    else:\n                        raise NotFoundError(\"Column\", col)\n                else:\n                    # Skip optional columns that are not in column_mapping\n                    continue\n\n            data.append(data_class(**kwargs_data))\n\n        return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.data_dict","title":"data_dict  <code>property</code>","text":"<pre><code>data_dict: List[Dict[str, Any]]\n</code></pre> <p>Get the data in dictionary format.</p> <p>Converts the series data to a list of dictionaries suitable for frontend serialization. Handles various data formats including dictionaries, lists of dictionaries, or lists of objects with asdict() methods.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of data dictionaries ready for frontend consumption.</p> Example <pre><code># Get data as dictionaries\ndata_dicts = series.data_dict\n\n# Access individual data points\nfor data_point in data_dicts:\n    # Data point contains time and value information\n    pass\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.prepare_index","title":"prepare_index  <code>staticmethod</code>","text":"<pre><code>prepare_index(data_frame: DataFrame, column_mapping: Dict[str, str]) -&gt; DataFrame\n</code></pre> <p>Prepare index for column mapping.</p> <p>Handles all index-related column mapping cases: - Time column mapping with DatetimeIndex - Level position mapping (e.g., \"0\", \"1\") - \"index\" mapping (first unnamed level or level 0) - Named level mapping (e.g., \"date\", \"symbol\") - Single index reset for non-time columns</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>DataFrame to prepare</p> required <code>column_mapping</code> <code>Dict[str, str]</code> <p>Mapping of required fields to column names</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with prepared index</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time column is not found and no DatetimeIndex is available</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@staticmethod\ndef prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n    \"\"\"Prepare index for column mapping.\n\n    Handles all index-related column mapping cases:\n    - Time column mapping with DatetimeIndex\n    - Level position mapping (e.g., \"0\", \"1\")\n    - \"index\" mapping (first unnamed level or level 0)\n    - Named level mapping (e.g., \"date\", \"symbol\")\n    - Single index reset for non-time columns\n\n    Args:\n        data_frame: DataFrame to prepare\n        column_mapping: Mapping of required fields to column names\n\n    Returns:\n        DataFrame with prepared index\n\n    Raises:\n        ValueError: If time column is not found and no DatetimeIndex is available\n    \"\"\"\n    # Handle time column mapping first (special case for DatetimeIndex)\n    if \"time\" in column_mapping:\n        time_col = column_mapping[\"time\"]\n        if time_col not in data_frame.columns:\n            # Handle single DatetimeIndex\n            if isinstance(data_frame.index, pd.DatetimeIndex):\n                if data_frame.index.name is None:\n                    # Set name and reset index to make it a regular column\n                    data_frame.index.name = time_col\n                    data_frame = data_frame.reset_index()\n                elif data_frame.index.name == time_col:\n                    # Index name already matches, just reset to make it a regular column\n                    data_frame = data_frame.reset_index()\n\n            # Handle MultiIndex with DatetimeIndex level\n            elif isinstance(data_frame.index, pd.MultiIndex):\n                for i, level in enumerate(data_frame.index.levels):\n                    if isinstance(level, pd.DatetimeIndex):\n                        if data_frame.index.names[i] is None:\n                            # Set name for this level and reset it\n                            new_names = list(data_frame.index.names)\n                            new_names[i] = time_col\n                            data_frame.index.names = new_names\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                        if data_frame.index.names[i] == time_col:\n                            # Level name already matches, reset this level\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                else:\n                    # No DatetimeIndex level found, check if any level name matches\n                    if time_col in data_frame.index.names or time_col == \"index\":\n                        # Reset the entire MultiIndex to get all levels as columns\n                        data_frame = data_frame.reset_index()\n                    else:\n                        # Check if time_col is an integer level position\n                        try:\n                            level_idx = int(time_col)\n                            if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                # Reset the entire MultiIndex to get all levels as columns\n                                data_frame = data_frame.reset_index()\n                            else:\n                                # Invalid level position, just pass through\n                                pass\n                        except ValueError:\n                            # Not an integer, just pass through\n                            pass\n            # No DatetimeIndex found\n            # Check if time_col is \"index\" and we have a regular index to reset\n            elif time_col == \"index\":\n                # Reset the index to make it a regular column\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[\"time\"] = new_col_name\n            elif time_col == data_frame.index.name:\n                # Time column matches index name, reset the index\n                data_frame = data_frame.reset_index()\n            else:\n                raise NotFoundError(\"Time Column\", time_col)\n\n    # Handle other index columns\n    for field, col_name in column_mapping.items():\n        if field == \"time\":\n            continue  # Already handled above\n\n        if col_name not in data_frame.columns:\n            if isinstance(data_frame.index, pd.MultiIndex):\n                level_names = list(data_frame.index.names)\n\n                # Integer string or int: treat as level position\n                try:\n                    level_idx = int(col_name)\n                    if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        # Update column mapping to use actual column name\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n                except (ValueError, IndexError):\n                    pass\n\n                # 'index': use first unnamed level if any, else first level\n                if col_name == \"index\":\n                    unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                    level_idx = unnamed_levels[0] if unnamed_levels else 0\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    level_name = level_names[level_idx]\n                    new_col_name = (\n                        level_name if level_name is not None else f\"level_{level_idx}\"\n                    )\n                    column_mapping[field] = new_col_name\n                    continue\n\n                # Named level\n                if col_name in level_names:\n                    level_idx = level_names.index(col_name)\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    continue\n\n            # Single index\n            elif col_name in (\"index\", data_frame.index.name):\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[field] = new_col_name\n                continue\n\n    return data_frame\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.add_marker","title":"add_marker","text":"<pre><code>add_marker(marker: MarkerBase) -&gt; Series\n</code></pre> <p>Add a marker to this series.</p> <p>Adds a marker object to the series for highlighting specific data points or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>MarkerBase</code> <p>The marker object to add. Must be a BarMarker or PriceMarker.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker position is not valid for its type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n from streamlit_lightweight_charts_pro.type_definitions.enums import (\n     MarkerPosition, MarkerShape\n )\n\n# Add a bar marker\nbar_marker = BarMarker(\n    time=\"2024-01-01 10:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    color=\"red\",\n    shape=MarkerShape.CIRCLE,\n    text=\"Buy Signal\",\n)\nseries.add_marker(bar_marker)\n\n# Add a price marker\nprice_marker = PriceMarker(\n    time=1640995200,\n    position=MarkerPosition.AT_PRICE_TOP,\n    color=\"#00ff00\",\n    shape=MarkerShape.ARROW_UP,\n    price=100.50,\n    text=\"Resistance Level\",\n)\nseries.add_marker(price_marker)\n\n# Method chaining\nseries.add_marker(marker1).add_marker(marker2)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n    \"\"\"Add a marker to this series.\n\n    Adds a marker object to the series for highlighting specific data points\n    or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n    Args:\n        marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If the marker position is not valid for its type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n         from streamlit_lightweight_charts_pro.type_definitions.enums import (\n             MarkerPosition, MarkerShape\n         )\n\n        # Add a bar marker\n        bar_marker = BarMarker(\n            time=\"2024-01-01 10:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            color=\"red\",\n            shape=MarkerShape.CIRCLE,\n            text=\"Buy Signal\",\n        )\n        series.add_marker(bar_marker)\n\n        # Add a price marker\n        price_marker = PriceMarker(\n            time=1640995200,\n            position=MarkerPosition.AT_PRICE_TOP,\n            color=\"#00ff00\",\n            shape=MarkerShape.ARROW_UP,\n            price=100.50,\n            text=\"Resistance Level\",\n        )\n        series.add_marker(price_marker)\n\n        # Method chaining\n        series.add_marker(marker1).add_marker(marker2)\n        ```\n    \"\"\"\n    # Validate the marker position\n    if not marker.validate_position():\n        raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.append(marker)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.add_markers","title":"add_markers","text":"<pre><code>add_markers(markers: List[MarkerBase]) -&gt; Series\n</code></pre> <p>Add multiple markers to this series.</p> <p>Adds a list of markers to the series. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>List[MarkerBase]</code> <p>List of marker objects to add. Must be MarkerBase subclasses.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any marker position is not valid for its type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n    \"\"\"Add multiple markers to this series.\n\n    Adds a list of markers to the series. Returns self for method chaining.\n\n    Args:\n        markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If any marker position is not valid for its type.\n    \"\"\"\n    # Validate all markers before adding\n    for marker in markers:\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.extend(markers)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.clear_markers","title":"clear_markers","text":"<pre><code>clear_markers() -&gt; Series\n</code></pre> <p>Clear all markers from this series.</p> <p>Removes all markers from the series. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_markers(self) -&gt; \"Series\":\n    \"\"\"Clear all markers from this series.\n\n    Removes all markers from the series. Returns self for method chaining.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._markers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.add_price_line","title":"add_price_line","text":"<pre><code>add_price_line(price_line: PriceLineOptions) -&gt; Series\n</code></pre> <p>Add a price line option to this series.</p> <p>Parameters:</p> Name Type Description Default <code>price_line</code> <code>PriceLineOptions</code> <p>The price line option to add.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n    \"\"\"Add a price line option to this series.\n\n    Args:\n        price_line (PriceLineOptions): The price line option to add.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.append(price_line)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.clear_price_lines","title":"clear_price_lines","text":"<pre><code>clear_price_lines() -&gt; Series\n</code></pre> <p>Remove all price line options from this series.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_price_lines(self) -&gt; \"Series\":\n    \"\"\"Remove all price line options from this series.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Series\n</code></pre> <p>Update series configuration with a dictionary of values.</p> <p>This method updates series properties using a configuration dictionary. It supports updating simple attributes, nested options objects, and lists of options. Keys may be in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types, dictionaries for nested objects, or lists.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute cannot be set due to type or value errors.</p> Example <pre><code>series = LineSeries(data=data)\nseries.update({\"visible\": False, \"price_scale_id\": \"left\"})\nseries.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\nseries.update(\n    {\n        \"price_lines\": [\n            {\"price\": 105, \"color\": \"#00ff00\"},\n            {\"price\": 110, \"color\": \"#ff0000\"},\n        ]\n    }\n)\nseries.update({\"visible\": True}).update({\"pane_id\": 1})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n    \"\"\"Update series configuration with a dictionary of values.\n\n    This method updates series properties using a configuration dictionary. It supports\n    updating simple attributes, nested options objects, and lists of options. Keys may be\n    in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n    Args:\n        updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n            or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        AttributeError: If an attribute cannot be set due to type or value errors.\n\n    Example:\n        ```python\n        series = LineSeries(data=data)\n        series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n        series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n        series.update(\n            {\n                \"price_lines\": [\n                    {\"price\": 105, \"color\": \"#00ff00\"},\n                    {\"price\": 110, \"color\": \"#ff0000\"},\n                ]\n            }\n        )\n        series.update({\"visible\": True}).update({\"pane_id\": 1})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        attr_name = self._get_attr_name(key)\n\n        if attr_name is None:\n            continue\n\n        try:\n            if isinstance(value, dict):\n                self._update_dict_value(attr_name, value)\n            elif isinstance(value, list):\n                self._update_list_value(attr_name, value)\n            else:\n                setattr(self, attr_name, value)\n        except Exception:\n            logger.exception(\"Failed to update attribute '%s'\", attr_name)\n            raise\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert series to dictionary representation.</p> <p>This method creates a dictionary representation of the series that can be consumed by the frontend React component.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing series configuration for the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert series to dictionary representation.\n\n    This method creates a dictionary representation of the series\n    that can be consumed by the frontend React component.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing series configuration for the frontend.\n    \"\"\"\n    # Validate pane configuration\n    self._validate_pane_config()\n\n    # Get base configuration\n    config = {\n        \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n        \"data\": self.data_dict,\n    }\n\n    # Add options from chainable properties only\n    options = {}\n    for attr_name in dir(self):\n        if attr_name.startswith(\"_\"):\n            continue\n        # Skip data attribute as it's handled separately\n        if attr_name == \"data\":\n            continue\n        # Skip class attributes (like DATA_CLASS)\n        if attr_name.isupper():\n            continue\n        # Skip class properties (like data_class)\n        if attr_name == \"data_class\":\n            continue\n\n        # Rule 1: Only include attributes decorated with chainable_property\n        if not self._is_chainable_property(attr_name):\n            continue\n\n        attr_value = getattr(self, attr_name)\n\n        # Rule 2: Skip if None and allow_none is True\n        if attr_value is None and self._is_allow_none(attr_name):\n            continue\n\n        # Determine if this should go to top level or options\n        is_top_level = self._is_top_level(attr_name)\n\n        # Handle objects with asdict() method\n        if (\n            hasattr(attr_value, \"asdict\")\n            and callable(attr_value.asdict)\n            and not isinstance(attr_value, type)\n        ):\n            # Rule 3: Flatten LineOptions with property name prefix for consistency\n            # This ensures all LineOptions are serialized the same way:\n            # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n            # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n            from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n            if isinstance(attr_value, LineOptions):\n                line_dict = attr_value.asdict()\n                # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                    # Send lineOptions nested - let frontend handle flattening via descriptors\n                    # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                    # based on the series type's descriptor apiMapping\n                    options[\"lineOptions\"] = line_dict\n                else:\n                    # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                    # Convert the property name to camelCase for the prefix\n                    prefix = snake_to_camel(attr_name)\n                    for line_key, line_value in line_dict.items():\n                        # Capitalize first letter of line property and append to prefix\n                        # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                        # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                        if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                            # Remove 'line' prefix from the key before appending\n                            # lineWidth -&gt; Width, lineStyle -&gt; Style\n                            key_without_line_prefix = line_key[4:]  # Remove 'line'\n                            flattened_key = prefix + key_without_line_prefix\n                        else:\n                            # Normal case: capitalize first letter and append\n                            # e.g., upperLine + color -&gt; upperLineColor\n                            flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                        if is_top_level:\n                            config[flattened_key] = line_value\n                        else:\n                            options[flattened_key] = line_value\n            elif attr_name.endswith(\"_options\"):\n                # Other options objects (not LineOptions) - flatten without prefix\n                options.update(attr_value.asdict())\n            else:\n                # Other objects with asdict() - keep nested\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = attr_value.asdict()\n                else:\n                    options[key] = attr_value.asdict()\n\n        # Handle lists of objects with asdict() method\n        elif (\n            isinstance(attr_value, list)\n            and attr_value\n            and hasattr(attr_value[0], \"asdict\")\n            and callable(attr_value[0].asdict)\n        ):\n            # Convert list of objects to list of dictionaries\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                config[key] = [item.asdict() for item in attr_value]\n            else:\n                options[key] = [item.asdict() for item in attr_value]\n\n        # Also include individual option attributes that are not None\n        elif (\n            not callable(attr_value)\n            and not isinstance(attr_value, type)\n            and attr_value is not None\n        ):\n            # Skip empty lists (they should not be included in configuration)\n            if isinstance(attr_value, list) and not attr_value:\n                continue\n\n            # Convert snake_case to camelCase for the key\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                # Include empty strings for top-level properties (they are valid)\n                config[key] = attr_value\n            # Skip empty strings for options (they are not meaningful)\n            elif attr_value != \"\":\n                options[key] = attr_value\n\n    # Only include options field if it's not empty\n    if options:\n        config[\"options\"] = options\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.data_class","title":"data_class","text":"<pre><code>data_class() -&gt; Type[Data]\n</code></pre> <p>Return the first DATA_CLASS found in the MRO (most-derived class wins).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classproperty\ndef data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n    \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n    for base in self.__mro__:  # type: ignore[attr-defined]\n        if hasattr(base, \"DATA_CLASS\"):\n            return base.DATA_CLASS\n    raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Series.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: Union[DataFrame, Series], column_mapping: Dict[str, str], price_scale_id: str = '', **kwargs) -&gt; Series\n</code></pre> <p>Create a Series instance from a pandas DataFrame or Series.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Union[DataFrame, Series]</code> <p>The input DataFrame or Series.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields (e.g., {'time': 'datetime', 'value': 'close', ...}).</p> required <code>price_scale_id</code> <code>str</code> <p>Price scale ID (default '').</p> <code>''</code> <code>**kwargs</code> <p>Additional arguments for the Series constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>An instance of the Series (or subclass) with normalized data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the subclass does not define DATA_CLASS.</p> <code>ValueError</code> <p>If required columns are missing in column_mapping or DataFrame.</p> <code>AttributeError</code> <p>If the data class does not define REQUIRED_COLUMNS.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classmethod\ndef from_dataframe(\n    cls,\n    df: Union[pd.DataFrame, pd.Series],\n    column_mapping: Dict[str, str],\n    price_scale_id: str = \"\",\n    **kwargs,\n) -&gt; \"Series\":\n    \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n    Args:\n        df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n        column_mapping (dict): Mapping of required fields\n            (e.g., {'time': 'datetime', 'value': 'close', ...}).\n        price_scale_id (str): Price scale ID (default '').\n        **kwargs: Additional arguments for the Series constructor.\n\n    Returns:\n        Series: An instance of the Series (or subclass) with normalized data.\n\n    Raises:\n        NotImplementedError: If the subclass does not define DATA_CLASS.\n        ValueError: If required columns are missing in column_mapping or DataFrame.\n        AttributeError: If the data class does not define REQUIRED_COLUMNS.\n    \"\"\"\n    # Convert Series to DataFrame if needed\n    dataframe = df\n    if isinstance(dataframe, pd.Series):\n        dataframe = dataframe.to_frame()\n\n    data_class = cls.data_class\n    required = data_class.required_columns\n    optional = data_class.optional_columns\n\n    # Check required columns in column_mapping\n    missing_mapping = [col for col in required if col not in column_mapping]\n    if missing_mapping:\n        raise ValueValidationError(\n            \"column_mapping\",\n            f\"missing required columns: {missing_mapping}\",\n        )\n    # Removed print\n\n    # Prepare index for all column mappings\n    data_frame = cls.prepare_index(dataframe, column_mapping)\n\n    # Check required columns in DataFrame (including index) - after processing\n    for key in required:\n        col = column_mapping[key]\n        if col not in data_frame.columns:\n            raise NotFoundError(\"Column\", col)\n        # Removed print\n\n    # Build data objects\n    data = []\n    for i in range(len(dataframe)):\n        kwargs_data = {}\n        for key in required.union(optional):\n            if key in column_mapping:\n                col = column_mapping[key]\n                if col in data_frame.columns:\n                    value = data_frame.iloc[i][col]\n                    kwargs_data[key] = value\n                else:\n                    raise NotFoundError(\"Column\", col)\n            else:\n                # Skip optional columns that are not in column_mapping\n                continue\n\n        data.append(data_class(**kwargs_data))\n\n    return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.SignalSeries","title":"SignalSeries","text":"<p>Signal series for background coloring in charts.</p> <p>SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>The series takes signal data with binary or ternary values and maps them to background colors for specific time periods. The background bands appear across all chart panes and provide visual context for the data.</p> <p>Signal data can be: - Binary (0, 1): Only uses neutral_color and signal_color - Ternary (0, 1, negative): Uses all three colors including alert_color</p> <p>Attributes:</p> Name Type Description <code>neutral_color</code> <p>Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")</p> <code>signal_color</code> <p>Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")</p> <code>alert_color</code> <p>Background color for signal value&lt;0 (negative, optional, default: None) Frontend intelligently uses this only when data contains non-boolean values</p> Example <pre><code># Create signal data\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n    SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n]\n\n# Create signal series\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n\n# Add to chart\nchart.add_series(signal_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/signal_series.py</code> <pre><code>@chainable_property(\"neutral_color\", str, validator=\"color\")\n@chainable_property(\"signal_color\", str, validator=\"color\")\n@chainable_property(\"alert_color\", str, validator=\"color\", allow_none=True)\nclass SignalSeries(Series):\n    \"\"\"Signal series for background coloring in charts.\n\n    SignalSeries creates vertical background bands that span the entire chart\n    height, colored based on signal values at specific time points. This is\n    commonly used in financial charts to highlight specific market conditions,\n    trading signals, or events.\n\n    The series takes signal data with binary or ternary values and maps them\n    to background colors for specific time periods. The background bands\n    appear across all chart panes and provide visual context for the data.\n\n    Signal data can be:\n    - Binary (0, 1): Only uses neutral_color and signal_color\n    - Ternary (0, 1, negative): Uses all three colors including alert_color\n\n    Attributes:\n        neutral_color: Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")\n        signal_color: Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")\n        alert_color: Background color for signal value&lt;0 (negative, optional, default: None)\n            Frontend intelligently uses this only when data contains non-boolean values\n\n    Example:\n        ```python\n        # Create signal data\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n            SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n        ]\n\n        # Create signal series\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n\n        # Add to chart\n        chart.add_series(signal_series)\n        ```\n    \"\"\"\n\n    DATA_CLASS = SignalData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: ChartType.SIGNAL indicating this is a signal series.\n        \"\"\"\n        return ChartType.SIGNAL\n\n    def __init__(\n        self,\n        data: Union[List[SignalData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        neutral_color: str = \"rgba(128, 128, 128, 0.1)\",\n        signal_color: str = \"rgba(76, 175, 80, 0.2)\",\n        alert_color: Optional[str] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize SignalSeries.\n\n        Args:\n            data: List of SignalData objects, DataFrame, or Series.\n            column_mapping: Optional column mapping for DataFrame input.\n            neutral_color: Background color for value=0. Defaults to \"rgba(128, 128, 128, 0.1)\".\n            signal_color: Background color for value&gt;0 (positive). Defaults to \"rgba(76, 175, 80, 0.2)\".\n            alert_color: Background color for value&lt;0 (negative). Defaults to None.\n                Frontend intelligently uses this only when needed based on data values.\n            visible: Whether the signal series should be visible. Defaults to True.\n            price_scale_id: Price scale ID. Defaults to \"right\".\n            pane_id: Pane ID for multi-pane charts. Defaults to 0.\n\n        Raises:\n            ValueError: If data is empty or invalid.\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize signal-specific properties with default values\n        self._neutral_color = neutral_color\n        self._signal_color = signal_color\n        self._alert_color = alert_color\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the signal series.\"\"\"\n        return (\n            f\"SignalSeries(data_points={len(self.data)}, neutral_color='{self._neutral_color}',\"\n            f\" signal_color='{self._signal_color}')\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.SignalSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.SignalSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>ChartType.SIGNAL indicating this is a signal series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TrendFillSeries","title":"TrendFillSeries","text":"<p>Trend fill series for lightweight charts.</p> <p>This class represents a trend fill series that displays fills between trend lines and base lines. It's commonly used for technical indicators like Supertrend, where the fill area changes color based on trend direction.</p> <p>The series properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p> <p>Attributes:</p> Name Type Description <code>uptrend_line</code> <code>LineOptions</code> <p>Line options for the uptrend line.</p> <code>downtrend_line</code> <code>LineOptions</code> <p>Line options for the downtrend line.</p> <code>base_line</code> <code>LineOptions</code> <p>Line options for the base line.</p> <code>uptrend_fill_color</code> <code>str</code> <p>Color for uptrend fills (default: green).</p> <code>downtrend_fill_color</code> <code>str</code> <p>Color for downtrend fills (default: red).</p> <code>fill_visible</code> <code>bool</code> <p>Whether fills are visible.</p> Example <pre><code>from streamlit_lightweight_charts_pro import TrendFillSeries\nfrom streamlit_lightweight_charts_pro.data import TrendFillData\n\n# Create trend fill data\ndata = [\n    TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n    TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n]\n\n# Create series with custom colors\nseries = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/trend_fill.py</code> <pre><code>@chainable_property(\"uptrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"downtrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"base_line\", LineOptions, allow_none=True)\n@chainable_property(\"uptrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"downtrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass TrendFillSeries(Series):\n    \"\"\"Trend fill series for lightweight charts.\n\n    This class represents a trend fill series that displays fills between\n    trend lines and base lines. It's commonly used for technical\n    indicators like Supertrend, where the fill area changes color based on\n    trend direction.\n\n    The series properly handles separate trend lines based on trend direction:\n    - Uptrend (+1): Uses uptrend_line options for trend line above price\n    - Downtrend (-1): Uses downtrend_line options for trend line below price\n\n    Attributes:\n        uptrend_line (LineOptions): Line options for the uptrend line.\n        downtrend_line (LineOptions): Line options for the downtrend line.\n        base_line (LineOptions): Line options for the base line.\n        uptrend_fill_color (str): Color for uptrend fills (default: green).\n        downtrend_fill_color (str): Color for downtrend fills (default: red).\n        fill_visible (bool): Whether fills are visible.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import TrendFillSeries\n        from streamlit_lightweight_charts_pro.data import TrendFillData\n\n        # Create trend fill data\n        data = [\n            TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n            TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n        ]\n\n        # Create series with custom colors\n        series = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n        ```\n    \"\"\"\n\n    DATA_CLASS = TrendFillData\n\n    def __init__(\n        self,\n        data: Union[List[TrendFillData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        uptrend_fill_color: str = \"#4CAF50\",\n        downtrend_fill_color: str = \"#F44336\",\n    ):\n        \"\"\"Initialize TrendFillSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            uptrend_fill_color: Color for uptrend fills (green)\n            downtrend_fill_color: Color for downtrend fills (red)\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Convert colors to rgba with default opacity\n        self._uptrend_fill_color = add_opacity(uptrend_fill_color)\n        self._downtrend_fill_color = add_opacity(downtrend_fill_color)\n\n        # Initialize line options for uptrend line, downtrend line, and base line\n        self._uptrend_line = create_uptrend_line()\n        self._downtrend_line = create_downtrend_line()\n        self._base_line = create_base_line()\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Return the chart type for this series.\"\"\"\n        return ChartType.TREND_FILL\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TrendFillSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TrendFillSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Return the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig","title":"PriceScaleConfig","text":"<p>Builder for common price scale configurations.</p> <p>This class provides static factory methods for creating properly configured PriceScaleOptions for common use cases like overlays, separate panes, and specific indicator types.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>class PriceScaleConfig:\n    \"\"\"Builder for common price scale configurations.\n\n    This class provides static factory methods for creating properly configured\n    PriceScaleOptions for common use cases like overlays, separate panes, and\n    specific indicator types.\n    \"\"\"\n\n    @staticmethod\n    def for_overlay(\n        scale_id: str,\n        top_margin: float = 0.8,\n        bottom_margin: float = 0.0,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for overlay series (hidden axis).\n\n        Overlays are series displayed in the same pane as the main series but\n        with a different value scale. The axis labels are hidden by default.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.0).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for overlay use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,  # Hide axis labels for overlays\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        # Merge with provided kwargs (kwargs take precedence)\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_separate_pane(\n        scale_id: str,\n        top_margin: float = 0.1,\n        bottom_margin: float = 0.1,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for separate pane (visible axis).\n\n        Separate pane series are displayed in their own vertical pane with\n        visible axis labels and balanced margins.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for separate pane use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,  # Show axis labels for separate panes\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_volume(\n        scale_id: str = \"volume\",\n        as_overlay: bool = True,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config optimized for volume series.\n\n        Volume series typically use large top margins to appear at the bottom\n        of the chart without interfering with price series.\n\n        Args:\n            scale_id: Unique identifier for the price scale (default: \"volume\").\n            as_overlay: Whether volume is overlay (True) or separate pane (False).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for volume visualization.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        if as_overlay:\n            # Volume as overlay: large top margin, hidden axis\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": False,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n            }\n        else:\n            # Volume as separate pane: visible axis, balanced margins\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": True,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n            }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_indicator(\n        scale_id: str,\n        min_value: Optional[float] = None,  # noqa: ARG004\n        max_value: Optional[float] = None,  # noqa: ARG004\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n        Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n        This method creates a config suitable for these bounded indicators.\n\n        Note: min_value and max_value are accepted for API compatibility but\n        are not used in PriceScaleOptions. Use chart-level options to set\n        value ranges if needed.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            min_value: Optional minimum value hint (not used by PriceScaleOptions).\n            max_value: Optional maximum value hint (not used by PriceScaleOptions).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for bounded indicators.\n\n        Example:\n            &gt;&gt;&gt; # RSI indicator (0-100 range)\n            &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,  # Always auto-scale for now\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n        }\n\n        # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n        # They would be used at the chart/series level if implemented in the future\n\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_percentage(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for percentage-based series.\n\n        Percentage-based series show changes as percentages rather than\n        absolute values, useful for comparing relative performance.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for percentage mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.PERCENTAGE,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_logarithmic(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for logarithmic scale.\n\n        Logarithmic scales are useful for displaying data that spans several\n        orders of magnitude or for emphasizing percentage changes.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for logarithmic mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.LOGARITHMIC,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_overlay","title":"for_overlay  <code>staticmethod</code>","text":"<pre><code>for_overlay(scale_id: str, top_margin: float = 0.8, bottom_margin: float = 0.0, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for overlay series (hidden axis).</p> <p>Overlays are series displayed in the same pane as the main series but with a different value scale. The axis labels are hidden by default.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.8 = 80% space at top).</p> <code>0.8</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.0).</p> <code>0.0</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for overlay use.</p> Example <p>config = PriceScaleConfig.for_overlay(\"volume\") chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_overlay(\n    scale_id: str,\n    top_margin: float = 0.8,\n    bottom_margin: float = 0.0,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for overlay series (hidden axis).\n\n    Overlays are series displayed in the same pane as the main series but\n    with a different value scale. The axis labels are hidden by default.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.0).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for overlay use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": False,  # Hide axis labels for overlays\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    # Merge with provided kwargs (kwargs take precedence)\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_separate_pane","title":"for_separate_pane  <code>staticmethod</code>","text":"<pre><code>for_separate_pane(scale_id: str, top_margin: float = 0.1, bottom_margin: float = 0.1, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for separate pane (visible axis).</p> <p>Separate pane series are displayed in their own vertical pane with visible axis labels and balanced margins.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.1 = 10% space at top).</p> <code>0.1</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.1 = 10% space at bottom).</p> <code>0.1</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for separate pane use.</p> Example <p>config = PriceScaleConfig.for_separate_pane(\"rsi\") chart.add_overlay_price_scale(\"rsi\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_separate_pane(\n    scale_id: str,\n    top_margin: float = 0.1,\n    bottom_margin: float = 0.1,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for separate pane (visible axis).\n\n    Separate pane series are displayed in their own vertical pane with\n    visible axis labels and balanced margins.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for separate pane use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,  # Show axis labels for separate panes\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_volume","title":"for_volume  <code>staticmethod</code>","text":"<pre><code>for_volume(scale_id: str = 'volume', as_overlay: bool = True, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config optimized for volume series.</p> <p>Volume series typically use large top margins to appear at the bottom of the chart without interfering with price series.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale (default: \"volume\").</p> <code>'volume'</code> <code>as_overlay</code> <code>bool</code> <p>Whether volume is overlay (True) or separate pane (False).</p> <code>True</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for volume visualization.</p> Example <p>config = PriceScaleConfig.for_volume(as_overlay=True) chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_volume(\n    scale_id: str = \"volume\",\n    as_overlay: bool = True,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config optimized for volume series.\n\n    Volume series typically use large top margins to appear at the bottom\n    of the chart without interfering with price series.\n\n    Args:\n        scale_id: Unique identifier for the price scale (default: \"volume\").\n        as_overlay: Whether volume is overlay (True) or separate pane (False).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for volume visualization.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    if as_overlay:\n        # Volume as overlay: large top margin, hidden axis\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n        }\n    else:\n        # Volume as separate pane: visible axis, balanced margins\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_indicator","title":"for_indicator  <code>staticmethod</code>","text":"<pre><code>for_indicator(scale_id: str, min_value: Optional[float] = None, max_value: Optional[float] = None, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for bounded indicators (RSI, Stochastic, etc).</p> <p>Many technical indicators have fixed value ranges (e.g., RSI: 0-100). This method creates a config suitable for these bounded indicators.</p> <p>Note: min_value and max_value are accepted for API compatibility but are not used in PriceScaleOptions. Use chart-level options to set value ranges if needed.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>min_value</code> <code>Optional[float]</code> <p>Optional minimum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>Optional maximum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for bounded indicators.</p> Example Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_indicator(\n    scale_id: str,\n    min_value: Optional[float] = None,  # noqa: ARG004\n    max_value: Optional[float] = None,  # noqa: ARG004\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n    Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n    This method creates a config suitable for these bounded indicators.\n\n    Note: min_value and max_value are accepted for API compatibility but\n    are not used in PriceScaleOptions. Use chart-level options to set\n    value ranges if needed.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        min_value: Optional minimum value hint (not used by PriceScaleOptions).\n        max_value: Optional maximum value hint (not used by PriceScaleOptions).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for bounded indicators.\n\n    Example:\n        &gt;&gt;&gt; # RSI indicator (0-100 range)\n        &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,  # Always auto-scale for now\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n    }\n\n    # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n    # They would be used at the chart/series level if implemented in the future\n\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_indicator--rsi-indicator-0-100-range","title":"RSI indicator (0-100 range)","text":"<p>config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100) chart.add_overlay_price_scale(\"rsi\", config)</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_percentage","title":"for_percentage  <code>staticmethod</code>","text":"<pre><code>for_percentage(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for percentage-based series.</p> <p>Percentage-based series show changes as percentages rather than absolute values, useful for comparing relative performance.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for percentage mode.</p> Example <p>config = PriceScaleConfig.for_percentage(\"pct_change\") chart.add_overlay_price_scale(\"pct_change\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_percentage(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for percentage-based series.\n\n    Percentage-based series show changes as percentages rather than\n    absolute values, useful for comparing relative performance.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for percentage mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.PERCENTAGE,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleConfig.for_logarithmic","title":"for_logarithmic  <code>staticmethod</code>","text":"<pre><code>for_logarithmic(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for logarithmic scale.</p> <p>Logarithmic scales are useful for displaying data that spans several orders of magnitude or for emphasizing percentage changes.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for logarithmic mode.</p> Example <p>config = PriceScaleConfig.for_logarithmic(\"price_log\") chart.add_overlay_price_scale(\"price_log\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_logarithmic(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for logarithmic scale.\n\n    Logarithmic scales are useful for displaying data that spans several\n    orders of magnitude or for emphasizing percentage changes.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for logarithmic mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.LOGARITHMIC,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidationError","title":"PriceScaleValidationError","text":"<p>Raised when price scale validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidationError(Exception):\n    \"\"\"Raised when price scale validation fails.\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidator","title":"PriceScaleValidator","text":"<p>Validates price scale configurations and provides helpful errors.</p> <p>This validator helps developers catch common price scale configuration mistakes early with actionable error messages.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidator:\n    \"\"\"Validates price scale configurations and provides helpful errors.\n\n    This validator helps developers catch common price scale configuration\n    mistakes early with actionable error messages.\n    \"\"\"\n\n    @staticmethod\n    def validate_series_price_scale(\n        series: Series,\n        available_scales: Dict[str, PriceScaleOptions],\n        auto_create_enabled: bool = True,\n    ) -&gt; None:\n        \"\"\"Validate that series price_scale_id references existing scale.\n\n        Args:\n            series: The series to validate.\n            available_scales: Dictionary of available overlay price scales.\n            auto_create_enabled: Whether auto-creation is enabled.\n\n        Raises:\n            PriceScaleValidationError: If validation fails and auto-create is disabled.\n        \"\"\"\n        scale_id = getattr(series, \"price_scale_id\", \"\")\n\n        # Built-in scales always valid\n        if scale_id in (\"\", \"left\", \"right\"):\n            return\n\n        # Check if custom scale exists\n        if scale_id not in available_scales:\n            if auto_create_enabled:\n                # Auto-creation will handle this - no error needed\n                return\n\n            # Auto-creation disabled - provide helpful error\n            available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n            raise PriceScaleValidationError(\n                f\"Series references non-existent price scale '{scale_id}'. \"\n                f\"Available scales: {available}. \"\n                f\"\\n\\nOptions to fix this:\"\n                f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n                f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n                f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n            )\n\n    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n\n    @staticmethod\n    def validate_pane_configuration(\n        pane_id: int,\n        existing_series: list,\n    ) -&gt; Optional[str]:\n        \"\"\"Validate pane configuration and provide warnings if needed.\n\n        Args:\n            pane_id: The pane ID to validate.\n            existing_series: List of existing series in the chart.\n\n        Returns:\n            Warning message if configuration seems inefficient, None otherwise.\n        \"\"\"\n        # Check if multiple series in same pane use different custom scales\n        pane_scales = {}\n        for series in existing_series:\n            series_pane = getattr(series, \"pane_id\", 0)\n            if series_pane == pane_id:\n                scale_id = getattr(series, \"price_scale_id\", \"\")\n                if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                    if scale_id not in pane_scales:\n                        pane_scales[scale_id] = []\n                    pane_scales[scale_id].append(series)\n\n        # If multiple different custom scales in same pane, suggest consolidation\n        if len(pane_scales) &gt; 1:\n            scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n            return (\n                f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n                f\"Consider using a single shared scale for better performance, or use \"\n                f\"built-in scales ('left', 'right') for primary series.\"\n            )\n\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidator-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidator.validate_series_price_scale","title":"validate_series_price_scale  <code>staticmethod</code>","text":"<pre><code>validate_series_price_scale(series: Series, available_scales: Dict[str, PriceScaleOptions], auto_create_enabled: bool = True) -&gt; None\n</code></pre> <p>Validate that series price_scale_id references existing scale.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series to validate.</p> required <code>available_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Dictionary of available overlay price scales.</p> required <code>auto_create_enabled</code> <code>bool</code> <p>Whether auto-creation is enabled.</p> <code>True</code> <p>Raises:</p> Type Description <code>PriceScaleValidationError</code> <p>If validation fails and auto-create is disabled.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_series_price_scale(\n    series: Series,\n    available_scales: Dict[str, PriceScaleOptions],\n    auto_create_enabled: bool = True,\n) -&gt; None:\n    \"\"\"Validate that series price_scale_id references existing scale.\n\n    Args:\n        series: The series to validate.\n        available_scales: Dictionary of available overlay price scales.\n        auto_create_enabled: Whether auto-creation is enabled.\n\n    Raises:\n        PriceScaleValidationError: If validation fails and auto-create is disabled.\n    \"\"\"\n    scale_id = getattr(series, \"price_scale_id\", \"\")\n\n    # Built-in scales always valid\n    if scale_id in (\"\", \"left\", \"right\"):\n        return\n\n    # Check if custom scale exists\n    if scale_id not in available_scales:\n        if auto_create_enabled:\n            # Auto-creation will handle this - no error needed\n            return\n\n        # Auto-creation disabled - provide helpful error\n        available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n        raise PriceScaleValidationError(\n            f\"Series references non-existent price scale '{scale_id}'. \"\n            f\"Available scales: {available}. \"\n            f\"\\n\\nOptions to fix this:\"\n            f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n            f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n            f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidator.suggest_configuration","title":"suggest_configuration  <code>staticmethod</code>","text":"<pre><code>suggest_configuration(series_type: str, pane_id: int, is_overlay: bool) -&gt; str\n</code></pre> <p>Provide configuration suggestions based on context.</p> <p>Parameters:</p> Name Type Description Default <code>series_type</code> <code>str</code> <p>The type of series (e.g., 'LineSeries').</p> required <code>pane_id</code> <code>int</code> <p>The pane ID.</p> required <code>is_overlay</code> <code>bool</code> <p>Whether this is an overlay series.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted suggestion string.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.PriceScaleValidator.validate_pane_configuration","title":"validate_pane_configuration  <code>staticmethod</code>","text":"<pre><code>validate_pane_configuration(pane_id: int, existing_series: list) -&gt; Optional[str]\n</code></pre> <p>Validate pane configuration and provide warnings if needed.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to validate.</p> required <code>existing_series</code> <code>list</code> <p>List of existing series in the chart.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Warning message if configuration seems inefficient, None otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_pane_configuration(\n    pane_id: int,\n    existing_series: list,\n) -&gt; Optional[str]:\n    \"\"\"Validate pane configuration and provide warnings if needed.\n\n    Args:\n        pane_id: The pane ID to validate.\n        existing_series: List of existing series in the chart.\n\n    Returns:\n        Warning message if configuration seems inefficient, None otherwise.\n    \"\"\"\n    # Check if multiple series in same pane use different custom scales\n    pane_scales = {}\n    for series in existing_series:\n        series_pane = getattr(series, \"pane_id\", 0)\n        if series_pane == pane_id:\n            scale_id = getattr(series, \"price_scale_id\", \"\")\n            if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                if scale_id not in pane_scales:\n                    pane_scales[scale_id] = []\n                pane_scales[scale_id].append(series)\n\n    # If multiple different custom scales in same pane, suggest consolidation\n    if len(pane_scales) &gt; 1:\n        scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n        return (\n            f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n            f\"Consider using a single shared scale for better performance, or use \"\n            f\"built-in scales ('left', 'right') for primary series.\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation","title":"Annotation","text":"<p>Represents a chart annotation.</p> <p>This class defines an annotation that can be displayed on charts to provide additional context, highlight important events, or add explanatory information. Annotations support various types, positions, and styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Annotation time (accepts pd.Timestamp, datetime, or string)</p> <code>price</code> <code>float</code> <p>Price level for the annotation</p> <code>text</code> <code>str</code> <p>Annotation text content</p> <code>annotation_type</code> <code>AnnotationType</code> <p>Type of annotation (text, arrow, shape, etc.)</p> <code>position</code> <code>AnnotationPosition</code> <p>Position of the annotation relative to the price level</p> <code>color</code> <code>str</code> <p>Primary color of the annotation</p> <code>background_color</code> <code>str</code> <p>Background color for text annotations</p> <code>font_size</code> <code>int</code> <p>Font size for text annotations</p> <code>font_weight</code> <code>str</code> <p>Font weight for text annotations</p> <code>text_color</code> <code>str</code> <p>Color of the text content</p> <code>border_color</code> <code>str</code> <p>Border color for shape annotations</p> <code>border_width</code> <code>int</code> <p>Border width for shape annotations</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the annotation (0.0 to 1.0)</p> <code>show_time</code> <code>bool</code> <p>Whether to show time in the annotation text</p> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip text for hover interactions</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class Annotation:\n    \"\"\"Represents a chart annotation.\n\n    This class defines an annotation that can be displayed on charts to\n    provide additional context, highlight important events, or add\n    explanatory information. Annotations support various types, positions,\n    and styling options.\n\n    Attributes:\n        time: Annotation time (accepts pd.Timestamp, datetime, or string)\n        price: Price level for the annotation\n        text: Annotation text content\n        annotation_type: Type of annotation (text, arrow, shape, etc.)\n        position: Position of the annotation relative to the price level\n        color: Primary color of the annotation\n        background_color: Background color for text annotations\n        font_size: Font size for text annotations\n        font_weight: Font weight for text annotations\n        text_color: Color of the text content\n        border_color: Border color for shape annotations\n        border_width: Border width for shape annotations\n        opacity: Overall opacity of the annotation (0.0 to 1.0)\n        show_time: Whether to show time in the annotation text\n        tooltip: Optional tooltip text for hover interactions\n    \"\"\"\n\n    time: Union[pd.Timestamp, datetime, str, int, float]\n    price: float\n    text: str\n    annotation_type: AnnotationType = AnnotationType.TEXT\n    position: AnnotationPosition = AnnotationPosition.ABOVE\n    color: str = \"#2196F3\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    font_size: int = 12\n    font_weight: str = \"normal\"\n    text_color: str = \"#000000\"\n    border_color: str = \"#CCCCCC\"\n    border_width: int = 1\n    opacity: float = 1.0\n    show_time: bool = False\n    tooltip: Optional[str] = None\n\n    def __init__(\n        self,\n        time: Union[pd.Timestamp, datetime, str, int, float],\n        price: float,\n        text: str,\n        annotation_type: Union[str, AnnotationType] = AnnotationType.TEXT,\n        position: Union[str, AnnotationPosition] = AnnotationPosition.ABOVE,\n        color: str = \"#2196F3\",\n        background_color: str = \"rgba(255, 255, 255, 0.9)\",\n        font_size: int = 12,\n        font_weight: str = \"normal\",\n        text_color: str = \"#000000\",\n        border_color: str = \"#CCCCCC\",\n        border_width: int = 1,\n        opacity: float = 1.0,\n        show_time: bool = False,\n        tooltip: Optional[str] = None,\n    ):\n        # Store time as-is, convert to UTC timestamp in asdict() for consistency\n        self.time = time\n\n        # Accept both str and Enum for annotation_type\n        if isinstance(annotation_type, str):\n            self.annotation_type = AnnotationType(annotation_type)\n        else:\n            self.annotation_type = annotation_type\n\n        # Accept both str and Enum for position\n        if isinstance(position, str):\n            self.position = AnnotationPosition(position)\n        else:\n            self.position = position\n\n        # Validate price value\n        if not isinstance(price, (int, float)):\n            raise TypeValidationError(\"price\", \"a number\")\n        self.price = price\n\n        # Validate text content\n        if not text:\n            raise ValueValidationError.required_field(\"text\")\n        self.text = text\n\n        # Validate opacity range\n        if opacity &lt; 0 or opacity &gt; 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n\n        # Validate font size\n        if font_size &lt;= 0:\n            raise ValueValidationError.positive_value(\"font_size\", font_size)\n        self.font_size = font_size\n\n        # Validate border width\n        if border_width &lt; 0:\n            raise ValueValidationError(\"border_width\", f\"must be non-negative, got {border_width}\")\n        self.border_width = border_width\n\n        self.color = color\n        self.background_color = background_color\n        self.font_weight = font_weight\n        self.text_color = text_color\n        self.border_color = border_color\n        self.show_time = show_time\n        self.tooltip = tooltip\n\n    @property\n    def timestamp(self) -&gt; int:\n        \"\"\"Get time as UTC timestamp (converted fresh).\n\n        Converts the time value to UTC timestamp each time it's accessed.\n        This allows the time to be modified after construction.\n\n        Returns:\n            int: UTC timestamp as integer (seconds).\n        \"\"\"\n        return to_utc_timestamp(self.time)\n\n    @property\n    def datetime_value(self) -&gt; pd.Timestamp:\n        \"\"\"Get time as pandas Timestamp.\n\n        Returns:\n            pd.Timestamp: Pandas Timestamp object representing the\n                annotation time.\n        \"\"\"\n        return pd.Timestamp(from_utc_timestamp(to_utc_timestamp(self.time)))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert annotation to dictionary for serialization.\n\n        This method creates a dictionary representation of the annotation\n        suitable for JSON serialization or frontend consumption.\n\n        Time conversion happens here (not cached) to allow users to modify\n        time values after construction.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing all annotation properties\n                in a format suitable for the frontend component.\n        \"\"\"\n        # Convert time fresh during serialization\n        return {\n            ColumnNames.TIME: to_utc_timestamp(self.time),\n            \"price\": self.price,\n            \"text\": self.text,\n            \"type\": self.annotation_type.value,\n            \"position\": self.position.value,\n            \"color\": self.color,\n            \"background_color\": self.background_color,\n            \"font_size\": self.font_size,\n            \"font_weight\": self.font_weight,\n            \"text_color\": self.text_color,\n            \"border_color\": self.border_color,\n            \"border_width\": self.border_width,\n            \"opacity\": self.opacity,\n            \"show_time\": self.show_time,\n            \"tooltip\": self.tooltip,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: int\n</code></pre> <p>Get time as UTC timestamp (converted fresh).</p> <p>Converts the time value to UTC timestamp each time it's accessed. This allows the time to be modified after construction.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UTC timestamp as integer (seconds).</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation.datetime_value","title":"datetime_value  <code>property</code>","text":"<pre><code>datetime_value: Timestamp\n</code></pre> <p>Get time as pandas Timestamp.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: Pandas Timestamp object representing the annotation time.</p>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.Annotation.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert annotation to dictionary for serialization.</p> <p>This method creates a dictionary representation of the annotation suitable for JSON serialization or frontend consumption.</p> <p>Time conversion happens here (not cached) to allow users to modify time values after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing all annotation properties in a format suitable for the frontend component.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert annotation to dictionary for serialization.\n\n    This method creates a dictionary representation of the annotation\n    suitable for JSON serialization or frontend consumption.\n\n    Time conversion happens here (not cached) to allow users to modify\n    time values after construction.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing all annotation properties\n            in a format suitable for the frontend component.\n    \"\"\"\n    # Convert time fresh during serialization\n    return {\n        ColumnNames.TIME: to_utc_timestamp(self.time),\n        \"price\": self.price,\n        \"text\": self.text,\n        \"type\": self.annotation_type.value,\n        \"position\": self.position.value,\n        \"color\": self.color,\n        \"background_color\": self.background_color,\n        \"font_size\": self.font_size,\n        \"font_weight\": self.font_weight,\n        \"text_color\": self.text_color,\n        \"border_color\": self.border_color,\n        \"border_width\": self.border_width,\n        \"opacity\": self.opacity,\n        \"show_time\": self.show_time,\n        \"tooltip\": self.tooltip,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AreaData","title":"AreaData  <code>dataclass</code>","text":"<p>Data class for area chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color fields for area chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding area-specific color features for enhanced visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>line_color</code> <code>Optional[str]</code> <p>Color for the area line in hex or rgba format. If not provided, the line_color field is not serialized.</p> <code>top_color</code> <code>Optional[str]</code> <p>Color for the top of the area fill in hex or rgba format. If not provided, the top_color field is not serialized.</p> <code>bottom_color</code> <code>Optional[str]</code> <p>Color for the bottom of the area fill in hex or rgba format. If not provided, the bottom_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/area_data.py</code> <pre><code>@dataclass\n@validated_field(\"line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_color\", str, validator=\"color\", allow_none=True)\nclass AreaData(SingleValueData):\n    \"\"\"Data class for area chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color fields for area chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding area-specific color features\n    for enhanced visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        line_color (Optional[str]): Color for the area line in hex or rgba format.\n            If not provided, the line_color field is not serialized.\n        top_color (Optional[str]): Color for the top of the area fill in hex or rgba format.\n            If not provided, the top_color field is not serialized.\n        bottom_color (Optional[str]): Color for the bottom of the area fill in hex or rgba format.\n            If not provided, the bottom_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data point with colors\n        data = AreaData(\n            time=\"2024-01-01T00:00:00\",\n            value=100.0,\n            line_color=\"#2196F3\",\n            top_color=\"rgba(33,150,243,0.3)\",\n            bottom_color=\"rgba(33,150,243,0.1)\",\n        )\n\n        # Create area data point without colors\n        data = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - area-specific color fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"line_color\", \"top_color\", \"bottom_color\"}\n\n    # Optional color field for the area line\n    line_color: Optional[str] = None\n    # Optional color field for the top of the area fill\n    top_color: Optional[str] = None\n    # Optional color field for the bottom of the area fill\n    bottom_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to strip whitespace from color values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Strips whitespace from color strings if provided\n        3. Sets empty/whitespace-only values to None to avoid serialization\n\n        Color validation is handled by @validated_field decorators.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Strip whitespace from color strings and clean up empty values\n        for color_attr in [\"line_color\", \"top_color\", \"bottom_color\"]:\n            color_value = getattr(self, color_attr)\n            if color_value is not None:\n                # Strip whitespace\n                stripped_value = color_value.strip()\n                # Set to None if empty after stripping to avoid serialization\n                setattr(self, color_attr, stripped_value if stripped_value else None)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BarData","title":"BarData  <code>dataclass</code>","text":"<p>Data class for a single value (line/area/histogram) chart point.</p> <p>Inherits from SingleValueData and adds an optional color field.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point (hex or rgba).                    If not provided, not serialized.</p> <p>See also: SingleValueData</p> Note <ul> <li>Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/bar_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass BarData(OhlcData):\n    \"\"\"Data class for a single value (line/area/histogram) chart point.\n\n    Inherits from SingleValueData and adds an optional color field.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        color (Optional[str]): Color for this data point (hex or rgba).\n                               If not provided, not serialized.\n\n    See also: SingleValueData\n\n    Note:\n        - Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.BaselineData","title":"BaselineData  <code>dataclass</code>","text":"<p>Data class for a baseline chart point.</p> <p>Inherits from SingleValueData and adds optional color properties for baseline series. Baseline series display data with both top and bottom areas, each with their own styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>top_fill_color1</code> <code>Optional[str]</code> <p>Optional top area top fill color (hex or rgba).</p> <code>top_fill_color2</code> <code>Optional[str]</code> <p>Optional top area bottom fill color (hex or rgba).</p> <code>top_line_color</code> <code>Optional[str]</code> <p>Optional top area line color (hex or rgba).</p> <code>bottom_fill_color1</code> <code>Optional[str]</code> <p>Optional bottom area top fill color (hex or rgba).</p> <code>bottom_fill_color2</code> <code>Optional[str]</code> <p>Optional bottom area bottom fill color (hex or rgba).</p> <code>bottom_line_color</code> <code>Optional[str]</code> <p>Optional bottom area line color (hex or rgba).</p> <p>See also: SingleValueData</p> Note <ul> <li>All color properties should be valid hex (e.g., #2196F3) or rgba strings   (e.g., rgba(33,150,243,1)).</li> </ul> <pre><code>- If color properties are not provided, colors from series options will be used.\n - Baseline series display data with both positive and negative areas relative\n   to a baseline value.\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/baseline_data.py</code> <pre><code>@dataclass\n@validated_field(\"top_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_line_color\", str, validator=\"color\", allow_none=True)\nclass BaselineData(SingleValueData):\n    \"\"\"Data class for a baseline chart point.\n\n    Inherits from SingleValueData and adds optional color properties for baseline series.\n    Baseline series display data with both top and bottom areas, each with their own\n    styling options.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        top_fill_color1 (Optional[str]): Optional top area top fill color (hex or rgba).\n        top_fill_color2 (Optional[str]): Optional top area bottom fill color (hex or rgba).\n        top_line_color (Optional[str]): Optional top area line color (hex or rgba).\n        bottom_fill_color1 (Optional[str]): Optional bottom area top fill color (hex or rgba).\n        bottom_fill_color2 (Optional[str]): Optional bottom area bottom fill color\n            (hex or rgba).\n        bottom_line_color (Optional[str]): Optional bottom area line color (hex or rgba).\n\n    See also: SingleValueData\n\n    Note:\n         - All color properties should be valid hex (e.g., #2196F3) or rgba strings\n           (e.g., rgba(33,150,243,1)).\n        - If color properties are not provided, colors from series options will be used.\n         - Baseline series display data with both positive and negative areas relative\n           to a baseline value.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"top_fill_color1\",\n        \"top_fill_color2\",\n        \"top_line_color\",\n        \"bottom_fill_color1\",\n        \"bottom_fill_color2\",\n        \"bottom_line_color\",\n    }\n\n    top_fill_color1: Optional[str] = None\n    top_fill_color2: Optional[str] = None\n    top_line_color: Optional[str] = None\n    bottom_fill_color1: Optional[str] = None\n    bottom_fill_color2: Optional[str] = None\n    bottom_line_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.CandlestickData","title":"CandlestickData  <code>dataclass</code>","text":"<p>Data class for candlestick chart data points with optional color styling.</p> <p>This class extends OhlcData to add optional color fields for candlestick styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for candlestick visualization.</p> <p>The class automatically handles time normalization, OHLC validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>color</code> <code>Optional[str]</code> <p>Color for the candlestick body in hex or rgba format. If not provided, the color field is not serialized.</p> <code>border_color</code> <code>Optional[str]</code> <p>Border color for the candlestick in hex or rgba format. If not provided, the border_color field is not serialized.</p> <code>wick_color</code> <code>Optional[str]</code> <p>Wick color for the candlestick in hex or rgba format. If not provided, the wick_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Set containing color-related optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/candlestick_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"border_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"wick_color\", str, validator=\"color\", allow_none=True)\nclass CandlestickData(OhlcData):\n    \"\"\"Data class for candlestick chart data points with optional color styling.\n\n    This class extends OhlcData to add optional color fields for candlestick\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for candlestick visualization.\n\n    The class automatically handles time normalization, OHLC validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        color (Optional[str]): Color for the candlestick body in hex or rgba format.\n            If not provided, the color field is not serialized.\n        border_color (Optional[str]): Border color for the candlestick in hex or rgba format.\n            If not provided, the border_color field is not serialized.\n        wick_color (Optional[str]): Wick color for the candlestick in hex or rgba format.\n            If not provided, the wick_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Set containing color-related optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data point with colors\n        data = CandlestickData(\n            time=\"2024-01-01T00:00:00\",\n            open=100.0,\n            high=105.0,\n            low=98.0,\n            close=102.0,\n            color=\"#4CAF50\",  # Green body for bullish candle\n            border_color=\"#2E7D32\",\n            wick_color=\"#1B5E20\",\n        )\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color fields are optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\", \"border_color\", \"wick_color\"}\n\n    # Optional color field for the candlestick body\n    color: Optional[str] = None\n    # Optional color field for the candlestick border\n    border_color: Optional[str] = None\n    # Optional color field for the candlestick wick\n    wick_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.HistogramData","title":"HistogramData  <code>dataclass</code>","text":"<p>Data class for histogram chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for histogram chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for histogram visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. AreaData: Similar data class for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/histogram_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass HistogramData(SingleValueData):\n    \"\"\"Data class for histogram chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for histogram chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for histogram visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data point with color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n        # Create histogram data point without color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        AreaData: Similar data class for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this histogram data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LineData","title":"LineData  <code>dataclass</code>","text":"<p>Data class for line chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for line chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. AreaData: Similar data class for area charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/line_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass LineData(SingleValueData):\n    \"\"\"Data class for line chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for line chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data point with color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n        # Create line data point without color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        AreaData: Similar data class for area charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.OhlcvData","title":"OhlcvData  <code>dataclass</code>","text":"<p>Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.</p> <p>This class represents an OHLCV data point commonly used in candlestick and bar charts for displaying financial market data with volume information. It extends the OhlcData class with volume-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships, ensures all values are non-negative, validates volume data, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>volume</code> <code>float</code> <p>Trading volume for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column     beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship) or volume &lt; 0.</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLCV field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. CandlestickData: OHLC data with color styling capabilities. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlcv_data.py</code> <pre><code>@dataclass\nclass OhlcvData(OhlcData):\n    \"\"\"Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.\n\n    This class represents an OHLCV data point commonly used in candlestick and bar charts\n    for displaying financial market data with volume information. It extends the OhlcData\n    class with volume-specific validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships, ensures all values are non-negative,\n    validates volume data, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        volume (float): Trading volume for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column\n            beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcvData\n\n        # Create OHLCV data point with volume\n        data = OhlcvData(\n            time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n        )\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship) or volume &lt; 0.\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLCV field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        CandlestickData: OHLC data with color styling capabilities.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - volume is additional requirement\n    # beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = {\"volume\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Trading volume for the time period - must be non-negative\n    volume: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLCV data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate OHLC data and time\n        2. Validates that volume is non-negative\n        3. Handles NaN values in the volume field\n        4. Validates that volume is not None\n\n        The method ensures that all OHLCV data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If volume &lt; 0 (volume cannot be negative).\n            RequiredFieldError: If volume field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to validate OHLC data and time normalization\n        super().__post_init__()\n\n        # Validate that volume is non-negative (volume cannot be negative)\n        if self.volume &lt; 0:\n            raise ValueValidationError(\"volume\", \"must be non-negative\")\n\n        # Handle NaN values in volume field - convert to 0.0 for frontend compatibility\n        for field_name in [\"volume\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - volume is required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.SignalData","title":"SignalData  <code>dataclass</code>","text":"<p>Signal data point for background coloring.</p> <p>SignalData represents a single time point with a signal value that determines the background color for that time period. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[str, datetime]</code> <p>Time point for the signal. Can be a string in ISO format (YYYY-MM-DD) or a datetime object.</p> <code>value</code> <code>Union[int, bool]</code> <p>Signal value that determines background color. Accepts both integers and booleans (converted to int automatically): - 0 or False: First color (typically neutral/gray) - 1 or True: Second color (typically signal/blue) - 2: Third color (optional, for ternary signals/alerts)</p> Example <pre><code># Create signal data for background coloring\n# Using integers (0, 1, 2)\nsignal_data_int = [\n    SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n    SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n]\n\n# Using booleans (False, True) - more natural for binary signals\nsignal_data_bool = [\n    SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n    SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n    SignalData(\"2024-01-03\", False),  # Neutral\n    SignalData(\"2024-01-04\", True),  # Signal\n]\n\n# Use with SignalSeries\nsignal_series = SignalSeries(\n    data=signal_data_bool,  # Works with both int and bool values\n    neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n    signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/signal_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass SignalData(SingleValueData):\n    \"\"\"Signal data point for background coloring.\n\n    SignalData represents a single time point with a signal value that determines\n    the background color for that time period. This is commonly used in financial\n    charts to highlight specific market conditions, trading signals, or events.\n\n    Attributes:\n        time (Union[str, datetime]): Time point for the signal. Can be a string\n            in ISO format (YYYY-MM-DD) or a datetime object.\n        value (Union[int, bool]): Signal value that determines background color.\n            Accepts both integers and booleans (converted to int automatically):\n            - 0 or False: First color (typically neutral/gray)\n            - 1 or True: Second color (typically signal/blue)\n            - 2: Third color (optional, for ternary signals/alerts)\n\n    Example:\n        ```python\n        # Create signal data for background coloring\n        # Using integers (0, 1, 2)\n        signal_data_int = [\n            SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n            SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n        ]\n\n        # Using booleans (False, True) - more natural for binary signals\n        signal_data_bool = [\n            SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n            SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n            SignalData(\"2024-01-03\", False),  # Neutral\n            SignalData(\"2024-01-04\", True),  # Signal\n        ]\n\n        # Use with SignalSeries\n        signal_series = SignalSeries(\n            data=signal_data_bool,  # Works with both int and bool values\n            neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n            signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.SingleValueData","title":"SingleValueData  <code>dataclass</code>","text":"<p>Data class for single value data points used in line and area charts.</p> <p>This class represents a single numeric value at a specific time point, commonly used for line charts, area charts, and other chart types that display one value per time. It extends the base Data class with value-specific validation and NaN handling.</p> <p>The class automatically handles time normalization, value validation, and serialization to camelCase dictionaries suitable for frontend communication.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"value\" as the required column     for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize for frontend\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. LineData: Specialized single value data for line charts. AreaData: Specialized single value data for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/single_value_data.py</code> <pre><code>@dataclass\nclass SingleValueData(Data):\n    \"\"\"Data class for single value data points used in line and area charts.\n\n    This class represents a single numeric value at a specific time point, commonly used\n    for line charts, area charts, and other chart types that display one value per time.\n    It extends the base Data class with value-specific validation and NaN handling.\n\n    The class automatically handles time normalization, value validation, and serialization\n    to camelCase dictionaries suitable for frontend communication.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"value\" as the required column\n            for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create single value data point\n        data = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        LineData: Specialized single value data for line charts.\n        AreaData: Specialized single value data for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - only \"value\" is required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"value\"}\n\n    # Define optional columns for DataFrame conversion - none for this simple data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # The single numeric value for this data point\n    value: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates the value field for None values\n        3. Converts NaN values to 0.0 for frontend compatibility\n\n        The method ensures that all data points have valid, non-NaN values\n        that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            RequiredFieldError: If the value field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Handle NaN values in the value field - convert to 0.0 for frontend compatibility\n        if isinstance(self.value, float) and math.isnan(self.value):\n            self.value = 0.0\n        # Validate that value is not None - this is a required field\n        elif self.value is None:\n            raise RequiredFieldError(\"value\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer","title":"AnnotationLayer  <code>dataclass</code>","text":"<p>Manages a layer of annotations for a chart.</p> <p>This class provides functionality for grouping related annotations together and applying bulk operations to them. Layers can be shown, hidden, or have their opacity adjusted as a group.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this layer</p> <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects in this layer</p> <code>visible</code> <code>bool</code> <p>Whether this layer is currently visible</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the layer (0.0 to 1.0)</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>@dataclass\nclass AnnotationLayer:\n    \"\"\"Manages a layer of annotations for a chart.\n\n    This class provides functionality for grouping related annotations\n    together and applying bulk operations to them. Layers can be shown,\n    hidden, or have their opacity adjusted as a group.\n\n    Attributes:\n        name: Unique name identifier for this layer\n        annotations: List of annotation objects in this layer\n        visible: Whether this layer is currently visible\n        opacity: Overall opacity of the layer (0.0 to 1.0)\n    \"\"\"\n\n    name: str\n    annotations: List[Annotation]\n    visible: bool = True\n    opacity: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate annotation layer after initialization.\n\n        Raises:\n            ValueError: If layer name is empty or opacity is invalid.\n        \"\"\"\n        if not self.name:\n            raise ValueValidationError.required_field(\"layer name\")\n\n        if not 0 &lt;= self.opacity &lt;= 1:\n            raise ValueValidationError(\n                \"opacity\",\n                f\"must be between 0.0 and 1.0, got {self.opacity}\",\n            )\n\n    def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n        \"\"\"Add annotation to layer.\n\n        Adds a single annotation to this layer and returns self for\n        method chaining.\n\n        Args:\n            annotation: Annotation object to add to the layer.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.add_annotation(text_annotation)\n            ```\n        \"\"\"\n        self.annotations.append(annotation)\n        return self\n\n    def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n        \"\"\"Remove annotation by index.\n\n        Removes an annotation from the layer by its index position\n        and returns self for method chaining.\n\n        Args:\n            index: Index of the annotation to remove.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.remove_annotation(0)  # Remove first annotation\n            ```\n        \"\"\"\n        if 0 &lt;= index &lt; len(self.annotations):\n            self.annotations.pop(index)\n        return self\n\n    def clear_annotations(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Clear all annotations from layer.\n\n        Removes all annotations from this layer and returns self\n        for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.clear_annotations()\n            ```\n        \"\"\"\n        self.annotations.clear()\n        return self\n\n    def hide(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Hide the layer.\n\n        Makes this layer and all its annotations invisible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.hide()\n            ```\n        \"\"\"\n        self.visible = False\n        return self\n\n    def show(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Show the layer.\n\n        Makes this layer and all its annotations visible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.show()\n            ```\n        \"\"\"\n        self.visible = True\n        return self\n\n    def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n        \"\"\"Set layer opacity.\n\n        Sets the overall opacity of this layer and returns self\n        for method chaining.\n\n        Args:\n            opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n\n        Example:\n            ```python\n            layer.set_opacity(0.5)  # 50% opacity\n            ```\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n        return self\n\n    def filter_by_time_range(\n        self,\n        start_time: Union[pd.Timestamp, datetime, str, int, float],\n        end_time: Union[pd.Timestamp, datetime, str, int, float],\n    ) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by time range.\n\n        Returns a list of annotations that fall within the specified\n        time range.\n\n        Args:\n            start_time: Start of the time range in various formats.\n            end_time: End of the time range in various formats.\n\n        Returns:\n            List[Annotation]: List of annotations within the time range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n            ```\n        \"\"\"\n        start_ts = to_utc_timestamp(start_time)\n        end_ts = to_utc_timestamp(end_time)\n\n        return [\n            annotation\n            for annotation in self.annotations\n            if start_ts &lt;= annotation.timestamp &lt;= end_ts\n        ]\n\n    def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by price range.\n\n        Returns a list of annotations that fall within the specified\n        price range.\n\n        Args:\n            min_price: Minimum price value.\n            max_price: Maximum price value.\n\n        Returns:\n            List[Annotation]: List of annotations within the price range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_price_range(100.0, 200.0)\n            ```\n        \"\"\"\n        return [\n            annotation\n            for annotation in self.annotations\n            if min_price &lt;= annotation.price &lt;= max_price\n        ]\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert layer to dictionary for serialization.\n\n        Creates a dictionary representation of the layer including\n        its properties and all contained annotations.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the layer.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"visible\": self.visible,\n            \"opacity\": self.opacity,\n            \"annotations\": [annotation.asdict() for annotation in self.annotations],\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation) -&gt; AnnotationLayer\n</code></pre> <p>Add annotation to layer.</p> <p>Adds a single annotation to this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.add_annotation(text_annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n    \"\"\"Add annotation to layer.\n\n    Adds a single annotation to this layer and returns self for\n    method chaining.\n\n    Args:\n        annotation: Annotation object to add to the layer.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.add_annotation(text_annotation)\n        ```\n    \"\"\"\n    self.annotations.append(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(index: int) -&gt; AnnotationLayer\n</code></pre> <p>Remove annotation by index.</p> <p>Removes an annotation from the layer by its index position and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the annotation to remove.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.remove_annotation(0)  # Remove first annotation\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n    \"\"\"Remove annotation by index.\n\n    Removes an annotation from the layer by its index position\n    and returns self for method chaining.\n\n    Args:\n        index: Index of the annotation to remove.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.remove_annotation(0)  # Remove first annotation\n        ```\n    \"\"\"\n    if 0 &lt;= index &lt; len(self.annotations):\n        self.annotations.pop(index)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations() -&gt; AnnotationLayer\n</code></pre> <p>Clear all annotations from layer.</p> <p>Removes all annotations from this layer and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.clear_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_annotations(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Clear all annotations from layer.\n\n    Removes all annotations from this layer and returns self\n    for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.clear_annotations()\n        ```\n    \"\"\"\n    self.annotations.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.hide","title":"hide","text":"<pre><code>hide() -&gt; AnnotationLayer\n</code></pre> <p>Hide the layer.</p> <p>Makes this layer and all its annotations invisible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.hide()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Hide the layer.\n\n    Makes this layer and all its annotations invisible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.hide()\n        ```\n    \"\"\"\n    self.visible = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.show","title":"show","text":"<pre><code>show() -&gt; AnnotationLayer\n</code></pre> <p>Show the layer.</p> <p>Makes this layer and all its annotations visible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.show()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Show the layer.\n\n    Makes this layer and all its annotations visible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.show()\n        ```\n    \"\"\"\n    self.visible = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.set_opacity","title":"set_opacity","text":"<pre><code>set_opacity(opacity: float) -&gt; AnnotationLayer\n</code></pre> <p>Set layer opacity.</p> <p>Sets the overall opacity of this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0.0 (transparent) and 1.0 (opaque).</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opacity is not between 0 and 1.</p> Example <pre><code>layer.set_opacity(0.5)  # 50% opacity\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n    \"\"\"Set layer opacity.\n\n    Sets the overall opacity of this layer and returns self\n    for method chaining.\n\n    Args:\n        opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Raises:\n        ValueError: If opacity is not between 0 and 1.\n\n    Example:\n        ```python\n        layer.set_opacity(0.5)  # 50% opacity\n        ```\n    \"\"\"\n    if not 0 &lt;= opacity &lt;= 1:\n        raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n    self.opacity = opacity\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.filter_by_time_range","title":"filter_by_time_range","text":"<pre><code>filter_by_time_range(start_time: Union[Timestamp, datetime, str, int, float], end_time: Union[Timestamp, datetime, str, int, float]) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by time range.</p> <p>Returns a list of annotations that fall within the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Start of the time range in various formats.</p> required <code>end_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>End of the time range in various formats.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the time range.</p> Example <pre><code>annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_time_range(\n    self,\n    start_time: Union[pd.Timestamp, datetime, str, int, float],\n    end_time: Union[pd.Timestamp, datetime, str, int, float],\n) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by time range.\n\n    Returns a list of annotations that fall within the specified\n    time range.\n\n    Args:\n        start_time: Start of the time range in various formats.\n        end_time: End of the time range in various formats.\n\n    Returns:\n        List[Annotation]: List of annotations within the time range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n        ```\n    \"\"\"\n    start_ts = to_utc_timestamp(start_time)\n    end_ts = to_utc_timestamp(end_time)\n\n    return [\n        annotation\n        for annotation in self.annotations\n        if start_ts &lt;= annotation.timestamp &lt;= end_ts\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.filter_by_price_range","title":"filter_by_price_range","text":"<pre><code>filter_by_price_range(min_price: float, max_price: float) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by price range.</p> <p>Returns a list of annotations that fall within the specified price range.</p> <p>Parameters:</p> Name Type Description Default <code>min_price</code> <code>float</code> <p>Minimum price value.</p> required <code>max_price</code> <code>float</code> <p>Maximum price value.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the price range.</p> Example <pre><code>annotations = layer.filter_by_price_range(100.0, 200.0)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by price range.\n\n    Returns a list of annotations that fall within the specified\n    price range.\n\n    Args:\n        min_price: Minimum price value.\n        max_price: Maximum price value.\n\n    Returns:\n        List[Annotation]: List of annotations within the price range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_price_range(100.0, 200.0)\n        ```\n    \"\"\"\n    return [\n        annotation\n        for annotation in self.annotations\n        if min_price &lt;= annotation.price &lt;= max_price\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationLayer.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert layer to dictionary for serialization.</p> <p>Creates a dictionary representation of the layer including its properties and all contained annotations.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the layer.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert layer to dictionary for serialization.\n\n    Creates a dictionary representation of the layer including\n    its properties and all contained annotations.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the layer.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"visible\": self.visible,\n        \"opacity\": self.opacity,\n        \"annotations\": [annotation.asdict() for annotation in self.annotations],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager","title":"AnnotationManager","text":"<p>Manages multiple annotation layers for a chart.</p> <p>This class provides a centralized way to manage multiple annotation layers, allowing for organization of annotations into logical groups. It supports creating, removing, and manipulating layers, as well as bulk operations across all layers.</p> <p>The AnnotationManager supports method chaining for fluent API usage and provides comprehensive layer management capabilities.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>Dict[str, AnnotationLayer]</code> <p>Dictionary mapping layer names to AnnotationLayer objects</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class AnnotationManager:\n    \"\"\"Manages multiple annotation layers for a chart.\n\n    This class provides a centralized way to manage multiple annotation\n    layers, allowing for organization of annotations into logical groups.\n    It supports creating, removing, and manipulating layers, as well as\n    bulk operations across all layers.\n\n    The AnnotationManager supports method chaining for fluent API usage\n    and provides comprehensive layer management capabilities.\n\n    Attributes:\n        layers: Dictionary mapping layer names to AnnotationLayer objects\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the annotation manager.\n\n        Creates a new AnnotationManager with an empty layers dictionary.\n        \"\"\"\n        self.layers: Dict[str, AnnotationLayer] = {}\n\n    def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new empty annotation layer with the specified name.\n        If a layer with that name already exists, returns self for method chaining.\n\n        Args:\n            name: Name for the new layer.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.create_layer(\"technical_analysis\")\n            ```\n        \"\"\"\n        if name not in self.layers:\n            layer = AnnotationLayer(name=name, annotations=[])\n            self.layers[name] = layer\n        return self\n\n    def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n        \"\"\"Get an annotation layer by name.\n\n        Args:\n            name: Name of the layer to retrieve.\n\n        Returns:\n            Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n        Example:\n            ```python\n            layer = manager.get_layer(\"events\")\n            if layer:\n                layer.add_annotation(annotation)\n            ```\n        \"\"\"\n        return self.layers.get(name)\n\n    def remove_layer(self, name: str) -&gt; bool:\n        \"\"\"Remove an annotation layer by name.\n\n        Removes the specified layer and all its annotations. Returns\n        True if the layer was found and removed, False otherwise.\n\n        Args:\n            name: Name of the layer to remove.\n\n        Returns:\n            bool: True if layer was removed, False if layer didn't exist.\n\n        Example:\n            ```python\n            success = manager.remove_layer(\"old_layer\")\n            if success:\n                logger.info(\"Layer removed successfully\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            del self.layers[name]\n            return True\n        return False\n\n    def clear_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotation layers.\n\n        Removes all layers and their annotations. Returns self for\n        method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_all_layers()\n            ```\n        \"\"\"\n        self.layers.clear()\n        return self\n\n    def add_annotation(\n        self,\n        annotation: Annotation,\n        layer_name: str = \"default\",\n    ) -&gt; \"AnnotationManager\":\n        \"\"\"Add annotation to a specific layer.\n\n        Adds an annotation to the specified layer. If the layer doesn't exist,\n        it will be created automatically. Returns self for method chaining.\n\n        Args:\n            annotation: Annotation object to add.\n            layer_name: Name of the layer to add the annotation to.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.add_annotation(text_annotation, \"events\")\n            ```\n        \"\"\"\n        if layer_name not in self.layers:\n            self.create_layer(layer_name)\n\n        self.layers[layer_name].add_annotation(annotation)\n        return self\n\n    def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Hide a specific annotation layer.\n\n        Makes the specified layer and all its annotations invisible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to hide.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].hide()\n        return self\n\n    def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Show a specific annotation layer.\n\n        Makes the specified layer and all its annotations visible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to show.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].show()\n        return self\n\n    def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotations from a specific layer.\n\n        Removes all annotations from the specified layer while keeping\n        the layer itself. Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to clear.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].clear_annotations()\n        return self\n\n    def get_all_annotations(self) -&gt; List[Annotation]:\n        \"\"\"Get all annotations from all layers.\n\n        Returns a flat list of all annotations from all layers,\n        regardless of layer visibility.\n\n        Returns:\n            List[Annotation]: List of all annotations across all layers.\n\n        Example:\n            ```python\n            all_annotations = manager.get_all_annotations()\n            ```\n        \"\"\"\n        all_annotations = []\n        for layer in self.layers.values():\n            all_annotations.extend(layer.annotations)\n        return all_annotations\n\n    def hide_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Hide all annotation layers.\n\n        Makes all layers and their annotations invisible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.hide()\n        return self\n\n    def show_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Show all annotation layers.\n\n        Makes all layers and their annotations visible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.show()\n        return self\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert manager to dictionary for serialization.\n\n        Creates a dictionary representation of all layers and their\n        annotations suitable for serialization.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of all layers with\n                a \"layers\" wrapper containing layer names as keys.\n        \"\"\"\n        return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.create_layer","title":"create_layer","text":"<pre><code>create_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new empty annotation layer with the specified name. If a layer with that name already exists, returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.create_layer(\"technical_analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new empty annotation layer with the specified name.\n    If a layer with that name already exists, returns self for method chaining.\n\n    Args:\n        name: Name for the new layer.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.create_layer(\"technical_analysis\")\n        ```\n    \"\"\"\n    if name not in self.layers:\n        layer = AnnotationLayer(name=name, annotations=[])\n        self.layers[name] = layer\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str) -&gt; Optional[AnnotationLayer]\n</code></pre> <p>Get an annotation layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[AnnotationLayer]</code> <p>Optional[AnnotationLayer]: The layer if found, None otherwise.</p> Example <pre><code>layer = manager.get_layer(\"events\")\nif layer:\n    layer.add_annotation(annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n    \"\"\"Get an annotation layer by name.\n\n    Args:\n        name: Name of the layer to retrieve.\n\n    Returns:\n        Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n    Example:\n        ```python\n        layer = manager.get_layer(\"events\")\n        if layer:\n            layer.add_annotation(annotation)\n        ```\n    \"\"\"\n    return self.layers.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.remove_layer","title":"remove_layer","text":"<pre><code>remove_layer(name: str) -&gt; bool\n</code></pre> <p>Remove an annotation layer by name.</p> <p>Removes the specified layer and all its annotations. Returns True if the layer was found and removed, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if layer was removed, False if layer didn't exist.</p> Example <pre><code>success = manager.remove_layer(\"old_layer\")\nif success:\n    logger.info(\"Layer removed successfully\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_layer(self, name: str) -&gt; bool:\n    \"\"\"Remove an annotation layer by name.\n\n    Removes the specified layer and all its annotations. Returns\n    True if the layer was found and removed, False otherwise.\n\n    Args:\n        name: Name of the layer to remove.\n\n    Returns:\n        bool: True if layer was removed, False if layer didn't exist.\n\n    Example:\n        ```python\n        success = manager.remove_layer(\"old_layer\")\n        if success:\n            logger.info(\"Layer removed successfully\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        del self.layers[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.clear_all_layers","title":"clear_all_layers","text":"<pre><code>clear_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Clear all annotation layers.</p> <p>Removes all layers and their annotations. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotation layers.\n\n    Removes all layers and their annotations. Returns self for\n    method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_all_layers()\n        ```\n    \"\"\"\n    self.layers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; AnnotationManager\n</code></pre> <p>Add annotation to a specific layer.</p> <p>Adds an annotation to the specified layer. If the layer doesn't exist, it will be created automatically. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer to add the annotation to.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.add_annotation(text_annotation, \"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(\n    self,\n    annotation: Annotation,\n    layer_name: str = \"default\",\n) -&gt; \"AnnotationManager\":\n    \"\"\"Add annotation to a specific layer.\n\n    Adds an annotation to the specified layer. If the layer doesn't exist,\n    it will be created automatically. Returns self for method chaining.\n\n    Args:\n        annotation: Annotation object to add.\n        layer_name: Name of the layer to add the annotation to.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.add_annotation(text_annotation, \"events\")\n        ```\n    \"\"\"\n    if layer_name not in self.layers:\n        self.create_layer(layer_name)\n\n    self.layers[layer_name].add_annotation(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.hide_layer","title":"hide_layer","text":"<pre><code>hide_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Hide a specific annotation layer.</p> <p>Makes the specified layer and all its annotations invisible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to hide.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Hide a specific annotation layer.\n\n    Makes the specified layer and all its annotations invisible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to hide.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.show_layer","title":"show_layer","text":"<pre><code>show_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Show a specific annotation layer.</p> <p>Makes the specified layer and all its annotations visible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to show.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Show a specific annotation layer.\n\n    Makes the specified layer and all its annotations visible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to show.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.clear_layer","title":"clear_layer","text":"<pre><code>clear_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Clear all annotations from a specific layer.</p> <p>Removes all annotations from the specified layer while keeping the layer itself. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to clear.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotations from a specific layer.\n\n    Removes all annotations from the specified layer while keeping\n    the layer itself. Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to clear.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].clear_annotations()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.get_all_annotations","title":"get_all_annotations","text":"<pre><code>get_all_annotations() -&gt; List[Annotation]\n</code></pre> <p>Get all annotations from all layers.</p> <p>Returns a flat list of all annotations from all layers, regardless of layer visibility.</p> <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of all annotations across all layers.</p> Example <pre><code>all_annotations = manager.get_all_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_all_annotations(self) -&gt; List[Annotation]:\n    \"\"\"Get all annotations from all layers.\n\n    Returns a flat list of all annotations from all layers,\n    regardless of layer visibility.\n\n    Returns:\n        List[Annotation]: List of all annotations across all layers.\n\n    Example:\n        ```python\n        all_annotations = manager.get_all_annotations()\n        ```\n    \"\"\"\n    all_annotations = []\n    for layer in self.layers.values():\n        all_annotations.extend(layer.annotations)\n    return all_annotations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.hide_all_layers","title":"hide_all_layers","text":"<pre><code>hide_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Hide all annotation layers.</p> <p>Makes all layers and their annotations invisible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Hide all annotation layers.\n\n    Makes all layers and their annotations invisible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.show_all_layers","title":"show_all_layers","text":"<pre><code>show_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Show all annotation layers.</p> <p>Makes all layers and their annotations visible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Show all annotation layers.\n\n    Makes all layers and their annotations visible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.AnnotationManager.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert manager to dictionary for serialization.</p> <p>Creates a dictionary representation of all layers and their annotations suitable for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of all layers with a \"layers\" wrapper containing layer names as keys.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert manager to dictionary for serialization.\n\n    Creates a dictionary representation of all layers and their\n    annotations suitable for serialization.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of all layers with\n            a \"layers\" wrapper containing layer names as keys.\n    \"\"\"\n    return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData","title":"TradeData  <code>dataclass</code>","text":"<p>Represents a single trade with entry and exit information.</p> <p>This class provides a comprehensive representation of a trading transaction, including entry and exit details, profit/loss calculations, and visualization capabilities. It supports both long and short trades with automatic P&amp;L calculations and marker generation for chart display.</p> <p>The class automatically validates trade data, normalizes time values, and provides computed properties for profit/loss analysis. It can convert trades to marker representations for visual display on charts.</p> <p>Attributes:</p> Name Type Description <code>entry_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Entry time in various formats (automatically normalized to UTC timestamp).</p> <code>entry_price</code> <code>Union[float, int]</code> <p>Entry price for the trade.</p> <code>exit_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Exit time in various formats (automatically normalized to UTC timestamp).</p> <code>exit_price</code> <code>Union[float, int]</code> <p>Exit price for the trade.</p> <code>is_profitable</code> <code>bool</code> <p>Whether the trade was profitable (True) or not (False).</p> <code>id</code> <code>str</code> <p>Unique identifier for the trade (required).</p> <code>additional_data</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing any additional trade data such as quantity, trade_type, notes, etc. This provides maximum flexibility for custom fields.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a profitable long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\nprint(f\"Profitable: {trade.is_profitable}\")  # True\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> Note <ul> <li>Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised</li> <li>Price values are automatically converted to appropriate numeric types</li> <li>Time values are normalized to UTC timestamps for consistent handling</li> <li>All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data</li> <li>The id field is required for trade identification</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>@dataclass\nclass TradeData(SerializableMixin):\n    \"\"\"Represents a single trade with entry and exit information.\n\n    This class provides a comprehensive representation of a trading transaction,\n    including entry and exit details, profit/loss calculations, and visualization\n    capabilities. It supports both long and short trades with automatic P&amp;L\n    calculations and marker generation for chart display.\n\n    The class automatically validates trade data, normalizes time values, and\n    provides computed properties for profit/loss analysis. It can convert trades\n    to marker representations for visual display on charts.\n\n    Attributes:\n        entry_time (Union[pd.Timestamp, datetime, str, int, float]): Entry time\n            in various formats (automatically normalized to UTC timestamp).\n        entry_price (Union[float, int]): Entry price for the trade.\n        exit_time (Union[pd.Timestamp, datetime, str, int, float]): Exit time\n            in various formats (automatically normalized to UTC timestamp).\n        exit_price (Union[float, int]): Exit price for the trade.\n        is_profitable (bool): Whether the trade was profitable (True) or not (False).\n        id (str): Unique identifier for the trade (required).\n        additional_data (Optional[Dict[str, Any]]): Optional dictionary containing\n            any additional trade data such as quantity, trade_type, notes, etc.\n            This provides maximum flexibility for custom fields.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n        # Create a profitable long trade\n        trade = TradeData(\n            entry_time=\"2024-01-01T09:00:00\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01T16:00:00\",\n            exit_price=105.0,\n            is_profitable=True,\n            id=\"trade_001\",\n            additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n        )\n\n        # Access calculated properties\n        print(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\n        print(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\n        print(f\"Profitable: {trade.is_profitable}\")  # True\n\n        # Serialize for frontend\n        trade_dict = trade.asdict()\n        ```\n\n    Note:\n        - Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised\n        - Price values are automatically converted to appropriate numeric types\n        - Time values are normalized to UTC timestamps for consistent handling\n        - All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data\n        - The id field is required for trade identification\n    \"\"\"\n\n    # Core fields required for trade visualization\n    entry_time: Union[pd.Timestamp, datetime, str, int, float]\n    entry_price: Union[float, int]\n    exit_time: Union[pd.Timestamp, datetime, str, int, float]\n    exit_price: Union[float, int]\n    is_profitable: bool\n    id: str  # Required for trade identification\n\n    # All other data moved to additional_data for maximum flexibility\n    additional_data: Optional[Dict[str, Any]] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize and validate trade data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Converts price values to appropriate numeric types\n        2. Validates that exit time is after entry time\n        3. Ensures is_profitable is a boolean\n\n        Raises:\n            ExitTimeAfterEntryTimeError: If exit time is not after entry time.\n            ValueValidationError: If time validation fails.\n        \"\"\"\n        # Step 1: Convert price values to float for consistent calculations\n        # This ensures prices are always numeric, regardless of input type\n        self.entry_price = float(self.entry_price)\n        self.exit_price = float(self.exit_price)\n\n        # Step 2: Ensure is_profitable is a boolean for consistent logic\n        # Converts any truthy/falsy value to explicit True/False\n        self.is_profitable = bool(self.is_profitable)\n\n        # Step 3: Validate that exit time is after entry time\n        # Convert times temporarily for validation only\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # This is critical for trade logic - a trade cannot exit before it enters\n        if isinstance(entry_timestamp, (int, float)) and isinstance(\n            exit_timestamp,\n            (int, float),\n        ):\n            # Case 1: Both timestamps are numeric - compare directly\n            if exit_timestamp &lt;= entry_timestamp:\n                raise ExitTimeAfterEntryTimeError()\n        elif (\n            isinstance(entry_timestamp, str)\n            and isinstance(exit_timestamp, str)\n            and exit_timestamp &lt;= entry_timestamp\n        ):\n            # Case 2: Both timestamps are strings - compare lexicographically\n            raise ValueValidationError(\"Exit time\", \"must be after entry time\")\n\n    def generate_tooltip_text(self) -&gt; str:\n        \"\"\"Generate tooltip text for the trade.\n\n        Creates a comprehensive tooltip text that displays key trade information\n        including entry/exit prices, quantity, profit/loss, and optional notes.\n        The tooltip is designed to be informative and easy to read when displayed\n        on charts.\n\n        Returns:\n            str: Formatted tooltip text with trade details and P&amp;L information.\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                quantity=100,\n                trade_type=TradeType.LONG,\n            )\n            tooltip = trade.generate_tooltip_text()\n            # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n            ```\n        \"\"\"\n        # Step 1: Calculate profit/loss metrics for tooltip display\n        # Uses the pnl and pnl_percentage properties which check additional_data first\n        pnl = self.pnl\n        pnl_pct = self.pnl_percentage\n\n        # Step 2: Determine win/loss label based on P&amp;L value\n        # Positive P&amp;L = Win, negative or zero = Loss\n        win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n        # Step 3: Build tooltip components with formatted trade information\n        # Start with core entry/exit prices (always shown)\n        tooltip_parts = [\n            f\"Entry: {self.entry_price:.2f}\",\n            f\"Exit: {self.exit_price:.2f}\",\n        ]\n\n        # Step 4: Add quantity if available in additional_data\n        # Quantity is optional and only shown if user provided it\n        if self.additional_data and \"quantity\" in self.additional_data:\n            tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n        # Step 5: Add P&amp;L information (always shown)\n        # Shows both absolute P&amp;L and percentage for complete picture\n        tooltip_parts.extend(\n            [\n                f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n                f\"{win_loss}\",\n            ],\n        )\n\n        # Step 6: Add custom notes if provided for additional context\n        # Notes are optional and only shown if user provided them\n        if self.additional_data and \"notes\" in self.additional_data:\n            tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n        # Step 7: Join all parts with newlines for multi-line tooltip display\n        return \"\\n\".join(tooltip_parts)\n\n    @property\n    def pnl(self) -&gt; float:\n        \"\"\"Get profit/loss amount from additional_data or calculate basic price difference.\n\n        First checks if P&amp;L is provided in additional_data, otherwise calculates\n        basic price difference. This allows users to provide their own P&amp;L calculation\n        logic while maintaining a fallback for basic visualization.\n\n        Returns:\n            float: Profit/loss amount. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl\n            trade = TradeData(..., additional_data={\"pnl\": 500.0})\n            trade.pnl  # Returns: 500.0\n\n            # Without additional_data, calculates basic difference\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl  # Returns: 5.0 (basic price difference)\n            ```\n        \"\"\"\n        # Check if P&amp;L is provided in additional_data dictionary\n        # User may provide custom P&amp;L calculation (e.g., accounting for fees, quantity)\n        if self.additional_data and \"pnl\" in self.additional_data:\n            return float(self.additional_data[\"pnl\"])\n\n        # Fallback: Calculate basic price difference for visualization\n        # Simple formula: exit_price - entry_price (doesn't account for quantity or fees)\n        return float(self.exit_price - self.entry_price)\n\n    @property\n    def pnl_percentage(self) -&gt; float:\n        \"\"\"Get profit/loss percentage from additional_data or calculate basic percentage.\n\n        First checks if P&amp;L percentage is provided in additional_data, otherwise\n        calculates basic percentage based on price difference relative to entry price.\n\n        Returns:\n            float: Profit/loss percentage. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl_percentage\n            trade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\n            trade.pnl_percentage  # Returns: 5.0\n\n            # Without additional_data, calculates basic percentage\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl_percentage  # Returns: 5.0 (5% gain)\n            ```\n        \"\"\"\n        # Check if P&amp;L percentage is provided in additional_data dictionary\n        # User may provide custom percentage calculation\n        if self.additional_data and \"pnl_percentage\" in self.additional_data:\n            return float(self.additional_data[\"pnl_percentage\"])\n\n        # Fallback: Calculate basic percentage from price difference\n        # Formula: ((exit - entry) / entry) * 100\n        if self.entry_price != 0:\n            return ((self.exit_price - self.entry_price) / self.entry_price) * 100\n\n        # Edge case: Return 0.0 if entry price is zero to avoid division by zero\n        return 0.0\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n        Converts the trade to a dictionary format suitable for frontend\n        communication. Converts times to UTC timestamps at serialization time\n        to handle any changes made to entry_time or exit_time after construction.\n\n        Returns:\n            Dict[str, Any]: Serialized trade with camelCase keys ready for\n                frontend consumption. Contains:\n                - entryTime: Entry timestamp (converted from entry_time)\n                - entryPrice: Entry price\n                - exitTime: Exit timestamp (converted from exit_time)\n                - exitPrice: Exit price\n                - isProfitable: Profitability status\n                - pnl: Profit/loss amount (from additional_data or calculated)\n                - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n                - All fields from additional_data (merged for template access)\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                is_profitable=True,\n                additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n            )\n\n            result = trade.asdict()\n            # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n            #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n            #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n            ```\n        \"\"\"\n        # Step 1: Convert times to UTC timestamps at serialization time\n        # This ensures we always use current entry_time/exit_time values\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # Step 2: Create base trade dictionary with core fields\n        # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n        trade_dict = {\n            \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n            \"entryPrice\": self.entry_price,  # Entry price as float\n            \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n            \"exitPrice\": self.exit_price,  # Exit price as float\n            \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n            \"id\": self.id,  # Unique trade identifier (required)\n            \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n            \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n        }\n\n        # Step 3: Merge additional data into the trade dict for template access\n        # This allows frontend templates to access custom fields like quantity, notes, etc.\n        if self.additional_data:\n            trade_dict.update(self.additional_data)\n\n        return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData.pnl","title":"pnl  <code>property</code>","text":"<pre><code>pnl: float\n</code></pre> <p>Get profit/loss amount from additional_data or calculate basic price difference.</p> <p>First checks if P&amp;L is provided in additional_data, otherwise calculates basic price difference. This allows users to provide their own P&amp;L calculation logic while maintaining a fallback for basic visualization.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss amount. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl\ntrade = TradeData(..., additional_data={\"pnl\": 500.0})\ntrade.pnl  # Returns: 500.0\n\n# Without additional_data, calculates basic difference\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl  # Returns: 5.0 (basic price difference)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData.pnl_percentage","title":"pnl_percentage  <code>property</code>","text":"<pre><code>pnl_percentage: float\n</code></pre> <p>Get profit/loss percentage from additional_data or calculate basic percentage.</p> <p>First checks if P&amp;L percentage is provided in additional_data, otherwise calculates basic percentage based on price difference relative to entry price.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss percentage. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl_percentage\ntrade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\ntrade.pnl_percentage  # Returns: 5.0\n\n# Without additional_data, calculates basic percentage\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl_percentage  # Returns: 5.0 (5% gain)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData.generate_tooltip_text","title":"generate_tooltip_text","text":"<pre><code>generate_tooltip_text() -&gt; str\n</code></pre> <p>Generate tooltip text for the trade.</p> <pre><code>    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\n</code></pre> <p>Exit: 105.00 Qty: 100.00 P&amp;L: 500.00 (5.0%) Win\"             ```</p> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def generate_tooltip_text(self) -&gt; str:\n    \"\"\"Generate tooltip text for the trade.\n\n    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n        ```\n    \"\"\"\n    # Step 1: Calculate profit/loss metrics for tooltip display\n    # Uses the pnl and pnl_percentage properties which check additional_data first\n    pnl = self.pnl\n    pnl_pct = self.pnl_percentage\n\n    # Step 2: Determine win/loss label based on P&amp;L value\n    # Positive P&amp;L = Win, negative or zero = Loss\n    win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n    # Step 3: Build tooltip components with formatted trade information\n    # Start with core entry/exit prices (always shown)\n    tooltip_parts = [\n        f\"Entry: {self.entry_price:.2f}\",\n        f\"Exit: {self.exit_price:.2f}\",\n    ]\n\n    # Step 4: Add quantity if available in additional_data\n    # Quantity is optional and only shown if user provided it\n    if self.additional_data and \"quantity\" in self.additional_data:\n        tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n    # Step 5: Add P&amp;L information (always shown)\n    # Shows both absolute P&amp;L and percentage for complete picture\n    tooltip_parts.extend(\n        [\n            f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n            f\"{win_loss}\",\n        ],\n    )\n\n    # Step 6: Add custom notes if provided for additional context\n    # Notes are optional and only shown if user provided them\n    if self.additional_data and \"notes\" in self.additional_data:\n        tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n    # Step 7: Join all parts with newlines for multi-line tooltip display\n    return \"\\n\".join(tooltip_parts)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeData.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the trade data to a dict with camelCase keys for frontend.</p> <p>Converts the trade to a dictionary format suitable for frontend communication. Converts times to UTC timestamps at serialization time to handle any changes made to entry_time or exit_time after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized trade with camelCase keys ready for frontend consumption. Contains: - entryTime: Entry timestamp (converted from entry_time) - entryPrice: Entry price - exitTime: Exit timestamp (converted from exit_time) - exitPrice: Exit price - isProfitable: Profitability status - pnl: Profit/loss amount (from additional_data or calculated) - pnlPercentage: Profit/loss percentage (from additional_data or calculated) - All fields from additional_data (merged for template access)</p> Example <pre><code>trade = TradeData(\n    entry_time=\"2024-01-01\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01\",\n    exit_price=105.0,\n    is_profitable=True,\n    additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n)\n\nresult = trade.asdict()\n# Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n#          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n#          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n    Converts the trade to a dictionary format suitable for frontend\n    communication. Converts times to UTC timestamps at serialization time\n    to handle any changes made to entry_time or exit_time after construction.\n\n    Returns:\n        Dict[str, Any]: Serialized trade with camelCase keys ready for\n            frontend consumption. Contains:\n            - entryTime: Entry timestamp (converted from entry_time)\n            - entryPrice: Entry price\n            - exitTime: Exit timestamp (converted from exit_time)\n            - exitPrice: Exit price\n            - isProfitable: Profitability status\n            - pnl: Profit/loss amount (from additional_data or calculated)\n            - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n            - All fields from additional_data (merged for template access)\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            is_profitable=True,\n            additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n        )\n\n        result = trade.asdict()\n        # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n        #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n        #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n        ```\n    \"\"\"\n    # Step 1: Convert times to UTC timestamps at serialization time\n    # This ensures we always use current entry_time/exit_time values\n    entry_timestamp = to_utc_timestamp(self.entry_time)\n    exit_timestamp = to_utc_timestamp(self.exit_time)\n\n    # Step 2: Create base trade dictionary with core fields\n    # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n    trade_dict = {\n        \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n        \"entryPrice\": self.entry_price,  # Entry price as float\n        \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n        \"exitPrice\": self.exit_price,  # Exit price as float\n        \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n        \"id\": self.id,  # Unique trade identifier (required)\n        \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n        \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n    }\n\n    # Step 3: Merge additional data into the trade dict for template access\n    # This allows frontend templates to access custom fields like quantity, notes, etc.\n    if self.additional_data:\n        trade_dict.update(self.additional_data)\n\n    return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ChartType","title":"ChartType","text":"<p>Chart type enumeration.</p> <p>Defines the available chart types that can be created and rendered. Each chart type corresponds to a specific visualization style and data format requirements.</p> <p>Attributes:</p> Name Type Description <code>AREA</code> <p>Area chart - filled area below a line.</p> <code>BAND</code> <p>Band chart - multiple lines with fill areas (e.g., Bollinger Bands).</p> <code>BASELINE</code> <p>Baseline chart - values relative to a baseline.</p> <code>HISTOGRAM</code> <p>Histogram chart - bar chart for volume or distribution.</p> <code>LINE</code> <p>Line chart - simple line connecting data points.</p> <code>BAR</code> <p>Bar chart - OHLC bars for price data.</p> <code>CANDLESTICK</code> <p>Candlestick chart - traditional Japanese candlesticks.</p> <code>RIBBON</code> <p>Ribbon chart - upper and lower bands with fill areas.</p> <code>GRADIENT_RIBBON</code> <p>Gradient ribbon chart - ribbon with gradient fills.</p> <code>TREND_FILL</code> <p>Trend fill chart - fills between trend lines and candle body midpoints.</p> <code>SIGNAL</code> <p>Signal chart - background coloring based on signal values.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ChartType(str, Enum):\n    \"\"\"Chart type enumeration.\n\n    Defines the available chart types that can be created and rendered.\n    Each chart type corresponds to a specific visualization style and\n    data format requirements.\n\n    Attributes:\n        AREA: Area chart - filled area below a line.\n        BAND: Band chart - multiple lines with fill areas (e.g., Bollinger Bands).\n        BASELINE: Baseline chart - values relative to a baseline.\n        HISTOGRAM: Histogram chart - bar chart for volume or distribution.\n        LINE: Line chart - simple line connecting data points.\n        BAR: Bar chart - OHLC bars for price data.\n        CANDLESTICK: Candlestick chart - traditional Japanese candlesticks.\n        RIBBON: Ribbon chart - upper and lower bands with fill areas.\n        GRADIENT_RIBBON: Gradient ribbon chart - ribbon with gradient fills.\n        TREND_FILL: Trend fill chart - fills between trend lines and candle body midpoints.\n        SIGNAL: Signal chart - background coloring based on signal values.\n    \"\"\"\n\n    AREA = \"area\"\n    BAND = \"band\"\n    BASELINE = \"baseline\"\n    HISTOGRAM = \"histogram\"\n    LINE = \"line\"\n    BAR = \"bar\"\n    CANDLESTICK = \"candlestick\"\n    RIBBON = \"ribbon\"\n    GRADIENT_RIBBON = \"gradient_ribbon\"\n    TREND_FILL = \"trend_fill\"\n    SIGNAL = \"signal\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.LineStyle","title":"LineStyle","text":"<p>Line style enumeration.</p> <p>Defines the visual style of lines in charts, including borders, grid lines, and series lines.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid line - continuous line without breaks.</p> <code>DOTTED</code> <p>Dotted line - series of dots.</p> <code>DASHED</code> <p>Dashed line - series of short dashes.</p> <code>LARGE_DASHED</code> <p>Large dashed line - series of long dashes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineStyle(IntEnum):\n    \"\"\"Line style enumeration.\n\n    Defines the visual style of lines in charts, including borders,\n    grid lines, and series lines.\n\n    Attributes:\n        SOLID: Solid line - continuous line without breaks.\n        DOTTED: Dotted line - series of dots.\n        DASHED: Dashed line - series of short dashes.\n        LARGE_DASHED: Large dashed line - series of long dashes.\n    \"\"\"\n\n    SOLID = 0\n    DOTTED = 1\n    DASHED = 2\n    LARGE_DASHED = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.MarkerPosition","title":"MarkerPosition","text":"<p>Marker position enumeration for chart markers.</p> <p>Defines where markers should be positioned relative to the data bars or points on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE_BAR</code> <p>Position marker above the data bar/point.</p> <code>BELOW_BAR</code> <p>Position marker below the data bar/point.</p> <code>IN_BAR</code> <p>Position marker inside the data bar/point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerPosition(str, Enum):\n    \"\"\"Marker position enumeration for chart markers.\n\n    Defines where markers should be positioned relative to the data bars\n    or points on the chart.\n\n    Attributes:\n        ABOVE_BAR: Position marker above the data bar/point.\n        BELOW_BAR: Position marker below the data bar/point.\n        IN_BAR: Position marker inside the data bar/point.\n    \"\"\"\n\n    ABOVE_BAR = \"aboveBar\"\n    BELOW_BAR = \"belowBar\"\n    IN_BAR = \"inBar\"\n    AT_PRICE_TOP = \"atPriceTop\"\n    AT_PRICE_BOTTOM = \"atPriceBottom\"\n    AT_PRICE_MIDDLE = \"atPriceMiddle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.ColumnNames","title":"ColumnNames","text":"<p>Column name enumeration for DataFrame integration.</p> <p>Defines the standard column names used when converting pandas DataFrames to chart data. These names ensure consistent mapping between DataFrame columns and chart data fields.</p> <p>Attributes:</p> Name Type Description <code>TIME</code> <p>Time or datetime column.</p> <code>OPEN</code> <p>Open price column (for OHLC data).</p> <code>HIGH</code> <p>High price column (for OHLC data).</p> <code>LOW</code> <p>Low price column (for OHLC data).</p> <code>CLOSE</code> <p>Close price column (for OHLC data).</p> <code>VOLUME</code> <p>Volume column (for OHLCV data).</p> <code>DATETIME</code> <p>Datetime column (alternative to TIME).</p> <code>VALUE</code> <p>Value column (for single-value data like line charts).</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColumnNames(str, Enum):\n    \"\"\"Column name enumeration for DataFrame integration.\n\n    Defines the standard column names used when converting pandas DataFrames\n    to chart data. These names ensure consistent mapping between DataFrame\n    columns and chart data fields.\n\n    Attributes:\n        TIME: Time or datetime column.\n        OPEN: Open price column (for OHLC data).\n        HIGH: High price column (for OHLC data).\n        LOW: Low price column (for OHLC data).\n        CLOSE: Close price column (for OHLC data).\n        VOLUME: Volume column (for OHLCV data).\n        DATETIME: Datetime column (alternative to TIME).\n        VALUE: Value column (for single-value data like line charts).\n    \"\"\"\n\n    TIME = \"time\"\n    OPEN = \"open\"\n    HIGH = \"high\"\n    LOW = \"low\"\n    CLOSE = \"close\"\n    VOLUME = \"volume\"\n    DATETIME = \"datetime\"\n    VALUE = \"value\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.MarkerShape","title":"MarkerShape","text":"<p>Marker shape enumeration for chart markers.</p> <p>Defines the available shapes for chart markers that can be displayed on charts to highlight specific data points or events.</p> <p>Attributes:</p> Name Type Description <code>CIRCLE</code> <p>Circular marker shape.</p> <code>SQUARE</code> <p>Square marker shape.</p> <code>ARROW_UP</code> <p>Upward-pointing arrow marker.</p> <code>ARROW_DOWN</code> <p>Downward-pointing arrow marker.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerShape(str, Enum):\n    \"\"\"Marker shape enumeration for chart markers.\n\n    Defines the available shapes for chart markers that can be displayed\n    on charts to highlight specific data points or events.\n\n    Attributes:\n        CIRCLE: Circular marker shape.\n        SQUARE: Square marker shape.\n        ARROW_UP: Upward-pointing arrow marker.\n        ARROW_DOWN: Downward-pointing arrow marker.\n    \"\"\"\n\n    CIRCLE = \"circle\"\n    SQUARE = \"square\"\n    ARROW_UP = \"arrowUp\"\n    ARROW_DOWN = \"arrowDown\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeType","title":"TradeType","text":"<p>Trade type enumeration.</p> <p>Defines the direction of a trade (long or short). Used for trade visualization and profit/loss calculations.</p> <p>Attributes:</p> Name Type Description <code>LONG</code> <p>Long trade - profit when price goes up.</p> <code>SHORT</code> <p>Short trade - profit when price goes down.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeType(str, Enum):\n    \"\"\"Trade type enumeration.\n\n    Defines the direction of a trade (long or short).\n    Used for trade visualization and profit/loss calculations.\n\n    Attributes:\n        LONG: Long trade - profit when price goes up.\n        SHORT: Short trade - profit when price goes down.\n    \"\"\"\n\n    LONG = \"long\"\n    SHORT = \"short\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.TradeVisualization","title":"TradeVisualization","text":"<p>Trade visualization style enumeration.</p> <p>Defines how trades should be visualized on the chart. Multiple visualization styles can be combined to create comprehensive trade displays.</p> <p>Attributes:</p> Name Type Description <code>MARKERS</code> <p>Display entry/exit markers only.</p> <code>RECTANGLES</code> <p>Display rectangle spanning from entry to exit.</p> <code>BOTH</code> <p>Display both markers and rectangles.</p> <code>LINES</code> <p>Display connecting lines between entry and exit.</p> <code>ARROWS</code> <p>Display directional arrows from entry to exit.</p> <code>ZONES</code> <p>Display colored zones with transparency around trades.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeVisualization(str, Enum):\n    \"\"\"Trade visualization style enumeration.\n\n    Defines how trades should be visualized on the chart.\n    Multiple visualization styles can be combined to create\n    comprehensive trade displays.\n\n    Attributes:\n        MARKERS: Display entry/exit markers only.\n        RECTANGLES: Display rectangle spanning from entry to exit.\n        BOTH: Display both markers and rectangles.\n        LINES: Display connecting lines between entry and exit.\n        ARROWS: Display directional arrows from entry to exit.\n        ZONES: Display colored zones with transparency around trades.\n    \"\"\"\n\n    MARKERS = \"markers\"  # Just entry/exit markers\n    RECTANGLES = \"rectangles\"  # Rectangle from entry to exit\n    BOTH = \"both\"  # Both markers and rectangles\n    LINES = \"lines\"  # Lines connecting entry to exit\n    ARROWS = \"arrows\"  # Arrows from entry to exit\n    ZONES = \"zones\"  # Colored zones with transparency\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.create_arrow_annotation","title":"create_arrow_annotation","text":"<pre><code>create_arrow_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create an arrow annotation.</p> <p>Convenience function for creating arrow annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the arrow.</p> required <code>**kwargs</code> <p>Additional styling options (color, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured arrow annotation.</p> Example <pre><code># Basic arrow annotation\nann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n# With custom styling\nann = create_arrow_annotation(\n    \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_arrow_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create an arrow annotation.\n\n    Convenience function for creating arrow annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the arrow.\n        **kwargs: Additional styling options (color, position, etc.).\n\n    Returns:\n        Annotation: Configured arrow annotation.\n\n    Example:\n        ```python\n        # Basic arrow annotation\n        ann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n        # With custom styling\n        ann = create_arrow_annotation(\n            \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.ARROW,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.create_shape_annotation","title":"create_shape_annotation","text":"<pre><code>create_shape_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a shape annotation.</p> <p>Convenience function for creating shape annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the shape.</p> required <code>**kwargs</code> <p>Additional styling options (color, border_color, border_width, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured shape annotation.</p> Example <pre><code># Basic shape annotation\nann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n# With custom styling\nann = create_shape_annotation(\n    \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_shape_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a shape annotation.\n\n    Convenience function for creating shape annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the shape.\n        **kwargs: Additional styling options (color, border_color,\n            border_width, etc.).\n\n    Returns:\n        Annotation: Configured shape annotation.\n\n    Example:\n        ```python\n        # Basic shape annotation\n        ann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n        # With custom styling\n        ann = create_shape_annotation(\n            \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.SHAPE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.create_text_annotation","title":"create_text_annotation","text":"<pre><code>create_text_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a text annotation.</p> <p>Convenience function for creating text annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display.</p> required <code>**kwargs</code> <p>Additional styling options (color, background_color, font_size, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured text annotation.</p> Example <pre><code># Basic text annotation\nann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n# With custom styling\nann = create_text_annotation(\n    \"2024-01-01\",\n    100,\n    \"Buy Signal\",\n    color=\"green\",\n    background_color=\"rgba(0, 255, 0, 0.2)\",\n    font_size=14,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_text_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a text annotation.\n\n    Convenience function for creating text annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display.\n        **kwargs: Additional styling options (color, background_color,\n            font_size, position, etc.).\n\n    Returns:\n        Annotation: Configured text annotation.\n\n    Example:\n        ```python\n        # Basic text annotation\n        ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n        # With custom styling\n        ann = create_text_annotation(\n            \"2024-01-01\",\n            100,\n            \"Buy Signal\",\n            color=\"green\",\n            background_color=\"rgba(0, 255, 0, 0.2)\",\n            font_size=14,\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.TEXT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: Optional[str] = None, level: int = DEBUG) -&gt; Logger\n</code></pre> <p>Get a logger instance for the package.</p> <p>This function creates or retrieves a logger instance with proper naming convention. The logger name is automatically prefixed with the package name to maintain logger hierarchy and enable filtering.</p> <p>Logger names follow the pattern: \"streamlit_lightweight_charts_pro.{component_name}\"</p> This hierarchical naming allows <ul> <li>Filtering logs by component</li> <li>Different log levels per component</li> <li>Inheritance of configuration from root logger</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Component name to append to package name. If None, returns the root package logger. The full logger name will be \"streamlit_lightweight_charts_pro.{name}\". Examples: \"chart_rendering\", \"data_processing\", \"validation\"</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level for this specific logger. Defaults to logging.DEBUG for detailed logging. This level is set on the logger instance and can be overridden by parent logger settings.</p> <code>DEBUG</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: A logger instance with the specified name and level. The logger inherits configuration from the root package logger.</p> Example <p>Get root logger::</p> <pre><code>&gt;&gt;&gt; root_logger = get_logger()\n&gt;&gt;&gt; root_logger.error(\"Critical error\")\n</code></pre> <p>Get component logger::</p> <pre><code>&gt;&gt;&gt; chart_logger = get_logger(\"chart_rendering\")\n&gt;&gt;&gt; chart_logger.info(\"Chart initialized\")\n</code></pre> <p>Get logger with custom level::</p> <pre><code>&gt;&gt;&gt; data_logger = get_logger(\"data\", level=logging.WARNING)\n&gt;&gt;&gt; data_logger.warning(\"Data validation failed\")\n</code></pre> Note <p>The logger inherits handlers and formatters from the root package logger configured by setup_logging(). You don't need to configure handlers for component loggers.</p> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def get_logger(\n    name: Optional[str] = None, level: int = logging.DEBUG\n) -&gt; logging.Logger:\n    \"\"\"Get a logger instance for the package.\n\n    This function creates or retrieves a logger instance with proper\n    naming convention. The logger name is automatically prefixed with\n    the package name to maintain logger hierarchy and enable filtering.\n\n    Logger names follow the pattern:\n    \"streamlit_lightweight_charts_pro.{component_name}\"\n\n    This hierarchical naming allows:\n        - Filtering logs by component\n        - Different log levels per component\n        - Inheritance of configuration from root logger\n\n    Args:\n        name (Optional[str]): Component name to append to package name.\n            If None, returns the root package logger. The full logger\n            name will be \"streamlit_lightweight_charts_pro.{name}\".\n            Examples: \"chart_rendering\", \"data_processing\", \"validation\"\n        level (int, optional): Logging level for this specific logger.\n            Defaults to logging.DEBUG for detailed logging. This level\n            is set on the logger instance and can be overridden by\n            parent logger settings.\n\n    Returns:\n        logging.Logger: A logger instance with the specified name\n            and level. The logger inherits configuration from the\n            root package logger.\n\n    Example:\n        Get root logger::\n\n            &gt;&gt;&gt; root_logger = get_logger()\n            &gt;&gt;&gt; root_logger.error(\"Critical error\")\n\n        Get component logger::\n\n            &gt;&gt;&gt; chart_logger = get_logger(\"chart_rendering\")\n            &gt;&gt;&gt; chart_logger.info(\"Chart initialized\")\n\n        Get logger with custom level::\n\n            &gt;&gt;&gt; data_logger = get_logger(\"data\", level=logging.WARNING)\n            &gt;&gt;&gt; data_logger.warning(\"Data validation failed\")\n\n    Note:\n        The logger inherits handlers and formatters from the root\n        package logger configured by setup_logging(). You don't need\n        to configure handlers for component loggers.\n    \"\"\"\n    # Create hierarchical logger name by combining package name with\n    # component name. Example:\n    # - \"streamlit_lightweight_charts_pro.None\" becomes root logger\n    # - \"streamlit_lightweight_charts_pro.charts\" for chart component\n    # - \"streamlit_lightweight_charts_pro.data\" for data component\n    logger = logging.getLogger(f\"streamlit_lightweight_charts_pro.{name}\")\n\n    # Set the logging level for this specific logger\n    # This level filters messages before they reach the handlers\n    # Messages below this level are discarded\n    logger.setLevel(level)\n\n    # Return the configured logger instance\n    # Caller can immediately use this logger for logging\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/index.html#streamlit_lightweight_charts_pro.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level: int = WARN, log_format: Optional[str] = None, stream: Optional[StreamHandler] = None) -&gt; Logger\n</code></pre> <p>Set up logging configuration for the package.</p> <p>This function configures the root logger for the package with the specified settings. It ensures that logging is properly initialized and prevents duplicate handlers from being added on repeated calls.</p> <p>The function creates a logger hierarchy under the package name \"streamlit_lightweight_charts_pro\", allowing for fine-grained control over logging for different components.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level to set for the root logger. Defaults to logging.WARN for production use. Common values:     - logging.DEBUG: Detailed information for diagnosing     - logging.INFO: General informational messages     - logging.WARNING: Warning messages (default)     - logging.ERROR: Error messages     - logging.CRITICAL: Critical error messages</p> <code>WARN</code> <code>log_format</code> <code>Optional[str]</code> <p>Custom log format string using Python logging format codes. If None, uses a standard format that includes timestamp, logger name, level, and message. Example: \"%(asctime)s - %(levelname)s - %(message)s\"</p> <code>None</code> <code>stream</code> <code>Optional[StreamHandler]</code> <p>Custom stream handler for log output. If None, creates a StreamHandler that writes to sys.stdout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The configured root logger instance for the package with the name \"streamlit_lightweight_charts_pro\".</p> Example <p>Basic setup::</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logger = setup_logging(level=logging.INFO)\n&gt;&gt;&gt; logger.info(\"Logging configured\")\n</code></pre> <p>Custom format setup::</p> <pre><code>&gt;&gt;&gt; custom_format = \"%(levelname)s: %(message)s\"\n&gt;&gt;&gt; logger = setup_logging(\n...     level=logging.DEBUG,\n...     log_format=custom_format\n... )\n</code></pre> Note <p>This function is idempotent - calling it multiple times with the same logger won't create duplicate handlers. However, the level will be updated on subsequent calls.</p> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def setup_logging(\n    level: int = logging.WARN,\n    log_format: Optional[str] = None,\n    stream: Optional[logging.StreamHandler] = None,\n) -&gt; logging.Logger:\n    \"\"\"Set up logging configuration for the package.\n\n    This function configures the root logger for the package with the\n    specified settings. It ensures that logging is properly initialized\n    and prevents duplicate handlers from being added on repeated calls.\n\n    The function creates a logger hierarchy under the package name\n    \"streamlit_lightweight_charts_pro\", allowing for fine-grained\n    control over logging for different components.\n\n    Args:\n        level (int, optional): Logging level to set for the root logger.\n            Defaults to logging.WARN for production use. Common values:\n                - logging.DEBUG: Detailed information for diagnosing\n                - logging.INFO: General informational messages\n                - logging.WARNING: Warning messages (default)\n                - logging.ERROR: Error messages\n                - logging.CRITICAL: Critical error messages\n        log_format (Optional[str]): Custom log format string using\n            Python logging format codes. If None, uses a standard format\n            that includes timestamp, logger name, level, and message.\n            Example: \"%(asctime)s - %(levelname)s - %(message)s\"\n        stream (Optional[logging.StreamHandler]): Custom stream handler\n            for log output. If None, creates a StreamHandler that writes\n            to sys.stdout.\n\n    Returns:\n        logging.Logger: The configured root logger instance for the\n            package with the name \"streamlit_lightweight_charts_pro\".\n\n    Example:\n        Basic setup::\n\n            &gt;&gt;&gt; import logging\n            &gt;&gt;&gt; logger = setup_logging(level=logging.INFO)\n            &gt;&gt;&gt; logger.info(\"Logging configured\")\n\n        Custom format setup::\n\n            &gt;&gt;&gt; custom_format = \"%(levelname)s: %(message)s\"\n            &gt;&gt;&gt; logger = setup_logging(\n            ...     level=logging.DEBUG,\n            ...     log_format=custom_format\n            ... )\n\n    Note:\n        This function is idempotent - calling it multiple times with\n        the same logger won't create duplicate handlers. However, the\n        level will be updated on subsequent calls.\n    \"\"\"\n    # Create or retrieve the root logger for this package\n    # Using a specific package name creates a logger hierarchy\n    # This allows filtering logs by package if needed\n    logger = logging.getLogger(\"streamlit_lightweight_charts_pro\")\n\n    # Set the logging level for this logger\n    # This controls which messages are processed by this logger\n    logger.setLevel(level)\n\n    # Check if handlers already exist to avoid duplicates\n    # Multiple handler additions would result in duplicate log entries\n    if logger.handlers:\n        # Handlers already configured, return existing logger\n        # This makes the function idempotent (safe to call multiple times)\n        return logger\n\n    # Set default format if not provided by user\n    # Format includes:\n    # - %(asctime)s: Timestamp when log entry was created\n    # - %(name)s: Logger name (useful for hierarchical loggers)\n    # - %(levelname)s: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    # - %(message)s: The actual log message\n    if log_format is None:\n        log_format = (\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n\n    # Create formatter to format log messages according to format string\n    # This formatter will be applied to all messages handled by this logger\n    formatter = logging.Formatter(log_format)\n\n    # Create stream handler if not provided\n    # Stream handler sends log messages to a stream (stdout, stderr, file)\n    if stream is None:\n        # Create handler that writes to stdout (standard output)\n        # Using stdout instead of stderr for better integration with\n        # Streamlit which captures stdout\n        stream = logging.StreamHandler(sys.stdout)\n\n        # Set level on the handler itself\n        # Handler level acts as a secondary filter after logger level\n        stream.setLevel(level)\n\n        # Apply the formatter to the handler\n        # This determines how log messages will be formatted when output\n        stream.setFormatter(formatter)\n\n    # Add the configured handler to the logger\n    # The logger will now send messages to this handler for output\n    logger.addHandler(stream)\n\n    # Return the configured logger instance\n    # Caller can use this to log messages immediately\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html","title":"streamlit_lightweight_charts_pro.cli","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli","title":"cli","text":"<p>Command-line interface for streamlit-lightweight-charts-pro.</p> <p>This module provides command-line utilities for managing the streamlit-lightweight-charts-pro package, including frontend building, dependency management, and development tools.</p> The CLI supports <ul> <li>Frontend build management and validation</li> <li>Dependency installation and updates</li> <li>Development environment setup</li> <li>Package validation and testing</li> </ul> Key Features <ul> <li>Automatic frontend build detection and building</li> <li>NPM dependency management with validation</li> <li>Development vs production mode handling</li> <li>Error handling with clear user messages</li> <li>Cross-platform compatibility</li> </ul> Example <p>Build frontend assets::</p> <pre><code>$ python -m streamlit_lightweight_charts_pro build-frontend\n</code></pre> <p>Check frontend build status::</p> <pre><code>$ python -m streamlit_lightweight_charts_pro check\n</code></pre> <p>Show version information::</p> <pre><code>$ python -m streamlit_lightweight_charts_pro version\n</code></pre> Note <p>This module requires Node.js and NPM to be installed for frontend build operations.</p>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.check_frontend_build","title":"check_frontend_build","text":"<pre><code>check_frontend_build()\n</code></pre> <p>Check if frontend is built and trigger build if necessary.</p> <p>This function validates that the frontend build directory exists and contains the required static assets. If the frontend is not built or missing static assets, it automatically triggers the build process.</p> The function checks for <ul> <li>Existence of the 'build' directory</li> <li>Existence of the 'static' subdirectory within build</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if frontend is built successfully or already exists, False if build fails.</p> Example <p>if check_frontend_build(): ...     print(\"Frontend is ready\") ... else: ...     print(\"Frontend build failed\")</p> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def check_frontend_build():\n    \"\"\"Check if frontend is built and trigger build if necessary.\n\n    This function validates that the frontend build directory exists and\n    contains the required static assets. If the frontend is not built or\n    missing static assets, it automatically triggers the build process.\n\n    The function checks for:\n        - Existence of the 'build' directory\n        - Existence of the 'static' subdirectory within build\n\n    Returns:\n        bool: True if frontend is built successfully or already exists,\n            False if build fails.\n\n    Example:\n        &gt;&gt;&gt; if check_frontend_build():\n        ...     print(\"Frontend is ready\")\n        ... else:\n        ...     print(\"Frontend build failed\")\n    \"\"\"\n    # Get the absolute path to the frontend directory\n    # __file__ gives us the path to this cli.py module\n    # .parent gets the package directory\n    frontend_dir = Path(__file__).parent / \"frontend\"\n\n    # Build directory is where compiled frontend assets are stored\n    build_dir = frontend_dir / \"build\"\n\n    # Check if build directory exists AND contains static assets\n    # Both conditions must be true for frontend to be considered built\n    if not build_dir.exists() or not (build_dir / \"static\").exists():\n        # Inform user that frontend needs to be built\n        print(\"\u274c Frontend not built. Building now...\")\n        # Trigger the build process and return its result\n        return build_frontend()\n\n    # Frontend is already built, no action needed\n    return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.build_frontend","title":"build_frontend","text":"<pre><code>build_frontend()\n</code></pre> <p>Build the frontend assets using NPM.</p> <p>This function handles the complete frontend build process including dependency installation, production build execution, and error handling.</p> The build process <ol> <li>Locates NPM executable in system PATH</li> <li>Changes to frontend directory</li> <li>Installs NPM dependencies via 'npm install'</li> <li>Runs production build via 'npm run build'</li> <li>Restores original working directory</li> </ol> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if build succeeds, False otherwise.</p> <p>Raises:</p> Type Description <code>NpmNotFoundError</code> <p>If NPM is not installed or not found in PATH.</p> <code>ValueError</code> <p>If NPM path validation fails.</p> Note <p>The function uses shell=False for security to prevent command injection attacks. It also validates the NPM path before execution.</p> Example <p>success = build_frontend() if success: ...     print(\"Frontend built successfully\")</p> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def build_frontend():\n    \"\"\"Build the frontend assets using NPM.\n\n    This function handles the complete frontend build process including\n    dependency installation, production build execution, and error handling.\n\n    The build process:\n        1. Locates NPM executable in system PATH\n        2. Changes to frontend directory\n        3. Installs NPM dependencies via 'npm install'\n        4. Runs production build via 'npm run build'\n        5. Restores original working directory\n\n    Returns:\n        bool: True if build succeeds, False otherwise.\n\n    Raises:\n        NpmNotFoundError: If NPM is not installed or not found in PATH.\n        ValueError: If NPM path validation fails.\n\n    Note:\n        The function uses shell=False for security to prevent command\n        injection attacks. It also validates the NPM path before execution.\n\n    Example:\n        &gt;&gt;&gt; success = build_frontend()\n        &gt;&gt;&gt; if success:\n        ...     print(\"Frontend built successfully\")\n    \"\"\"\n    # Get the absolute path to the frontend directory\n    # This is where package.json and source files are located\n    frontend_dir = Path(__file__).parent / \"frontend\"\n\n    try:\n        # Store current working directory so we can restore it later\n        # This ensures we don't leave the user in a different directory\n        original_dir = Path.cwd()\n\n        # Change to frontend directory for NPM operations\n        # NPM needs to run from the directory containing package.json\n        os.chdir(frontend_dir)\n\n        # Install dependencies first to ensure all packages are available\n        print(\"\ud83d\udce6 Installing frontend dependencies...\")\n\n        # Find NPM executable in system PATH\n        # shutil.which() returns full path to executable or None\n        npm_path = shutil.which(\"npm\")\n\n        # Check if NPM was found in PATH\n        if not npm_path:\n            # Define nested function to raise NPM not found error\n            # This pattern is used to satisfy certain linting rules\n            def _raise_npm_not_found():\n                raise NpmNotFoundError()  # noqa: TRY301\n\n            # Execute the error raising function\n            _raise_npm_not_found()\n\n        # Validate npm_path to prevent command injection attacks\n        # We need to ensure the path actually exists and is valid\n        def _raise_invalid_npm_path():\n            raise ValueError(\"Invalid npm path\")  # noqa: TRY301\n\n        # Double-check NPM path exists on filesystem\n        if not npm_path or not Path(npm_path).exists():\n            _raise_invalid_npm_path()\n\n        # Run 'npm install' to install all dependencies from package.json\n        # check=True causes subprocess to raise CalledProcessError on failure\n        # shell=False prevents shell injection attacks\n        subprocess.run([npm_path, \"install\"], check=True, shell=False)\n\n        # Build frontend using the build script defined in package.json\n        print(\"\ud83d\udd28 Building frontend...\")\n        # Run 'npm run build' which executes the build script\n        subprocess.run([npm_path, \"run\", \"build\"], check=True, shell=False)\n\n        # Build completed successfully\n        print(\"\u2705 Frontend build successful!\")\n        # Return True to indicate success\n        # Note: No explicit return needed as we reach end of try block\n\n    except subprocess.CalledProcessError as e:\n        # NPM command failed (non-zero exit code)\n        # Print error message to help user diagnose the issue\n        print(f\"\u274c Frontend build failed: {e}\")\n        return False\n\n    except Exception as e:\n        # Catch any other unexpected errors\n        # This could include file system errors, permission errors, etc.\n        print(f\"\u274c Unexpected error during frontend build: {e}\")\n        return False\n\n    finally:\n        # Always restore original working directory\n        # This executes whether build succeeded or failed\n        os.chdir(original_dir)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Main CLI entry point for command-line interface.</p> <p>Parses command-line arguments and dispatches to appropriate handler functions. Supported commands:     - build-frontend: Build the frontend assets     - check: Check if frontend is built     - version: Show version information</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Exit code (0 for success, 1 for failure).</p> Example <p>import sys sys.argv = ['cli', 'version'] exit_code = main() print(f\"Exit code: {exit_code}\")</p> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def main():\n    \"\"\"Main CLI entry point for command-line interface.\n\n    Parses command-line arguments and dispatches to appropriate handler\n    functions. Supported commands:\n        - build-frontend: Build the frontend assets\n        - check: Check if frontend is built\n        - version: Show version information\n\n    Returns:\n        int: Exit code (0 for success, 1 for failure).\n\n    Example:\n        &gt;&gt;&gt; import sys\n        &gt;&gt;&gt; sys.argv = ['cli', 'version']\n        &gt;&gt;&gt; exit_code = main()\n        &gt;&gt;&gt; print(f\"Exit code: {exit_code}\")\n    \"\"\"\n    # Check if user provided a command argument\n    # sys.argv[0] is the script name, sys.argv[1] is the command\n    if len(sys.argv) &lt; 2:\n        # No command provided, show usage information\n        print(\"Usage: streamlit-lightweight-charts-pro &lt;command&gt;\")\n        print(\"Commands:\")\n        print(\"  build-frontend  Build the frontend assets\")\n        print(\"  check          Check if frontend is built\")\n        print(\"  version        Show version information\")\n        # Return 1 to indicate error (missing command)\n        return 1\n\n    # Extract the command from command-line arguments\n    command = sys.argv[1]\n\n    # Handle 'build-frontend' command\n    if command == \"build-frontend\":\n        # Trigger frontend build process\n        success = build_frontend()\n        # Return 0 if successful, 1 if failed\n        return 0 if success else 1\n\n    # Handle 'check' command\n    if command == \"check\":\n        # Check if frontend is already built\n        success = check_frontend_build()\n        # Return 0 if successful, 1 if failed\n        return 0 if success else 1\n\n    # Handle 'version' command\n    if command == \"version\":\n        # Display version information from package metadata\n        print(f\"streamlit-lightweight-charts-pro version {__version__}\")\n        # Return 0 to indicate success\n        return 0\n\n    # Unknown command provided\n    print(f\"Unknown command: {command}\")\n    # Return 1 to indicate error (invalid command)\n    return 1\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html","title":"streamlit_lightweight_charts_pro.component","text":""},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component","title":"component","text":"<p>Component initialization for Streamlit Lightweight Charts Pro.</p> <p>This module handles the initialization of the Streamlit custom component that enables TradingView Lightweight Charts in Streamlit applications. It manages the component lifecycle, handles both development and production modes, and provides utilities for debugging component initialization issues.</p> <p>The module uses Streamlit's components API to create a bidirectional bridge between Python (backend) and React/JavaScript (frontend). This bridge allows:     - Sending chart configuration from Python to JavaScript     - Receiving user interactions from JavaScript back to Python     - Managing component state and lifecycle     - Hot reloading during development</p> Key Features <ul> <li>Automatic mode detection (development vs production)</li> <li>Lazy component initialization to avoid import cycles</li> <li>Comprehensive error handling and logging</li> <li>Debug utilities for troubleshooting</li> <li>Support for component reinitialization</li> </ul> Architecture <p>The component follows a singleton pattern where _component_func is initialized once at module import time. This ensures consistent behavior across the application and avoids redundant initialization overhead.</p> <p>Component Modes:     - Production (_RELEASE=True): Uses pre-built static files from       frontend/build directory. Optimized for deployment.     - Development (_RELEASE=False): Connects to local dev server at       localhost:3001 for hot reloading and rapid iteration.</p> Example <p>Basic chart rendering::</p> <pre><code>from streamlit_lightweight_charts_pro.component import (\n    get_component_func\n)\n\n# Get the initialized component function\ncomponent_func = get_component_func()\n\nif component_func:\n    # Render a chart with configuration\n    result = component_func(\n        config={\"chart_options\": {...}},\n        key=\"my_chart\"\n    )\nelse:\n    st.error(\"Chart component failed to initialize\")\n</code></pre> <p>Debugging initialization issues::</p> <pre><code>from streamlit_lightweight_charts_pro.component import (\n    debug_component_status,\n    reinitialize_component\n)\n\n# Check component status\nstatus = debug_component_status()\nprint(f\"Component initialized: {status['component_initialized']}\")\n\n# Attempt reinitialization if needed\nif not status['component_initialized']:\n    success = reinitialize_component()\n    print(f\"Reinitialization {'succeeded' if success else 'failed'}\")\n</code></pre> Note <p>The module initializes the component automatically at import time. Component initialization failures are logged but don't raise exceptions, allowing the application to start even if charts can't be rendered.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Streamlit components module cannot be imported</p> <code>FileNotFoundError</code> <p>If frontend build directory is missing in production</p>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.get_component_func","title":"get_component_func","text":"<pre><code>get_component_func() -&gt; Optional[Callable[..., Any]]\n</code></pre> <p>Get the Streamlit component function for rendering charts.</p> <p>This function returns the initialized component function that enables chart rendering in Streamlit applications. The component function acts as a bridge between Python configuration and the React frontend.</p> <p>The returned function can be called with chart configuration to render interactive TradingView Lightweight Charts. It handles serialization, communication with the JavaScript frontend, and state management.</p> <p>Returns:</p> Type Description <code>Optional[Callable[..., Any]]</code> <p>Optional[Callable[..., Any]]: The component function if successfully initialized, None if initialization failed. When not None, the function has the signature:</p> <p>component_func(     config: Dict[str, Any],     key: Optional[str] = None,     height: int = 400 ) -&gt; Any</p> <p>Where:     - config: Chart configuration dictionary     - key: Unique identifier for the component instance     - height: Component height in pixels</p> Example <p>Render a simple chart::</p> <pre><code>&gt;&gt;&gt; component_func = get_component_func()\n&gt;&gt;&gt; if component_func:\n...     component_func(\n...         config={\"chart_options\": {\"layout\": {...}}},\n...         key=\"my_chart\",\n...         height=500\n...     )\n</code></pre> <p>Handle missing component gracefully::</p> <pre><code>&gt;&gt;&gt; component_func = get_component_func()\n&gt;&gt;&gt; if component_func is None:\n...     st.warning(\"Chart component unavailable\")\n</code></pre> Note <p>If the function returns None, check logs and use debug_component_status() to diagnose initialization issues. Common causes include:     - Missing frontend build files     - Incorrect file paths     - Import errors     - Permission issues</p> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def get_component_func() -&gt; Optional[Callable[..., Any]]:\n    \"\"\"Get the Streamlit component function for rendering charts.\n\n    This function returns the initialized component function that enables\n    chart rendering in Streamlit applications. The component function acts\n    as a bridge between Python configuration and the React frontend.\n\n    The returned function can be called with chart configuration to render\n    interactive TradingView Lightweight Charts. It handles serialization,\n    communication with the JavaScript frontend, and state management.\n\n    Returns:\n        Optional[Callable[..., Any]]: The component function if successfully\n            initialized, None if initialization failed. When not None, the\n            function has the signature:\n\n            component_func(\n                config: Dict[str, Any],\n                key: Optional[str] = None,\n                height: int = 400\n            ) -&gt; Any\n\n            Where:\n                - config: Chart configuration dictionary\n                - key: Unique identifier for the component instance\n                - height: Component height in pixels\n\n    Example:\n        Render a simple chart::\n\n            &gt;&gt;&gt; component_func = get_component_func()\n            &gt;&gt;&gt; if component_func:\n            ...     component_func(\n            ...         config={\"chart_options\": {\"layout\": {...}}},\n            ...         key=\"my_chart\",\n            ...         height=500\n            ...     )\n\n        Handle missing component gracefully::\n\n            &gt;&gt;&gt; component_func = get_component_func()\n            &gt;&gt;&gt; if component_func is None:\n            ...     st.warning(\"Chart component unavailable\")\n\n    Note:\n        If the function returns None, check logs and use\n        debug_component_status() to diagnose initialization issues.\n        Common causes include:\n            - Missing frontend build files\n            - Incorrect file paths\n            - Import errors\n            - Permission issues\n    \"\"\"\n    # Check if component function was successfully initialized\n    if _component_func is None:\n        # Log warning to help diagnose why component is unavailable\n        # This could indicate:\n        # - Frontend build directory missing\n        # - Component declaration failed\n        # - Import errors during initialization\n        logger.warning(\n            \"Component function is not initialized. This may indicate a \"\n            \"loading issue.\"\n        )\n\n    # Return the component function (or None if initialization failed)\n    return _component_func\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.debug_component_status","title":"debug_component_status","text":"<pre><code>debug_component_status() -&gt; Dict[str, Any]\n</code></pre> <p>Debug function to check component initialization status.</p> <p>This utility function provides comprehensive information about the component's initialization state, file paths, and available resources. It's invaluable for troubleshooting component loading issues.</p> The function checks <ul> <li>Whether component function was initialized</li> <li>Current mode (production vs development)</li> <li>Frontend directory existence and path</li> <li>Static asset directory structure</li> <li>JavaScript bundle files availability</li> </ul> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Status information dictionary containing: - component_initialized (bool): True if component loaded - release_mode (bool): True if in production mode - frontend_dir_exists (bool): True if build dir exists - component_type (str): Type name of component function - frontend_dir_path (str): Absolute path to frontend - static_dir_exists (bool): True if static dir exists - js_dir_exists (bool): True if js dir exists - js_files_count (int): Number of JavaScript files found - js_files (List[str]): Names of JavaScript bundle files</p> Example <p>Basic status check::</p> <pre><code>&gt;&gt;&gt; status = debug_component_status()\n&gt;&gt;&gt; print(f\"Initialized: {status['component_initialized']}\")\n&gt;&gt;&gt; print(f\"Mode: {'Production' if status['release_mode'] else 'Dev'}\")\n</code></pre> <p>Diagnose missing files::</p> <pre><code>&gt;&gt;&gt; status = debug_component_status()\n&gt;&gt;&gt; if not status['component_initialized']:\n...     if not status['frontend_dir_exists']:\n...         print(\"Frontend build missing - run npm build\")\n...     elif not status['js_dir_exists']:\n...         print(\"JavaScript bundles missing\")\n...     else:\n...         print(f\"Found {status['js_files_count']} JS files\")\n</code></pre> Note <p>This function only checks production mode files. Development mode status depends on the dev server running at localhost:3001.</p> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def debug_component_status() -&gt; Dict[str, Any]:\n    \"\"\"Debug function to check component initialization status.\n\n    This utility function provides comprehensive information about the\n    component's initialization state, file paths, and available resources.\n    It's invaluable for troubleshooting component loading issues.\n\n    The function checks:\n        - Whether component function was initialized\n        - Current mode (production vs development)\n        - Frontend directory existence and path\n        - Static asset directory structure\n        - JavaScript bundle files availability\n\n    Returns:\n        Dict[str, Any]: Status information dictionary containing:\n            - component_initialized (bool): True if component loaded\n            - release_mode (bool): True if in production mode\n            - frontend_dir_exists (bool): True if build dir exists\n            - component_type (str): Type name of component function\n            - frontend_dir_path (str): Absolute path to frontend\n            - static_dir_exists (bool): True if static dir exists\n            - js_dir_exists (bool): True if js dir exists\n            - js_files_count (int): Number of JavaScript files found\n            - js_files (List[str]): Names of JavaScript bundle files\n\n    Example:\n        Basic status check::\n\n            &gt;&gt;&gt; status = debug_component_status()\n            &gt;&gt;&gt; print(f\"Initialized: {status['component_initialized']}\")\n            &gt;&gt;&gt; print(f\"Mode: {'Production' if status['release_mode'] else 'Dev'}\")\n\n        Diagnose missing files::\n\n            &gt;&gt;&gt; status = debug_component_status()\n            &gt;&gt;&gt; if not status['component_initialized']:\n            ...     if not status['frontend_dir_exists']:\n            ...         print(\"Frontend build missing - run npm build\")\n            ...     elif not status['js_dir_exists']:\n            ...         print(\"JavaScript bundles missing\")\n            ...     else:\n            ...         print(f\"Found {status['js_files_count']} JS files\")\n\n    Note:\n        This function only checks production mode files. Development mode\n        status depends on the dev server running at localhost:3001.\n    \"\"\"\n    # Initialize status dictionary with basic component information\n    # This will be populated with detailed information below\n    status: Dict[str, Any] = {\n        # Check if component function was successfully created\n        \"component_initialized\": _component_func is not None,\n        # Current mode: True = production, False = development\n        \"release_mode\": _RELEASE,\n        # Will be set to True if frontend directory exists\n        \"frontend_dir_exists\": False,\n        # Type of component function (or None if not initialized)\n        \"component_type\": (\n            type(_component_func).__name__ if _component_func else None\n        ),\n    }\n\n    # Only check filesystem paths in production mode\n    # In development mode, frontend is served from separate dev server\n    if _RELEASE:\n        # Construct path to the frontend build directory\n        # This is where npm build outputs the compiled React app\n        frontend_dir = Path(__file__).parent / \"frontend\" / \"build\"\n\n        # Check if the build directory actually exists on disk\n        status[\"frontend_dir_exists\"] = frontend_dir.exists()\n\n        # Store the absolute path for debugging\n        status[\"frontend_dir_path\"] = str(frontend_dir)\n\n        # If build directory exists, check for required subdirectories\n        if frontend_dir.exists():\n            # The 'static' directory contains all compiled assets\n            static_dir = frontend_dir / \"static\"\n\n            # The 'js' subdirectory contains JavaScript bundles\n            js_dir = static_dir / \"js\" if static_dir.exists() else None\n\n            # Record whether static directory exists\n            status[\"static_dir_exists\"] = static_dir.exists()\n\n            # Record whether js directory exists (only if static exists)\n            status[\"js_dir_exists\"] = js_dir.exists() if js_dir else False\n\n            # If js directory exists, enumerate JavaScript bundle files\n            if js_dir and js_dir.exists():\n                # Find all .js files in the js directory\n                js_files = list(js_dir.glob(\"*.js\"))\n\n                # Count how many JavaScript files were found\n                status[\"js_files_count\"] = len(js_files)\n\n                # Store list of filenames for detailed debugging\n                status[\"js_files\"] = [f.name for f in js_files]\n\n    # Return the populated status dictionary\n    return status\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.reinitialize_component","title":"reinitialize_component","text":"<pre><code>reinitialize_component() -&gt; bool\n</code></pre> <p>Attempt to reinitialize the component if it failed to load initially.</p> <p>This function provides a recovery mechanism for component initialization failures. It's useful when the frontend build was missing at import time but has since been built, or when temporary errors prevented loading.</p> <p>The function attempts to reinitialize the component using the same logic as the initial _initialize_component() call. It respects the current mode (production vs development) and updates the global _component_func.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if reinitialization succeeded, False if it failed. Success means the component function was successfully declared and is ready for use. Failure indicates persistent issues that require investigation.</p> Example <p>Retry after building frontend::</p> <pre><code>&gt;&gt;&gt; # Initial load failed, build frontend\n&gt;&gt;&gt; subprocess.run([\"npm\", \"run\", \"build\"], cwd=\"frontend\")\n&gt;&gt;&gt; # Attempt to reinitialize\n&gt;&gt;&gt; if reinitialize_component():\n...     print(\"Component now ready\")\n... else:\n...     print(\"Reinitialization failed\")\n</code></pre> <p>Check status before reinitializing::</p> <pre><code>&gt;&gt;&gt; status = debug_component_status()\n&gt;&gt;&gt; if not status['component_initialized']:\n...     if status['frontend_dir_exists']:\n...         # Build exists, try reinitializing\n...         success = reinitialize_component()\n...     else:\n...         print(\"Build frontend first\")\n</code></pre> Note <p>This function modifies the global _component_func variable. Reinitialization does not affect existing component instances, only new components created after this call.</p> <p>Common reasons to reinitialize:     - Frontend was built after module import     - Temporary file system issues resolved     - Network issues resolved (dev mode)     - Manual troubleshooting steps completed</p> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def reinitialize_component() -&gt; bool:\n    \"\"\"Attempt to reinitialize the component if it failed to load initially.\n\n    This function provides a recovery mechanism for component initialization\n    failures. It's useful when the frontend build was missing at import time\n    but has since been built, or when temporary errors prevented loading.\n\n    The function attempts to reinitialize the component using the same logic\n    as the initial _initialize_component() call. It respects the current\n    mode (production vs development) and updates the global _component_func.\n\n    Returns:\n        bool: True if reinitialization succeeded, False if it failed.\n            Success means the component function was successfully declared\n            and is ready for use. Failure indicates persistent issues that\n            require investigation.\n\n    Example:\n        Retry after building frontend::\n\n            &gt;&gt;&gt; # Initial load failed, build frontend\n            &gt;&gt;&gt; subprocess.run([\"npm\", \"run\", \"build\"], cwd=\"frontend\")\n            &gt;&gt;&gt; # Attempt to reinitialize\n            &gt;&gt;&gt; if reinitialize_component():\n            ...     print(\"Component now ready\")\n            ... else:\n            ...     print(\"Reinitialization failed\")\n\n        Check status before reinitializing::\n\n            &gt;&gt;&gt; status = debug_component_status()\n            &gt;&gt;&gt; if not status['component_initialized']:\n            ...     if status['frontend_dir_exists']:\n            ...         # Build exists, try reinitializing\n            ...         success = reinitialize_component()\n            ...     else:\n            ...         print(\"Build frontend first\")\n\n    Note:\n        This function modifies the global _component_func variable.\n        Reinitialization does not affect existing component instances,\n        only new components created after this call.\n\n        Common reasons to reinitialize:\n            - Frontend was built after module import\n            - Temporary file system issues resolved\n            - Network issues resolved (dev mode)\n            - Manual troubleshooting steps completed\n    \"\"\"\n    # Declare _component_func as global so we can modify it\n    # Without this, we'd create a new local variable instead\n    global _component_func  # pylint: disable=global-statement  # noqa: PLW0603\n\n    # Log the reinitialization attempt for debugging\n    logger.info(\"Attempting to reinitialize component...\")\n\n    # Handle production mode reinitialization\n    if _RELEASE:\n        # Construct path to frontend build directory\n        frontend_dir = Path(__file__).parent / \"frontend\" / \"build\"\n\n        # Verify build directory exists before attempting initialization\n        if not frontend_dir.exists():\n            # Log error with specific path that's missing\n            logger.error(\n                \"Frontend build directory not found at %s\", frontend_dir\n            )\n            # Return False to indicate reinitialization failed\n            return False\n\n        try:\n            # Attempt to declare the production component\n            # Use package name only to avoid module path conflicts\n            _component_func = components.declare_component(\n                \"streamlit_lightweight_charts_pro\",\n                path=str(frontend_dir),\n            )\n        except Exception:\n            # Log the exception with full traceback for debugging\n            logger.exception(\"Failed to reinitialize component\")\n            # Return False to indicate reinitialization failed\n            return False\n        else:\n            # No exception raised, initialization succeeded\n            logger.info(\"Successfully reinitialized production component\")\n            # Return True to indicate success\n            return True\n\n    # Handle development mode reinitialization\n    try:\n        # Attempt to declare the development component\n        # Connects to local dev server at localhost:3001\n        _component_func = components.declare_component(\n            \"streamlit_lightweight_charts_pro\",\n            url=\"http://localhost:3001\",\n        )\n    except Exception:\n        # Log the exception with full traceback for debugging\n        logger.exception(\"Failed to reinitialize development component\")\n        # Return False to indicate reinitialization failed\n        return False\n    else:\n        # No exception raised, initialization succeeded\n        logger.info(\"Successfully reinitialized development component\")\n        # Return True to indicate success\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html","title":"streamlit_lightweight_charts_pro.exceptions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions","title":"exceptions","text":"<p>Custom exceptions for streamlit-lightweight-charts-pro.</p> <p>This module provides a hierarchical structure of custom exceptions for precise error handling across the streamlit-lightweight-charts-pro package. The exceptions are organized into categories for validation, configuration, type checking, and data handling errors.</p> The exception hierarchy <ul> <li>ValidationError: Base for all validation-related errors<ul> <li>TypeValidationError: Type mismatch errors</li> <li>ValueValidationError: Value constraint errors</li> <li>RangeValidationError: Out-of-range errors</li> <li>RequiredFieldError: Missing required fields</li> <li>DuplicateError: Duplicate value errors</li> <li>ColorValidationError: Invalid color formats</li> <li>DataFrameValidationError: DataFrame validation errors</li> <li>TimeValidationError: Time validation errors</li> </ul> </li> <li>ConfigurationError: Base for configuration errors<ul> <li>ComponentNotAvailableError: Component initialization errors</li> <li>NpmNotFoundError: NPM not found errors</li> <li>CliNotFoundError: CLI not found errors</li> </ul> </li> </ul> Example <p>Catching validation errors::</p> <pre><code>from streamlit_lightweight_charts_pro.exceptions import (\n    ValidationError,\n    ValueValidationError\n)\n\ntry:\n    # Some validation logic\n    if value &lt; 0:\n        raise ValueValidationError.positive_value(\"price\", value)\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValidationError","title":"ValidationError","text":"<p>Base exception for all validation errors.</p> <p>This is the root exception class for all validation-related errors in the package. It should be caught when you want to handle any type of validation failure.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Descriptive error message explaining the validation failure.</p> required Example <p>raise ValidationError(\"Invalid input provided\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Base exception for all validation errors.\n\n    This is the root exception class for all validation-related errors\n    in the package. It should be caught when you want to handle any type\n    of validation failure.\n\n    Args:\n        message (str): Descriptive error message explaining the validation\n            failure.\n\n    Example:\n        &gt;&gt;&gt; raise ValidationError(\"Invalid input provided\")\n    \"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize ValidationError with a message.\n\n        Args:\n            message (str): Error message describing the validation failure.\n        \"\"\"\n        # Call parent Exception class constructor with the message\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ConfigurationError","title":"ConfigurationError","text":"<p>Base exception for configuration-related errors.</p> <p>This exception is raised when there are issues with system configuration, environment setup, or package initialization.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Descriptive error message explaining the configuration issue.</p> required Example <p>raise ConfigurationError(\"Invalid configuration detected\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ConfigurationError(Exception):\n    \"\"\"Base exception for configuration-related errors.\n\n    This exception is raised when there are issues with system configuration,\n    environment setup, or package initialization.\n\n    Args:\n        message (str): Descriptive error message explaining the\n            configuration issue.\n\n    Example:\n        &gt;&gt;&gt; raise ConfigurationError(\"Invalid configuration detected\")\n    \"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize ConfigurationError with a message.\n\n        Args:\n            message (str): Error message describing the configuration issue.\n        \"\"\"\n        # Call parent Exception class constructor with the message\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeValidationError","title":"TypeValidationError","text":"<p>Raised when type validation fails.</p> <p>This exception is used when a value is of an incorrect type. It provides formatted error messages that clearly indicate what type was expected versus what was received.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that failed validation.</p> required <code>expected_type</code> <code>str</code> <p>Description of the expected type.</p> required <code>actual_type</code> <code>Optional[str]</code> <p>Description of the actual type received. If None, only expected type is shown.</p> <code>None</code> Example <p>raise TypeValidationError(\"price\", \"float\", \"str\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TypeValidationError(ValidationError):\n    \"\"\"Raised when type validation fails.\n\n    This exception is used when a value is of an incorrect type.\n    It provides formatted error messages that clearly indicate what\n    type was expected versus what was received.\n\n    Args:\n        field_name (str): Name of the field that failed validation.\n        expected_type (str): Description of the expected type.\n        actual_type (Optional[str]): Description of the actual type\n            received. If None, only expected type is shown.\n\n    Example:\n        &gt;&gt;&gt; raise TypeValidationError(\"price\", \"float\", \"str\")\n        # Error: price must be float, got str\n    \"\"\"\n\n    def __init__(\n        self,\n        field_name: str,\n        expected_type: str,\n        actual_type: Optional[str] = None,\n    ):\n        \"\"\"Initialize TypeValidationError.\n\n        Args:\n            field_name (str): Name of the field being validated.\n            expected_type (str): Expected type description.\n            actual_type (Optional[str]): Actual type received, if known.\n        \"\"\"\n        # Build error message based on whether actual type is provided\n        if actual_type:\n            # Include both expected and actual types in message\n            message = f\"{field_name} must be {expected_type}, got {actual_type}\"\n        else:\n            # Only show expected type\n            message = f\"{field_name} must be {expected_type}\"\n\n        # Call parent ValidationError with formatted message\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeValidationError--error-price-must-be-float-got-str","title":"Error: price must be float, got str","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError","title":"ValueValidationError","text":"<p>Raised when value validation fails.</p> <p>This class provides helper methods for common validation patterns, reducing the need for overly specific exception classes. It handles validations like positive numbers, ranges, and required fields.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that failed validation.</p> required <code>message</code> <code>str</code> <p>Description of why validation failed.</p> required Example <p>error = ValueValidationError.positive_value(\"price\", -10) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ValueValidationError(ValidationError):\n    \"\"\"Raised when value validation fails.\n\n    This class provides helper methods for common validation patterns,\n    reducing the need for overly specific exception classes. It handles\n    validations like positive numbers, ranges, and required fields.\n\n    Args:\n        field_name (str): Name of the field that failed validation.\n        message (str): Description of why validation failed.\n\n    Example:\n        &gt;&gt;&gt; error = ValueValidationError.positive_value(\"price\", -10)\n        &gt;&gt;&gt; raise error\n        # Error: price must be positive, got -10\n    \"\"\"\n\n    def __init__(self, field_name: str, message: str):\n        \"\"\"Initialize ValueValidationError.\n\n        Args:\n            field_name (str): Name of the field being validated.\n            message (str): Validation failure description.\n        \"\"\"\n        # Combine field name and message for full error text\n        super().__init__(f\"{field_name} {message}\")\n\n    @classmethod\n    def positive_value(\n        cls, field_name: str, value: float | int\n    ) -&gt; \"ValueValidationError\":\n        \"\"\"Create error for non-positive value.\n\n        Helper method for validating that a value is positive (&gt; 0).\n\n        Args:\n            field_name (str): Name of the field being validated.\n            value (float | int): The invalid value that was provided.\n\n        Returns:\n            ValueValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = ValueValidationError.positive_value(\"price\", -5)\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with positive value message\n        return cls(field_name, f\"must be positive, got {value}\")\n\n    @classmethod\n    def non_negative_value(\n        cls,\n        field_name: str,\n        value: float | int | None = None,\n    ) -&gt; \"ValueValidationError\":\n        \"\"\"Create error for negative value.\n\n        Helper method for validating that a value is non-negative (&gt;= 0).\n\n        Args:\n            field_name (str): Name of the field being validated.\n            value (float | int | None): The invalid value that was provided.\n                If None, only shows constraint without value.\n\n        Returns:\n            ValueValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = ValueValidationError.non_negative_value(\"count\", -1)\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Build message based on whether value is provided\n        if value is not None:\n            # Include the invalid value in message\n            return cls(field_name, f\"must be &gt;= 0, got {value}\")\n        # Generic message without specific value\n        return cls(field_name, \"must be non-negative\")\n\n    @classmethod\n    def in_range(\n        cls,\n        field_name: str,\n        min_val: float,\n        max_val: float,\n        value: float | int,\n    ) -&gt; \"ValueValidationError\":\n        \"\"\"Create error for out-of-range value.\n\n        Helper method for validating that a value falls within a\n        specified range [min_val, max_val].\n\n        Args:\n            field_name (str): Name of the field being validated.\n            min_val (float): Minimum acceptable value (inclusive).\n            max_val (float): Maximum acceptable value (inclusive).\n            value (float | int): The invalid value that was provided.\n\n        Returns:\n            ValueValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = ValueValidationError.in_range(\n            ...     \"percentage\", 0, 100, 150\n            ... )\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with range validation message\n        return cls(\n            field_name, f\"must be between {min_val} and {max_val}, got {value}\"\n        )\n\n    @classmethod\n    def required_field(cls, field_name: str) -&gt; \"ValueValidationError\":\n        \"\"\"Create error for missing required field.\n\n        Helper method for validating that a required field is present.\n\n        Args:\n            field_name (str): Name of the required field.\n\n        Returns:\n            ValueValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = ValueValidationError.required_field(\"title\")\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with required field message\n        return cls(field_name, \"is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError--error-price-must-be-positive-got-10","title":"Error: price must be positive, got -10","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.positive_value","title":"positive_value  <code>classmethod</code>","text":"<pre><code>positive_value(field_name: str, value: float | int) -&gt; ValueValidationError\n</code></pre> <p>Create error for non-positive value.</p> <p>Helper method for validating that a value is positive (&gt; 0).</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field being validated.</p> required <code>value</code> <code>float | int</code> <p>The invalid value that was provided.</p> required <p>Returns:</p> Name Type Description <code>ValueValidationError</code> <code>ValueValidationError</code> <p>Configured error instance.</p> Example <p>error = ValueValidationError.positive_value(\"price\", -5) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef positive_value(\n    cls, field_name: str, value: float | int\n) -&gt; \"ValueValidationError\":\n    \"\"\"Create error for non-positive value.\n\n    Helper method for validating that a value is positive (&gt; 0).\n\n    Args:\n        field_name (str): Name of the field being validated.\n        value (float | int): The invalid value that was provided.\n\n    Returns:\n        ValueValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = ValueValidationError.positive_value(\"price\", -5)\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with positive value message\n    return cls(field_name, f\"must be positive, got {value}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.non_negative_value","title":"non_negative_value  <code>classmethod</code>","text":"<pre><code>non_negative_value(field_name: str, value: float | int | None = None) -&gt; ValueValidationError\n</code></pre> <p>Create error for negative value.</p> <p>Helper method for validating that a value is non-negative (&gt;= 0).</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field being validated.</p> required <code>value</code> <code>float | int | None</code> <p>The invalid value that was provided. If None, only shows constraint without value.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ValueValidationError</code> <code>ValueValidationError</code> <p>Configured error instance.</p> Example <p>error = ValueValidationError.non_negative_value(\"count\", -1) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef non_negative_value(\n    cls,\n    field_name: str,\n    value: float | int | None = None,\n) -&gt; \"ValueValidationError\":\n    \"\"\"Create error for negative value.\n\n    Helper method for validating that a value is non-negative (&gt;= 0).\n\n    Args:\n        field_name (str): Name of the field being validated.\n        value (float | int | None): The invalid value that was provided.\n            If None, only shows constraint without value.\n\n    Returns:\n        ValueValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = ValueValidationError.non_negative_value(\"count\", -1)\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Build message based on whether value is provided\n    if value is not None:\n        # Include the invalid value in message\n        return cls(field_name, f\"must be &gt;= 0, got {value}\")\n    # Generic message without specific value\n    return cls(field_name, \"must be non-negative\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.in_range","title":"in_range  <code>classmethod</code>","text":"<pre><code>in_range(field_name: str, min_val: float, max_val: float, value: float | int) -&gt; ValueValidationError\n</code></pre> <p>Create error for out-of-range value.</p> <p>Helper method for validating that a value falls within a specified range [min_val, max_val].</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field being validated.</p> required <code>min_val</code> <code>float</code> <p>Minimum acceptable value (inclusive).</p> required <code>max_val</code> <code>float</code> <p>Maximum acceptable value (inclusive).</p> required <code>value</code> <code>float | int</code> <p>The invalid value that was provided.</p> required <p>Returns:</p> Name Type Description <code>ValueValidationError</code> <code>ValueValidationError</code> <p>Configured error instance.</p> Example <p>error = ValueValidationError.in_range( ...     \"percentage\", 0, 100, 150 ... ) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef in_range(\n    cls,\n    field_name: str,\n    min_val: float,\n    max_val: float,\n    value: float | int,\n) -&gt; \"ValueValidationError\":\n    \"\"\"Create error for out-of-range value.\n\n    Helper method for validating that a value falls within a\n    specified range [min_val, max_val].\n\n    Args:\n        field_name (str): Name of the field being validated.\n        min_val (float): Minimum acceptable value (inclusive).\n        max_val (float): Maximum acceptable value (inclusive).\n        value (float | int): The invalid value that was provided.\n\n    Returns:\n        ValueValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = ValueValidationError.in_range(\n        ...     \"percentage\", 0, 100, 150\n        ... )\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with range validation message\n    return cls(\n        field_name, f\"must be between {min_val} and {max_val}, got {value}\"\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.required_field","title":"required_field  <code>classmethod</code>","text":"<pre><code>required_field(field_name: str) -&gt; ValueValidationError\n</code></pre> <p>Create error for missing required field.</p> <p>Helper method for validating that a required field is present.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the required field.</p> required <p>Returns:</p> Name Type Description <code>ValueValidationError</code> <code>ValueValidationError</code> <p>Configured error instance.</p> Example <p>error = ValueValidationError.required_field(\"title\") raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef required_field(cls, field_name: str) -&gt; \"ValueValidationError\":\n    \"\"\"Create error for missing required field.\n\n    Helper method for validating that a required field is present.\n\n    Args:\n        field_name (str): Name of the required field.\n\n    Returns:\n        ValueValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = ValueValidationError.required_field(\"title\")\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with required field message\n    return cls(field_name, \"is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RangeValidationError","title":"RangeValidationError","text":"<p>Raised when value is outside valid range.</p> <p>This exception is used for numeric range validation, supporting minimum-only, maximum-only, or bounded ranges.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field being validated.</p> required <code>value</code> <code>float | int</code> <p>The value that failed validation.</p> required <code>min_value</code> <code>Optional[float]</code> <p>Minimum acceptable value, if any.</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>Maximum acceptable value, if any.</p> <code>None</code> Example <p>raise RangeValidationError(\"opacity\", 1.5, 0.0, 1.0)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class RangeValidationError(ValueValidationError):\n    \"\"\"Raised when value is outside valid range.\n\n    This exception is used for numeric range validation, supporting\n    minimum-only, maximum-only, or bounded ranges.\n\n    Args:\n        field_name (str): Name of the field being validated.\n        value (float | int): The value that failed validation.\n        min_value (Optional[float]): Minimum acceptable value, if any.\n        max_value (Optional[float]): Maximum acceptable value, if any.\n\n    Example:\n        &gt;&gt;&gt; raise RangeValidationError(\"opacity\", 1.5, 0.0, 1.0)\n        # Error: opacity must be between 0.0 and 1.0, got 1.5\n    \"\"\"\n\n    def __init__(\n        self,\n        field_name: str,\n        value: float | int,\n        min_value: Optional[float] = None,\n        max_value: Optional[float] = None,\n    ):\n        \"\"\"Initialize RangeValidationError.\n\n        Args:\n            field_name (str): Name of the field being validated.\n            value (float | int): Invalid value provided.\n            min_value (Optional[float]): Minimum bound, if applicable.\n            max_value (Optional[float]): Maximum bound, if applicable.\n        \"\"\"\n        # Build appropriate message based on which bounds are specified\n        if min_value is not None and max_value is not None:\n            # Both bounds specified - full range message\n            message = f\"must be between {min_value} and {max_value}, got {value}\"\n        elif min_value is not None:\n            # Only minimum bound specified\n            message = f\"must be &gt;= {min_value}, got {value}\"\n        elif max_value is not None:\n            # Only maximum bound specified\n            message = f\"must be &lt;= {max_value}, got {value}\"\n        else:\n            # No bounds specified - generic invalid value message\n            message = f\"invalid value: {value}\"\n\n        # Call parent ValueValidationError with formatted message\n        super().__init__(field_name, message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RangeValidationError--error-opacity-must-be-between-00-and-10-got-15","title":"Error: opacity must be between 0.0 and 1.0, got 1.5","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RequiredFieldError","title":"RequiredFieldError","text":"<p>Raised when a required field is missing.</p> <p>This exception indicates that a mandatory field was not provided when creating or updating an object.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the required field that is missing.</p> required Example <p>raise RequiredFieldError(\"title\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class RequiredFieldError(ValidationError):\n    \"\"\"Raised when a required field is missing.\n\n    This exception indicates that a mandatory field was not provided\n    when creating or updating an object.\n\n    Args:\n        field_name (str): Name of the required field that is missing.\n\n    Example:\n        &gt;&gt;&gt; raise RequiredFieldError(\"title\")\n        # Error: title is required\n    \"\"\"\n\n    def __init__(self, field_name: str):\n        \"\"\"Initialize RequiredFieldError.\n\n        Args:\n            field_name (str): Name of the missing required field.\n        \"\"\"\n        # Format message indicating field is required\n        super().__init__(f\"{field_name} is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RequiredFieldError--error-title-is-required","title":"Error: title is required","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DuplicateError","title":"DuplicateError","text":"<p>Raised when duplicate values are detected.</p> <p>This exception is used when a unique constraint is violated, such as duplicate IDs, names, or other identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field where duplicate was detected.</p> required <code>value</code> <code>Any</code> <p>The duplicate value.</p> required Example <p>raise DuplicateError(\"series_id\", \"main\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DuplicateError(ValidationError):\n    \"\"\"Raised when duplicate values are detected.\n\n    This exception is used when a unique constraint is violated, such as\n    duplicate IDs, names, or other identifiers.\n\n    Args:\n        field_name (str): Name of the field where duplicate was detected.\n        value (Any): The duplicate value.\n\n    Example:\n        &gt;&gt;&gt; raise DuplicateError(\"series_id\", \"main\")\n        # Error: Duplicate series_id: main\n    \"\"\"\n\n    def __init__(self, field_name: str, value: Any):\n        \"\"\"Initialize DuplicateError.\n\n        Args:\n            field_name (str): Field name where duplicate was found.\n            value (Any): The duplicate value.\n        \"\"\"\n        # Format message showing duplicate field and value\n        super().__init__(f\"Duplicate {field_name}: {value}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DuplicateError--error-duplicate-series_id-main","title":"Error: Duplicate series_id: main","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ComponentNotAvailableError","title":"ComponentNotAvailableError","text":"<p>Raised when component function is not available.</p> <p>This error occurs when the Streamlit component has not been properly initialized or the component build is not available.</p> Example <p>raise ComponentNotAvailableError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ComponentNotAvailableError(ConfigurationError):\n    \"\"\"Raised when component function is not available.\n\n    This error occurs when the Streamlit component has not been properly\n    initialized or the component build is not available.\n\n    Example:\n        &gt;&gt;&gt; raise ComponentNotAvailableError()\n        # Error: Component function not available. Please check if the\n        # component is properly initialized.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize ComponentNotAvailableError with standard message.\"\"\"\n        # Use predefined message for component availability issues\n        super().__init__(\n            \"Component function not available. \"\n            \"Please check if the component is properly initialized.\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ComponentNotAvailableError--error-component-function-not-available-please-check-if-the","title":"Error: Component function not available. Please check if the","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ComponentNotAvailableError--component-is-properly-initialized","title":"component is properly initialized.","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.AnnotationItemsTypeError","title":"AnnotationItemsTypeError","text":"<p>Raised when annotation items are not correct type.</p> <p>This exception indicates that items in an annotation list are not instances of the Annotation class.</p> Example <p>raise AnnotationItemsTypeError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class AnnotationItemsTypeError(TypeValidationError):\n    \"\"\"Raised when annotation items are not correct type.\n\n    This exception indicates that items in an annotation list are not\n    instances of the Annotation class.\n\n    Example:\n        &gt;&gt;&gt; raise AnnotationItemsTypeError()\n        # Error: All items must be Annotation instances\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize AnnotationItemsTypeError with standard message.\"\"\"\n        # Use predefined message for annotation type errors\n        super().__init__(\"All items\", \"Annotation instances\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.AnnotationItemsTypeError--error-all-items-must-be-annotation-instances","title":"Error: All items must be Annotation instances","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.SeriesItemsTypeError","title":"SeriesItemsTypeError","text":"<p>Raised when series items are not correct type.</p> <p>This exception indicates that items in a series list are not instances of the Series class.</p> Example <p>raise SeriesItemsTypeError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class SeriesItemsTypeError(TypeValidationError):\n    \"\"\"Raised when series items are not correct type.\n\n    This exception indicates that items in a series list are not\n    instances of the Series class.\n\n    Example:\n        &gt;&gt;&gt; raise SeriesItemsTypeError()\n        # Error: All items must be Series instances\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize SeriesItemsTypeError with standard message.\"\"\"\n        # Use predefined message for series type errors\n        super().__init__(\"All items\", \"Series instances\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.SeriesItemsTypeError--error-all-items-must-be-series-instances","title":"Error: All items must be Series instances","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleIdTypeError","title":"PriceScaleIdTypeError","text":"<p>Raised when price scale ID is not a string.</p> <p>Parameters:</p> Name Type Description Default <code>scale_name</code> <code>str</code> <p>Name of the price scale.</p> required <code>actual_type</code> <code>type</code> <p>The actual type that was provided.</p> required Example <p>raise PriceScaleIdTypeError(\"left_scale\", int)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class PriceScaleIdTypeError(TypeValidationError):\n    \"\"\"Raised when price scale ID is not a string.\n\n    Args:\n        scale_name (str): Name of the price scale.\n        actual_type (type): The actual type that was provided.\n\n    Example:\n        &gt;&gt;&gt; raise PriceScaleIdTypeError(\"left_scale\", int)\n        # Error: left_scale.price_scale_id must be a string, got int\n    \"\"\"\n\n    def __init__(self, scale_name: str, actual_type: type):\n        \"\"\"Initialize PriceScaleIdTypeError.\n\n        Args:\n            scale_name (str): Name of the price scale configuration.\n            actual_type (type): Actual type of the invalid value.\n        \"\"\"\n        # Format message with scale name and type information\n        super().__init__(\n            f\"{scale_name}.price_scale_id\",\n            \"must be a string\",\n            actual_type.__name__,\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleIdTypeError--error-left_scaleprice_scale_id-must-be-a-string-got-int","title":"Error: left_scale.price_scale_id must be a string, got int","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleOptionsTypeError","title":"PriceScaleOptionsTypeError","text":"<p>Raised when price scale options are invalid.</p> <p>Parameters:</p> Name Type Description Default <code>scale_name</code> <code>str</code> <p>Name of the price scale.</p> required <code>actual_type</code> <code>type</code> <p>The actual type that was provided.</p> required Example <p>raise PriceScaleOptionsTypeError(\"right_scale\", dict)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class PriceScaleOptionsTypeError(TypeValidationError):\n    \"\"\"Raised when price scale options are invalid.\n\n    Args:\n        scale_name (str): Name of the price scale.\n        actual_type (type): The actual type that was provided.\n\n    Example:\n        &gt;&gt;&gt; raise PriceScaleOptionsTypeError(\"right_scale\", dict)\n        # Error: right_scale must be a PriceScaleOptions object, got dict\n    \"\"\"\n\n    def __init__(self, scale_name: str, actual_type: type):\n        \"\"\"Initialize PriceScaleOptionsTypeError.\n\n        Args:\n            scale_name (str): Name of the price scale configuration.\n            actual_type (type): Actual type of the invalid value.\n        \"\"\"\n        # Format message indicating PriceScaleOptions is required\n        super().__init__(\n            scale_name,\n            \"must be a PriceScaleOptions object\",\n            actual_type.__name__,\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleOptionsTypeError--error-right_scale-must-be-a-pricescaleoptions-object-got-dict","title":"Error: right_scale must be a PriceScaleOptions object, got dict","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColorValidationError","title":"ColorValidationError","text":"<p>Raised when color format is invalid.</p> <p>This exception is used when a color value doesn't match expected formats (hex or rgba).</p> <p>Parameters:</p> Name Type Description Default <code>property_name</code> <code>str</code> <p>Name of the property with invalid color.</p> required <code>color_value</code> <code>str</code> <p>The invalid color value.</p> required Example <p>raise ColorValidationError(\"backgroundColor\", \"invalid\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ColorValidationError(ValidationError):\n    \"\"\"Raised when color format is invalid.\n\n    This exception is used when a color value doesn't match expected\n    formats (hex or rgba).\n\n    Args:\n        property_name (str): Name of the property with invalid color.\n        color_value (str): The invalid color value.\n\n    Example:\n        &gt;&gt;&gt; raise ColorValidationError(\"backgroundColor\", \"invalid\")\n        # Error: Invalid color format for backgroundColor: 'invalid'.\n        # Must be hex or rgba.\n    \"\"\"\n\n    def __init__(self, property_name: str, color_value: str):\n        \"\"\"Initialize ColorValidationError.\n\n        Args:\n            property_name (str): Property name containing the color.\n            color_value (str): The invalid color value.\n        \"\"\"\n        # Format message with property name and color value\n        super().__init__(\n            f\"Invalid color format for {property_name}: {color_value!r}. \"\n            f\"Must be hex or rgba.\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColorValidationError--error-invalid-color-format-for-backgroundcolor-invalid","title":"Error: Invalid color format for backgroundColor: 'invalid'.","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColorValidationError--must-be-hex-or-rgba","title":"Must be hex or rgba.","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError","title":"DataFrameValidationError","text":"<p>Raised when DataFrame validation fails.</p> <p>This exception provides helper methods for common DataFrame validation errors like missing columns or invalid data types.</p> Example <p>error = DataFrameValidationError.missing_column(\"price\") raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DataFrameValidationError(ValidationError):\n    \"\"\"Raised when DataFrame validation fails.\n\n    This exception provides helper methods for common DataFrame validation\n    errors like missing columns or invalid data types.\n\n    Example:\n        &gt;&gt;&gt; error = DataFrameValidationError.missing_column(\"price\")\n        &gt;&gt;&gt; raise error\n        # Error: DataFrame is missing required column: price\n    \"\"\"\n\n    @classmethod\n    def missing_column(cls, column: str) -&gt; \"DataFrameValidationError\":\n        \"\"\"Create error for missing DataFrame column.\n\n        Args:\n            column (str): Name of the missing column.\n\n        Returns:\n            DataFrameValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = DataFrameValidationError.missing_column(\"time\")\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with missing column message\n        return cls(f\"DataFrame is missing required column: {column}\")\n\n    @classmethod\n    def invalid_data_type(\n        cls, data_type: type\n    ) -&gt; \"DataFrameValidationError\":\n        \"\"\"Create error for invalid data type.\n\n        Args:\n            data_type (type): The invalid data type provided.\n\n        Returns:\n            DataFrameValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = DataFrameValidationError.invalid_data_type(str)\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with invalid data type message\n        return cls(\n            f\"data must be a list of SingleValueData objects, DataFrame, \"\n            f\"or Series, got {data_type}\"\n        )\n\n    @classmethod\n    def missing_columns_mapping(\n        cls,\n        missing_columns: list[str],\n        required: list[str],\n        mapping: dict[str, str],\n    ) -&gt; \"DataFrameValidationError\":\n        \"\"\"Create error for missing columns in mapping.\n\n        Args:\n            missing_columns (list[str]): List of missing column names.\n            required (list[str]): List of required column names.\n            mapping (dict[str, str]): The column mapping that was provided.\n\n        Returns:\n            DataFrameValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = DataFrameValidationError.missing_columns_mapping(\n            ...     [\"price\"], [\"time\", \"price\"], {\"time\": \"timestamp\"}\n            ... )\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Build detailed message showing what's missing\n        message = (\n            f\"Missing required columns in column_mapping: {missing_columns}\\n\"\n            f\"Required columns: {required}\\n\"\n            f\"Column mapping: {mapping}\"\n        )\n        # Create instance with detailed mapping error message\n        return cls(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError--error-dataframe-is-missing-required-column-price","title":"Error: DataFrame is missing required column: price","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.missing_column","title":"missing_column  <code>classmethod</code>","text":"<pre><code>missing_column(column: str) -&gt; DataFrameValidationError\n</code></pre> <p>Create error for missing DataFrame column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Name of the missing column.</p> required <p>Returns:</p> Name Type Description <code>DataFrameValidationError</code> <code>DataFrameValidationError</code> <p>Configured error instance.</p> Example <p>error = DataFrameValidationError.missing_column(\"time\") raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef missing_column(cls, column: str) -&gt; \"DataFrameValidationError\":\n    \"\"\"Create error for missing DataFrame column.\n\n    Args:\n        column (str): Name of the missing column.\n\n    Returns:\n        DataFrameValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = DataFrameValidationError.missing_column(\"time\")\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with missing column message\n    return cls(f\"DataFrame is missing required column: {column}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.invalid_data_type","title":"invalid_data_type  <code>classmethod</code>","text":"<pre><code>invalid_data_type(data_type: type) -&gt; DataFrameValidationError\n</code></pre> <p>Create error for invalid data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>type</code> <p>The invalid data type provided.</p> required <p>Returns:</p> Name Type Description <code>DataFrameValidationError</code> <code>DataFrameValidationError</code> <p>Configured error instance.</p> Example <p>error = DataFrameValidationError.invalid_data_type(str) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef invalid_data_type(\n    cls, data_type: type\n) -&gt; \"DataFrameValidationError\":\n    \"\"\"Create error for invalid data type.\n\n    Args:\n        data_type (type): The invalid data type provided.\n\n    Returns:\n        DataFrameValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = DataFrameValidationError.invalid_data_type(str)\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with invalid data type message\n    return cls(\n        f\"data must be a list of SingleValueData objects, DataFrame, \"\n        f\"or Series, got {data_type}\"\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.missing_columns_mapping","title":"missing_columns_mapping  <code>classmethod</code>","text":"<pre><code>missing_columns_mapping(missing_columns: list[str], required: list[str], mapping: dict[str, str]) -&gt; DataFrameValidationError\n</code></pre> <p>Create error for missing columns in mapping.</p> <p>Parameters:</p> Name Type Description Default <code>missing_columns</code> <code>list[str]</code> <p>List of missing column names.</p> required <code>required</code> <code>list[str]</code> <p>List of required column names.</p> required <code>mapping</code> <code>dict[str, str]</code> <p>The column mapping that was provided.</p> required <p>Returns:</p> Name Type Description <code>DataFrameValidationError</code> <code>DataFrameValidationError</code> <p>Configured error instance.</p> Example <p>error = DataFrameValidationError.missing_columns_mapping( ...     [\"price\"], [\"time\", \"price\"], {\"time\": \"timestamp\"} ... ) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef missing_columns_mapping(\n    cls,\n    missing_columns: list[str],\n    required: list[str],\n    mapping: dict[str, str],\n) -&gt; \"DataFrameValidationError\":\n    \"\"\"Create error for missing columns in mapping.\n\n    Args:\n        missing_columns (list[str]): List of missing column names.\n        required (list[str]): List of required column names.\n        mapping (dict[str, str]): The column mapping that was provided.\n\n    Returns:\n        DataFrameValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = DataFrameValidationError.missing_columns_mapping(\n        ...     [\"price\"], [\"time\", \"price\"], {\"time\": \"timestamp\"}\n        ... )\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Build detailed message showing what's missing\n    message = (\n        f\"Missing required columns in column_mapping: {missing_columns}\\n\"\n        f\"Required columns: {required}\\n\"\n        f\"Column mapping: {mapping}\"\n    )\n    # Create instance with detailed mapping error message\n    return cls(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError","title":"TimeValidationError","text":"<p>Raised when time validation fails.</p> <p>This exception is used for time-related validation errors such as invalid time strings or unsupported time types.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of the time validation failure.</p> required Example <p>raise TimeValidationError(\"Invalid timestamp format\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TimeValidationError(ValidationError):\n    \"\"\"Raised when time validation fails.\n\n    This exception is used for time-related validation errors such as\n    invalid time strings or unsupported time types.\n\n    Args:\n        message (str): Description of the time validation failure.\n\n    Example:\n        &gt;&gt;&gt; raise TimeValidationError(\"Invalid timestamp format\")\n        # Error: Time validation failed: Invalid timestamp format\n    \"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize TimeValidationError.\n\n        Args:\n            message (str): Time validation failure description.\n        \"\"\"\n        # Prefix message with \"Time validation failed:\"\n        super().__init__(f\"Time validation failed: {message}\")\n\n    @classmethod\n    def invalid_time_string(cls, time_value: str) -&gt; \"TimeValidationError\":\n        \"\"\"Create error for invalid time string.\n\n        Args:\n            time_value (str): The invalid time string.\n\n        Returns:\n            TimeValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = TimeValidationError.invalid_time_string(\"not-a-date\")\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with invalid time string message\n        return cls(f\"Invalid time string: {time_value!r}\")\n\n    @classmethod\n    def unsupported_type(cls, time_type: type) -&gt; \"TimeValidationError\":\n        \"\"\"Create error for unsupported time type.\n\n        Args:\n            time_type (type): The unsupported type.\n\n        Returns:\n            TimeValidationError: Configured error instance.\n\n        Example:\n            &gt;&gt;&gt; error = TimeValidationError.unsupported_type(list)\n            &gt;&gt;&gt; raise error\n        \"\"\"\n        # Create instance with unsupported type message\n        return cls(f\"Unsupported time type {time_type.__name__}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError--error-time-validation-failed-invalid-timestamp-format","title":"Error: Time validation failed: Invalid timestamp format","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError.invalid_time_string","title":"invalid_time_string  <code>classmethod</code>","text":"<pre><code>invalid_time_string(time_value: str) -&gt; TimeValidationError\n</code></pre> <p>Create error for invalid time string.</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>str</code> <p>The invalid time string.</p> required <p>Returns:</p> Name Type Description <code>TimeValidationError</code> <code>TimeValidationError</code> <p>Configured error instance.</p> Example <p>error = TimeValidationError.invalid_time_string(\"not-a-date\") raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef invalid_time_string(cls, time_value: str) -&gt; \"TimeValidationError\":\n    \"\"\"Create error for invalid time string.\n\n    Args:\n        time_value (str): The invalid time string.\n\n    Returns:\n        TimeValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = TimeValidationError.invalid_time_string(\"not-a-date\")\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with invalid time string message\n    return cls(f\"Invalid time string: {time_value!r}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError.unsupported_type","title":"unsupported_type  <code>classmethod</code>","text":"<pre><code>unsupported_type(time_type: type) -&gt; TimeValidationError\n</code></pre> <p>Create error for unsupported time type.</p> <p>Parameters:</p> Name Type Description Default <code>time_type</code> <code>type</code> <p>The unsupported type.</p> required <p>Returns:</p> Name Type Description <code>TimeValidationError</code> <code>TimeValidationError</code> <p>Configured error instance.</p> Example <p>error = TimeValidationError.unsupported_type(list) raise error</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef unsupported_type(cls, time_type: type) -&gt; \"TimeValidationError\":\n    \"\"\"Create error for unsupported time type.\n\n    Args:\n        time_type (type): The unsupported type.\n\n    Returns:\n        TimeValidationError: Configured error instance.\n\n    Example:\n        &gt;&gt;&gt; error = TimeValidationError.unsupported_type(list)\n        &gt;&gt;&gt; raise error\n    \"\"\"\n    # Create instance with unsupported type message\n    return cls(f\"Unsupported time type {time_type.__name__}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.UnsupportedTimeTypeError","title":"UnsupportedTimeTypeError","text":"<p>Raised when time type is unsupported.</p> <p>Parameters:</p> Name Type Description Default <code>time_type</code> <code>type</code> <p>The unsupported time type.</p> required Example <p>raise UnsupportedTimeTypeError(list)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class UnsupportedTimeTypeError(TypeValidationError):\n    \"\"\"Raised when time type is unsupported.\n\n    Args:\n        time_type (type): The unsupported time type.\n\n    Example:\n        &gt;&gt;&gt; raise UnsupportedTimeTypeError(list)\n        # Error: time unsupported type, got list\n    \"\"\"\n\n    def __init__(self, time_type: type):\n        \"\"\"Initialize UnsupportedTimeTypeError.\n\n        Args:\n            time_type (type): The unsupported type provided.\n        \"\"\"\n        # Use predefined message for unsupported time types\n        super().__init__(\"time\", \"unsupported type\", time_type.__name__)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.UnsupportedTimeTypeError--error-time-unsupported-type-got-list","title":"Error: time unsupported type, got list","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InvalidMarkerPositionError","title":"InvalidMarkerPositionError","text":"<p>Raised when marker position is invalid.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The invalid position value.</p> required <code>marker_type</code> <code>str</code> <p>The type of marker.</p> required Example <p>raise InvalidMarkerPositionError(\"top\", \"circle\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class InvalidMarkerPositionError(ValidationError):\n    \"\"\"Raised when marker position is invalid.\n\n    Args:\n        position (str): The invalid position value.\n        marker_type (str): The type of marker.\n\n    Example:\n        &gt;&gt;&gt; raise InvalidMarkerPositionError(\"top\", \"circle\")\n        # Error: Invalid position 'top' for marker type circle\n    \"\"\"\n\n    def __init__(self, position: str, marker_type: str):\n        \"\"\"Initialize InvalidMarkerPositionError.\n\n        Args:\n            position (str): The invalid position string.\n            marker_type (str): Type of marker being configured.\n        \"\"\"\n        # Format message with position and marker type\n        super().__init__(\n            f\"Invalid position '{position}' for marker type {marker_type}\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InvalidMarkerPositionError--error-invalid-position-top-for-marker-type-circle","title":"Error: Invalid position 'top' for marker type circle","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColumnMappingRequiredError","title":"ColumnMappingRequiredError","text":"<p>Raised when column mapping is required but not provided.</p> <p>This exception is used when DataFrame or Series data is provided without the necessary column mapping configuration.</p> Example <p>raise ColumnMappingRequiredError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ColumnMappingRequiredError(RequiredFieldError):\n    \"\"\"Raised when column mapping is required but not provided.\n\n    This exception is used when DataFrame or Series data is provided\n    without the necessary column mapping configuration.\n\n    Example:\n        &gt;&gt;&gt; raise ColumnMappingRequiredError()\n        # Error: column_mapping is required when providing DataFrame or\n        # Series data is required\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize ColumnMappingRequiredError with standard message.\"\"\"\n        # Use predefined message for missing column mapping\n        super().__init__(\n            \"column_mapping is required when providing DataFrame or \"\n            \"Series data\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColumnMappingRequiredError--error-column_mapping-is-required-when-providing-dataframe-or","title":"Error: column_mapping is required when providing DataFrame or","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColumnMappingRequiredError--series-data-is-required","title":"Series data is required","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataItemsTypeError","title":"DataItemsTypeError","text":"<p>Raised when data items are not correct type.</p> <p>This exception indicates that items in a data list are not instances of Data class or its subclasses.</p> Example <p>raise DataItemsTypeError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DataItemsTypeError(TypeValidationError):\n    \"\"\"Raised when data items are not correct type.\n\n    This exception indicates that items in a data list are not instances\n    of Data class or its subclasses.\n\n    Example:\n        &gt;&gt;&gt; raise DataItemsTypeError()\n        # Error: All items in data list must be instances of Data or its\n        # subclasses\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize DataItemsTypeError with standard message.\"\"\"\n        # Use predefined message for data items type errors\n        super().__init__(\n            \"All items in data list\",\n            \"instances of Data or its subclasses\",\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataItemsTypeError--error-all-items-in-data-list-must-be-instances-of-data-or-its","title":"Error: All items in data list must be instances of Data or its","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataItemsTypeError--subclasses","title":"subclasses","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ExitTimeAfterEntryTimeError","title":"ExitTimeAfterEntryTimeError","text":"<p>Raised when exit time must be after entry time.</p> <p>This exception is used in trading-related functionality where exit time must logically come after entry time.</p> Example <p>raise ExitTimeAfterEntryTimeError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ExitTimeAfterEntryTimeError(ValueValidationError):\n    \"\"\"Raised when exit time must be after entry time.\n\n    This exception is used in trading-related functionality where exit\n    time must logically come after entry time.\n\n    Example:\n        &gt;&gt;&gt; raise ExitTimeAfterEntryTimeError()\n        # Error: Exit time must be after entry time\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize ExitTimeAfterEntryTimeError with standard message.\"\"\"\n        # Use predefined message for time ordering errors\n        super().__init__(\"Exit time\", \"must be after entry time\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ExitTimeAfterEntryTimeError--error-exit-time-must-be-after-entry-time","title":"Error: Exit time must be after entry time","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InstanceTypeError","title":"InstanceTypeError","text":"<p>Raised when value must be an instance of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of the attribute being validated.</p> required <code>value_type</code> <code>type</code> <p>The required type.</p> required <code>allow_none</code> <code>bool</code> <p>Whether None is allowed as a valid value.</p> <code>False</code> Example <p>raise InstanceTypeError(\"series\", Series, allow_none=True)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class InstanceTypeError(TypeValidationError):\n    \"\"\"Raised when value must be an instance of a specific type.\n\n    Args:\n        attr_name (str): Name of the attribute being validated.\n        value_type (type): The required type.\n        allow_none (bool): Whether None is allowed as a valid value.\n\n    Example:\n        &gt;&gt;&gt; raise InstanceTypeError(\"series\", Series, allow_none=True)\n        # Error: series must be an instance of Series or None\n    \"\"\"\n\n    def __init__(\n        self, attr_name: str, value_type: type, allow_none: bool = False\n    ):\n        \"\"\"Initialize InstanceTypeError.\n\n        Args:\n            attr_name (str): Attribute name being validated.\n            value_type (type): Required type for the value.\n            allow_none (bool): Whether None is acceptable.\n        \"\"\"\n        # Build message based on whether None is allowed\n        if allow_none:\n            # Include \"or None\" in the message\n            message = f\"an instance of {value_type.__name__} or None\"\n        else:\n            # Only require the specific type\n            message = f\"an instance of {value_type.__name__}\"\n\n        # Call parent TypeValidationError with formatted message\n        super().__init__(attr_name, message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InstanceTypeError--error-series-must-be-an-instance-of-series-or-none","title":"Error: series must be an instance of Series or None","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeMismatchError","title":"TypeMismatchError","text":"<p>Raised when type mismatch occurs.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of the attribute with type mismatch.</p> required <code>value_type</code> <code>type</code> <p>The expected type.</p> required <code>actual_type</code> <code>type</code> <p>The actual type received.</p> required Example <p>raise TypeMismatchError(\"count\", int, str)</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TypeMismatchError(TypeValidationError):\n    \"\"\"Raised when type mismatch occurs.\n\n    Args:\n        attr_name (str): Name of the attribute with type mismatch.\n        value_type (type): The expected type.\n        actual_type (type): The actual type received.\n\n    Example:\n        &gt;&gt;&gt; raise TypeMismatchError(\"count\", int, str)\n        # Error: count must be of type int, got str\n    \"\"\"\n\n    def __init__(self, attr_name: str, value_type: type, actual_type: type):\n        \"\"\"Initialize TypeMismatchError.\n\n        Args:\n            attr_name (str): Attribute name being validated.\n            value_type (type): Expected type.\n            actual_type (type): Actual type received.\n        \"\"\"\n        # Format message with expected and actual type names\n        super().__init__(\n            attr_name,\n            f\"must be of type {value_type.__name__}\",\n            actual_type.__name__,\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeMismatchError--error-count-must-be-of-type-int-got-str","title":"Error: count must be of type int, got str","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TrendDirectionIntegerError","title":"TrendDirectionIntegerError","text":"<p>Raised when trend direction is not an integer.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field containing trend direction.</p> required <code>expected_type</code> <code>str</code> <p>Description of expected type.</p> required <code>actual_type</code> <code>str</code> <p>Description of actual type.</p> required Example <p>raise TrendDirectionIntegerError(\"direction\", \"int\", \"float\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TrendDirectionIntegerError(TypeValidationError):\n    \"\"\"Raised when trend direction is not an integer.\n\n    Args:\n        field_name (str): Name of the field containing trend direction.\n        expected_type (str): Description of expected type.\n        actual_type (str): Description of actual type.\n\n    Example:\n        &gt;&gt;&gt; raise TrendDirectionIntegerError(\"direction\", \"int\", \"float\")\n        # Error: direction must be int, got float\n    \"\"\"\n\n    def __init__(\n        self, field_name: str, expected_type: str, actual_type: str\n    ):\n        \"\"\"Initialize TrendDirectionIntegerError.\n\n        Args:\n            field_name (str): Field name being validated.\n            expected_type (str): Expected type description.\n            actual_type (str): Actual type description.\n        \"\"\"\n        # Format message with type requirement\n        super().__init__(field_name, f\"must be {expected_type}\", actual_type)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TrendDirectionIntegerError--error-direction-must-be-int-got-float","title":"Error: direction must be int, got float","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.BaseValueFormatError","title":"BaseValueFormatError","text":"<p>Raised when base value format is invalid.</p> <p>This exception is used when a base value dictionary doesn't contain the required 'type' and 'price' keys.</p> Example <p>raise BaseValueFormatError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class BaseValueFormatError(ValidationError):\n    \"\"\"Raised when base value format is invalid.\n\n    This exception is used when a base value dictionary doesn't contain\n    the required 'type' and 'price' keys.\n\n    Example:\n        &gt;&gt;&gt; raise BaseValueFormatError()\n        # Error: Base value must be a dict with 'type' and 'price' keys\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize BaseValueFormatError with standard message.\"\"\"\n        # Use predefined message for base value format errors\n        super().__init__(\n            \"Base value must be a dict with 'type' and 'price' keys\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.BaseValueFormatError--error-base-value-must-be-a-dict-with-type-and-price-keys","title":"Error: Base value must be a dict with 'type' and 'price' keys","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NotFoundError","title":"NotFoundError","text":"<p>Raised when a requested resource is not found.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Type of resource (e.g., \"Series\", \"Chart\").</p> required <code>identifier</code> <code>str</code> <p>Identifier used to search for the resource.</p> required Example <p>raise NotFoundError(\"Series\", \"main-series\")</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class NotFoundError(ValidationError):\n    \"\"\"Raised when a requested resource is not found.\n\n    Args:\n        resource_type (str): Type of resource (e.g., \"Series\", \"Chart\").\n        identifier (str): Identifier used to search for the resource.\n\n    Example:\n        &gt;&gt;&gt; raise NotFoundError(\"Series\", \"main-series\")\n        # Error: Series with identifier 'main-series' not found\n    \"\"\"\n\n    def __init__(self, resource_type: str, identifier: str):\n        \"\"\"Initialize NotFoundError.\n\n        Args:\n            resource_type (str): Type of the missing resource.\n            identifier (str): Identifier that was searched for.\n        \"\"\"\n        # Format message with resource type and identifier\n        super().__init__(\n            f\"{resource_type} with identifier '{identifier}' not found\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NotFoundError--error-series-with-identifier-main-series-not-found","title":"Error: Series with identifier 'main-series' not found","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NpmNotFoundError","title":"NpmNotFoundError","text":"<p>Raised when NPM is not found in the system PATH.</p> <p>This error occurs during frontend build operations when NPM (Node Package Manager) is not installed or not accessible.</p> Example <p>raise NpmNotFoundError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class NpmNotFoundError(ConfigurationError):\n    \"\"\"Raised when NPM is not found in the system PATH.\n\n    This error occurs during frontend build operations when NPM\n    (Node Package Manager) is not installed or not accessible.\n\n    Example:\n        &gt;&gt;&gt; raise NpmNotFoundError()\n        # Error: NPM not found in system PATH. Please install Node.js\n        # and NPM to build frontend assets.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize NpmNotFoundError with standard message.\"\"\"\n        # Use predefined message for NPM not found errors\n        message = (\n            \"NPM not found in system PATH. Please install Node.js and NPM \"\n            \"to build frontend assets.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NpmNotFoundError--error-npm-not-found-in-system-path-please-install-nodejs","title":"Error: NPM not found in system PATH. Please install Node.js","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NpmNotFoundError--and-npm-to-build-frontend-assets","title":"and NPM to build frontend assets.","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.CliNotFoundError","title":"CliNotFoundError","text":"<p>Raised when CLI is not found in the system PATH.</p> <p>This error occurs when the package CLI tools are not properly installed or accessible.</p> Example <p>raise CliNotFoundError()</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class CliNotFoundError(ConfigurationError):\n    \"\"\"Raised when CLI is not found in the system PATH.\n\n    This error occurs when the package CLI tools are not properly\n    installed or accessible.\n\n    Example:\n        &gt;&gt;&gt; raise CliNotFoundError()\n        # Error: CLI not found in system PATH. Please ensure the package\n        # is properly installed.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize CliNotFoundError with standard message.\"\"\"\n        # Use predefined message for CLI not found errors\n        message = (\n            \"CLI not found in system PATH. Please ensure the package is \"\n            \"properly installed.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.CliNotFoundError--error-cli-not-found-in-system-path-please-ensure-the-package","title":"Error: CLI not found in system PATH. Please ensure the package","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.CliNotFoundError--is-properly-installed","title":"is properly installed.","text":""},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html","title":"streamlit_lightweight_charts_pro.logging_config","text":""},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config","title":"logging_config","text":"<p>Logging configuration for Streamlit Lightweight Charts Pro.</p> <p>This module provides centralized logging configuration for the package, ensuring consistent logging behavior across all components. It handles logger initialization, formatting, handler management, and prevents common logging pitfalls like duplicate handlers.</p> The module provides <ul> <li>Root logger configuration with customizable levels</li> <li>Component-specific logger retrieval with proper naming</li> <li>Automatic handler management to prevent duplicates</li> <li>Consistent log format across the package</li> <li>Production-ready default settings (ERROR level)</li> </ul> Key Features <ul> <li>Centralized logging configuration</li> <li>Customizable log levels and formats</li> <li>Automatic duplicate handler prevention</li> <li>Hierarchical logger naming convention</li> <li>Thread-safe logger retrieval</li> <li>stdout/stderr stream handling</li> </ul> Example <p>Basic logging setup::</p> <pre><code>from streamlit_lightweight_charts_pro.logging_config import (\n    setup_logging,\n    get_logger\n)\nimport logging\n\n# Set up logging with INFO level\nsetup_logging(level=logging.INFO)\n\n# Get a logger for chart rendering component\nlogger = get_logger(\"chart_rendering\")\nlogger.info(\"Chart rendered successfully\")\n</code></pre> <p>Custom log format::</p> <pre><code># Define custom format\ncustom_format = \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\"\n\n# Setup with custom format\nsetup_logging(level=logging.DEBUG, log_format=custom_format)\n</code></pre> Note <p>The module automatically initializes logging with ERROR level at import time. Call setup_logging() to change the configuration.</p>"},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level: int = WARN, log_format: Optional[str] = None, stream: Optional[StreamHandler] = None) -&gt; Logger\n</code></pre> <p>Set up logging configuration for the package.</p> <p>This function configures the root logger for the package with the specified settings. It ensures that logging is properly initialized and prevents duplicate handlers from being added on repeated calls.</p> <p>The function creates a logger hierarchy under the package name \"streamlit_lightweight_charts_pro\", allowing for fine-grained control over logging for different components.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level to set for the root logger. Defaults to logging.WARN for production use. Common values:     - logging.DEBUG: Detailed information for diagnosing     - logging.INFO: General informational messages     - logging.WARNING: Warning messages (default)     - logging.ERROR: Error messages     - logging.CRITICAL: Critical error messages</p> <code>WARN</code> <code>log_format</code> <code>Optional[str]</code> <p>Custom log format string using Python logging format codes. If None, uses a standard format that includes timestamp, logger name, level, and message. Example: \"%(asctime)s - %(levelname)s - %(message)s\"</p> <code>None</code> <code>stream</code> <code>Optional[StreamHandler]</code> <p>Custom stream handler for log output. If None, creates a StreamHandler that writes to sys.stdout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The configured root logger instance for the package with the name \"streamlit_lightweight_charts_pro\".</p> Example <p>Basic setup::</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logger = setup_logging(level=logging.INFO)\n&gt;&gt;&gt; logger.info(\"Logging configured\")\n</code></pre> <p>Custom format setup::</p> <pre><code>&gt;&gt;&gt; custom_format = \"%(levelname)s: %(message)s\"\n&gt;&gt;&gt; logger = setup_logging(\n...     level=logging.DEBUG,\n...     log_format=custom_format\n... )\n</code></pre> Note <p>This function is idempotent - calling it multiple times with the same logger won't create duplicate handlers. However, the level will be updated on subsequent calls.</p> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def setup_logging(\n    level: int = logging.WARN,\n    log_format: Optional[str] = None,\n    stream: Optional[logging.StreamHandler] = None,\n) -&gt; logging.Logger:\n    \"\"\"Set up logging configuration for the package.\n\n    This function configures the root logger for the package with the\n    specified settings. It ensures that logging is properly initialized\n    and prevents duplicate handlers from being added on repeated calls.\n\n    The function creates a logger hierarchy under the package name\n    \"streamlit_lightweight_charts_pro\", allowing for fine-grained\n    control over logging for different components.\n\n    Args:\n        level (int, optional): Logging level to set for the root logger.\n            Defaults to logging.WARN for production use. Common values:\n                - logging.DEBUG: Detailed information for diagnosing\n                - logging.INFO: General informational messages\n                - logging.WARNING: Warning messages (default)\n                - logging.ERROR: Error messages\n                - logging.CRITICAL: Critical error messages\n        log_format (Optional[str]): Custom log format string using\n            Python logging format codes. If None, uses a standard format\n            that includes timestamp, logger name, level, and message.\n            Example: \"%(asctime)s - %(levelname)s - %(message)s\"\n        stream (Optional[logging.StreamHandler]): Custom stream handler\n            for log output. If None, creates a StreamHandler that writes\n            to sys.stdout.\n\n    Returns:\n        logging.Logger: The configured root logger instance for the\n            package with the name \"streamlit_lightweight_charts_pro\".\n\n    Example:\n        Basic setup::\n\n            &gt;&gt;&gt; import logging\n            &gt;&gt;&gt; logger = setup_logging(level=logging.INFO)\n            &gt;&gt;&gt; logger.info(\"Logging configured\")\n\n        Custom format setup::\n\n            &gt;&gt;&gt; custom_format = \"%(levelname)s: %(message)s\"\n            &gt;&gt;&gt; logger = setup_logging(\n            ...     level=logging.DEBUG,\n            ...     log_format=custom_format\n            ... )\n\n    Note:\n        This function is idempotent - calling it multiple times with\n        the same logger won't create duplicate handlers. However, the\n        level will be updated on subsequent calls.\n    \"\"\"\n    # Create or retrieve the root logger for this package\n    # Using a specific package name creates a logger hierarchy\n    # This allows filtering logs by package if needed\n    logger = logging.getLogger(\"streamlit_lightweight_charts_pro\")\n\n    # Set the logging level for this logger\n    # This controls which messages are processed by this logger\n    logger.setLevel(level)\n\n    # Check if handlers already exist to avoid duplicates\n    # Multiple handler additions would result in duplicate log entries\n    if logger.handlers:\n        # Handlers already configured, return existing logger\n        # This makes the function idempotent (safe to call multiple times)\n        return logger\n\n    # Set default format if not provided by user\n    # Format includes:\n    # - %(asctime)s: Timestamp when log entry was created\n    # - %(name)s: Logger name (useful for hierarchical loggers)\n    # - %(levelname)s: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    # - %(message)s: The actual log message\n    if log_format is None:\n        log_format = (\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n\n    # Create formatter to format log messages according to format string\n    # This formatter will be applied to all messages handled by this logger\n    formatter = logging.Formatter(log_format)\n\n    # Create stream handler if not provided\n    # Stream handler sends log messages to a stream (stdout, stderr, file)\n    if stream is None:\n        # Create handler that writes to stdout (standard output)\n        # Using stdout instead of stderr for better integration with\n        # Streamlit which captures stdout\n        stream = logging.StreamHandler(sys.stdout)\n\n        # Set level on the handler itself\n        # Handler level acts as a secondary filter after logger level\n        stream.setLevel(level)\n\n        # Apply the formatter to the handler\n        # This determines how log messages will be formatted when output\n        stream.setFormatter(formatter)\n\n    # Add the configured handler to the logger\n    # The logger will now send messages to this handler for output\n    logger.addHandler(stream)\n\n    # Return the configured logger instance\n    # Caller can use this to log messages immediately\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: Optional[str] = None, level: int = DEBUG) -&gt; Logger\n</code></pre> <p>Get a logger instance for the package.</p> <p>This function creates or retrieves a logger instance with proper naming convention. The logger name is automatically prefixed with the package name to maintain logger hierarchy and enable filtering.</p> <p>Logger names follow the pattern: \"streamlit_lightweight_charts_pro.{component_name}\"</p> This hierarchical naming allows <ul> <li>Filtering logs by component</li> <li>Different log levels per component</li> <li>Inheritance of configuration from root logger</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Component name to append to package name. If None, returns the root package logger. The full logger name will be \"streamlit_lightweight_charts_pro.{name}\". Examples: \"chart_rendering\", \"data_processing\", \"validation\"</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level for this specific logger. Defaults to logging.DEBUG for detailed logging. This level is set on the logger instance and can be overridden by parent logger settings.</p> <code>DEBUG</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: A logger instance with the specified name and level. The logger inherits configuration from the root package logger.</p> Example <p>Get root logger::</p> <pre><code>&gt;&gt;&gt; root_logger = get_logger()\n&gt;&gt;&gt; root_logger.error(\"Critical error\")\n</code></pre> <p>Get component logger::</p> <pre><code>&gt;&gt;&gt; chart_logger = get_logger(\"chart_rendering\")\n&gt;&gt;&gt; chart_logger.info(\"Chart initialized\")\n</code></pre> <p>Get logger with custom level::</p> <pre><code>&gt;&gt;&gt; data_logger = get_logger(\"data\", level=logging.WARNING)\n&gt;&gt;&gt; data_logger.warning(\"Data validation failed\")\n</code></pre> Note <p>The logger inherits handlers and formatters from the root package logger configured by setup_logging(). You don't need to configure handlers for component loggers.</p> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def get_logger(\n    name: Optional[str] = None, level: int = logging.DEBUG\n) -&gt; logging.Logger:\n    \"\"\"Get a logger instance for the package.\n\n    This function creates or retrieves a logger instance with proper\n    naming convention. The logger name is automatically prefixed with\n    the package name to maintain logger hierarchy and enable filtering.\n\n    Logger names follow the pattern:\n    \"streamlit_lightweight_charts_pro.{component_name}\"\n\n    This hierarchical naming allows:\n        - Filtering logs by component\n        - Different log levels per component\n        - Inheritance of configuration from root logger\n\n    Args:\n        name (Optional[str]): Component name to append to package name.\n            If None, returns the root package logger. The full logger\n            name will be \"streamlit_lightweight_charts_pro.{name}\".\n            Examples: \"chart_rendering\", \"data_processing\", \"validation\"\n        level (int, optional): Logging level for this specific logger.\n            Defaults to logging.DEBUG for detailed logging. This level\n            is set on the logger instance and can be overridden by\n            parent logger settings.\n\n    Returns:\n        logging.Logger: A logger instance with the specified name\n            and level. The logger inherits configuration from the\n            root package logger.\n\n    Example:\n        Get root logger::\n\n            &gt;&gt;&gt; root_logger = get_logger()\n            &gt;&gt;&gt; root_logger.error(\"Critical error\")\n\n        Get component logger::\n\n            &gt;&gt;&gt; chart_logger = get_logger(\"chart_rendering\")\n            &gt;&gt;&gt; chart_logger.info(\"Chart initialized\")\n\n        Get logger with custom level::\n\n            &gt;&gt;&gt; data_logger = get_logger(\"data\", level=logging.WARNING)\n            &gt;&gt;&gt; data_logger.warning(\"Data validation failed\")\n\n    Note:\n        The logger inherits handlers and formatters from the root\n        package logger configured by setup_logging(). You don't need\n        to configure handlers for component loggers.\n    \"\"\"\n    # Create hierarchical logger name by combining package name with\n    # component name. Example:\n    # - \"streamlit_lightweight_charts_pro.None\" becomes root logger\n    # - \"streamlit_lightweight_charts_pro.charts\" for chart component\n    # - \"streamlit_lightweight_charts_pro.data\" for data component\n    logger = logging.getLogger(f\"streamlit_lightweight_charts_pro.{name}\")\n\n    # Set the logging level for this specific logger\n    # This level filters messages before they reach the handlers\n    # Messages below this level are discarded\n    logger.setLevel(level)\n\n    # Return the configured logger instance\n    # Caller can immediately use this logger for logging\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html","title":"streamlit_lightweight_charts_pro.charts","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts","title":"charts","text":"<p>Chart classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides all chart classes including Chart and various series types for creating interactive financial charts. It serves as the main interface for chart creation and configuration in the library.</p> The module includes <ul> <li>Chart: Main chart class with fluent API and method chaining</li> <li>Series classes: LineSeries, AreaSeries, CandlestickSeries, etc.</li> <li>Options classes: Chart configuration and styling options</li> <li>Series management: Adding, updating, and removing series</li> </ul> <p>The Chart class provides a fluent API for creating charts with method chaining, making chart creation more intuitive and readable. It supports all major chart types and provides comprehensive customization options.</p> Example Usage <pre><code>from streamlit_lightweight_charts_pro.charts import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create data\ndata = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\n\n# Method 1: Direct chart creation\nchart = Chart()\nchart.add_series(LineSeries(data, color=\"#ff0000\"))\nchart.update_options(height=400)\nchart.render(key=\"my_chart\")\n\n# Method 2: Fluent API with method chaining\nchart = (\n    Chart()\n    .add_series(LineSeries(data, color=\"#ff0000\"))\n    .update_options(height=400)\n    .add_annotation(create_text_annotation(\"2024-01-01\", 100, \"Start\"))\n)\nchart.render(key=\"my_chart\")\n</code></pre> Available Series Types <ul> <li>LineSeries: Simple line charts</li> <li>AreaSeries: Filled area charts</li> <li>CandlestickSeries: Japanese candlestick charts</li> <li>BarSeries: OHLC bar charts</li> <li>HistogramSeries: Volume or distribution charts</li> <li>BaselineSeries: Relative to baseline charts</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart","title":"Chart","text":"<p>Single pane chart for displaying financial data.</p> <p>This class represents a single pane chart that can display multiple series of financial data. It supports various chart types including candlestick, line, area, bar, and histogram series. The chart includes comprehensive annotation support, trade visualization, and method chaining for fluent API usage.</p> <p>The Chart class uses a manager-based architecture where each manager handles a specific aspect of chart functionality. This design provides clear separation of concerns and makes the codebase easier to maintain and extend.</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects to display in the chart. This is exposed for backward compatibility and delegates to SeriesManager internally.</p> <code>options</code> <code>ChartOptions</code> <p>Chart configuration options including layout, grid, time scale, price scale, etc.</p> <code>annotation_manager</code> <code>AnnotationManager</code> <p>Manager for chart annotations and layers. Handles text, arrows, shapes, and other visual elements.</p> <code>force_reinit</code> <code>bool</code> <p>Flag to force frontend re-initialization. Set to True when indicator parameters or other settings change that require the chart to be completely rebuilt on the frontend.</p> Private Attributes <p>_series_manager (SeriesManager): Manages all data series. _price_scale_manager (PriceScaleManager): Manages price scale config. _trade_manager (TradeManager): Manages trade visualization. _session_state_manager (SessionStateManager): Manages state persistence. _chart_renderer (ChartRenderer): Handles rendering pipeline. _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips. _chart_group_id (int): Group ID for chart synchronization. _chart_manager (Optional[Any]): Reference to parent ChartManager.</p> Example <p>Basic usage::</p> <pre><code># Create a simple line chart\nchart = Chart(series=LineSeries(data))\n\n# Configure options\nchart.update_options(height=400, width=800)\n\n# Render in Streamlit\nchart.render(key=\"my_chart\")\n</code></pre> <p>With method chaining::</p> <pre><code>chart = (\n    Chart(series=LineSeries(data))\n    .update_options(height=400)\n    .add_annotation(text_annotation)\n    .add_series(candlestick_series)\n)\nchart.render()\n</code></pre> <p>From DataFrame with price and volume::</p> <pre><code>chart = Chart.from_price_volume_dataframe(\n    df,\n    column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n    price_type=\"candlestick\"\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>class Chart:\n    \"\"\"Single pane chart for displaying financial data.\n\n    This class represents a single pane chart that can display multiple\n    series of financial data. It supports various chart types including\n    candlestick, line, area, bar, and histogram series. The chart includes\n    comprehensive annotation support, trade visualization, and method chaining\n    for fluent API usage.\n\n    The Chart class uses a manager-based architecture where each manager\n    handles a specific aspect of chart functionality. This design provides\n    clear separation of concerns and makes the codebase easier to maintain\n    and extend.\n\n    Attributes:\n        series (List[Series]): List of series objects to display in the chart.\n            This is exposed for backward compatibility and delegates to\n            SeriesManager internally.\n        options (ChartOptions): Chart configuration options including layout,\n            grid, time scale, price scale, etc.\n        annotation_manager (AnnotationManager): Manager for chart annotations\n            and layers. Handles text, arrows, shapes, and other visual elements.\n        force_reinit (bool): Flag to force frontend re-initialization. Set to\n            True when indicator parameters or other settings change that require\n            the chart to be completely rebuilt on the frontend.\n\n    Private Attributes:\n        _series_manager (SeriesManager): Manages all data series.\n        _price_scale_manager (PriceScaleManager): Manages price scale config.\n        _trade_manager (TradeManager): Manages trade visualization.\n        _session_state_manager (SessionStateManager): Manages state persistence.\n        _chart_renderer (ChartRenderer): Handles rendering pipeline.\n        _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips.\n        _chart_group_id (int): Group ID for chart synchronization.\n        _chart_manager (Optional[Any]): Reference to parent ChartManager.\n\n    Example:\n        Basic usage::\n\n            # Create a simple line chart\n            chart = Chart(series=LineSeries(data))\n\n            # Configure options\n            chart.update_options(height=400, width=800)\n\n            # Render in Streamlit\n            chart.render(key=\"my_chart\")\n\n        With method chaining::\n\n            chart = (\n                Chart(series=LineSeries(data))\n                .update_options(height=400)\n                .add_annotation(text_annotation)\n                .add_series(candlestick_series)\n            )\n            chart.render()\n\n        From DataFrame with price and volume::\n\n            chart = Chart.from_price_volume_dataframe(\n                df,\n                column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n                price_type=\"candlestick\"\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        series: Optional[Union[Series, List[Series]]] = None,\n        options: Optional[ChartOptions] = None,\n        annotations: Optional[List[Annotation]] = None,\n        chart_group_id: int = 0,\n        chart_manager: Optional[Any] = None,\n    ):\n        \"\"\"Initialize a single pane chart.\n\n        Creates a new Chart instance with optional series, configuration options,\n        and annotations. The chart can be configured with multiple series types\n        and supports method chaining for fluent API usage.\n\n        The initialization process:\n            1. Set up chart options (use defaults if not provided)\n            2. Initialize all managers for chart functionality\n            3. Set up annotation system\n            4. Configure chart synchronization\n            5. Process initial annotations if provided\n\n        Args:\n            series: Optional single series object or list of series objects to\n                display. Each series represents a different data visualization\n                (line, candlestick, area, etc.). If None, an empty chart is\n                created.\n            options: Optional chart configuration options. If not provided,\n                default options will be used.\n            annotations: Optional list of annotations to add to the chart.\n                Annotations can include text, arrows, shapes, etc.\n            chart_group_id: Group ID for synchronization. Charts with the same\n                group ID will be synchronized. Defaults to 0.\n            chart_manager: Reference to the ChartManager that owns this chart.\n                Used to access sync configuration when rendering individual charts.\n\n        Returns:\n            Chart: Initialized chart instance ready for configuration and rendering.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list, or if\n                annotations is not a list.\n            AnnotationItemsTypeError: If any item in annotations is not an Annotation\n                instance.\n\n        Example:\n            Create empty chart::\n\n                &gt;&gt;&gt; chart = Chart()\n\n            Create chart with single series::\n\n                &gt;&gt;&gt; chart = Chart(series=LineSeries(data))\n\n            Create chart with multiple series::\n\n                &gt;&gt;&gt; chart = Chart(series=[line_series, candlestick_series])\n\n            Create chart with custom options::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     options=ChartOptions(height=600, width=800)\n                ... )\n\n            Create chart with annotations::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     annotations=[text_ann, arrow_ann]\n                ... )\n        \"\"\"\n        # Step 1: Set up chart configuration\n        # Use provided options or create default ChartOptions instance\n        # ChartOptions contains all chart-level configuration like height,\n        # width, layout, grid, time scale, price scale, etc.\n        self.options = options or ChartOptions()\n\n        # Step 2: Initialize managers for different chart functionalities\n        # Each manager handles a specific aspect of chart behavior\n\n        # SeriesManager: Manages all data series (line, candlestick, etc.)\n        # Handles series validation, ordering, and serialization\n        self._series_manager = SeriesManager(series)\n\n        # PriceScaleManager: Manages price scale configuration\n        # Handles left/right price scales and overlay price scales\n        # Overlay scales are used for volume, indicators, etc.\n        self._price_scale_manager = PriceScaleManager(\n            left_price_scale=self.options.left_price_scale,\n            right_price_scale=self.options.right_price_scale,\n            overlay_price_scales=self.options.overlay_price_scales,\n        )\n\n        # TradeManager: Manages trade visualization\n        # Converts TradeData objects to visual elements (markers, rectangles, etc.)\n        self._trade_manager = TradeManager()\n\n        # SessionStateManager: Handles state persistence across renders\n        # Manages series configurations and user interactions\n        # Stores data in Streamlit session state for persistence\n        self._session_state_manager = SessionStateManager()\n\n        # ChartRenderer: Handles the rendering pipeline\n        # Converts chart configuration to frontend format\n        # Manages component rendering and response handling\n        # Takes reference to chart_manager for sync configuration\n        self._chart_renderer = ChartRenderer(chart_manager_ref=chart_manager)\n\n        # Step 3: Set up annotation system\n        # AnnotationManager handles layers and annotation lifecycle\n        # Supports multiple layers for organizing different annotation types\n        self.annotation_manager = AnnotationManager()\n\n        # Step 4: Initialize tooltip manager for lazy loading\n        # TooltipManager is created on-demand when tooltips are configured\n        # This avoids overhead for charts that don't use custom tooltips\n        self._tooltip_manager: Optional[TooltipManager] = None\n\n        # Step 5: Initialize chart synchronization support\n        # Charts with same group_id are synchronized (crosshair, time range)\n        # This is different from ChartManager's sync_group which manages\n        # multiple charts\n        self._chart_group_id = chart_group_id\n\n        # Store reference to parent ChartManager (if this chart is managed)\n        # Used to access sync configuration when rendering\n        self._chart_manager = chart_manager\n\n        # Step 6: Initialize force re-initialization flag\n        # When True, forces frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        # that can't be updated through normal data updates\n        self.force_reinit: bool = False\n\n        # Step 7: Expose series list for backward compatibility\n        # This allows direct access to series: chart.series[0]\n        # Internally delegates to SeriesManager\n        self.series = self._series_manager.series\n\n        # Step 8: Process initial annotations if provided\n        if annotations is not None:\n            # Validate that annotations is a list\n            if not isinstance(annotations, list):\n                raise TypeValidationError(\"annotations\", \"list\")\n\n            # Validate and add each annotation\n            for annotation in annotations:\n                # Ensure each item is an Annotation instance\n                if not isinstance(annotation, Annotation):\n                    raise AnnotationItemsTypeError()\n                # Add to default annotation layer\n                self.add_annotation(annotation)\n\n    def get_stored_series_config(\n        self,\n        key: str,\n        series_index: int = 0,\n        pane_id: int = 0,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get stored configuration for a specific series.\n\n        Retrieves the stored configuration for a series from session state.\n        This is useful for applying previously saved configurations when\n        creating new series instances, enabling persistence of user\n        customizations across renders.\n\n        The stored configuration includes user-modified settings like:\n            - Colors and styles\n            - Line widths and types\n            - Visibility settings\n            - Other series-specific options\n\n        Args:\n            key: Component key used to namespace the stored configs. This should\n                match the key used when rendering the chart.\n            series_index: Index of the series (0-based). Defaults to 0.\n            pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n                charts where the same series index may exist in different panes.\n\n        Returns:\n            Dictionary of stored configuration or empty dict if none found.\n            The dictionary keys match the series option property names.\n\n        Example:\n            Get and apply stored config::\n\n                &gt;&gt;&gt; # Get stored config for first series\n                &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Apply to new series\n                &gt;&gt;&gt; if config:\n                ...     line_series = LineSeries(data)\n                ...     if \"color\" in config:\n                ...         line_series.line_options.color = config[\"color\"]\n                ...     if \"lineWidth\" in config:\n                ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n            Restore all series configs::\n\n                &gt;&gt;&gt; for i, series in enumerate(chart.series):\n                ...     config = chart.get_stored_series_config(\"my_chart\", i)\n                ...     if config:\n                ...         apply_config_to_series(series, config)\n        \"\"\"\n        # Delegate to SessionStateManager which handles the actual storage\n        # SessionStateManager uses Streamlit's session_state for persistence\n        return self._session_state_manager.get_stored_series_config(\n            key, series_index, pane_id\n        )\n\n    def add_series(self, series: Series) -&gt; \"Chart\":\n        \"\"\"Add a series to the chart.\n\n        Adds a new series object to the chart's series list. The series will be\n        displayed according to its type (line, candlestick, area, etc.) and\n        configuration options. The method automatically handles price scale\n        configuration for custom price scale IDs.\n\n        When a series is added:\n            1. Series is validated to ensure it's a Series instance\n            2. SeriesManager adds it to the series list\n            3. If series has custom price_scale_id, PriceScaleManager is notified\n            4. Series is assigned a z-index for proper layering\n\n        Args:\n            series: Series object to add to the chart. Must be an instance of a\n                Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n\n        Example:\n            Add a candlestick series::\n\n                &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n            Add a line series with custom options::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n                &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n                &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n            Add series with custom price scale::\n\n                &gt;&gt;&gt; # Series with custom price scale ID\n                &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n                &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add overlay price scale configuration\n                &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add the series\n                &gt;&gt;&gt; chart.add_series(volume_series)\n        \"\"\"\n        # Delegate to SeriesManager which handles validation and storage\n        # Also pass PriceScaleManager reference so it can be notified of\n        # custom price scale IDs\n        self._series_manager.add_series(series, self._price_scale_manager)\n\n        # Return self to enable method chaining\n        return self\n\n    def update_options(self, **kwargs) -&gt; \"Chart\":\n        \"\"\"Update chart options.\n\n        Updates the chart's configuration options using keyword arguments.\n        Only valid ChartOptions attributes will be updated; invalid attributes\n        are silently ignored to support method chaining and forward compatibility.\n\n        The method performs type checking to ensure new values match the\n        expected types of the chart options. This prevents runtime errors\n        from invalid configurations.\n\n        Args:\n            **kwargs: Chart options to update. Valid options include:\n                - width (Optional[int]): Chart width in pixels\n                - height (int): Chart height in pixels (default: 400)\n                - auto_size (bool): Whether to auto-size the chart\n                - handle_scroll (bool): Whether to enable scroll interactions\n                - handle_scale (bool): Whether to enable scale interactions\n                - add_default_pane (bool): Whether to add a default pane\n                And many more options defined in ChartOptions class.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Update basic dimensions::\n\n                &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n            Update interaction options::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     handle_scroll=True,\n                ...     handle_scale=False,\n                ...     auto_size=True\n                ... )\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n            Update multiple options at once::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     height=600,\n                ...     width=1200,\n                ...     auto_size=False,\n                ...     handle_scroll=True\n                ... )\n        \"\"\"\n        # Process each keyword argument to update chart options\n        for key, value in kwargs.items():\n            # Step 1: Validate the option exists and value is not None\n            # Check that the attribute exists on ChartOptions instance\n            # and that the new value is not None (None values are ignored)\n            if value is not None and hasattr(self.options, key):\n                # Step 2: Get current attribute value for type checking\n                # This helps ensure type consistency\n                current_value = getattr(self.options, key)\n\n                # Step 3: Validate type compatibility\n                # Allow update if:\n                # - New value type matches current value type, OR\n                # - Current value is None and new value is not None\n                #   (allows setting previously unset options)\n                if isinstance(value, type(current_value)) or (\n                    current_value is None and value is not None\n                ):\n                    # Update the attribute with the validated value\n                    setattr(self.options, key, value)\n\n            # Note: Invalid attributes and None values are silently ignored\n            # This enables method chaining and forward compatibility\n\n        # Return self for method chaining\n        return self\n\n    def add_annotation(\n        self, annotation: Annotation, layer_name: str = \"default\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add an annotation to the chart.\n\n        Adds a single annotation to the specified annotation layer. If the layer\n        doesn't exist, it will be created automatically. Annotations are visual\n        elements like text, arrows, shapes, and lines that provide additional\n        information or highlight specific points on the chart.\n\n        Annotations are organized into layers for better management:\n            - Each layer can contain multiple annotations\n            - Layers can be shown/hidden independently\n            - Layers can be cleared without affecting other layers\n            - Default layer is used if no layer name is specified\n\n        Args:\n            annotation (Annotation): Annotation object to add to the chart.\n                Must be a valid Annotation instance with proper configuration.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". Layer will be created if it doesn't exist.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If annotation is None or layer_name is invalid.\n            TypeValidationError: If annotation is not an Annotation instance.\n\n        Example:\n            Add text annotation::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n                ...     create_text_annotation\n                ... )\n                &gt;&gt;&gt; text_ann = create_text_annotation(\n                ...     \"2024-01-01\", 100, \"Important Event\"\n                ... )\n                &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n            Add annotation to custom layer::\n\n                &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n                &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n            Organize annotations by layer::\n\n                &gt;&gt;&gt; # Technical analysis annotations\n                &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n                &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Trading signals\n                &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n                &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n        \"\"\"\n        # Step 1: Validate annotation is not None\n        if annotation is None:\n            raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n        # Step 2: Validate annotation is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n        # Step 3: Handle layer name validation\n        # Use default layer name if None is provided\n        if layer_name is None:\n            layer_name = \"default\"\n        # Validate layer_name is a non-empty string\n        elif not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Add annotation to the specified layer\n        # AnnotationManager will create the layer if it doesn't exist\n        self.annotation_manager.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def add_annotations(\n        self,\n        annotations: List[Annotation],\n        layer_name: str = \"default\",\n    ) -&gt; \"Chart\":\n        \"\"\"Add multiple annotations to the chart.\n\n        Adds multiple annotation objects to the specified annotation layer. This\n        is more efficient than calling add_annotation multiple times as it\n        processes all annotations in a single operation and provides better\n        performance for bulk annotation operations.\n\n        All annotations are added to the same layer, enabling consistent\n        management (show/hide/clear) of related annotations.\n\n        Args:\n            annotations (List[Annotation]): List of annotation objects to add\n                to the chart. All must be valid Annotation instances.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". All annotations will be added to this layer.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If annotations is not a list.\n            ValueValidationError: If layer_name is invalid.\n            AnnotationItemsTypeError: If any item in annotations is not an\n                Annotation instance.\n\n        Example:\n            Add multiple annotations at once::\n\n                &gt;&gt;&gt; annotations = [\n                ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n                ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n                ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n                ... ]\n                &gt;&gt;&gt; chart.add_annotations(annotations)\n\n            Add to custom layer::\n\n                &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n                &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n            Bulk operations with method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n                ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n                ...  .update_options(height=600))\n        \"\"\"\n        # Step 1: Validate annotations is not None\n        if annotations is None:\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 2: Validate annotations is a list\n        if not isinstance(annotations, list):\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 3: Validate layer_name\n        if not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Validate and add each annotation\n        for annotation in annotations:\n            # Ensure each item is an Annotation instance\n            if not isinstance(annotation, Annotation):\n                raise AnnotationItemsTypeError()\n\n            # Add the annotation to the specified layer\n            # Reuses add_annotation logic for consistency\n            self.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new annotation layer with the specified name. Annotation layers\n        allow you to organize and manage groups of annotations independently.\n        Each layer can be shown, hidden, or cleared separately, providing\n        flexible control over annotation visibility.\n\n        Common use cases for layers:\n            - Separate technical analysis from trading signals\n            - Organize annotations by timeframe or strategy\n            - Group annotations by type (text, arrows, shapes)\n            - Enable/disable different annotation sets dynamically\n\n        Args:\n            name (str): Name of the annotation layer to create. Must be a\n                non-empty string and should be unique.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If name is None.\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Create custom layers for different types of annotations::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .create_annotation_layer(\"layer1\")\n                ...  .create_annotation_layer(\"layer2\")\n                ...  .add_annotation(ann1, \"layer1\")\n                ...  .add_annotation(ann2, \"layer2\"))\n\n            Organize by strategy::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n                &gt;&gt;&gt; # Add annotations specific to each strategy\n        \"\"\"\n        # Step 1: Validate name is not None\n        if name is None:\n            raise TypeValidationError(\"name\", \"string\")\n\n        # Step 2: Validate name is a non-empty string\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 3: Create the layer in AnnotationManager\n        # If layer already exists, this operation is idempotent\n        self.annotation_manager.create_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Hide an annotation layer.\n\n        Hides the specified annotation layer, making all annotations in that\n        layer invisible on the chart. The layer and its annotations are preserved\n        and can be shown again using show_annotation_layer. This is useful for\n        temporarily hiding certain annotation groups without removing them.\n\n        Hidden layers:\n            - Remain in memory with all annotations intact\n            - Can be shown again without re-adding annotations\n            - Don't affect other layers' visibility\n            - Are persisted across chart updates\n\n        Args:\n            name (str): Name of the annotation layer to hide.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Hide specific layers::\n\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .hide_annotation_layer(\"layer1\")\n                ...  .hide_annotation_layer(\"layer2\")\n                ...  .show_annotation_layer(\"layer3\"))\n\n            Toggle layer visibility::\n\n                &gt;&gt;&gt; # Hide analysis layer temporarily\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; # ... show chart without analysis\n                &gt;&gt;&gt; # Show analysis layer again\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Hide the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.hide_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Show an annotation layer.\n\n        Makes the specified annotation layer visible on the chart. This will\n        display all annotations that were previously added to this layer.\n        If the layer doesn't exist or is already visible, this method will\n        have no effect.\n\n        This is the counterpart to hide_annotation_layer and enables dynamic\n        control over which annotation groups are visible.\n\n        Args:\n            name (str): Name of the annotation layer to show.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Show specific layers::\n\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .show_annotation_layer(\"layer1\")\n                ...  .show_annotation_layer(\"layer2\")\n                ...  .hide_annotation_layer(\"layer3\"))\n\n            Conditional visibility::\n\n                &gt;&gt;&gt; # Show different layers based on user selection\n                &gt;&gt;&gt; if show_technical_analysis:\n                ...     chart.show_annotation_layer(\"ta\")\n                &gt;&gt;&gt; if show_trading_signals:\n                ...     chart.show_annotation_layer(\"signals\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Show the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.show_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n        \"\"\"Clear annotations from the chart.\n\n        Removes all annotations from the specified layer or from all layers if\n        no layer name is provided. The layer itself is preserved and can be\n        reused for new annotations. This is useful for refreshing annotations\n        without recreating the entire chart.\n\n        Clearing behavior:\n            - With layer_name: Clears only that specific layer\n            - Without layer_name: Does nothing (for backward compatibility)\n            - Layer structure is preserved (can add new annotations)\n            - Does not affect hidden/shown state of layers\n\n        Args:\n            layer_name (Optional[str]): Name of the layer to clear. If None,\n                no action is taken. Defaults to None.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If layer_name is not None and invalid.\n\n        Example:\n            Clear specific layer::\n\n                &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n            Clear all layers (provide None)::\n\n                &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .clear_annotations(\"layer1\")\n                ...  .add_annotation(new_annotation, \"layer1\"))\n\n            Refresh annotations::\n\n                &gt;&gt;&gt; # Clear old annotations and add new ones\n                &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n                &gt;&gt;&gt; for signal in new_signals:\n                ...     chart.add_annotation(signal, \"signals\")\n        \"\"\"\n        # Step 1: Validate layer_name if provided\n        if layer_name is not None and (\n            not layer_name or not isinstance(layer_name, str)\n        ):\n            raise ValueValidationError(\n                \"layer_name\", \"must be None or a non-empty string\"\n            )\n\n        # Step 2: Clear the specified layer\n        if layer_name is not None:\n            # Clear only the specified layer through AnnotationManager\n            self.annotation_manager.clear_layer(layer_name)\n\n        # Note: If layer_name is None, no action is taken\n        # This maintains backward compatibility with existing code\n\n        # Return self for method chaining\n        return self\n\n    def add_overlay_price_scale(\n        self, scale_id: str, options: \"PriceScaleOptions\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Adds or updates an overlay price scale configuration for the chart.\n        Overlay price scales allow multiple series to share the same price axis\n        while maintaining independent scaling and positioning. This is commonly\n        used for volume bars, indicators, and other overlays.\n\n        Overlay price scales enable:\n            - Independent vertical positioning (scale margins)\n            - Separate auto-scaling behavior\n            - Different visibility settings\n            - Custom formatting and precision\n\n        Args:\n            scale_id (str): The unique identifier for the custom price scale\n                (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n                by series that use this price scale.\n            options (PriceScaleOptions): A PriceScaleOptions instance containing\n                the configuration for the overlay price scale.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            PriceScaleIdTypeError: If scale_id is not a string.\n            PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n        Example:\n            Add volume overlay price scale::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n                ...     PriceScaleOptions\n                ... )\n                &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n                ...     visible=False,  # Hide the price scale itself\n                ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n                ...     scale_margin_bottom=0,\n                ...     overlay=True,  # Mark as overlay\n                ...     auto_scale=True  # Auto-scale to data\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n            Add indicator overlay::\n\n                &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n                ...     visible=True,\n                ...     scale_margin_top=0.7,\n                ...     scale_margin_bottom=0.1,\n                ...     overlay=True\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_overlay_price_scale('volume', volume_scale)\n                ...  .add_series(volume_series))\n        \"\"\"\n        # Step 1: Add overlay scale through PriceScaleManager\n        # Manager validates scale_id and options internally\n        self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n        # Step 2: Sync back to options for backward compatibility\n        # This ensures options.overlay_price_scales is updated\n        # Some legacy code may access overlay scales directly from options\n        self.options.overlay_price_scales[scale_id] = options\n\n        # Return self for method chaining\n        return self\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series to the chart from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale positioned at the\n        bottom of the chart.\n\n        This is a convenience method that:\n            1. Configures the volume overlay price scale\n            2. Creates price series (candlestick or line)\n            3. Creates volume histogram series\n            4. Adds both series to the chart\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information. Can be a sequence of OhlcvData objects\n                or a pandas DataFrame.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n                Defaults to None (assumes standard column names).\n            price_type (str, optional): Type of price series to create. Options:\n                \"candlestick\" or \"line\". Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration (colors, line width, etc.). Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration (colors, transparency, etc.). Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0. Used in multi-pane charts.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If data type is invalid.\n            ValueError: If column_mapping is invalid or required columns are missing.\n\n        Example:\n            Add candlestick with volume::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n                ...     price_type=\"candlestick\"\n                ... )\n\n            Add line chart with custom volume colors::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     price_type=\"line\",\n                ...     volume_kwargs={\n                ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n                ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n                ...     }\n                ... )\n\n            From DataFrame::\n\n                &gt;&gt;&gt; df = pd.DataFrame({\n                ...     'timestamp': [...],\n                ...     'o': [...],\n                ...     'h': [...],\n                ...     'l': [...],\n                ...     'c': [...],\n                ...     'v': [...]\n                ... })\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     df,\n                ...     column_mapping={\n                ...         \"time\": \"timestamp\",\n                ...         \"open\": \"o\",\n                ...         \"high\": \"h\",\n                ...         \"low\": \"l\",\n                ...         \"close\": \"c\",\n                ...         \"volume\": \"v\"\n                ...     }\n                ... )\n        \"\"\"\n        # Step 1: Configure price scale manager for volume visualization\n        # This sets up the overlay price scale with proper margins\n        # Volume typically occupies the bottom 20% of the chart\n        self._price_scale_manager.configure_for_volume()\n\n        # Step 2: Delegate to series manager for actual series creation\n        # SeriesManager handles:\n        # - Data conversion (DataFrame to OhlcvData if needed)\n        # - Price series creation (candlestick or line)\n        # - Volume histogram series creation\n        # - Series configuration from kwargs\n        # - Adding both series to the chart\n        self._series_manager.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n            price_scale_manager=self._price_scale_manager,\n        )\n\n        # Return self for method chaining\n        return self\n\n    def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements and adds them to the chart\n        for visualization. Each trade is displayed with entry/exit markers,\n        connecting lines, profit/loss rectangles, or zones based on the\n        TradeVisualizationOptions.style configuration.\n\n        Trade visualization styles:\n            - \"markers\": Entry and exit markers only\n            - \"rectangle\": Filled rectangle between entry and exit\n            - \"line\": Simple line connecting entry to exit\n            - \"arrow\": Arrow from entry to exit\n            - \"zone\": Highlighted zone with transparency\n\n        The visualization automatically color-codes trades:\n            - Green/profit color for winning trades\n            - Red/loss color for losing trades\n            - Customizable through TradeVisualizationOptions\n\n        Args:\n            trades (List[TradeData]): List of TradeData objects to visualize\n                on the chart. Each trade must have entry_time, entry_price,\n                exit_time, exit_price, and trade_type.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Add basic trade visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                ...     TradeType\n                ... )\n                &gt;&gt;&gt; trades = [\n                ...     TradeData(\n                ...         entry_time=\"2024-01-01 10:00:00\",\n                ...         entry_price=100.0,\n                ...         exit_time=\"2024-01-01 15:00:00\",\n                ...         exit_price=105.0,\n                ...         quantity=100,\n                ...         trade_type=TradeType.LONG,\n                ...     )\n                ... ]\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            With custom visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n                ...     TradeVisualizationOptions\n                ... )\n                &gt;&gt;&gt; # Configure trade visualization\n                &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n                ...     style=\"rectangle\",\n                ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n                ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n                ... )\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_trades(trades)\n                ...  .update_options(height=600))\n        \"\"\"\n        # Delegate to TradeManager which handles:\n        # - Trade validation\n        # - Conversion to visual elements (markers, rectangles, etc.)\n        # - Profit/loss calculations\n        # - Color coding based on trade outcome\n        # - Annotation creation for visualization\n        self._trade_manager.add_trades(trades)\n\n        # Return self for method chaining\n        return self\n\n    def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n        \"\"\"Set the tooltip manager for the chart.\n\n        Assigns a TooltipManager instance to handle custom tooltip functionality.\n        Tooltips provide additional information when hovering over chart elements.\n\n        Args:\n            tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n        Example:\n            Set custom tooltip manager::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipManager\n                ... )\n                &gt;&gt;&gt; manager = TooltipManager()\n                &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n        \"\"\"\n        # Validate tooltip_manager is a TooltipManager instance\n        if not isinstance(tooltip_manager, TooltipManager):\n            raise TypeValidationError(\n                \"tooltip_manager\", \"TooltipManager instance\"\n            )\n\n        # Assign the tooltip manager\n        self._tooltip_manager = tooltip_manager\n\n        # Return self for method chaining\n        return self\n\n    def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n        \"\"\"Add a tooltip configuration to the chart.\n\n        Adds a named tooltip configuration that defines how tooltips should\n        be displayed for specific data points or series. Multiple tooltip\n        configurations can be registered and used selectively.\n\n        Args:\n            name: Name for the tooltip configuration (unique identifier).\n            config: TooltipConfig instance defining tooltip appearance and behavior.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If config is not a TooltipConfig instance.\n\n        Example:\n            Add custom tooltip configuration::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipConfig\n                ... )\n                &gt;&gt;&gt; config = TooltipConfig(\n                ...     title=\"Price Info\",\n                ...     show_time=True,\n                ...     show_value=True\n                ... )\n                &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n        \"\"\"\n        # Validate config is a TooltipConfig instance\n        if not isinstance(config, TooltipConfig):\n            raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n        # Lazy-load tooltip manager if not already set\n        # This avoids creating TooltipManager until actually needed\n        if self._tooltip_manager is None:\n            self._tooltip_manager = TooltipManager()\n\n        # Add the configuration to the tooltip manager\n        self._tooltip_manager.add_config(name, config)\n\n        # Return self for method chaining\n        return self\n\n    def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID which is used for synchronizing multiple charts.\n        Charts with the same group_id will be synchronized with each other,\n        sharing crosshair position and time range changes.\n\n        Note:\n            This is different from ChartManager's sync_group which manages\n            synchronization at a higher level. chart_group_id is used for\n            individual chart synchronization, while sync_group is used for\n            managing groups of charts in ChartManager.\n\n        Args:\n            group_id (int): Group ID for synchronization. Charts with the same\n                group_id will be synchronized.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID::\n\n                &gt;&gt;&gt; chart1.set_chart_group_id(1)\n                &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n            Disable synchronization::\n\n                &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n        \"\"\"\n        # Use property setter which includes validation\n        self.chart_group_id = group_id\n\n        # Return self for method chaining\n        return self\n\n    @property\n    def chart_group_id(self) -&gt; int:\n        \"\"\"Get the chart group ID for synchronization.\n\n        Returns the current chart group ID used for synchronization.\n\n        Returns:\n            int: The chart group ID.\n\n        Example:\n            Get chart group ID::\n\n                &gt;&gt;&gt; group_id = chart.chart_group_id\n                &gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n        \"\"\"\n        # Return the internal chart group ID\n        return self._chart_group_id\n\n    @chart_group_id.setter\n    def chart_group_id(self, group_id: int) -&gt; None:\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID with validation.\n\n        Args:\n            group_id (int): Group ID for synchronization.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID via property::\n\n                &gt;&gt;&gt; chart.chart_group_id = 1\n        \"\"\"\n        # Validate group_id is an integer\n        if not isinstance(group_id, int):\n            raise TypeValidationError(\"chart_group_id\", \"integer\")\n\n        # Set the internal chart group ID\n        self._chart_group_id = group_id\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert chart to frontend configuration dictionary.\n\n        Converts the chart and all its components (series, options, annotations,\n        trades, tooltips) to a dictionary format suitable for frontend consumption.\n        This method orchestrates the serialization of all chart elements.\n\n        The serialization process:\n            1. Get series configurations from SeriesManager\n            2. Get base chart options\n            3. Get price scale configuration from PriceScaleManager\n            4. Get annotations configuration from AnnotationManager\n            5. Get trades configuration from TradeManager\n            6. Get tooltip configurations from TooltipManager (if set)\n            7. Generate complete frontend config using ChartRenderer\n            8. Add force_reinit flag if set\n\n        Returns:\n            Dict[str, Any]: Complete chart configuration ready for frontend\n                rendering. The configuration includes:\n                - charts: List of chart objects with series and options\n                - syncConfig: Synchronization settings for multi-chart layouts\n                - annotations: Annotation layers and elements\n                - trades: Trade visualization elements\n                - tooltips: Custom tooltip configurations\n\n        Note:\n            Series are automatically ordered by z-index within each pane to ensure\n            proper layering in the frontend. Series with lower z-index values\n            render behind series with higher z-index values.\n\n        Example:\n            Get frontend configuration::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n            Access specific parts::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n                &gt;&gt;&gt; series_config = chart_config[\"series\"]\n                &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n        \"\"\"\n        # Step 1: Get series configurations from SeriesManager\n        # SeriesManager handles series ordering by z-index and pane\n        series_configs = self._series_manager.to_frontend_configs()\n\n        # Step 2: Get base chart configuration from ChartOptions\n        # Convert ChartOptions to dictionary for frontend\n        chart_config = (\n            self.options.asdict()\n            if self.options is not None\n            else ChartOptions().asdict()\n        )\n\n        # Step 3: Get price scale configuration from PriceScaleManager\n        # Manager validates scales and returns serialized configuration\n        price_scale_config = self._price_scale_manager.validate_and_serialize()\n        # Merge price scale config into chart config\n        chart_config.update(price_scale_config)\n\n        # Step 4: Get annotations configuration from AnnotationManager\n        # Converts all annotation layers to frontend format\n        annotations_config = self.annotation_manager.asdict()\n\n        # Step 5: Get trades configuration from TradeManager\n        # Converts TradeData objects to visual elements\n        # Uses trade_visualization options from chart options\n        trades_config = self._trade_manager.to_frontend_config(\n            self.options.trade_visualization if self.options else None\n        )\n\n        # Step 6: Get tooltip configurations from TooltipManager\n        tooltip_configs = None\n        if self._tooltip_manager:\n            # Convert each tooltip config to dictionary\n            tooltip_configs = {}\n            for name, tooltip_config in self._tooltip_manager.configs.items():\n                tooltip_configs[name] = tooltip_config.asdict()\n\n        # Step 7: Generate complete frontend configuration using ChartRenderer\n        # ChartRenderer assembles all components into final configuration\n        config = self._chart_renderer.generate_frontend_config(\n            chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n            chart_options=self.options,\n            series_configs=series_configs,\n            annotations_config=annotations_config,\n            trades_config=trades_config,\n            tooltip_configs=tooltip_configs,\n            chart_group_id=self.chart_group_id,\n            price_scale_config=price_scale_config,\n        )\n\n        # Step 8: Add force_reinit flag if set\n        # This tells frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Return the complete frontend configuration\n        return config\n\n    def render(self, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Converts the chart to frontend configuration and renders it using the\n        Streamlit component. This is the final step in the chart creation process\n        that displays the interactive chart in the Streamlit application.\n\n        The rendering process follows these steps:\n            1. Generate or validate component key\n            2. Reset config application flag for this render cycle\n            3. Load and apply stored series configurations from session state\n            4. Generate frontend configuration (after configs applied)\n            5. Render component using ChartRenderer\n            6. Handle component response and save updated series configs\n\n        The chart configuration is generated fresh on each render, allowing users\n        to control chart lifecycle and state management in their own code if needed.\n\n        Args:\n            key (Optional[str]): Optional unique key for the Streamlit component.\n                This key is used to identify the component instance and is useful\n                for debugging and component state management. If not provided,\n                a unique key will be generated automatically using timestamp and UUID.\n\n        Returns:\n            Any: The rendered Streamlit component that displays the interactive chart.\n                May contain user interaction data if the frontend sends responses.\n\n        Example:\n            Basic rendering::\n\n                &gt;&gt;&gt; chart.render()\n\n            Rendering with custom key::\n\n                &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n            Method chaining with rendering::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_series(line_series)\n                ...  .update_options(height=600)\n                ...  .render(key=\"chart1\"))\n\n            User-managed state (advanced)::\n\n                &gt;&gt;&gt; # Store chart in session state for persistence\n                &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n                ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Render the persisted chart\n                &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n            Dynamic key generation::\n\n                &gt;&gt;&gt; # Key includes timestamp for uniqueness\n                &gt;&gt;&gt; import time\n                &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n        \"\"\"\n        # STEP 1: Generate a unique key if none provided or if it's invalid\n        if key is None or not isinstance(key, str) or not key.strip():\n            # Create unique identifier using timestamp and UUID\n            unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n            timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n            key = f\"chart_{timestamp}_{unique_id}\"\n\n        # STEP 2: Reset config application flag for this render cycle\n        # This ensures configs are only applied once per render\n        # Prevents duplicate application of stored configurations\n        self._session_state_manager.reset_config_applied_flag()\n\n        # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n        # This is critical: we must apply user-modified configs BEFORE\n        # generating the frontend configuration, otherwise the configs\n        # won't be included in the serialized data\n        stored_configs = self._session_state_manager.load_series_configs(key)\n        if stored_configs:\n            # Apply stored configs to all series\n            # This updates series options with user-modified settings\n            self._session_state_manager.apply_stored_configs_to_series(\n                stored_configs,\n                self.series,  # Current series list\n            )\n\n        # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n        # This ensures the frontend config includes all user modifications\n        # The to_frontend_config() method serializes all chart components\n        config = self.to_frontend_config()\n\n        # STEP 5: Render component using ChartRenderer\n        # ChartRenderer handles:\n        # - Component function retrieval\n        # - Configuration serialization to JSON\n        # - Component rendering through Streamlit\n        # - Error handling if component is unavailable\n        result = self._chart_renderer.render(config, key, self.options)\n\n        # STEP 6: Handle component return value and save series configs\n        # The frontend may send back user interactions or config changes\n        if result:\n            # ChartRenderer processes the response and updates session state\n            # This includes saving any user-modified series configurations\n            self._chart_renderer.handle_response(\n                result,\n                key,\n                self._session_state_manager,\n            )\n\n        # Return the component result\n        # This may contain user interaction data or None\n        return result\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for the series settings dialog.\n\n        Retrieves information about all series in a specific pane. This is\n        used by the series settings dialog to display available series and\n        their current configurations.\n\n        Args:\n            _pane_id: The pane ID to get series info for (default: 0).\n\n        Returns:\n            List of series information dictionaries containing:\n                - series_index: Index of the series\n                - series_type: Type of series (line, candlestick, etc.)\n                - series_name: Display name of the series\n                - current_config: Current series configuration\n\n        Example:\n            Get series info::\n\n                &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n                &gt;&gt;&gt; for info in series_info:\n                ...     print(f\"{info['series_name']}: {info['series_type']}\")\n        \"\"\"\n        # Delegate to SeriesManager which has access to all series data\n        return self._series_manager.get_series_info_for_pane(_pane_id)\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        This method supports conversion from various time formats (datetime,\n        string, timestamp) to UNIX timestamp in seconds.\n\n        Args:\n            time_value: Time value in various formats (datetime, string, int, float).\n\n        Returns:\n            Timestamp in seconds or None if conversion fails.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's conversion logic\n        return self._chart_renderer._convert_time_to_timestamp(time_value)\n\n    def _calculate_data_timespan(self) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Calculates the total time range covered by all series data,\n        which is used for auto-ranging and time scale configuration.\n\n        Returns:\n            Timespan in seconds or None if unable to calculate.\n            None may be returned if:\n                - No series have data\n                - Time values are invalid\n                - Serialization fails\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        try:\n            # Get series configurations which include time data\n            series_configs = self._series_manager.to_frontend_configs()\n\n            # Delegate to ChartRenderer to calculate timespan\n            return self._chart_renderer._calculate_data_timespan(series_configs)\n        except Exception:\n            # Catch any error during serialization or calculation\n            # Return None if unable to calculate (invalid time values, etc.)\n            return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Converts a range configuration (e.g., {\"days\": 7}) to total seconds.\n\n        Args:\n            range_config: Range configuration dictionary with time units.\n                Example: {\"days\": 7, \"hours\": 12}\n\n        Returns:\n            Number of seconds in the range or None for \"ALL\" range.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's range calculation logic\n        return self._chart_renderer._get_range_seconds(range_config)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.chart_group_id","title":"chart_group_id  <code>property</code> <code>writable</code>","text":"<pre><code>chart_group_id: int\n</code></pre> <p>Get the chart group ID for synchronization.</p> <p>Returns the current chart group ID used for synchronization.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The chart group ID.</p> Example <p>Get chart group ID::</p> <pre><code>&gt;&gt;&gt; group_id = chart.chart_group_id\n&gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.get_stored_series_config","title":"get_stored_series_config","text":"<pre><code>get_stored_series_config(key: str, series_index: int = 0, pane_id: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Get stored configuration for a specific series.</p> <p>Retrieves the stored configuration for a series from session state. This is useful for applying previously saved configurations when creating new series instances, enabling persistence of user customizations across renders.</p> The stored configuration includes user-modified settings like <ul> <li>Colors and styles</li> <li>Line widths and types</li> <li>Visibility settings</li> <li>Other series-specific options</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs. This should match the key used when rendering the chart.</p> required <code>series_index</code> <code>int</code> <p>Index of the series (0-based). Defaults to 0.</p> <code>0</code> <code>pane_id</code> <code>int</code> <p>Pane ID for the series. Defaults to 0. Useful for multi-pane charts where the same series index may exist in different panes.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of stored configuration or empty dict if none found.</p> <code>Dict[str, Any]</code> <p>The dictionary keys match the series option property names.</p> Example <p>Get and apply stored config::</p> <pre><code>&gt;&gt;&gt; # Get stored config for first series\n&gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply to new series\n&gt;&gt;&gt; if config:\n...     line_series = LineSeries(data)\n...     if \"color\" in config:\n...         line_series.line_options.color = config[\"color\"]\n...     if \"lineWidth\" in config:\n...         line_series.line_options.line_width = config[\"lineWidth\"]\n</code></pre> <p>Restore all series configs::</p> <pre><code>&gt;&gt;&gt; for i, series in enumerate(chart.series):\n...     config = chart.get_stored_series_config(\"my_chart\", i)\n...     if config:\n...         apply_config_to_series(series, config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_stored_series_config(\n    self,\n    key: str,\n    series_index: int = 0,\n    pane_id: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get stored configuration for a specific series.\n\n    Retrieves the stored configuration for a series from session state.\n    This is useful for applying previously saved configurations when\n    creating new series instances, enabling persistence of user\n    customizations across renders.\n\n    The stored configuration includes user-modified settings like:\n        - Colors and styles\n        - Line widths and types\n        - Visibility settings\n        - Other series-specific options\n\n    Args:\n        key: Component key used to namespace the stored configs. This should\n            match the key used when rendering the chart.\n        series_index: Index of the series (0-based). Defaults to 0.\n        pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n            charts where the same series index may exist in different panes.\n\n    Returns:\n        Dictionary of stored configuration or empty dict if none found.\n        The dictionary keys match the series option property names.\n\n    Example:\n        Get and apply stored config::\n\n            &gt;&gt;&gt; # Get stored config for first series\n            &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Apply to new series\n            &gt;&gt;&gt; if config:\n            ...     line_series = LineSeries(data)\n            ...     if \"color\" in config:\n            ...         line_series.line_options.color = config[\"color\"]\n            ...     if \"lineWidth\" in config:\n            ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n        Restore all series configs::\n\n            &gt;&gt;&gt; for i, series in enumerate(chart.series):\n            ...     config = chart.get_stored_series_config(\"my_chart\", i)\n            ...     if config:\n            ...         apply_config_to_series(series, config)\n    \"\"\"\n    # Delegate to SessionStateManager which handles the actual storage\n    # SessionStateManager uses Streamlit's session_state for persistence\n    return self._session_state_manager.get_stored_series_config(\n        key, series_index, pane_id\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_series","title":"add_series","text":"<pre><code>add_series(series: Series) -&gt; Chart\n</code></pre> <p>Add a series to the chart.</p> <p>Adds a new series object to the chart's series list. The series will be displayed according to its type (line, candlestick, area, etc.) and configuration options. The method automatically handles price scale configuration for custom price scale IDs.</p> When a series is added <ol> <li>Series is validated to ensure it's a Series instance</li> <li>SeriesManager adds it to the series list</li> <li>If series has custom price_scale_id, PriceScaleManager is notified</li> <li>Series is assigned a z-index for proper layering</li> </ol> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add to the chart. Must be an instance of a Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Example <p>Add a candlestick series::</p> <pre><code>&gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n</code></pre> <p>Add a line series with custom options::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n&gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n&gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n</code></pre> <p>Add series with custom price scale::</p> <pre><code>&gt;&gt;&gt; # Series with custom price scale ID\n&gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n&gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add overlay price scale configuration\n&gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add the series\n&gt;&gt;&gt; chart.add_series(volume_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_series(self, series: Series) -&gt; \"Chart\":\n    \"\"\"Add a series to the chart.\n\n    Adds a new series object to the chart's series list. The series will be\n    displayed according to its type (line, candlestick, area, etc.) and\n    configuration options. The method automatically handles price scale\n    configuration for custom price scale IDs.\n\n    When a series is added:\n        1. Series is validated to ensure it's a Series instance\n        2. SeriesManager adds it to the series list\n        3. If series has custom price_scale_id, PriceScaleManager is notified\n        4. Series is assigned a z-index for proper layering\n\n    Args:\n        series: Series object to add to the chart. Must be an instance of a\n            Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n\n    Example:\n        Add a candlestick series::\n\n            &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n        Add a line series with custom options::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n            &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n            &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n        Add series with custom price scale::\n\n            &gt;&gt;&gt; # Series with custom price scale ID\n            &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n            &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add overlay price scale configuration\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add the series\n            &gt;&gt;&gt; chart.add_series(volume_series)\n    \"\"\"\n    # Delegate to SeriesManager which handles validation and storage\n    # Also pass PriceScaleManager reference so it can be notified of\n    # custom price scale IDs\n    self._series_manager.add_series(series, self._price_scale_manager)\n\n    # Return self to enable method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.update_options","title":"update_options","text":"<pre><code>update_options(**kwargs) -&gt; Chart\n</code></pre> <p>Update chart options.</p> <p>Updates the chart's configuration options using keyword arguments. Only valid ChartOptions attributes will be updated; invalid attributes are silently ignored to support method chaining and forward compatibility.</p> <p>The method performs type checking to ensure new values match the expected types of the chart options. This prevents runtime errors from invalid configurations.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Chart options to update. Valid options include: - width (Optional[int]): Chart width in pixels - height (int): Chart height in pixels (default: 400) - auto_size (bool): Whether to auto-size the chart - handle_scroll (bool): Whether to enable scroll interactions - handle_scale (bool): Whether to enable scale interactions - add_default_pane (bool): Whether to add a default pane And many more options defined in ChartOptions class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Update basic dimensions::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=600, width=800)\n</code></pre> <p>Update interaction options::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     handle_scroll=True,\n...     handle_scale=False,\n...     auto_size=True\n... )\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n</code></pre> <p>Update multiple options at once::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     height=600,\n...     width=1200,\n...     auto_size=False,\n...     handle_scroll=True\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def update_options(self, **kwargs) -&gt; \"Chart\":\n    \"\"\"Update chart options.\n\n    Updates the chart's configuration options using keyword arguments.\n    Only valid ChartOptions attributes will be updated; invalid attributes\n    are silently ignored to support method chaining and forward compatibility.\n\n    The method performs type checking to ensure new values match the\n    expected types of the chart options. This prevents runtime errors\n    from invalid configurations.\n\n    Args:\n        **kwargs: Chart options to update. Valid options include:\n            - width (Optional[int]): Chart width in pixels\n            - height (int): Chart height in pixels (default: 400)\n            - auto_size (bool): Whether to auto-size the chart\n            - handle_scroll (bool): Whether to enable scroll interactions\n            - handle_scale (bool): Whether to enable scale interactions\n            - add_default_pane (bool): Whether to add a default pane\n            And many more options defined in ChartOptions class.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Update basic dimensions::\n\n            &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n        Update interaction options::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     handle_scroll=True,\n            ...     handle_scale=False,\n            ...     auto_size=True\n            ... )\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n        Update multiple options at once::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     height=600,\n            ...     width=1200,\n            ...     auto_size=False,\n            ...     handle_scroll=True\n            ... )\n    \"\"\"\n    # Process each keyword argument to update chart options\n    for key, value in kwargs.items():\n        # Step 1: Validate the option exists and value is not None\n        # Check that the attribute exists on ChartOptions instance\n        # and that the new value is not None (None values are ignored)\n        if value is not None and hasattr(self.options, key):\n            # Step 2: Get current attribute value for type checking\n            # This helps ensure type consistency\n            current_value = getattr(self.options, key)\n\n            # Step 3: Validate type compatibility\n            # Allow update if:\n            # - New value type matches current value type, OR\n            # - Current value is None and new value is not None\n            #   (allows setting previously unset options)\n            if isinstance(value, type(current_value)) or (\n                current_value is None and value is not None\n            ):\n                # Update the attribute with the validated value\n                setattr(self.options, key, value)\n\n        # Note: Invalid attributes and None values are silently ignored\n        # This enables method chaining and forward compatibility\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add an annotation to the chart.</p> <p>Adds a single annotation to the specified annotation layer. If the layer doesn't exist, it will be created automatically. Annotations are visual elements like text, arrows, shapes, and lines that provide additional information or highlight specific points on the chart.</p> Annotations are organized into layers for better management <ul> <li>Each layer can contain multiple annotations</li> <li>Layers can be shown/hidden independently</li> <li>Layers can be cleared without affecting other layers</li> <li>Default layer is used if no layer name is specified</li> </ul> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the chart. Must be a valid Annotation instance with proper configuration.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". Layer will be created if it doesn't exist.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If annotation is None or layer_name is invalid.</p> <code>TypeValidationError</code> <p>If annotation is not an Annotation instance.</p> Example <p>Add text annotation::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n...     create_text_annotation\n... )\n&gt;&gt;&gt; text_ann = create_text_annotation(\n...     \"2024-01-01\", 100, \"Important Event\"\n... )\n&gt;&gt;&gt; chart.add_annotation(text_ann)\n</code></pre> <p>Add annotation to custom layer::</p> <pre><code>&gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n&gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n</code></pre> <p>Organize annotations by layer::</p> <pre><code>&gt;&gt;&gt; # Technical analysis annotations\n&gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n&gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Trading signals\n&gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n&gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotation(\n    self, annotation: Annotation, layer_name: str = \"default\"\n) -&gt; \"Chart\":\n    \"\"\"Add an annotation to the chart.\n\n    Adds a single annotation to the specified annotation layer. If the layer\n    doesn't exist, it will be created automatically. Annotations are visual\n    elements like text, arrows, shapes, and lines that provide additional\n    information or highlight specific points on the chart.\n\n    Annotations are organized into layers for better management:\n        - Each layer can contain multiple annotations\n        - Layers can be shown/hidden independently\n        - Layers can be cleared without affecting other layers\n        - Default layer is used if no layer name is specified\n\n    Args:\n        annotation (Annotation): Annotation object to add to the chart.\n            Must be a valid Annotation instance with proper configuration.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". Layer will be created if it doesn't exist.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If annotation is None or layer_name is invalid.\n        TypeValidationError: If annotation is not an Annotation instance.\n\n    Example:\n        Add text annotation::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n            ...     create_text_annotation\n            ... )\n            &gt;&gt;&gt; text_ann = create_text_annotation(\n            ...     \"2024-01-01\", 100, \"Important Event\"\n            ... )\n            &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n        Add annotation to custom layer::\n\n            &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n            &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n        Organize annotations by layer::\n\n            &gt;&gt;&gt; # Technical analysis annotations\n            &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n            &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Trading signals\n            &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n            &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n    \"\"\"\n    # Step 1: Validate annotation is not None\n    if annotation is None:\n        raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n    # Step 2: Validate annotation is an Annotation instance\n    if not isinstance(annotation, Annotation):\n        raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n    # Step 3: Handle layer name validation\n    # Use default layer name if None is provided\n    if layer_name is None:\n        layer_name = \"default\"\n    # Validate layer_name is a non-empty string\n    elif not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Add annotation to the specified layer\n    # AnnotationManager will create the layer if it doesn't exist\n    self.annotation_manager.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_annotations","title":"add_annotations","text":"<pre><code>add_annotations(annotations: List[Annotation], layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add multiple annotations to the chart.</p> <p>Adds multiple annotation objects to the specified annotation layer. This is more efficient than calling add_annotation multiple times as it processes all annotations in a single operation and provides better performance for bulk annotation operations.</p> <p>All annotations are added to the same layer, enabling consistent management (show/hide/clear) of related annotations.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects to add to the chart. All must be valid Annotation instances.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". All annotations will be added to this layer.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If annotations is not a list.</p> <code>ValueValidationError</code> <p>If layer_name is invalid.</p> <code>AnnotationItemsTypeError</code> <p>If any item in annotations is not an Annotation instance.</p> Example <p>Add multiple annotations at once::</p> <pre><code>&gt;&gt;&gt; annotations = [\n...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n... ]\n&gt;&gt;&gt; chart.add_annotations(annotations)\n</code></pre> <p>Add to custom layer::</p> <pre><code>&gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n&gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n</code></pre> <p>Bulk operations with method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_annotations(ta_annotations, layer_name=\"ta\")\n...  .add_annotations(signal_annotations, layer_name=\"signals\")\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotations(\n    self,\n    annotations: List[Annotation],\n    layer_name: str = \"default\",\n) -&gt; \"Chart\":\n    \"\"\"Add multiple annotations to the chart.\n\n    Adds multiple annotation objects to the specified annotation layer. This\n    is more efficient than calling add_annotation multiple times as it\n    processes all annotations in a single operation and provides better\n    performance for bulk annotation operations.\n\n    All annotations are added to the same layer, enabling consistent\n    management (show/hide/clear) of related annotations.\n\n    Args:\n        annotations (List[Annotation]): List of annotation objects to add\n            to the chart. All must be valid Annotation instances.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". All annotations will be added to this layer.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If annotations is not a list.\n        ValueValidationError: If layer_name is invalid.\n        AnnotationItemsTypeError: If any item in annotations is not an\n            Annotation instance.\n\n    Example:\n        Add multiple annotations at once::\n\n            &gt;&gt;&gt; annotations = [\n            ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n            ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n            ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n            ... ]\n            &gt;&gt;&gt; chart.add_annotations(annotations)\n\n        Add to custom layer::\n\n            &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n            &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n        Bulk operations with method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n            ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n            ...  .update_options(height=600))\n    \"\"\"\n    # Step 1: Validate annotations is not None\n    if annotations is None:\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 2: Validate annotations is a list\n    if not isinstance(annotations, list):\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 3: Validate layer_name\n    if not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Validate and add each annotation\n    for annotation in annotations:\n        # Ensure each item is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise AnnotationItemsTypeError()\n\n        # Add the annotation to the specified layer\n        # Reuses add_annotation logic for consistency\n        self.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.create_annotation_layer","title":"create_annotation_layer","text":"<pre><code>create_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new annotation layer with the specified name. Annotation layers allow you to organize and manage groups of annotations independently. Each layer can be shown, hidden, or cleared separately, providing flexible control over annotation visibility.</p> Common use cases for layers <ul> <li>Separate technical analysis from trading signals</li> <li>Organize annotations by timeframe or strategy</li> <li>Group annotations by type (text, arrows, shapes)</li> <li>Enable/disable different annotation sets dynamically</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to create. Must be a non-empty string and should be unique.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If name is None.</p> <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Create custom layers for different types of annotations::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .create_annotation_layer(\"layer1\")\n...  .create_annotation_layer(\"layer2\")\n...  .add_annotation(ann1, \"layer1\")\n...  .add_annotation(ann2, \"layer2\"))\n</code></pre> <p>Organize by strategy::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n&gt;&gt;&gt; # Add annotations specific to each strategy\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new annotation layer with the specified name. Annotation layers\n    allow you to organize and manage groups of annotations independently.\n    Each layer can be shown, hidden, or cleared separately, providing\n    flexible control over annotation visibility.\n\n    Common use cases for layers:\n        - Separate technical analysis from trading signals\n        - Organize annotations by timeframe or strategy\n        - Group annotations by type (text, arrows, shapes)\n        - Enable/disable different annotation sets dynamically\n\n    Args:\n        name (str): Name of the annotation layer to create. Must be a\n            non-empty string and should be unique.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If name is None.\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Create custom layers for different types of annotations::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .create_annotation_layer(\"layer1\")\n            ...  .create_annotation_layer(\"layer2\")\n            ...  .add_annotation(ann1, \"layer1\")\n            ...  .add_annotation(ann2, \"layer2\"))\n\n        Organize by strategy::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n            &gt;&gt;&gt; # Add annotations specific to each strategy\n    \"\"\"\n    # Step 1: Validate name is not None\n    if name is None:\n        raise TypeValidationError(\"name\", \"string\")\n\n    # Step 2: Validate name is a non-empty string\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 3: Create the layer in AnnotationManager\n    # If layer already exists, this operation is idempotent\n    self.annotation_manager.create_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.hide_annotation_layer","title":"hide_annotation_layer","text":"<pre><code>hide_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Hide an annotation layer.</p> <p>Hides the specified annotation layer, making all annotations in that layer invisible on the chart. The layer and its annotations are preserved and can be shown again using show_annotation_layer. This is useful for temporarily hiding certain annotation groups without removing them.</p> Hidden layers <ul> <li>Remain in memory with all annotations intact</li> <li>Can be shown again without re-adding annotations</li> <li>Don't affect other layers' visibility</li> <li>Are persisted across chart updates</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to hide.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Hide specific layers::</p> <pre><code>&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .hide_annotation_layer(\"layer1\")\n...  .hide_annotation_layer(\"layer2\")\n...  .show_annotation_layer(\"layer3\"))\n</code></pre> <p>Toggle layer visibility::</p> <pre><code>&gt;&gt;&gt; # Hide analysis layer temporarily\n&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; # ... show chart without analysis\n&gt;&gt;&gt; # Show analysis layer again\n&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Hide an annotation layer.\n\n    Hides the specified annotation layer, making all annotations in that\n    layer invisible on the chart. The layer and its annotations are preserved\n    and can be shown again using show_annotation_layer. This is useful for\n    temporarily hiding certain annotation groups without removing them.\n\n    Hidden layers:\n        - Remain in memory with all annotations intact\n        - Can be shown again without re-adding annotations\n        - Don't affect other layers' visibility\n        - Are persisted across chart updates\n\n    Args:\n        name (str): Name of the annotation layer to hide.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Hide specific layers::\n\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .hide_annotation_layer(\"layer1\")\n            ...  .hide_annotation_layer(\"layer2\")\n            ...  .show_annotation_layer(\"layer3\"))\n\n        Toggle layer visibility::\n\n            &gt;&gt;&gt; # Hide analysis layer temporarily\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; # ... show chart without analysis\n            &gt;&gt;&gt; # Show analysis layer again\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Hide the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.hide_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.show_annotation_layer","title":"show_annotation_layer","text":"<pre><code>show_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Show an annotation layer.</p> <p>Makes the specified annotation layer visible on the chart. This will display all annotations that were previously added to this layer. If the layer doesn't exist or is already visible, this method will have no effect.</p> <p>This is the counterpart to hide_annotation_layer and enables dynamic control over which annotation groups are visible.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to show.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Show specific layers::</p> <pre><code>&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .show_annotation_layer(\"layer1\")\n...  .show_annotation_layer(\"layer2\")\n...  .hide_annotation_layer(\"layer3\"))\n</code></pre> <p>Conditional visibility::</p> <pre><code>&gt;&gt;&gt; # Show different layers based on user selection\n&gt;&gt;&gt; if show_technical_analysis:\n...     chart.show_annotation_layer(\"ta\")\n&gt;&gt;&gt; if show_trading_signals:\n...     chart.show_annotation_layer(\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Show an annotation layer.\n\n    Makes the specified annotation layer visible on the chart. This will\n    display all annotations that were previously added to this layer.\n    If the layer doesn't exist or is already visible, this method will\n    have no effect.\n\n    This is the counterpart to hide_annotation_layer and enables dynamic\n    control over which annotation groups are visible.\n\n    Args:\n        name (str): Name of the annotation layer to show.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Show specific layers::\n\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .show_annotation_layer(\"layer1\")\n            ...  .show_annotation_layer(\"layer2\")\n            ...  .hide_annotation_layer(\"layer3\"))\n\n        Conditional visibility::\n\n            &gt;&gt;&gt; # Show different layers based on user selection\n            &gt;&gt;&gt; if show_technical_analysis:\n            ...     chart.show_annotation_layer(\"ta\")\n            &gt;&gt;&gt; if show_trading_signals:\n            ...     chart.show_annotation_layer(\"signals\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Show the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.show_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations(layer_name: Optional[str] = None) -&gt; Chart\n</code></pre> <p>Clear annotations from the chart.</p> <p>Removes all annotations from the specified layer or from all layers if no layer name is provided. The layer itself is preserved and can be reused for new annotations. This is useful for refreshing annotations without recreating the entire chart.</p> Clearing behavior <ul> <li>With layer_name: Clears only that specific layer</li> <li>Without layer_name: Does nothing (for backward compatibility)</li> <li>Layer structure is preserved (can add new annotations)</li> <li>Does not affect hidden/shown state of layers</li> </ul> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>Optional[str]</code> <p>Name of the layer to clear. If None, no action is taken. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If layer_name is not None and invalid.</p> Example <p>Clear specific layer::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n</code></pre> <p>Clear all layers (provide None)::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .clear_annotations(\"layer1\")\n...  .add_annotation(new_annotation, \"layer1\"))\n</code></pre> <p>Refresh annotations::</p> <pre><code>&gt;&gt;&gt; # Clear old annotations and add new ones\n&gt;&gt;&gt; chart.clear_annotations(\"signals\")\n&gt;&gt;&gt; for signal in new_signals:\n...     chart.add_annotation(signal, \"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n    \"\"\"Clear annotations from the chart.\n\n    Removes all annotations from the specified layer or from all layers if\n    no layer name is provided. The layer itself is preserved and can be\n    reused for new annotations. This is useful for refreshing annotations\n    without recreating the entire chart.\n\n    Clearing behavior:\n        - With layer_name: Clears only that specific layer\n        - Without layer_name: Does nothing (for backward compatibility)\n        - Layer structure is preserved (can add new annotations)\n        - Does not affect hidden/shown state of layers\n\n    Args:\n        layer_name (Optional[str]): Name of the layer to clear. If None,\n            no action is taken. Defaults to None.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If layer_name is not None and invalid.\n\n    Example:\n        Clear specific layer::\n\n            &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n        Clear all layers (provide None)::\n\n            &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .clear_annotations(\"layer1\")\n            ...  .add_annotation(new_annotation, \"layer1\"))\n\n        Refresh annotations::\n\n            &gt;&gt;&gt; # Clear old annotations and add new ones\n            &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n            &gt;&gt;&gt; for signal in new_signals:\n            ...     chart.add_annotation(signal, \"signals\")\n    \"\"\"\n    # Step 1: Validate layer_name if provided\n    if layer_name is not None and (\n        not layer_name or not isinstance(layer_name, str)\n    ):\n        raise ValueValidationError(\n            \"layer_name\", \"must be None or a non-empty string\"\n        )\n\n    # Step 2: Clear the specified layer\n    if layer_name is not None:\n        # Clear only the specified layer through AnnotationManager\n        self.annotation_manager.clear_layer(layer_name)\n\n    # Note: If layer_name is None, no action is taken\n    # This maintains backward compatibility with existing code\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_overlay_price_scale","title":"add_overlay_price_scale","text":"<pre><code>add_overlay_price_scale(scale_id: str, options: PriceScaleOptions) -&gt; Chart\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Adds or updates an overlay price scale configuration for the chart. Overlay price scales allow multiple series to share the same price axis while maintaining independent scaling and positioning. This is commonly used for volume bars, indicators, and other overlays.</p> Overlay price scales enable <ul> <li>Independent vertical positioning (scale margins)</li> <li>Separate auto-scaling behavior</li> <li>Different visibility settings</li> <li>Custom formatting and precision</li> </ul> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced by series that use this price scale.</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration for the overlay price scale.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>PriceScaleIdTypeError</code> <p>If scale_id is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If options is not a PriceScaleOptions instance.</p> Example <p>Add volume overlay price scale::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n...     PriceScaleOptions\n... )\n&gt;&gt;&gt; volume_scale = PriceScaleOptions(\n...     visible=False,  # Hide the price scale itself\n...     scale_margin_top=0.8,  # Volume takes bottom 20%\n...     scale_margin_bottom=0,\n...     overlay=True,  # Mark as overlay\n...     auto_scale=True  # Auto-scale to data\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n</code></pre> <p>Add indicator overlay::</p> <pre><code>&gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n...     visible=True,\n...     scale_margin_top=0.7,\n...     scale_margin_bottom=0.1,\n...     overlay=True\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_overlay_price_scale('volume', volume_scale)\n...  .add_series(volume_series))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_overlay_price_scale(\n    self, scale_id: str, options: \"PriceScaleOptions\"\n) -&gt; \"Chart\":\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Adds or updates an overlay price scale configuration for the chart.\n    Overlay price scales allow multiple series to share the same price axis\n    while maintaining independent scaling and positioning. This is commonly\n    used for volume bars, indicators, and other overlays.\n\n    Overlay price scales enable:\n        - Independent vertical positioning (scale margins)\n        - Separate auto-scaling behavior\n        - Different visibility settings\n        - Custom formatting and precision\n\n    Args:\n        scale_id (str): The unique identifier for the custom price scale\n            (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n            by series that use this price scale.\n        options (PriceScaleOptions): A PriceScaleOptions instance containing\n            the configuration for the overlay price scale.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        PriceScaleIdTypeError: If scale_id is not a string.\n        PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n    Example:\n        Add volume overlay price scale::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n            ...     PriceScaleOptions\n            ... )\n            &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n            ...     visible=False,  # Hide the price scale itself\n            ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n            ...     scale_margin_bottom=0,\n            ...     overlay=True,  # Mark as overlay\n            ...     auto_scale=True  # Auto-scale to data\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n        Add indicator overlay::\n\n            &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n            ...     visible=True,\n            ...     scale_margin_top=0.7,\n            ...     scale_margin_bottom=0.1,\n            ...     overlay=True\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_overlay_price_scale('volume', volume_scale)\n            ...  .add_series(volume_series))\n    \"\"\"\n    # Step 1: Add overlay scale through PriceScaleManager\n    # Manager validates scale_id and options internally\n    self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n    # Step 2: Sync back to options for backward compatibility\n    # This ensures options.overlay_price_scales is updated\n    # Some legacy code may access overlay scales directly from options\n    self.options.overlay_price_scales[scale_id] = options\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series to the chart from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale positioned at the bottom of the chart.</p> This is a convenience method that <ol> <li>Configures the volume overlay price scale</li> <li>Creates price series (candlestick or line)</li> <li>Creates volume histogram series</li> <li>Adds both series to the chart</li> </ol> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information. Can be a sequence of OhlcvData objects or a pandas DataFrame.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\". Defaults to None (assumes standard column names).</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series to create. Options: \"candlestick\" or \"line\". Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration (colors, line width, etc.). Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration (colors, transparency, etc.). Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0. Used in multi-pane charts.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If data type is invalid.</p> <code>ValueError</code> <p>If column_mapping is invalid or required columns are missing.</p> Example <p>Add candlestick with volume::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n...     price_type=\"candlestick\"\n... )\n</code></pre> <p>Add line chart with custom volume colors::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     price_type=\"line\",\n...     volume_kwargs={\n...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n...     }\n... )\n</code></pre> <p>From DataFrame::</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'timestamp': [...],\n...     'o': [...],\n...     'h': [...],\n...     'l': [...],\n...     'c': [...],\n...     'v': [...]\n... })\n&gt;&gt;&gt; chart.add_price_volume_series(\n...     df,\n...     column_mapping={\n...         \"time\": \"timestamp\",\n...         \"open\": \"o\",\n...         \"high\": \"h\",\n...         \"low\": \"l\",\n...         \"close\": \"c\",\n...         \"volume\": \"v\"\n...     }\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series to the chart from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale positioned at the\n    bottom of the chart.\n\n    This is a convenience method that:\n        1. Configures the volume overlay price scale\n        2. Creates price series (candlestick or line)\n        3. Creates volume histogram series\n        4. Adds both series to the chart\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information. Can be a sequence of OhlcvData objects\n            or a pandas DataFrame.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n            Defaults to None (assumes standard column names).\n        price_type (str, optional): Type of price series to create. Options:\n            \"candlestick\" or \"line\". Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration (colors, line width, etc.). Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration (colors, transparency, etc.). Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0. Used in multi-pane charts.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If data type is invalid.\n        ValueError: If column_mapping is invalid or required columns are missing.\n\n    Example:\n        Add candlestick with volume::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n            ...     price_type=\"candlestick\"\n            ... )\n\n        Add line chart with custom volume colors::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     price_type=\"line\",\n            ...     volume_kwargs={\n            ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n            ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n            ...     }\n            ... )\n\n        From DataFrame::\n\n            &gt;&gt;&gt; df = pd.DataFrame({\n            ...     'timestamp': [...],\n            ...     'o': [...],\n            ...     'h': [...],\n            ...     'l': [...],\n            ...     'c': [...],\n            ...     'v': [...]\n            ... })\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     df,\n            ...     column_mapping={\n            ...         \"time\": \"timestamp\",\n            ...         \"open\": \"o\",\n            ...         \"high\": \"h\",\n            ...         \"low\": \"l\",\n            ...         \"close\": \"c\",\n            ...         \"volume\": \"v\"\n            ...     }\n            ... )\n    \"\"\"\n    # Step 1: Configure price scale manager for volume visualization\n    # This sets up the overlay price scale with proper margins\n    # Volume typically occupies the bottom 20% of the chart\n    self._price_scale_manager.configure_for_volume()\n\n    # Step 2: Delegate to series manager for actual series creation\n    # SeriesManager handles:\n    # - Data conversion (DataFrame to OhlcvData if needed)\n    # - Price series creation (candlestick or line)\n    # - Volume histogram series creation\n    # - Series configuration from kwargs\n    # - Adding both series to the chart\n    self._series_manager.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n        price_scale_manager=self._price_scale_manager,\n    )\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; Chart\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements and adds them to the chart for visualization. Each trade is displayed with entry/exit markers, connecting lines, profit/loss rectangles, or zones based on the TradeVisualizationOptions.style configuration.</p> Trade visualization styles <ul> <li>\"markers\": Entry and exit markers only</li> <li>\"rectangle\": Filled rectangle between entry and exit</li> <li>\"line\": Simple line connecting entry to exit</li> <li>\"arrow\": Arrow from entry to exit</li> <li>\"zone\": Highlighted zone with transparency</li> </ul> The visualization automatically color-codes trades <ul> <li>Green/profit color for winning trades</li> <li>Red/loss color for losing trades</li> <li>Customizable through TradeVisualizationOptions</li> </ul> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart. Each trade must have entry_time, entry_price, exit_time, exit_price, and trade_type.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Add basic trade visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n&gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n...     TradeType\n... )\n&gt;&gt;&gt; trades = [\n...     TradeData(\n...         entry_time=\"2024-01-01 10:00:00\",\n...         entry_price=100.0,\n...         exit_time=\"2024-01-01 15:00:00\",\n...         exit_price=105.0,\n...         quantity=100,\n...         trade_type=TradeType.LONG,\n...     )\n... ]\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>With custom visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n...     TradeVisualizationOptions\n... )\n&gt;&gt;&gt; # Configure trade visualization\n&gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n...     style=\"rectangle\",\n...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n... )\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_trades(trades)\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements and adds them to the chart\n    for visualization. Each trade is displayed with entry/exit markers,\n    connecting lines, profit/loss rectangles, or zones based on the\n    TradeVisualizationOptions.style configuration.\n\n    Trade visualization styles:\n        - \"markers\": Entry and exit markers only\n        - \"rectangle\": Filled rectangle between entry and exit\n        - \"line\": Simple line connecting entry to exit\n        - \"arrow\": Arrow from entry to exit\n        - \"zone\": Highlighted zone with transparency\n\n    The visualization automatically color-codes trades:\n        - Green/profit color for winning trades\n        - Red/loss color for losing trades\n        - Customizable through TradeVisualizationOptions\n\n    Args:\n        trades (List[TradeData]): List of TradeData objects to visualize\n            on the chart. Each trade must have entry_time, entry_price,\n            exit_time, exit_price, and trade_type.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Add basic trade visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            ...     TradeType\n            ... )\n            &gt;&gt;&gt; trades = [\n            ...     TradeData(\n            ...         entry_time=\"2024-01-01 10:00:00\",\n            ...         entry_price=100.0,\n            ...         exit_time=\"2024-01-01 15:00:00\",\n            ...         exit_price=105.0,\n            ...         quantity=100,\n            ...         trade_type=TradeType.LONG,\n            ...     )\n            ... ]\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        With custom visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n            ...     TradeVisualizationOptions\n            ... )\n            &gt;&gt;&gt; # Configure trade visualization\n            &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n            ...     style=\"rectangle\",\n            ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n            ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n            ... )\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_trades(trades)\n            ...  .update_options(height=600))\n    \"\"\"\n    # Delegate to TradeManager which handles:\n    # - Trade validation\n    # - Conversion to visual elements (markers, rectangles, etc.)\n    # - Profit/loss calculations\n    # - Color coding based on trade outcome\n    # - Annotation creation for visualization\n    self._trade_manager.add_trades(trades)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.set_tooltip_manager","title":"set_tooltip_manager","text":"<pre><code>set_tooltip_manager(tooltip_manager) -&gt; Chart\n</code></pre> <p>Set the tooltip manager for the chart.</p> <p>Assigns a TooltipManager instance to handle custom tooltip functionality. Tooltips provide additional information when hovering over chart elements.</p> <p>Parameters:</p> Name Type Description Default <code>tooltip_manager</code> <p>TooltipManager instance to handle tooltip functionality.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If tooltip_manager is not a TooltipManager instance.</p> Example <p>Set custom tooltip manager::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipManager\n... )\n&gt;&gt;&gt; manager = TooltipManager()\n&gt;&gt;&gt; chart.set_tooltip_manager(manager)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n    \"\"\"Set the tooltip manager for the chart.\n\n    Assigns a TooltipManager instance to handle custom tooltip functionality.\n    Tooltips provide additional information when hovering over chart elements.\n\n    Args:\n        tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n    Example:\n        Set custom tooltip manager::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipManager\n            ... )\n            &gt;&gt;&gt; manager = TooltipManager()\n            &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n    \"\"\"\n    # Validate tooltip_manager is a TooltipManager instance\n    if not isinstance(tooltip_manager, TooltipManager):\n        raise TypeValidationError(\n            \"tooltip_manager\", \"TooltipManager instance\"\n        )\n\n    # Assign the tooltip manager\n    self._tooltip_manager = tooltip_manager\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.add_tooltip_config","title":"add_tooltip_config","text":"<pre><code>add_tooltip_config(name: str, config) -&gt; Chart\n</code></pre> <p>Add a tooltip configuration to the chart.</p> <p>Adds a named tooltip configuration that defines how tooltips should be displayed for specific data points or series. Multiple tooltip configurations can be registered and used selectively.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the tooltip configuration (unique identifier).</p> required <code>config</code> <p>TooltipConfig instance defining tooltip appearance and behavior.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If config is not a TooltipConfig instance.</p> Example <p>Add custom tooltip configuration::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipConfig\n... )\n&gt;&gt;&gt; config = TooltipConfig(\n...     title=\"Price Info\",\n...     show_time=True,\n...     show_value=True\n... )\n&gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n    \"\"\"Add a tooltip configuration to the chart.\n\n    Adds a named tooltip configuration that defines how tooltips should\n    be displayed for specific data points or series. Multiple tooltip\n    configurations can be registered and used selectively.\n\n    Args:\n        name: Name for the tooltip configuration (unique identifier).\n        config: TooltipConfig instance defining tooltip appearance and behavior.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If config is not a TooltipConfig instance.\n\n    Example:\n        Add custom tooltip configuration::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipConfig\n            ... )\n            &gt;&gt;&gt; config = TooltipConfig(\n            ...     title=\"Price Info\",\n            ...     show_time=True,\n            ...     show_value=True\n            ... )\n            &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n    \"\"\"\n    # Validate config is a TooltipConfig instance\n    if not isinstance(config, TooltipConfig):\n        raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n    # Lazy-load tooltip manager if not already set\n    # This avoids creating TooltipManager until actually needed\n    if self._tooltip_manager is None:\n        self._tooltip_manager = TooltipManager()\n\n    # Add the configuration to the tooltip manager\n    self._tooltip_manager.add_config(name, config)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.set_chart_group_id","title":"set_chart_group_id","text":"<pre><code>set_chart_group_id(group_id: int) -&gt; Chart\n</code></pre> <p>Set the chart group ID for synchronization.</p> <p>Sets the chart group ID which is used for synchronizing multiple charts. Charts with the same group_id will be synchronized with each other, sharing crosshair position and time range changes.</p> Note <p>This is different from ChartManager's sync_group which manages synchronization at a higher level. chart_group_id is used for individual chart synchronization, while sync_group is used for managing groups of charts in ChartManager.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>int</code> <p>Group ID for synchronization. Charts with the same group_id will be synchronized.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If group_id is not an integer.</p> Example <p>Set chart group ID::</p> <pre><code>&gt;&gt;&gt; chart1.set_chart_group_id(1)\n&gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n</code></pre> <p>Disable synchronization::</p> <pre><code>&gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n    \"\"\"Set the chart group ID for synchronization.\n\n    Sets the chart group ID which is used for synchronizing multiple charts.\n    Charts with the same group_id will be synchronized with each other,\n    sharing crosshair position and time range changes.\n\n    Note:\n        This is different from ChartManager's sync_group which manages\n        synchronization at a higher level. chart_group_id is used for\n        individual chart synchronization, while sync_group is used for\n        managing groups of charts in ChartManager.\n\n    Args:\n        group_id (int): Group ID for synchronization. Charts with the same\n            group_id will be synchronized.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If group_id is not an integer.\n\n    Example:\n        Set chart group ID::\n\n            &gt;&gt;&gt; chart1.set_chart_group_id(1)\n            &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n        Disable synchronization::\n\n            &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n    \"\"\"\n    # Use property setter which includes validation\n    self.chart_group_id = group_id\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert chart to frontend configuration dictionary.</p> <p>Converts the chart and all its components (series, options, annotations, trades, tooltips) to a dictionary format suitable for frontend consumption. This method orchestrates the serialization of all chart elements.</p> The serialization process <ol> <li>Get series configurations from SeriesManager</li> <li>Get base chart options</li> <li>Get price scale configuration from PriceScaleManager</li> <li>Get annotations configuration from AnnotationManager</li> <li>Get trades configuration from TradeManager</li> <li>Get tooltip configurations from TooltipManager (if set)</li> <li>Generate complete frontend config using ChartRenderer</li> <li>Add force_reinit flag if set</li> </ol> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Complete chart configuration ready for frontend rendering. The configuration includes: - charts: List of chart objects with series and options - syncConfig: Synchronization settings for multi-chart layouts - annotations: Annotation layers and elements - trades: Trade visualization elements - tooltips: Custom tooltip configurations</p> Note <p>Series are automatically ordered by z-index within each pane to ensure proper layering in the frontend. Series with lower z-index values render behind series with higher z-index values.</p> Example <p>Get frontend configuration::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; print(json.dumps(config, indent=2))\n</code></pre> <p>Access specific parts::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; chart_config = config[\"charts\"][0]\n&gt;&gt;&gt; series_config = chart_config[\"series\"]\n&gt;&gt;&gt; options_config = chart_config[\"chart\"]\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert chart to frontend configuration dictionary.\n\n    Converts the chart and all its components (series, options, annotations,\n    trades, tooltips) to a dictionary format suitable for frontend consumption.\n    This method orchestrates the serialization of all chart elements.\n\n    The serialization process:\n        1. Get series configurations from SeriesManager\n        2. Get base chart options\n        3. Get price scale configuration from PriceScaleManager\n        4. Get annotations configuration from AnnotationManager\n        5. Get trades configuration from TradeManager\n        6. Get tooltip configurations from TooltipManager (if set)\n        7. Generate complete frontend config using ChartRenderer\n        8. Add force_reinit flag if set\n\n    Returns:\n        Dict[str, Any]: Complete chart configuration ready for frontend\n            rendering. The configuration includes:\n            - charts: List of chart objects with series and options\n            - syncConfig: Synchronization settings for multi-chart layouts\n            - annotations: Annotation layers and elements\n            - trades: Trade visualization elements\n            - tooltips: Custom tooltip configurations\n\n    Note:\n        Series are automatically ordered by z-index within each pane to ensure\n        proper layering in the frontend. Series with lower z-index values\n        render behind series with higher z-index values.\n\n    Example:\n        Get frontend configuration::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n        Access specific parts::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n            &gt;&gt;&gt; series_config = chart_config[\"series\"]\n            &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n    \"\"\"\n    # Step 1: Get series configurations from SeriesManager\n    # SeriesManager handles series ordering by z-index and pane\n    series_configs = self._series_manager.to_frontend_configs()\n\n    # Step 2: Get base chart configuration from ChartOptions\n    # Convert ChartOptions to dictionary for frontend\n    chart_config = (\n        self.options.asdict()\n        if self.options is not None\n        else ChartOptions().asdict()\n    )\n\n    # Step 3: Get price scale configuration from PriceScaleManager\n    # Manager validates scales and returns serialized configuration\n    price_scale_config = self._price_scale_manager.validate_and_serialize()\n    # Merge price scale config into chart config\n    chart_config.update(price_scale_config)\n\n    # Step 4: Get annotations configuration from AnnotationManager\n    # Converts all annotation layers to frontend format\n    annotations_config = self.annotation_manager.asdict()\n\n    # Step 5: Get trades configuration from TradeManager\n    # Converts TradeData objects to visual elements\n    # Uses trade_visualization options from chart options\n    trades_config = self._trade_manager.to_frontend_config(\n        self.options.trade_visualization if self.options else None\n    )\n\n    # Step 6: Get tooltip configurations from TooltipManager\n    tooltip_configs = None\n    if self._tooltip_manager:\n        # Convert each tooltip config to dictionary\n        tooltip_configs = {}\n        for name, tooltip_config in self._tooltip_manager.configs.items():\n            tooltip_configs[name] = tooltip_config.asdict()\n\n    # Step 7: Generate complete frontend configuration using ChartRenderer\n    # ChartRenderer assembles all components into final configuration\n    config = self._chart_renderer.generate_frontend_config(\n        chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n        chart_options=self.options,\n        series_configs=series_configs,\n        annotations_config=annotations_config,\n        trades_config=trades_config,\n        tooltip_configs=tooltip_configs,\n        chart_group_id=self.chart_group_id,\n        price_scale_config=price_scale_config,\n    )\n\n    # Step 8: Add force_reinit flag if set\n    # This tells frontend to completely rebuild the chart\n    # Used when indicator parameters or other settings change\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Return the complete frontend configuration\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.render","title":"render","text":"<pre><code>render(key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Converts the chart to frontend configuration and renders it using the Streamlit component. This is the final step in the chart creation process that displays the interactive chart in the Streamlit application.</p> The rendering process follows these steps <ol> <li>Generate or validate component key</li> <li>Reset config application flag for this render cycle</li> <li>Load and apply stored series configurations from session state</li> <li>Generate frontend configuration (after configs applied)</li> <li>Render component using ChartRenderer</li> <li>Handle component response and save updated series configs</li> </ol> <p>The chart configuration is generated fresh on each render, allowing users to control chart lifecycle and state management in their own code if needed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional unique key for the Streamlit component. This key is used to identify the component instance and is useful for debugging and component state management. If not provided, a unique key will be generated automatically using timestamp and UUID.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The rendered Streamlit component that displays the interactive chart. May contain user interaction data if the frontend sends responses.</p> Example <p>Basic rendering::</p> <pre><code>&gt;&gt;&gt; chart.render()\n</code></pre> <p>Rendering with custom key::</p> <pre><code>&gt;&gt;&gt; chart.render(key=\"my_chart\")\n</code></pre> <p>Method chaining with rendering::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_series(line_series)\n...  .update_options(height=600)\n...  .render(key=\"chart1\"))\n</code></pre> <p>User-managed state (advanced)::</p> <pre><code>&gt;&gt;&gt; # Store chart in session state for persistence\n&gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n...     st.session_state.my_chart = Chart(series=LineSeries(data))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Render the persisted chart\n&gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n</code></pre> <p>Dynamic key generation::</p> <pre><code>&gt;&gt;&gt; # Key includes timestamp for uniqueness\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def render(self, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Converts the chart to frontend configuration and renders it using the\n    Streamlit component. This is the final step in the chart creation process\n    that displays the interactive chart in the Streamlit application.\n\n    The rendering process follows these steps:\n        1. Generate or validate component key\n        2. Reset config application flag for this render cycle\n        3. Load and apply stored series configurations from session state\n        4. Generate frontend configuration (after configs applied)\n        5. Render component using ChartRenderer\n        6. Handle component response and save updated series configs\n\n    The chart configuration is generated fresh on each render, allowing users\n    to control chart lifecycle and state management in their own code if needed.\n\n    Args:\n        key (Optional[str]): Optional unique key for the Streamlit component.\n            This key is used to identify the component instance and is useful\n            for debugging and component state management. If not provided,\n            a unique key will be generated automatically using timestamp and UUID.\n\n    Returns:\n        Any: The rendered Streamlit component that displays the interactive chart.\n            May contain user interaction data if the frontend sends responses.\n\n    Example:\n        Basic rendering::\n\n            &gt;&gt;&gt; chart.render()\n\n        Rendering with custom key::\n\n            &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n        Method chaining with rendering::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_series(line_series)\n            ...  .update_options(height=600)\n            ...  .render(key=\"chart1\"))\n\n        User-managed state (advanced)::\n\n            &gt;&gt;&gt; # Store chart in session state for persistence\n            &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n            ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Render the persisted chart\n            &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n        Dynamic key generation::\n\n            &gt;&gt;&gt; # Key includes timestamp for uniqueness\n            &gt;&gt;&gt; import time\n            &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n    \"\"\"\n    # STEP 1: Generate a unique key if none provided or if it's invalid\n    if key is None or not isinstance(key, str) or not key.strip():\n        # Create unique identifier using timestamp and UUID\n        unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n        timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n        key = f\"chart_{timestamp}_{unique_id}\"\n\n    # STEP 2: Reset config application flag for this render cycle\n    # This ensures configs are only applied once per render\n    # Prevents duplicate application of stored configurations\n    self._session_state_manager.reset_config_applied_flag()\n\n    # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n    # This is critical: we must apply user-modified configs BEFORE\n    # generating the frontend configuration, otherwise the configs\n    # won't be included in the serialized data\n    stored_configs = self._session_state_manager.load_series_configs(key)\n    if stored_configs:\n        # Apply stored configs to all series\n        # This updates series options with user-modified settings\n        self._session_state_manager.apply_stored_configs_to_series(\n            stored_configs,\n            self.series,  # Current series list\n        )\n\n    # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n    # This ensures the frontend config includes all user modifications\n    # The to_frontend_config() method serializes all chart components\n    config = self.to_frontend_config()\n\n    # STEP 5: Render component using ChartRenderer\n    # ChartRenderer handles:\n    # - Component function retrieval\n    # - Configuration serialization to JSON\n    # - Component rendering through Streamlit\n    # - Error handling if component is unavailable\n    result = self._chart_renderer.render(config, key, self.options)\n\n    # STEP 6: Handle component return value and save series configs\n    # The frontend may send back user interactions or config changes\n    if result:\n        # ChartRenderer processes the response and updates session state\n        # This includes saving any user-modified series configurations\n        self._chart_renderer.handle_response(\n            result,\n            key,\n            self._session_state_manager,\n        )\n\n    # Return the component result\n    # This may contain user interaction data or None\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.Chart.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for the series settings dialog.</p> <p>Retrieves information about all series in a specific pane. This is used by the series settings dialog to display available series and their current configurations.</p> <p>Parameters:</p> Name Type Description Default <code>_pane_id</code> <code>int</code> <p>The pane ID to get series info for (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries containing: - series_index: Index of the series - series_type: Type of series (line, candlestick, etc.) - series_name: Display name of the series - current_config: Current series configuration</p> Example <p>Get series info::</p> <pre><code>&gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n&gt;&gt;&gt; for info in series_info:\n...     print(f\"{info['series_name']}: {info['series_type']}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for the series settings dialog.\n\n    Retrieves information about all series in a specific pane. This is\n    used by the series settings dialog to display available series and\n    their current configurations.\n\n    Args:\n        _pane_id: The pane ID to get series info for (default: 0).\n\n    Returns:\n        List of series information dictionaries containing:\n            - series_index: Index of the series\n            - series_type: Type of series (line, candlestick, etc.)\n            - series_name: Display name of the series\n            - current_config: Current series configuration\n\n    Example:\n        Get series info::\n\n            &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n            &gt;&gt;&gt; for info in series_info:\n            ...     print(f\"{info['series_name']}: {info['series_type']}\")\n    \"\"\"\n    # Delegate to SeriesManager which has access to all series data\n    return self._series_manager.get_series_info_for_pane(_pane_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager","title":"ChartManager","text":"<p>Manager for multiple synchronized charts.</p> <p>This class provides comprehensive functionality to manage multiple Chart instances with advanced synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> <p>The ChartManager maintains a registry of charts with unique identifiers and manages synchronization groups that allow charts to share crosshair position, time ranges, and other interactive states. This is particularly useful for creating multi-pane financial dashboards with coordinated chart behavior.</p> <p>Attributes:</p> Name Type Description <code>charts</code> <code>Dict[str, Chart]</code> <p>Dictionary mapping chart IDs to Chart instances.</p> <code>sync_groups</code> <code>Dict[str, SyncOptions]</code> <p>Dictionary mapping chart IDs to their synchronization group options.</p> <code>default_sync</code> <code>SyncOptions</code> <p>Default synchronization options applied to new charts when no specific group is assigned.</p> Example <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager\nmanager = ChartManager()\n\n# Add charts with unique IDs\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization groups\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render all charts with synchronization\nmanager.render_all_charts()\n</code></pre> Note <ul> <li>Charts must have unique IDs within the manager</li> <li>Synchronization groups allow coordinated behavior between charts</li> <li>Individual charts can be rendered or all charts can be rendered together</li> <li>The manager handles component lifecycle and state management</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>class ChartManager:\n    \"\"\"Manager for multiple synchronized charts.\n\n    This class provides comprehensive functionality to manage multiple Chart instances\n    with advanced synchronization capabilities. It enables coordinated display of\n    multiple charts with shared time ranges, crosshair synchronization, and group-based\n    configuration management.\n\n    The ChartManager maintains a registry of charts with unique identifiers and\n    manages synchronization groups that allow charts to share crosshair position,\n    time ranges, and other interactive states. This is particularly useful for\n    creating multi-pane financial dashboards with coordinated chart behavior.\n\n    Attributes:\n        charts (Dict[str, Chart]): Dictionary mapping chart IDs to Chart instances.\n        sync_groups (Dict[str, SyncOptions]): Dictionary mapping chart IDs to their\n            synchronization group options.\n        default_sync (SyncOptions): Default synchronization options applied to\n            new charts when no specific group is assigned.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create manager\n        manager = ChartManager()\n\n        # Add charts with unique IDs\n        manager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\n        manager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n        # Configure synchronization groups\n        manager.set_sync_group(\"price_chart\", \"main_group\")\n        manager.set_sync_group(\"volume_chart\", \"main_group\")\n\n        # Render all charts with synchronization\n        manager.render_all_charts()\n        ```\n\n    Note:\n        - Charts must have unique IDs within the manager\n        - Synchronization groups allow coordinated behavior between charts\n        - Individual charts can be rendered or all charts can be rendered together\n        - The manager handles component lifecycle and state management\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ChartManager.\n\n        Creates a new ChartManager with empty chart registry and default\n        synchronization settings. The manager starts with no charts and uses\n        default sync options for new charts.\n        \"\"\"\n        # Initialize chart registry - maps chart IDs to Chart instances\n        self.charts: Dict[str, Chart] = {}\n\n        # Initialize sync groups - maps chart IDs to their sync configuration\n        self.sync_groups: Dict[str, SyncOptions] = {}\n\n        # Set default sync options for new charts without specific group assignment\n        self.default_sync: SyncOptions = SyncOptions()\n\n        # Flag to force frontend re-initialization (for indicator/parameter changes)\n        self.force_reinit: bool = False\n\n        # Metadata for change detection (symbol/interval)\n        # These are used by frontend to detect when data context changes\n        self.symbol: Optional[str] = None\n        self.display_interval: Optional[str] = None\n\n    def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n        \"\"\"Add a chart to the manager.\n\n        Adds a Chart instance to the manager with a unique identifier. The chart\n        is registered in the manager's chart registry and can participate in\n        synchronization groups. If no chart ID is provided, one is automatically\n        generated.\n\n        Args:\n            chart (Chart): The Chart instance to add to the manager.\n            chart_id (Optional[str]): Optional unique identifier for the chart.\n                If not provided, an auto-generated ID in the format \"chart_N\"\n                will be assigned.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Raises:\n            DuplicateError: If a chart with the specified ID already exists.\n\n        Example:\n            ```python\n            manager = ChartManager()\n            chart = Chart(series=LineSeries(data))\n\n            # Add chart with auto-generated ID\n            manager.add_chart(chart)\n\n            # Add chart with custom ID\n            manager.add_chart(chart, \"price_chart\")\n            ```\n        \"\"\"\n        # Generate unique chart ID if not provided\n        if chart_id is None:\n            chart_id = f\"chart_{len(self.charts) + 1}\"\n\n        # Validate that chart ID is unique within the manager\n        if chart_id in self.charts:\n            raise DuplicateError(\"Chart\", chart_id)\n\n        # Set the ChartManager reference on the chart for bidirectional communication\n        # This allows the chart to access manager configuration and sync settings\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add chart to the registry with its unique identifier\n        self.charts[chart_id] = chart\n        return self\n\n    def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n        \"\"\"Remove a chart from the manager.\n\n        Args:\n            chart_id: ID of the chart to remove\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        del self.charts[chart_id]\n        return self\n\n    def get_chart(self, chart_id: str) -&gt; Chart:\n        \"\"\"Get a chart by ID.\n\n        Args:\n            chart_id: ID of the chart to retrieve\n\n        Returns:\n            The Chart instance\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        return self.charts[chart_id]\n\n    def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n        This method renders a single chart while preserving the ChartManager's\n        sync configuration and group settings. This ensures that individual\n        charts can still participate in group synchronization.\n\n        Args:\n            chart_id: The ID of the chart to render\n            key: Optional key for the Streamlit component\n\n        Returns:\n            The rendered component\n\n        Raises:\n            ValueError: If chart_id is not found\n\n        Example:\n            ```python\n            manager = ChartManager()\n            manager.add_chart(chart1, \"chart1\")\n            manager.add_chart(chart2, \"chart2\")\n\n            col1, col2 = st.columns(2)\n            with col1:\n                manager.render_chart(\"chart1\")\n            with col2:\n                manager.render_chart(\"chart2\")\n            ```\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        # Get the chart and render it (sync config is automatically included)\n        chart = self.charts[chart_id]\n        return chart.render(key=key)\n\n    def get_chart_ids(self) -&gt; List[str]:\n        \"\"\"Get all chart IDs.\n\n        Returns:\n            List of chart IDs\n        \"\"\"\n        return list(self.charts.keys())\n\n    def clear_charts(self) -&gt; \"ChartManager\":\n        \"\"\"Remove all charts from the manager.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self.charts.clear()\n        return self\n\n    def set_sync_group_config(\n        self,\n        group_id: Union[int, str],\n        sync_options: SyncOptions,\n    ) -&gt; \"ChartManager\":\n        \"\"\"Set synchronization configuration for a specific group.\n\n        This method allows you to configure synchronization options for a\n        specific group of charts. Groups enable you to have multiple independent\n        sets of synchronized charts within the same ChartManager.\n\n        For example, you might want to:\n        - Synchronize price and volume charts in one group\n        - Synchronize indicator charts in another group\n        - Keep some charts completely independent\n\n        Args:\n            group_id: The sync group ID (int or str). Charts with the same\n                group_id will be synchronized according to these options.\n            sync_options: The SyncOptions configuration object for this group,\n                specifying which synchronization features to enable.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n            manager = ChartManager()\n\n            # Configure group \"price_charts\" with full sync\n            price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n            manager.set_sync_group_config(\"price_charts\", price_sync)\n\n            # Configure group \"indicators\" with crosshair only\n            indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n            manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n            # Add charts to different groups\n            manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n            manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n            ```\n        \"\"\"\n        self.sync_groups[str(group_id)] = sync_options\n        return self\n\n    def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n        \"\"\"Get synchronization configuration for a specific group.\n\n        Retrieves the current synchronization options for a specified group.\n        This is useful for inspecting or modifying existing group configurations.\n\n        Args:\n            group_id: The sync group ID (int or str) to retrieve configuration for.\n\n        Returns:\n            SyncOptions: The sync configuration for the group, or None if the\n                group hasn't been configured yet.\n\n        Example:\n            ```python\n            # Get configuration for a group\n            config = manager.get_sync_group_config(\"price_charts\")\n            if config:\n                print(f\"Crosshair sync: {config.crosshair}\")\n                print(f\"Time range sync: {config.time_range}\")\n\n            # Check if group exists before modifying\n            if manager.get_sync_group_config(\"indicators\") is None:\n                manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n            ```\n        \"\"\"\n        return self.sync_groups.get(str(group_id))\n\n    def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable crosshair synchronization for linked charts.\n\n        When enabled, moving the crosshair on one chart will synchronize the\n        crosshair position across all charts in the same synchronization group.\n        This creates a coordinated viewing experience where users can see\n        corresponding data points across multiple charts simultaneously.\n\n        The synchronization uses a robust implementation with debouncing and\n        flag-based protection to prevent race conditions and feedback loops,\n        even during rapid user interactions.\n\n        Args:\n            group_id: Optional group ID to enable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n                Groups allow you to have multiple independent sets of\n                synchronized charts.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_crosshair_sync()\n\n            # Enable for specific group\n            manager.enable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_crosshair()\n        else:\n            self.default_sync.enable_crosshair()\n        return self\n\n    def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable crosshair synchronization for linked charts.\n\n        When disabled, crosshair movements will not be synchronized across\n        charts. Each chart will have an independent crosshair that only\n        responds to mouse movements over that specific chart.\n\n        Args:\n            group_id: Optional group ID to disable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_crosshair_sync()\n\n            # Disable for specific group\n            manager.disable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_crosshair()\n        else:\n            self.default_sync.disable_crosshair()\n        return self\n\n    def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n        When enabled, zooming or panning the time range on one chart will\n        synchronize the visible time range across all charts in the same\n        synchronization group. This allows users to maintain consistent\n        time alignment while analyzing multiple charts.\n\n        The synchronization includes:\n        - Zoom operations (pinch, scroll wheel, double-click)\n        - Pan/scroll operations (drag, arrow keys)\n        - Programmatic range changes\n\n        Implementation uses throttling (16ms ~60fps) to ensure smooth\n        performance and prevent race conditions during rapid interactions.\n\n        Args:\n            group_id: Optional group ID to enable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_time_range_sync()\n\n            # Enable for specific group\n            manager.enable_time_range_sync(group_id=\"indicators\")\n\n            # Enable both crosshair and time range\n            manager.enable_crosshair_sync().enable_time_range_sync()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_time_range()\n        else:\n            self.default_sync.enable_time_range()\n        return self\n\n    def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n        When disabled, zoom and pan operations will not be synchronized across\n        charts. Each chart can be zoomed and panned independently.\n\n        Args:\n            group_id: Optional group ID to disable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_time_range_sync()\n\n            # Disable for specific group\n            manager.disable_time_range_sync(group_id=\"indicators\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_time_range()\n        else:\n            self.default_sync.disable_time_range()\n        return self\n\n    def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable all synchronization features for linked charts.\n\n        This is a convenience method that enables both crosshair and time range\n        synchronization in a single call. It's the most common configuration for\n        creating fully synchronized multi-chart dashboards.\n\n        When all synchronization is enabled:\n        - Crosshair movements are synchronized across all charts\n        - Zoom/pan operations are synchronized across all charts\n        - Users get a fully coordinated viewing experience\n\n        Args:\n            group_id: Optional group ID to enable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable all sync for default group\n            manager.enable_all_sync()\n\n            # Enable all sync for specific group\n            manager.enable_all_sync(group_id=\"main_charts\")\n\n            # Create fully synchronized dashboard\n            manager = ChartManager()\n            manager.add_chart(price_chart, \"price\")\n            manager.add_chart(volume_chart, \"volume\")\n            manager.add_chart(indicator_chart, \"indicator\")\n            manager.enable_all_sync()\n            manager.render()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_all()\n        else:\n            self.default_sync.enable_all()\n        return self\n\n    def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable all synchronization features for linked charts.\n\n        This is a convenience method that disables both crosshair and time range\n        synchronization in a single call. Use this when you want charts to\n        operate completely independently.\n\n        When all synchronization is disabled:\n        - Each chart has its own independent crosshair\n        - Each chart can be zoomed/panned independently\n        - No coordination between charts\n\n        Args:\n            group_id: Optional group ID to disable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable all sync for default group\n            manager.disable_all_sync()\n\n            # Disable all sync for specific group\n            manager.disable_all_sync(group_id=\"main_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_all()\n        else:\n            self.default_sync.disable_all()\n        return self\n\n    def from_price_volume_dataframe(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        chart_id: str = \"main_chart\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Create a chart from OHLCV data with price and volume series.\n\n        Factory method that creates a new Chart instance with both price and volume\n        series from OHLCV data. This is a convenient way to create a complete\n        price-volume chart in a single operation.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Defaults to None.\n            price_type (str, optional): Type of price series ('candlestick' or 'line').\n                Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration. Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration. Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0.\n\n        Returns:\n            Chart: A new Chart instance with price and volume series.\n\n        Example:\n            ```python\n            # Create chart from DataFrame\n            chart = Chart.from_price_volume_dataframe(\n                df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n            )\n\n            # Create chart from OHLCV data\n            chart = Chart.from_price_volume_dataframe(\n                ohlcv_data,\n                price_type=\"line\",\n                volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n            )\n            ```\n        \"\"\"\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)):\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n        chart = Chart()\n        chart.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n        )\n\n        # Set the ChartManager reference on the chart\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add the chart to the manager with an ID\n        self.add_chart(chart, chart_id=chart_id)\n\n        return chart\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the chart manager to frontend configuration.\n\n        Returns:\n            Dictionary containing the frontend configuration\n        \"\"\"\n        if not self.charts:\n            return {\n                \"charts\": [],\n                \"syncConfig\": self.default_sync.asdict(),\n            }\n\n        chart_configs = []\n        for chart_id, chart in self.charts.items():\n            chart_config = chart.to_frontend_config()\n            if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n                chart_obj = chart_config[\"charts\"][0]\n                chart_obj[\"chartId\"] = chart_id\n                chart_configs.append(chart_obj)\n            else:\n                # Skip charts with invalid configuration\n                continue\n\n        # Build sync configuration\n        sync_config = self.default_sync.asdict()\n\n        # Add group-specific sync configurations\n        if self.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.sync_groups.items():\n                sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n        config = {\n            \"charts\": chart_configs,\n            \"syncConfig\": sync_config,\n        }\n\n        # Add force_reinit flag if set\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Add metadata for frontend change detection\n        # This allows frontend to detect symbol/interval changes\n        if self.symbol is not None:\n            config[\"symbol\"] = self.symbol\n        if self.display_interval is not None:\n            config[\"displayInterval\"] = str(self.display_interval)\n\n        return config\n\n    def _auto_detect_changes(self, key: str) -&gt; None:\n        \"\"\"\n        Automatically detect changes and set force_reinit if needed.\n\n        This is internal library logic - the user should never call this.\n        It compares current state with previous render to detect changes.\n\n        Args:\n            key: Component key for state storage\n        \"\"\"\n        import hashlib  # pylint: disable=import-outside-toplevel\n        import json  # pylint: disable=import-outside-toplevel\n\n        import streamlit as st  # pylint: disable=import-outside-toplevel\n\n        # Build state key for this chart\n        state_key = f\"_lwc_chart_state_{key}\"\n\n        # Get previous state\n        prev_state = st.session_state.get(state_key)\n\n        # Build current state signature\n        # Include: symbol, interval, chart count, series structure\n        current_state = {\n            \"symbol\": self.symbol,\n            \"interval\": self.display_interval,\n            \"chart_count\": len(self.charts),\n            \"series_structure\": [],\n        }\n\n        # Add series structure fingerprint (types, data length, and full data hash)\n        for chart in self.charts.values():\n            for _idx, series in enumerate(chart.series):\n                # Calculate hash of entire data array for 100% accurate change detection\n                # This is cheap (~1ms for 10K points) and catches ALL data changes\n                data_hash = None\n                if hasattr(series, \"data\") and series.data:\n                    try:\n                        # Hash the entire data array\n                        data_str = str(series.data)\n                        data_hash = hashlib.md5(data_str.encode()).hexdigest()[:8]  # noqa: S324\n                    except Exception:\n                        # Fallback to None if serialization fails\n                        data_hash = None\n\n                series_info = {\n                    \"type\": type(series).__name__,\n                    \"data_length\": len(series.data)\n                    if hasattr(series, \"data\") and series.data\n                    else 0,\n                    \"data_hash\": data_hash,  # Full data hash - catches ALL changes!\n                }\n                current_state[\"series_structure\"].append(series_info)\n\n        # Calculate hash for comparison\n        current_hash = hashlib.md5(  # noqa: S324\n            json.dumps(current_state, sort_keys=True, default=str).encode()\n        ).hexdigest()[:8]\n\n        # AUTO-DETECT if reinit needed\n        # Check if there's a pending reinit from previous run (handles Streamlit multiple reruns)\n        pending_reinit_key = f\"{state_key}_pending_reinit\"\n        pending_reinit = st.session_state.get(pending_reinit_key, False)\n\n        if prev_state is None:\n            # First render - no reinit needed\n            self.force_reinit = False\n            st.session_state[pending_reinit_key] = False\n        elif prev_state != current_hash:\n            # State changed - force reinit and mark as pending for next rerun\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = True\n        elif pending_reinit:\n            # Hash is same but there's a pending reinit from previous run\n            # This handles Streamlit's multiple reruns after a change\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = False  # Clear the flag\n        else:\n            # Same hash, no pending reinit - no changes detected\n            self.force_reinit = False\n\n        # Store current state for next render\n        st.session_state[state_key] = current_hash\n\n    def render(\n        self,\n        key: Optional[str] = None,\n        symbol: Optional[str] = None,\n        interval: Optional[str] = None,\n    ) -&gt; Any:\n        \"\"\"Render the chart manager with automatic change detection.\n\n        The library automatically detects changes in symbol, interval, series structure,\n        and data, and reinitializes the chart only when needed while preserving\n        customizations.\n\n        Args:\n            key: Optional key for the Streamlit component\n            symbol: Optional symbol name for automatic change detection and metadata\n            interval: Optional interval for automatic change detection and metadata\n\n        Returns:\n            The rendered component\n\n        Raises:\n            RuntimeError: If no charts have been added to the manager\n\n        Note:\n            The library handles change detection internally. You don't need to:\n            - Calculate hashes\n            - Track previous values\n            - Set force_reinit manually\n            - Clear caches\n\n            Just call render() with current symbol/interval and the library\n            handles the rest!\n        \"\"\"\n        if not self.charts:\n            raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n        # STEP 0: Set metadata if provided (before change detection)\n        if symbol is not None:\n            self.symbol = symbol\n        if interval is not None:\n            self.display_interval = interval\n\n        # STEP 1: Generate/validate key (same as Chart.render())\n        if key is None or not isinstance(key, str) or not key.strip():\n            unique_id = str(uuid.uuid4())[:8]\n            key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n        # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n        # This makes the library handle change detection instead of the user\n        self._auto_detect_changes(key)\n\n        # STEP 2: For each chart, reset config flag and load/apply stored configs\n        # This ensures user changes from series dialog persist across reruns\n        # Use the same key for loading/saving so customizations persist\n        for chart in self.charts.values():\n            # Reset config application flag for this render cycle\n            chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n            # Load stored configs from session state using the component key\n            stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n            # Apply configs to series objects BEFORE serialization\n            if stored_configs:\n                chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                    stored_configs,\n                    chart.series,\n                )\n\n        # STEP 3: Generate frontend configuration AFTER configs are applied\n        config = self.to_frontend_config()\n\n        # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n        # Get the first chart's renderer since they all use the same implementation\n        first_chart = next(iter(self.charts.values()))\n        result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n            config,\n            key,\n            None,  # ChartManager doesn't have global chart_options\n        )\n\n        # STEP 5: Handle component return value and save series configs\n        # This ensures changes from frontend are saved to session state\n        # Use same key for saving so configs persist\n        if result:\n            for chart in self.charts.values():\n                chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                    result,\n                    key,  # Use same key for consistency\n                    chart._session_state_manager,  # pylint: disable=protected-access\n                )\n\n        return result\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of charts in the manager.\"\"\"\n        return len(self.charts)\n\n    def __contains__(self, chart_id: str) -&gt; bool:\n        \"\"\"Check if a chart ID exists in the manager.\"\"\"\n        return chart_id in self.charts\n\n    def __iter__(self):\n        \"\"\"Iterate over chart IDs in the manager.\"\"\"\n        return iter(self.charts.keys())\n\n    def keys(self):\n        \"\"\"Return chart IDs in the manager.\"\"\"\n        return self.charts.keys()\n\n    def values(self):\n        \"\"\"Return chart instances in the manager.\"\"\"\n        return self.charts.values()\n\n    def items(self):\n        \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n        return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.add_chart","title":"add_chart","text":"<pre><code>add_chart(chart: Chart, chart_id: Optional[str] = None) -&gt; ChartManager\n</code></pre> <p>Add a chart to the manager.</p> <p>Adds a Chart instance to the manager with a unique identifier. The chart is registered in the manager's chart registry and can participate in synchronization groups. If no chart ID is provided, one is automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>Chart</code> <p>The Chart instance to add to the manager.</p> required <code>chart_id</code> <code>Optional[str]</code> <p>Optional unique identifier for the chart. If not provided, an auto-generated ID in the format \"chart_N\" will be assigned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>DuplicateError</code> <p>If a chart with the specified ID already exists.</p> Example <pre><code>manager = ChartManager()\nchart = Chart(series=LineSeries(data))\n\n# Add chart with auto-generated ID\nmanager.add_chart(chart)\n\n# Add chart with custom ID\nmanager.add_chart(chart, \"price_chart\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n    \"\"\"Add a chart to the manager.\n\n    Adds a Chart instance to the manager with a unique identifier. The chart\n    is registered in the manager's chart registry and can participate in\n    synchronization groups. If no chart ID is provided, one is automatically\n    generated.\n\n    Args:\n        chart (Chart): The Chart instance to add to the manager.\n        chart_id (Optional[str]): Optional unique identifier for the chart.\n            If not provided, an auto-generated ID in the format \"chart_N\"\n            will be assigned.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Raises:\n        DuplicateError: If a chart with the specified ID already exists.\n\n    Example:\n        ```python\n        manager = ChartManager()\n        chart = Chart(series=LineSeries(data))\n\n        # Add chart with auto-generated ID\n        manager.add_chart(chart)\n\n        # Add chart with custom ID\n        manager.add_chart(chart, \"price_chart\")\n        ```\n    \"\"\"\n    # Generate unique chart ID if not provided\n    if chart_id is None:\n        chart_id = f\"chart_{len(self.charts) + 1}\"\n\n    # Validate that chart ID is unique within the manager\n    if chart_id in self.charts:\n        raise DuplicateError(\"Chart\", chart_id)\n\n    # Set the ChartManager reference on the chart for bidirectional communication\n    # This allows the chart to access manager configuration and sync settings\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add chart to the registry with its unique identifier\n    self.charts[chart_id] = chart\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.remove_chart","title":"remove_chart","text":"<pre><code>remove_chart(chart_id: str) -&gt; ChartManager\n</code></pre> <p>Remove a chart from the manager.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to remove</p> required <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n    \"\"\"Remove a chart from the manager.\n\n    Args:\n        chart_id: ID of the chart to remove\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    del self.charts[chart_id]\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.get_chart","title":"get_chart","text":"<pre><code>get_chart(chart_id: str) -&gt; Chart\n</code></pre> <p>Get a chart by ID.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to retrieve</p> required <p>Returns:</p> Type Description <code>Chart</code> <p>The Chart instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart(self, chart_id: str) -&gt; Chart:\n    \"\"\"Get a chart by ID.\n\n    Args:\n        chart_id: ID of the chart to retrieve\n\n    Returns:\n        The Chart instance\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    return self.charts[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.render_chart","title":"render_chart","text":"<pre><code>render_chart(chart_id: str, key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render a specific chart from the manager with proper sync configuration.</p> <p>This method renders a single chart while preserving the ChartManager's sync configuration and group settings. This ensures that individual charts can still participate in group synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>The ID of the chart to render</p> required <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chart_id is not found</p> Example <pre><code>manager = ChartManager()\nmanager.add_chart(chart1, \"chart1\")\nmanager.add_chart(chart2, \"chart2\")\n\ncol1, col2 = st.columns(2)\nwith col1:\n    manager.render_chart(\"chart1\")\nwith col2:\n    manager.render_chart(\"chart2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n    This method renders a single chart while preserving the ChartManager's\n    sync configuration and group settings. This ensures that individual\n    charts can still participate in group synchronization.\n\n    Args:\n        chart_id: The ID of the chart to render\n        key: Optional key for the Streamlit component\n\n    Returns:\n        The rendered component\n\n    Raises:\n        ValueError: If chart_id is not found\n\n    Example:\n        ```python\n        manager = ChartManager()\n        manager.add_chart(chart1, \"chart1\")\n        manager.add_chart(chart2, \"chart2\")\n\n        col1, col2 = st.columns(2)\n        with col1:\n            manager.render_chart(\"chart1\")\n        with col2:\n            manager.render_chart(\"chart2\")\n        ```\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    # Get the chart and render it (sync config is automatically included)\n    chart = self.charts[chart_id]\n    return chart.render(key=key)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.get_chart_ids","title":"get_chart_ids","text":"<pre><code>get_chart_ids() -&gt; List[str]\n</code></pre> <p>Get all chart IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of chart IDs</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart_ids(self) -&gt; List[str]:\n    \"\"\"Get all chart IDs.\n\n    Returns:\n        List of chart IDs\n    \"\"\"\n    return list(self.charts.keys())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.clear_charts","title":"clear_charts","text":"<pre><code>clear_charts() -&gt; ChartManager\n</code></pre> <p>Remove all charts from the manager.</p> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def clear_charts(self) -&gt; \"ChartManager\":\n    \"\"\"Remove all charts from the manager.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.charts.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.set_sync_group_config","title":"set_sync_group_config","text":"<pre><code>set_sync_group_config(group_id: Union[int, str], sync_options: SyncOptions) -&gt; ChartManager\n</code></pre> <p>Set synchronization configuration for a specific group.</p> <p>This method allows you to configure synchronization options for a specific group of charts. Groups enable you to have multiple independent sets of synchronized charts within the same ChartManager.</p> <p>For example, you might want to: - Synchronize price and volume charts in one group - Synchronize indicator charts in another group - Keep some charts completely independent</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str). Charts with the same group_id will be synchronized according to these options.</p> required <code>sync_options</code> <code>SyncOptions</code> <p>The SyncOptions configuration object for this group, specifying which synchronization features to enable.</p> required <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\nmanager = ChartManager()\n\n# Configure group \"price_charts\" with full sync\nprice_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\nmanager.set_sync_group_config(\"price_charts\", price_sync)\n\n# Configure group \"indicators\" with crosshair only\nindicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\nmanager.set_sync_group_config(\"indicators\", indicator_sync)\n\n# Add charts to different groups\nmanager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\nmanager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def set_sync_group_config(\n    self,\n    group_id: Union[int, str],\n    sync_options: SyncOptions,\n) -&gt; \"ChartManager\":\n    \"\"\"Set synchronization configuration for a specific group.\n\n    This method allows you to configure synchronization options for a\n    specific group of charts. Groups enable you to have multiple independent\n    sets of synchronized charts within the same ChartManager.\n\n    For example, you might want to:\n    - Synchronize price and volume charts in one group\n    - Synchronize indicator charts in another group\n    - Keep some charts completely independent\n\n    Args:\n        group_id: The sync group ID (int or str). Charts with the same\n            group_id will be synchronized according to these options.\n        sync_options: The SyncOptions configuration object for this group,\n            specifying which synchronization features to enable.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n        manager = ChartManager()\n\n        # Configure group \"price_charts\" with full sync\n        price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n        manager.set_sync_group_config(\"price_charts\", price_sync)\n\n        # Configure group \"indicators\" with crosshair only\n        indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n        manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n        # Add charts to different groups\n        manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n        manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n        ```\n    \"\"\"\n    self.sync_groups[str(group_id)] = sync_options\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.get_sync_group_config","title":"get_sync_group_config","text":"<pre><code>get_sync_group_config(group_id: Union[int, str]) -&gt; Optional[SyncOptions]\n</code></pre> <p>Get synchronization configuration for a specific group.</p> <p>Retrieves the current synchronization options for a specified group. This is useful for inspecting or modifying existing group configurations.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str) to retrieve configuration for.</p> required <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>Optional[SyncOptions]</code> <p>The sync configuration for the group, or None if the group hasn't been configured yet.</p> Example <pre><code># Get configuration for a group\nconfig = manager.get_sync_group_config(\"price_charts\")\nif config:\n    print(f\"Crosshair sync: {config.crosshair}\")\n    print(f\"Time range sync: {config.time_range}\")\n\n# Check if group exists before modifying\nif manager.get_sync_group_config(\"indicators\") is None:\n    manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n    \"\"\"Get synchronization configuration for a specific group.\n\n    Retrieves the current synchronization options for a specified group.\n    This is useful for inspecting or modifying existing group configurations.\n\n    Args:\n        group_id: The sync group ID (int or str) to retrieve configuration for.\n\n    Returns:\n        SyncOptions: The sync configuration for the group, or None if the\n            group hasn't been configured yet.\n\n    Example:\n        ```python\n        # Get configuration for a group\n        config = manager.get_sync_group_config(\"price_charts\")\n        if config:\n            print(f\"Crosshair sync: {config.crosshair}\")\n            print(f\"Time range sync: {config.time_range}\")\n\n        # Check if group exists before modifying\n        if manager.get_sync_group_config(\"indicators\") is None:\n            manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n        ```\n    \"\"\"\n    return self.sync_groups.get(str(group_id))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.enable_crosshair_sync","title":"enable_crosshair_sync","text":"<pre><code>enable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable crosshair synchronization for linked charts.</p> <p>When enabled, moving the crosshair on one chart will synchronize the crosshair position across all charts in the same synchronization group. This creates a coordinated viewing experience where users can see corresponding data points across multiple charts simultaneously.</p> <p>The synchronization uses a robust implementation with debouncing and flag-based protection to prevent race conditions and feedback loops, even during rapid user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable crosshair sync for a specific group. If None, applies to the default synchronization group. Groups allow you to have multiple independent sets of synchronized charts.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_crosshair_sync()\n\n# Enable for specific group\nmanager.enable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable crosshair synchronization for linked charts.\n\n    When enabled, moving the crosshair on one chart will synchronize the\n    crosshair position across all charts in the same synchronization group.\n    This creates a coordinated viewing experience where users can see\n    corresponding data points across multiple charts simultaneously.\n\n    The synchronization uses a robust implementation with debouncing and\n    flag-based protection to prevent race conditions and feedback loops,\n    even during rapid user interactions.\n\n    Args:\n        group_id: Optional group ID to enable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n            Groups allow you to have multiple independent sets of\n            synchronized charts.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_crosshair_sync()\n\n        # Enable for specific group\n        manager.enable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_crosshair()\n    else:\n        self.default_sync.enable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.disable_crosshair_sync","title":"disable_crosshair_sync","text":"<pre><code>disable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable crosshair synchronization for linked charts.</p> <p>When disabled, crosshair movements will not be synchronized across charts. Each chart will have an independent crosshair that only responds to mouse movements over that specific chart.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable crosshair sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_crosshair_sync()\n\n# Disable for specific group\nmanager.disable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable crosshair synchronization for linked charts.\n\n    When disabled, crosshair movements will not be synchronized across\n    charts. Each chart will have an independent crosshair that only\n    responds to mouse movements over that specific chart.\n\n    Args:\n        group_id: Optional group ID to disable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_crosshair_sync()\n\n        # Disable for specific group\n        manager.disable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_crosshair()\n    else:\n        self.default_sync.disable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.enable_time_range_sync","title":"enable_time_range_sync","text":"<pre><code>enable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable time range (zoom/scroll) synchronization for linked charts.</p> <p>When enabled, zooming or panning the time range on one chart will synchronize the visible time range across all charts in the same synchronization group. This allows users to maintain consistent time alignment while analyzing multiple charts.</p> <p>The synchronization includes: - Zoom operations (pinch, scroll wheel, double-click) - Pan/scroll operations (drag, arrow keys) - Programmatic range changes</p> <p>Implementation uses throttling (16ms ~60fps) to ensure smooth performance and prevent race conditions during rapid interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_time_range_sync()\n\n# Enable for specific group\nmanager.enable_time_range_sync(group_id=\"indicators\")\n\n# Enable both crosshair and time range\nmanager.enable_crosshair_sync().enable_time_range_sync()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n    When enabled, zooming or panning the time range on one chart will\n    synchronize the visible time range across all charts in the same\n    synchronization group. This allows users to maintain consistent\n    time alignment while analyzing multiple charts.\n\n    The synchronization includes:\n    - Zoom operations (pinch, scroll wheel, double-click)\n    - Pan/scroll operations (drag, arrow keys)\n    - Programmatic range changes\n\n    Implementation uses throttling (16ms ~60fps) to ensure smooth\n    performance and prevent race conditions during rapid interactions.\n\n    Args:\n        group_id: Optional group ID to enable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_time_range_sync()\n\n        # Enable for specific group\n        manager.enable_time_range_sync(group_id=\"indicators\")\n\n        # Enable both crosshair and time range\n        manager.enable_crosshair_sync().enable_time_range_sync()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_time_range()\n    else:\n        self.default_sync.enable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.disable_time_range_sync","title":"disable_time_range_sync","text":"<pre><code>disable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable time range (zoom/scroll) synchronization for linked charts.</p> <p>When disabled, zoom and pan operations will not be synchronized across charts. Each chart can be zoomed and panned independently.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_time_range_sync()\n\n# Disable for specific group\nmanager.disable_time_range_sync(group_id=\"indicators\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n    When disabled, zoom and pan operations will not be synchronized across\n    charts. Each chart can be zoomed and panned independently.\n\n    Args:\n        group_id: Optional group ID to disable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_time_range_sync()\n\n        # Disable for specific group\n        manager.disable_time_range_sync(group_id=\"indicators\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_time_range()\n    else:\n        self.default_sync.disable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.enable_all_sync","title":"enable_all_sync","text":"<pre><code>enable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable all synchronization features for linked charts.</p> <p>This is a convenience method that enables both crosshair and time range synchronization in a single call. It's the most common configuration for creating fully synchronized multi-chart dashboards.</p> <p>When all synchronization is enabled: - Crosshair movements are synchronized across all charts - Zoom/pan operations are synchronized across all charts - Users get a fully coordinated viewing experience</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable all sync for default group\nmanager.enable_all_sync()\n\n# Enable all sync for specific group\nmanager.enable_all_sync(group_id=\"main_charts\")\n\n# Create fully synchronized dashboard\nmanager = ChartManager()\nmanager.add_chart(price_chart, \"price\")\nmanager.add_chart(volume_chart, \"volume\")\nmanager.add_chart(indicator_chart, \"indicator\")\nmanager.enable_all_sync()\nmanager.render()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable all synchronization features for linked charts.\n\n    This is a convenience method that enables both crosshair and time range\n    synchronization in a single call. It's the most common configuration for\n    creating fully synchronized multi-chart dashboards.\n\n    When all synchronization is enabled:\n    - Crosshair movements are synchronized across all charts\n    - Zoom/pan operations are synchronized across all charts\n    - Users get a fully coordinated viewing experience\n\n    Args:\n        group_id: Optional group ID to enable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable all sync for default group\n        manager.enable_all_sync()\n\n        # Enable all sync for specific group\n        manager.enable_all_sync(group_id=\"main_charts\")\n\n        # Create fully synchronized dashboard\n        manager = ChartManager()\n        manager.add_chart(price_chart, \"price\")\n        manager.add_chart(volume_chart, \"volume\")\n        manager.add_chart(indicator_chart, \"indicator\")\n        manager.enable_all_sync()\n        manager.render()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_all()\n    else:\n        self.default_sync.enable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.disable_all_sync","title":"disable_all_sync","text":"<pre><code>disable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable all synchronization features for linked charts.</p> <p>This is a convenience method that disables both crosshair and time range synchronization in a single call. Use this when you want charts to operate completely independently.</p> <p>When all synchronization is disabled: - Each chart has its own independent crosshair - Each chart can be zoomed/panned independently - No coordination between charts</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable all sync for default group\nmanager.disable_all_sync()\n\n# Disable all sync for specific group\nmanager.disable_all_sync(group_id=\"main_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable all synchronization features for linked charts.\n\n    This is a convenience method that disables both crosshair and time range\n    synchronization in a single call. Use this when you want charts to\n    operate completely independently.\n\n    When all synchronization is disabled:\n    - Each chart has its own independent crosshair\n    - Each chart can be zoomed/panned independently\n    - No coordination between charts\n\n    Args:\n        group_id: Optional group ID to disable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable all sync for default group\n        manager.disable_all_sync()\n\n        # Disable all sync for specific group\n        manager.disable_all_sync(group_id=\"main_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_all()\n    else:\n        self.default_sync.disable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.from_price_volume_dataframe","title":"from_price_volume_dataframe","text":"<pre><code>from_price_volume_dataframe(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', chart_id: str = 'main_chart', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Create a chart from OHLCV data with price and volume series.</p> <p>Factory method that creates a new Chart instance with both price and volume series from OHLCV data. This is a convenient way to create a complete price-volume chart in a single operation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Defaults to None.</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line'). Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration. Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration. Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>A new Chart instance with price and volume series.</p> Example <pre><code># Create chart from DataFrame\nchart = Chart.from_price_volume_dataframe(\n    df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n)\n\n# Create chart from OHLCV data\nchart = Chart.from_price_volume_dataframe(\n    ohlcv_data,\n    price_type=\"line\",\n    volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def from_price_volume_dataframe(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    chart_id: str = \"main_chart\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Create a chart from OHLCV data with price and volume series.\n\n    Factory method that creates a new Chart instance with both price and volume\n    series from OHLCV data. This is a convenient way to create a complete\n    price-volume chart in a single operation.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Defaults to None.\n        price_type (str, optional): Type of price series ('candlestick' or 'line').\n            Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration. Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration. Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0.\n\n    Returns:\n        Chart: A new Chart instance with price and volume series.\n\n    Example:\n        ```python\n        # Create chart from DataFrame\n        chart = Chart.from_price_volume_dataframe(\n            df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n        )\n\n        # Create chart from OHLCV data\n        chart = Chart.from_price_volume_dataframe(\n            ohlcv_data,\n            price_type=\"line\",\n            volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n        )\n        ```\n    \"\"\"\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)):\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n    chart = Chart()\n    chart.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n    )\n\n    # Set the ChartManager reference on the chart\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add the chart to the manager with an ID\n    self.add_chart(chart, chart_id=chart_id)\n\n    return chart\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert the chart manager to frontend configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing the frontend configuration</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the chart manager to frontend configuration.\n\n    Returns:\n        Dictionary containing the frontend configuration\n    \"\"\"\n    if not self.charts:\n        return {\n            \"charts\": [],\n            \"syncConfig\": self.default_sync.asdict(),\n        }\n\n    chart_configs = []\n    for chart_id, chart in self.charts.items():\n        chart_config = chart.to_frontend_config()\n        if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n            chart_obj = chart_config[\"charts\"][0]\n            chart_obj[\"chartId\"] = chart_id\n            chart_configs.append(chart_obj)\n        else:\n            # Skip charts with invalid configuration\n            continue\n\n    # Build sync configuration\n    sync_config = self.default_sync.asdict()\n\n    # Add group-specific sync configurations\n    if self.sync_groups:\n        sync_config[\"groups\"] = {}\n        for group_id, group_sync in self.sync_groups.items():\n            sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n    config = {\n        \"charts\": chart_configs,\n        \"syncConfig\": sync_config,\n    }\n\n    # Add force_reinit flag if set\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Add metadata for frontend change detection\n    # This allows frontend to detect symbol/interval changes\n    if self.symbol is not None:\n        config[\"symbol\"] = self.symbol\n    if self.display_interval is not None:\n        config[\"displayInterval\"] = str(self.display_interval)\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.render","title":"render","text":"<pre><code>render(key: Optional[str] = None, symbol: Optional[str] = None, interval: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart manager with automatic change detection.</p> <p>The library automatically detects changes in symbol, interval, series structure, and data, and reinitializes the chart only when needed while preserving customizations.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <code>symbol</code> <code>Optional[str]</code> <p>Optional symbol name for automatic change detection and metadata</p> <code>None</code> <code>interval</code> <code>Optional[str]</code> <p>Optional interval for automatic change detection and metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no charts have been added to the manager</p> Note <p>The library handles change detection internally. You don't need to: - Calculate hashes - Track previous values - Set force_reinit manually - Clear caches</p> <p>Just call render() with current symbol/interval and the library handles the rest!</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render(\n    self,\n    key: Optional[str] = None,\n    symbol: Optional[str] = None,\n    interval: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Render the chart manager with automatic change detection.\n\n    The library automatically detects changes in symbol, interval, series structure,\n    and data, and reinitializes the chart only when needed while preserving\n    customizations.\n\n    Args:\n        key: Optional key for the Streamlit component\n        symbol: Optional symbol name for automatic change detection and metadata\n        interval: Optional interval for automatic change detection and metadata\n\n    Returns:\n        The rendered component\n\n    Raises:\n        RuntimeError: If no charts have been added to the manager\n\n    Note:\n        The library handles change detection internally. You don't need to:\n        - Calculate hashes\n        - Track previous values\n        - Set force_reinit manually\n        - Clear caches\n\n        Just call render() with current symbol/interval and the library\n        handles the rest!\n    \"\"\"\n    if not self.charts:\n        raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n    # STEP 0: Set metadata if provided (before change detection)\n    if symbol is not None:\n        self.symbol = symbol\n    if interval is not None:\n        self.display_interval = interval\n\n    # STEP 1: Generate/validate key (same as Chart.render())\n    if key is None or not isinstance(key, str) or not key.strip():\n        unique_id = str(uuid.uuid4())[:8]\n        key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n    # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n    # This makes the library handle change detection instead of the user\n    self._auto_detect_changes(key)\n\n    # STEP 2: For each chart, reset config flag and load/apply stored configs\n    # This ensures user changes from series dialog persist across reruns\n    # Use the same key for loading/saving so customizations persist\n    for chart in self.charts.values():\n        # Reset config application flag for this render cycle\n        chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n        # Load stored configs from session state using the component key\n        stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n        # Apply configs to series objects BEFORE serialization\n        if stored_configs:\n            chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                stored_configs,\n                chart.series,\n            )\n\n    # STEP 3: Generate frontend configuration AFTER configs are applied\n    config = self.to_frontend_config()\n\n    # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n    # Get the first chart's renderer since they all use the same implementation\n    first_chart = next(iter(self.charts.values()))\n    result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n        config,\n        key,\n        None,  # ChartManager doesn't have global chart_options\n    )\n\n    # STEP 5: Handle component return value and save series configs\n    # This ensures changes from frontend are saved to session state\n    # Use same key for saving so configs persist\n    if result:\n        for chart in self.charts.values():\n            chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                result,\n                key,  # Use same key for consistency\n                chart._session_state_manager,  # pylint: disable=protected-access\n            )\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return chart IDs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def keys(self):\n    \"\"\"Return chart IDs in the manager.\"\"\"\n    return self.charts.keys()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return chart instances in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def values(self):\n    \"\"\"Return chart instances in the manager.\"\"\"\n    return self.charts.values()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.ChartManager.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return chart ID and instance pairs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def items(self):\n    \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n    return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.AreaSeries","title":"AreaSeries","text":"<p>Area series for creating filled area charts in financial visualization.</p> <p>This class represents an area series that displays continuous data points with filled areas under the line. It's commonly used for price charts, technical indicators, and trend analysis where the area under the curve provides visual emphasis and context.</p> <p>The AreaSeries supports various styling options including area colors, line styling via LineOptions, and gradient effects for enhanced visual appeal and data interpretation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[AreaData], DataFrame, Series]</code> <p>Data points for the area series. Can be a list of AreaData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <code>LineOptions</code> <p>LineOptions instance for line styling. Provides comprehensive line customization including color, width, style, and animation effects.</p> <code>top_color</code> <code>str</code> <p>Color of the top part of the area fill. Defaults to \"#2196F3\" (blue). Can be hex or rgba format.</p> <code>bottom_color</code> <code>str</code> <p>Color of the bottom part of the area fill. Defaults to \"rgba(33, 150, 243, 0.0)\" (transparent blue).</p> <code>relative_gradient</code> <code>bool</code> <p>Whether gradient is relative to base value. Defaults to False for absolute gradient positioning.</p> <code>invert_filled_area</code> <code>bool</code> <p>Whether to invert the filled area direction. Defaults to False for normal area filling.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (AreaData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data with line colors\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with gradient styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n\n# Configure line options\nseries.line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre> See also <p>Series: Base class providing common series functionality. LineOptions: Configuration class for line styling options. AreaData: Data class for area chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/area.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"top_color\", str, validator=\"color\")\n@chainable_property(\"bottom_color\", str, validator=\"color\")\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"invert_filled_area\", bool)\nclass AreaSeries(Series):\n    \"\"\"Area series for creating filled area charts in financial visualization.\n\n    This class represents an area series that displays continuous data points\n    with filled areas under the line. It's commonly used for price charts,\n    technical indicators, and trend analysis where the area under the curve\n    provides visual emphasis and context.\n\n    The AreaSeries supports various styling options including area colors,\n    line styling via LineOptions, and gradient effects for enhanced\n    visual appeal and data interpretation.\n\n    Attributes:\n        data (Union[List[AreaData], pd.DataFrame, pd.Series]): Data points for\n            the area series. Can be a list of AreaData objects, a pandas\n            DataFrame, or a pandas Series.\n        line_options (LineOptions): LineOptions instance for line styling.\n            Provides comprehensive line customization including color, width,\n            style, and animation effects.\n        top_color (str): Color of the top part of the area fill. Defaults to\n            \"#2196F3\" (blue). Can be hex or rgba format.\n        bottom_color (str): Color of the bottom part of the area fill. Defaults\n            to \"rgba(33, 150, 243, 0.0)\" (transparent blue).\n        relative_gradient (bool): Whether gradient is relative to base value.\n            Defaults to False for absolute gradient positioning.\n        invert_filled_area (bool): Whether to invert the filled area direction.\n            Defaults to False for normal area filling.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (AreaData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import AreaSeries\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data with line colors\n        data = [\n            AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n        ]\n\n        # Create area series with gradient styling\n        series = AreaSeries(\n            data=data,\n            top_color=\"rgba(33, 150, 243, 0.4)\",\n            bottom_color=\"rgba(33, 150, 243, 0.0)\",\n            relative_gradient=False,\n            invert_filled_area=False,\n        )\n\n        # Configure line options\n        series.line_options.set_color(\"#2196F3\").set_width(2)\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        LineOptions: Configuration class for line styling options.\n        AreaData: Data class for area chart data points.\n    \"\"\"\n\n    DATA_CLASS = AreaData\n\n    def __init__(\n        self,\n        data: Union[List[AreaData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize AreaSeries with data and configuration options.\n\n        Creates a new area series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes area-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[AreaData], pd.DataFrame, pd.Series]): Area data as a list\n                of AreaData objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of AreaData objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of AreaData or its subclasses.\n\n        Example:\n            ```python\n            # Basic area series with list of data objects\n            data = [AreaData(\"2024-01-01\", 100)]\n            series = AreaSeries(data=data)\n\n            # Area series with DataFrame\n            series = AreaSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Area series with custom configuration\n            series = AreaSeries(data=data, visible=True, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize area-specific properties with default values\n        self._line_options = LineOptions()  # Line styling configuration\n        self._top_color = COLOR_BLUE_MATERIAL  # Top area color (blue)\n        self._bottom_color = AREA_BOTTOM_COLOR_DEFAULT  # Bottom area color (transparent)\n        self._relative_gradient = False  # Absolute gradient positioning\n        self._invert_filled_area = False  # Normal area filling direction\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as an area chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The area chart type identifier.\n\n        Example:\n            ```python\n            series = AreaSeries(data=data)\n            chart_type = series.chart_type  # ChartType.AREA\n            ```\n        \"\"\"\n        return ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.AreaSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.AreaSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as an area chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The area chart type identifier.</p> Example <pre><code>series = AreaSeries(data=data)\nchart_type = series.chart_type  # ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BandSeries","title":"BandSeries","text":"<p>Band series for lightweight charts (e.g., Bollinger Bands).</p> <p>This class represents a band series that displays upper, middle, and lower bands. It's commonly used for technical indicators like Bollinger Bands, Keltner Channels, and other envelope indicators.</p> <p>The BandSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>middle_line</code> <p>LineOptions instance for middle band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>upper_fill_color</code> <p>Fill color for upper band area.</p> <code>lower_fill_color</code> <p>Fill color for lower band area.</p> <code>upper_fill</code> <p>Whether to display the upper fill area.</p> <code>lower_fill</code> <p>Whether to display the lower fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/band.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"middle_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"upper_fill_color\", str, validator=\"color\")\n@chainable_property(\"lower_fill_color\", str, validator=\"color\")\n@chainable_property(\"upper_fill\", bool)\n@chainable_property(\"lower_fill\", bool)\nclass BandSeries(Series):\n    \"\"\"Band series for lightweight charts (e.g., Bollinger Bands).\n\n    This class represents a band series that displays upper, middle, and lower bands.\n    It's commonly used for technical indicators like Bollinger Bands, Keltner Channels,\n    and other envelope indicators.\n\n    The BandSeries supports various styling options including separate line styling\n    for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        middle_line: LineOptions instance for middle band styling.\n        lower_line: LineOptions instance for lower band styling.\n        upper_fill_color: Fill color for upper band area.\n        lower_fill_color: Fill color for lower band area.\n        upper_fill: Whether to display the upper fill area.\n        lower_fill: Whether to display the lower fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BandData\n\n    def __init__(\n        self,\n        data: Union[List[BandData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize BandSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._middle_line = create_middle_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill colors\n        self._upper_fill_color = BAND_UPPER_FILL_COLOR\n        self._lower_fill_color = BAND_LOWER_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._upper_fill = True\n        self._lower_fill = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAND\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BandSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BandSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BarSeries","title":"BarSeries","text":"<p>Bar series for lightweight charts.</p> <p>This class represents a bar series that displays data as bars. It's commonly used for price charts, volume overlays, and other bar-based visualizations.</p> <p>The BarSeries supports various styling options including bar colors, base value, and animation effects.</p> <p>Attributes:</p> Name Type Description <code>color</code> <p>Color of the bars (set via property).</p> <code>base</code> <p>Base value for the bars (set via property).</p> <code>up_color</code> <p>Color for up bars (set via property).</p> <code>down_color</code> <p>Color for down bars (set via property).</p> <code>open_visible</code> <p>Whether open values are visible (set via property).</p> <code>thin_bars</code> <p>Whether to use thin bars (set via property).</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/bar_series.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"open_visible\", bool)\n@chainable_property(\"thin_bars\", bool)\nclass BarSeries(Series):\n    \"\"\"Bar series for lightweight charts.\n\n    This class represents a bar series that displays data as bars.\n    It's commonly used for price charts, volume overlays, and other\n    bar-based visualizations.\n\n    The BarSeries supports various styling options including bar colors,\n    base value, and animation effects.\n\n    Attributes:\n        color: Color of the bars (set via property).\n        base: Base value for the bars (set via property).\n        up_color: Color for up bars (set via property).\n        down_color: Color for down bars (set via property).\n        open_visible: Whether open values are visible (set via property).\n        thin_bars: Whether to use thin bars (set via property).\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BarData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAR\n\n    def __init__(\n        self,\n        data: Union[List[BarData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize properties with default values\n        self._up_color = \"#26a69a\"\n        self._down_color = \"#ef5350\"\n        self._open_visible = True\n        self._thin_bars = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BarSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BarSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BaselineSeries","title":"BaselineSeries","text":"<p>Baseline series for lightweight charts.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/baseline.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=_validate_base_value_static)\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"top_fill_color1\", str, validator=\"color\")\n@chainable_property(\"top_fill_color2\", str, validator=\"color\")\n@chainable_property(\"top_line_color\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color1\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color2\", str, validator=\"color\")\n@chainable_property(\"bottom_line_color\", str, validator=\"color\")\nclass BaselineSeries(Series):\n    \"\"\"Baseline series for lightweight charts.\"\"\"\n\n    DATA_CLASS = BaselineData\n\n    def __init__(\n        self,\n        data: Union[List[BaselineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize LineOptions for common line properties\n        self._line_options = LineOptions()\n\n        # Baseline-specific properties (not in LineOptions) - set default values internally\n        self._base_value = self._validate_base_value({\"type\": \"price\", \"price\": 0})\n        self._relative_gradient = False\n        self._top_fill_color1 = BASELINE_TOP_FILL_COLOR1\n        self._top_fill_color2 = BASELINE_TOP_FILL_COLOR2\n        self._top_line_color = BASELINE_TOP_LINE_COLOR\n        self._bottom_fill_color1 = BASELINE_BOTTOM_FILL_COLOR1\n        self._bottom_fill_color2 = BASELINE_BOTTOM_FILL_COLOR2\n        self._bottom_line_color = BASELINE_BOTTOM_LINE_COLOR\n\n    def _validate_base_value(self, base_value: Union[int, float, Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate and normalize base_value.\"\"\"\n        if isinstance(base_value, (int, float)):\n            return {\"type\": \"price\", \"price\": float(base_value)}\n        if isinstance(base_value, dict):\n            if \"type\" not in base_value or \"price\" not in base_value:\n                raise BaseValueFormatError()\n            return {\"type\": str(base_value[\"type\"]), \"price\": float(base_value[\"price\"])}\n        raise BaseValueFormatError()\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BASELINE\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BaselineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.BaselineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.CandlestickSeries","title":"CandlestickSeries","text":"<p>Candlestick series for creating OHLC candlestick charts in financial visualization.</p> <p>This class represents a candlestick series that displays OHLC (Open, High, Low, Close) data as candlestick bars. It's commonly used for price charts, technical analysis, and comprehensive price action visualization in financial applications.</p> <p>The CandlestickSeries extends the base Series class with candlestick-specific functionality and supports extensive styling options through chainable properties. It provides comprehensive color customization for bullish/bearish candles, wicks, borders, and other visual elements.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[CandlestickData], DataFrame, Series]</code> <p>Data points for the candlestick series. Can be a list of CandlestickData objects, a pandas DataFrame, or a pandas Series.</p> <code>up_color</code> <code>str</code> <p>Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).</p> <code>down_color</code> <code>str</code> <p>Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).</p> <code>wick_visible</code> <code>bool</code> <p>Whether wicks are visible. Defaults to True.</p> <code>border_visible</code> <code>bool</code> <p>Whether borders are visible. Defaults to False.</p> <code>border_color</code> <code>str</code> <p>General border color. Defaults to \"#378658\" (green).</p> <code>border_up_color</code> <code>str</code> <p>Border color for bullish candles. Defaults to \"#26a69a\".</p> <code>border_down_color</code> <code>str</code> <p>Border color for bearish candles. Defaults to \"#ef5350\".</p> <code>wick_color</code> <code>str</code> <p>General wick color. Defaults to \"#737375\" (gray).</p> <code>wick_up_color</code> <code>str</code> <p>Wick color for bullish candles. Defaults to \"#26a69a\".</p> <code>wick_down_color</code> <code>str</code> <p>Wick color for bearish candles. Defaults to \"#ef5350\".</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (CandlestickData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. CandlestickData: Data class for candlestick chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/candlestick.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"wick_visible\", bool)\n@chainable_property(\"border_visible\", bool)\n@chainable_property(\"border_color\", str, validator=\"color\")\n@chainable_property(\"border_up_color\", str, validator=\"color\")\n@chainable_property(\"border_down_color\", str, validator=\"color\")\n@chainable_property(\"wick_color\", str, validator=\"color\")\n@chainable_property(\"wick_up_color\", str, validator=\"color\")\n@chainable_property(\"wick_down_color\", str, validator=\"color\")\nclass CandlestickSeries(Series):\n    \"\"\"Candlestick series for creating OHLC candlestick charts in financial visualization.\n\n    This class represents a candlestick series that displays OHLC (Open, High, Low, Close)\n    data as candlestick bars. It's commonly used for price charts, technical analysis,\n    and comprehensive price action visualization in financial applications.\n\n    The CandlestickSeries extends the base Series class with candlestick-specific\n    functionality and supports extensive styling options through chainable properties.\n    It provides comprehensive color customization for bullish/bearish candles,\n    wicks, borders, and other visual elements.\n\n    Attributes:\n        data (Union[List[CandlestickData], pd.DataFrame, pd.Series]): Data points for\n            the candlestick series. Can be a list of CandlestickData objects,\n            a pandas DataFrame, or a pandas Series.\n        up_color (str): Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).\n        down_color (str): Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).\n        wick_visible (bool): Whether wicks are visible. Defaults to True.\n        border_visible (bool): Whether borders are visible. Defaults to False.\n        border_color (str): General border color. Defaults to \"#378658\" (green).\n        border_up_color (str): Border color for bullish candles. Defaults to \"#26a69a\".\n        border_down_color (str): Border color for bearish candles. Defaults to \"#ef5350\".\n        wick_color (str): General wick color. Defaults to \"#737375\" (gray).\n        wick_up_color (str): Wick color for bullish candles. Defaults to \"#26a69a\".\n        wick_down_color (str): Wick color for bearish candles. Defaults to \"#ef5350\".\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (CandlestickData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data\n        data = [\n            CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n            CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n        ]\n\n        # Create candlestick series with styling\n        series = (\n            CandlestickSeries(data=data)\n            .set_up_color(\"#4CAF50\")\n            .set_down_color(\"#F44336\")\n            .set_border_visible(True)\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        CandlestickData: Data class for candlestick chart data points.\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = CandlestickData\n\n    def __init__(\n        self,\n        data: Union[List[CandlestickData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a CandlestickSeries instance with data and configuration options.\n\n        This constructor initializes a candlestick series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes candlestick-specific styling properties with default values.\n\n        Args:\n            data: Data points for the candlestick series. Can be a list of\n                CandlestickData objects, a pandas DataFrame, or a pandas Series.\n                If DataFrame is provided, column_mapping can be used to specify\n                field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize candlestick-specific properties with default values\n        # Up color for bullish candles - defaults to teal\n        self._up_color = \"#26a69a\"\n        # Down color for bearish candles - defaults to red\n        self._down_color = \"#ef5350\"\n        # Wick visibility - defaults to True (wicks visible)\n        self._wick_visible = True\n        # Border visibility - defaults to False (borders hidden)\n        self._border_visible = False\n        # General border color - defaults to green\n        self._border_color = \"#378658\"\n        # Border color for bullish candles - defaults to teal\n        self._border_up_color = \"#26a69a\"\n        # Border color for bearish candles - defaults to red\n        self._border_down_color = \"#ef5350\"\n        # General wick color - defaults to gray\n        self._wick_color = \"#737375\"\n        # Wick color for bullish candles - defaults to teal\n        self._wick_up_color = \"#26a69a\"\n        # Wick color for bearish candles - defaults to red\n        self._wick_down_color = \"#ef5350\"\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format for candlestick styling properties.\n\n        This method validates that the provided color string is in a valid\n        format (hex or rgba) for use in candlestick styling. It's used\n        internally by the chainable property validators.\n\n        Args:\n            color: The color string to validate in hex or rgba format.\n            property_name: The name of the property being validated (for error messages).\n\n        Returns:\n            str: The validated color string.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for candlestick charts.\n        \"\"\"\n        return ChartType.CANDLESTICK\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.CandlestickSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.CandlestickSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for candlestick charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries","title":"GradientRibbonSeries","text":"<p>Gradient ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with gradient fill areas based on gradient values. It extends RibbonSeries with gradient fill capabilities, allowing for dynamic color transitions based on data values.</p> <p>The GradientRibbonSeries supports various styling options including separate line styling for each band via LineOptions, and gradient color effects based on data values.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>gradient_start_color</code> <p>Starting color for gradient fills (minimum value).</p> <code>gradient_end_color</code> <p>Ending color for gradient fills (maximum value).</p> <code>normalize_gradients</code> <p>Whether to normalize gradient values to 0-1 range.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>@chainable_property(\"gradient_start_color\", str, validator=\"color\")\n@chainable_property(\"gradient_end_color\", str, validator=\"color\")\n@chainable_property(\"normalize_gradients\", bool)\nclass GradientRibbonSeries(RibbonSeries):\n    \"\"\"Gradient ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with gradient fill areas based on gradient values. It extends RibbonSeries\n    with gradient fill capabilities, allowing for dynamic color transitions\n    based on data values.\n\n    The GradientRibbonSeries supports various styling options including separate\n    line styling for each band via LineOptions, and gradient color effects based\n    on data values.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_visible: Whether to display the fill area.\n        gradient_start_color: Starting color for gradient fills (minimum value).\n        gradient_end_color: Ending color for gradient fills (maximum value).\n        normalize_gradients: Whether to normalize gradient values to 0-1 range.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = GradientRibbonData\n\n    def __init__(\n        self,\n        data: Union[List[GradientRibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        gradient_start_color: str = \"#4CAF50\",\n        gradient_end_color: str = \"#F44336\",\n        normalize_gradients: bool = False,\n    ):\n        \"\"\"Initialize GradientRibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            gradient_start_color: Starting color for gradient fills\n            gradient_end_color: Ending color for gradient fills\n            normalize_gradients: Whether to normalize gradient values to 0-1 range\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize gradient-specific properties\n        self._gradient_start_color = gradient_start_color\n        self._gradient_end_color = gradient_end_color\n        self._normalize_gradients = normalize_gradients\n        self._gradient_bounds: Optional[tuple[float, float]] = None\n\n        # Performance optimization: cache normalized results\n        self._normalized_cache: Optional[dict] = None\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.GRADIENT_RIBBON\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate the normalized data cache.\n\n        This method should be called whenever the data changes to ensure\n        the cached normalized results are recalculated on the next asdict() call.\n        \"\"\"\n        self._normalized_cache = None\n        self._gradient_bounds = None\n\n    def update(self, updates: dict):\n        \"\"\"Override update to invalidate cache when data changes.\n\n        Args:\n            updates: Dictionary of updates to apply.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        # Invalidate cache before updating\n        self._invalidate_cache()\n        # Call parent update\n        return super().update(updates)\n\n    @property\n    def data(self):\n        \"\"\"Get the series data.\"\"\"\n        return self._data if hasattr(self, \"_data\") else []\n\n    @data.setter\n    def data(self, value):\n        \"\"\"Set the series data and invalidate cache.\n\n        Args:\n            value: New data to set.\n        \"\"\"\n        self._data = value\n        self._invalidate_cache()\n\n    def _calculate_gradient_bounds(self) -&gt; None:\n        \"\"\"Calculate min/max gradient values for normalization with optimized performance.\"\"\"\n        if not self.data:\n            self._gradient_bounds = None\n            return\n\n        # Ultra-optimized single-pass min/max tracking\n        min_grad = float(\"inf\")\n        max_grad = float(\"-inf\")\n        valid_count = 0\n\n        # Single pass with inline min/max tracking - no list building\n        for data_point in self.data:\n            # Type check: ensure data point has gradient attribute\n            if not hasattr(data_point, \"gradient\"):\n                continue\n            gradient = data_point.gradient  # type: ignore[attr-defined]\n            if (\n                gradient is not None\n                and isinstance(gradient, (int, float))\n                and not math.isnan(gradient)  # Not NaN\n                and gradient != float(\"inf\")\n                and gradient != float(\"-inf\")\n            ):\n                # Update min/max inline - no list operations\n                min_grad = min(min_grad, gradient)\n                max_grad = max(max_grad, gradient)\n                valid_count += 1\n                continue\n\n        # Set bounds efficiently - only if we found valid values\n        if valid_count &gt; 0:\n            self._gradient_bounds = (min_grad, max_grad)\n        else:\n            self._gradient_bounds = None\n\n    def _compute_normalized_dict(self) -&gt; dict:\n        \"\"\"Compute the normalized dictionary (expensive operation).\n\n        This method performs the actual gradient normalization computation.\n        It's called only when the cache is invalid.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        data_dict = super().asdict()\n\n        # Remove inherited fill_color property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n        data_dict.get(\"options\", {}).pop(\"fillColor\", None)\n\n        if self._normalize_gradients:\n            # Calculate bounds if not already calculated\n            if self._gradient_bounds is None:\n                self._calculate_gradient_bounds()\n\n            if self._gradient_bounds:\n                min_grad, max_grad = self._gradient_bounds\n                range_grad = max_grad - min_grad\n\n                if range_grad &gt; 0:  # Avoid division by zero\n                    # Ultra-optimized normalization with minimal function calls\n                    data_items = data_dict[\"data\"]\n                    range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                    for item in data_items:  # Remove enumerate for speed\n                        gradient = item.get(\"gradient\")\n                        if gradient is not None:\n                            # Since we already validated in _calculate_gradient_bounds,\n                            # we can trust the gradient values here\n                            try:\n                                # Use pre-calculated inverse for faster division\n                                normalized = (gradient - min_grad) * range_grad_inv\n                                # Fast clamping using conditional expression\n                                item[\"gradient\"] = (\n                                    0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                                )\n                            except (TypeError, ValueError):\n                                item.pop(\"gradient\", None)\n\n        return data_dict\n\n    def asdict(self):\n        \"\"\"Override to include normalized gradients with caching for performance.\n\n        Returns cached normalized results if available, otherwise computes and caches them.\n        This optimization prevents O(2n) iterations on every serialization call.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        # Return cached result if available\n        if self._normalized_cache is not None:\n            return self._normalized_cache\n\n        # Compute and cache the result\n        self._normalized_cache = self._compute_normalized_dict()\n        return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data\n</code></pre> <p>Get the series data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries.update","title":"update","text":"<pre><code>update(updates: dict)\n</code></pre> <p>Override update to invalidate cache when data changes.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict</code> <p>Dictionary of updates to apply.</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def update(self, updates: dict):\n    \"\"\"Override update to invalidate cache when data changes.\n\n    Args:\n        updates: Dictionary of updates to apply.\n\n    Returns:\n        Self for method chaining.\n    \"\"\"\n    # Invalidate cache before updating\n    self._invalidate_cache()\n    # Call parent update\n    return super().update(updates)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.GradientRibbonSeries.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Override to include normalized gradients with caching for performance.</p> <p>Returns cached normalized results if available, otherwise computes and caches them. This optimization prevents O(2n) iterations on every serialization call.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The serialized dictionary with normalized gradients.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def asdict(self):\n    \"\"\"Override to include normalized gradients with caching for performance.\n\n    Returns cached normalized results if available, otherwise computes and caches them.\n    This optimization prevents O(2n) iterations on every serialization call.\n\n    Returns:\n        dict: The serialized dictionary with normalized gradients.\n    \"\"\"\n    # Return cached result if available\n    if self._normalized_cache is not None:\n        return self._normalized_cache\n\n    # Compute and cache the result\n    self._normalized_cache = self._compute_normalized_dict()\n    return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.HistogramSeries","title":"HistogramSeries","text":"<p>Histogram series for creating bar-based charts in financial visualization.</p> <p>This class represents a histogram series that displays data as bars. It's commonly used for volume overlays, technical indicators, and other bar-based visualizations where individual data points are represented as vertical bars.</p> <p>The HistogramSeries supports various styling options including bar color, base value, and animation effects. It also provides a factory method for creating volume series with automatic bullish/bearish color coding.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for the histogram series. Can be a list of Data objects, a pandas DataFrame, or a pandas Series.</p> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to \"#26a69a\" (teal). Can be hex or rgba format.</p> <code>base</code> <code>Union[int, float]</code> <p>Base value for the histogram bars. Defaults to 0. This determines the baseline from which bars extend.</p> <code>scale_margins</code> <code>dict</code> <p>Scale margins for the histogram series. Controls the top and bottom margins of the price scale. Defaults to {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (HistogramData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. HistogramData: Data class for histogram chart data points. create_volume_series: Factory method for volume series with color coding.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"base\", (int, float))\n@chainable_property(\"scale_margins\", dict)\nclass HistogramSeries(Series):\n    \"\"\"Histogram series for creating bar-based charts in financial visualization.\n\n    This class represents a histogram series that displays data as bars.\n    It's commonly used for volume overlays, technical indicators, and other\n    bar-based visualizations where individual data points are represented\n    as vertical bars.\n\n    The HistogramSeries supports various styling options including bar color,\n    base value, and animation effects. It also provides a factory method\n    for creating volume series with automatic bullish/bearish color coding.\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for\n            the histogram series. Can be a list of Data objects, a pandas\n            DataFrame, or a pandas Series.\n        color (str): Color of the histogram bars. Defaults to \"#26a69a\" (teal).\n            Can be hex or rgba format.\n        base (Union[int, float]): Base value for the histogram bars. Defaults to 0.\n            This determines the baseline from which bars extend.\n        scale_margins (dict): Scale margins for the histogram series. Controls\n            the top and bottom margins of the price scale. Defaults to\n            {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (HistogramData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data\n        data = [\n            HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n            HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n        ]\n\n        # Create histogram series with styling\n        series = HistogramSeries(data=data)\n        series.set_color(\"#2196F3\").set_base(0)\n\n        # Create volume series with color coding\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n            up_color=\"rgba(38,166,154,0.5)\",\n            down_color=\"rgba(239,83,80,0.5)\",\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        HistogramData: Data class for histogram chart data points.\n        create_volume_series: Factory method for volume series with color coding.\n    \"\"\"\n\n    DATA_CLASS = HistogramData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as a histogram chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The histogram chart type identifier.\n\n        Example:\n            ```python\n            series = HistogramSeries(data=data)\n            chart_type = series.chart_type  # ChartType.HISTOGRAM\n            ```\n        \"\"\"\n        return ChartType.HISTOGRAM\n\n    @classmethod\n    def create_volume_series(\n        cls,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: dict,\n        up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n        down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n        **kwargs,\n    ) -&gt; \"HistogramSeries\":\n        \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n        This factory method processes OHLCV data and creates a HistogramSeries\n        with volume bars colored based on whether the candle is bullish (close &gt;= open)\n        or bearish (close &lt; open). This provides visual context for volume analysis\n        by showing whether volume occurred during price increases or decreases.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n                or sequence of OhlcvData objects containing price and volume information.\n            column_mapping (dict): Mapping of required fields to column names.\n                Must include \"open\", \"close\", and \"volume\" mappings.\n            up_color (str, optional): Color for bullish candles (close &gt;= open).\n                Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n            down_color (str, optional): Color for bearish candles (close &lt; open).\n                Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n            **kwargs: Additional arguments for HistogramSeries constructor.\n\n        Returns:\n            HistogramSeries: Configured histogram series for volume visualization\n                with color-coded bars based on price movement.\n\n        Raises:\n            ValueError: If required columns are missing from the data or column mapping.\n            KeyError: If column mapping doesn't include required fields.\n\n        Example:\n            ```python\n            # Create volume series with default colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping={\n                    \"time\": \"datetime\",\n                    \"open\": \"open_price\",\n                    \"close\": \"close_price\",\n                    \"volume\": \"trading_volume\",\n                },\n            )\n\n            # Create volume series with custom colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping=column_mapping,\n                up_color=\"#4CAF50\",  # Green for bullish\n                down_color=\"#F44336\",  # Red for bearish\n            )\n            ```\n\n        Note:\n            The method automatically sets _last_value_visible to False for volume series\n            as it's typically used as an overlay rather than a main price series.\n        \"\"\"\n        if isinstance(data, pd.DataFrame):\n            # Use vectorized operations for efficient color assignment on large datasets\n            volume_dataframe = data.copy()\n\n            # Extract column names for open and close prices from mapping\n            open_col = column_mapping.get(\"open\", \"open\")\n            close_col = column_mapping.get(\"close\", \"close\")\n\n            # Use NumPy vectorized operations to assign colors based on price movement\n            # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n            colors = np.where(\n                volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n                up_color,\n                down_color,\n            )\n\n            # Add color column to DataFrame for histogram visualization\n            volume_dataframe[\"color\"] = colors\n\n            # Update column mapping to include color field and map volume to value\n            volume_col = column_mapping.get(\"volume\", \"volume\")\n            updated_mapping = column_mapping.copy()\n            updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n            updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n            # Use from_dataframe factory method to create the series\n            return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n        # Handle sequence of OhlcvData objects (non-DataFrame input)\n        if data is None:\n            # Return empty series for None data input\n            return cls(data=[])\n\n        # Process each item in the sequence individually\n        processed_data = []\n        for item in data:\n            if isinstance(item, dict):\n                # Determine color based on price movement for dictionary input\n                color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n                processed_item = item.copy()\n                processed_item[\"color\"] = color  # Add color information\n                processed_data.append(processed_item)\n            else:\n                # For OhlcvData objects, convert to dict and add color\n                item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n                color = (\n                    up_color\n                    if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                    else down_color\n                )\n                item_dict[\"color\"] = color  # Add color information\n                processed_data.append(item_dict)\n\n        # Convert processed data to DataFrame and use from_dataframe factory method\n        processed_dataframe = pd.DataFrame(processed_data)\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n        # Map volume to value for HistogramSeries compatibility\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping[\"value\"] = volume_col\n\n        # Create the volume series using the factory method\n        volume_series = cls.from_dataframe(\n            processed_dataframe,\n            column_mapping=updated_mapping,\n            **kwargs,\n        )\n\n        # Disable last value visibility for volume series (typically used as overlay)\n        volume_series._last_value_visible = False\n\n        return volume_series  # type: ignore[return-value]\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize HistogramSeries with data and configuration options.\n\n        Creates a new histogram series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes histogram-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Histogram data as a list\n                of Data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"right\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic histogram series with list of data objects\n            data = [HistogramData(\"2024-01-01\", 1000)]\n            series = HistogramSeries(data=data)\n\n            # Histogram series with DataFrame\n            series = HistogramSeries(data=dataframe, column_mapping={\"time\": \"datetime\", \"value\": \"volume\"})\n\n            # Histogram series with Series\n            series = HistogramSeries(data=series_data, column_mapping={\"time\": \"index\", \"value\": \"values\"})\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize histogram-specific properties with default values\n        self._color = \"#26a69a\"  # Default teal color for histogram bars\n        self._base = 0  # Default base value (baseline for bars)\n        self._scale_margins = {\"top\": 0.75, \"bottom\": 0}  # Default scale margins\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.HistogramSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.HistogramSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as a histogram chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The histogram chart type identifier.</p> Example <pre><code>series = HistogramSeries(data=data)\nchart_type = series.chart_type  # ChartType.HISTOGRAM\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.HistogramSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.HistogramSeries.create_volume_series","title":"create_volume_series  <code>classmethod</code>","text":"<pre><code>create_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: dict, up_color: str = HISTOGRAM_UP_COLOR_DEFAULT, down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT, **kwargs) -&gt; HistogramSeries\n</code></pre> <p>Create a histogram series for volume data with colors based on price movement.</p> <p>This factory method processes OHLCV data and creates a HistogramSeries with volume bars colored based on whether the candle is bullish (close &gt;= open) or bearish (close &lt; open). This provides visual context for volume analysis by showing whether volume occurred during price increases or decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data as DataFrame or sequence of OhlcvData objects containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields to column names. Must include \"open\", \"close\", and \"volume\" mappings.</p> required <code>up_color</code> <code>str</code> <p>Color for bullish candles (close &gt;= open). Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).</p> <code>HISTOGRAM_UP_COLOR_DEFAULT</code> <code>down_color</code> <code>str</code> <p>Color for bearish candles (close &lt; open). Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).</p> <code>HISTOGRAM_DOWN_COLOR_DEFAULT</code> <code>**kwargs</code> <p>Additional arguments for HistogramSeries constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HistogramSeries</code> <code>HistogramSeries</code> <p>Configured histogram series for volume visualization with color-coded bars based on price movement.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing from the data or column mapping.</p> <code>KeyError</code> <p>If column mapping doesn't include required fields.</p> Example <pre><code># Create volume series with default colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\n        \"time\": \"datetime\",\n        \"open\": \"open_price\",\n        \"close\": \"close_price\",\n        \"volume\": \"trading_volume\",\n    },\n)\n\n# Create volume series with custom colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping=column_mapping,\n    up_color=\"#4CAF50\",  # Green for bullish\n    down_color=\"#F44336\",  # Red for bearish\n)\n</code></pre> Note <p>The method automatically sets _last_value_visible to False for volume series as it's typically used as an overlay rather than a main price series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@classmethod\ndef create_volume_series(\n    cls,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: dict,\n    up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n    down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n    **kwargs,\n) -&gt; \"HistogramSeries\":\n    \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n    This factory method processes OHLCV data and creates a HistogramSeries\n    with volume bars colored based on whether the candle is bullish (close &gt;= open)\n    or bearish (close &lt; open). This provides visual context for volume analysis\n    by showing whether volume occurred during price increases or decreases.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n            or sequence of OhlcvData objects containing price and volume information.\n        column_mapping (dict): Mapping of required fields to column names.\n            Must include \"open\", \"close\", and \"volume\" mappings.\n        up_color (str, optional): Color for bullish candles (close &gt;= open).\n            Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n        down_color (str, optional): Color for bearish candles (close &lt; open).\n            Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n        **kwargs: Additional arguments for HistogramSeries constructor.\n\n    Returns:\n        HistogramSeries: Configured histogram series for volume visualization\n            with color-coded bars based on price movement.\n\n    Raises:\n        ValueError: If required columns are missing from the data or column mapping.\n        KeyError: If column mapping doesn't include required fields.\n\n    Example:\n        ```python\n        # Create volume series with default colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\n                \"time\": \"datetime\",\n                \"open\": \"open_price\",\n                \"close\": \"close_price\",\n                \"volume\": \"trading_volume\",\n            },\n        )\n\n        # Create volume series with custom colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping=column_mapping,\n            up_color=\"#4CAF50\",  # Green for bullish\n            down_color=\"#F44336\",  # Red for bearish\n        )\n        ```\n\n    Note:\n        The method automatically sets _last_value_visible to False for volume series\n        as it's typically used as an overlay rather than a main price series.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # Use vectorized operations for efficient color assignment on large datasets\n        volume_dataframe = data.copy()\n\n        # Extract column names for open and close prices from mapping\n        open_col = column_mapping.get(\"open\", \"open\")\n        close_col = column_mapping.get(\"close\", \"close\")\n\n        # Use NumPy vectorized operations to assign colors based on price movement\n        # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n        colors = np.where(\n            volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n            up_color,\n            down_color,\n        )\n\n        # Add color column to DataFrame for histogram visualization\n        volume_dataframe[\"color\"] = colors\n\n        # Update column mapping to include color field and map volume to value\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n        updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n        # Use from_dataframe factory method to create the series\n        return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n    # Handle sequence of OhlcvData objects (non-DataFrame input)\n    if data is None:\n        # Return empty series for None data input\n        return cls(data=[])\n\n    # Process each item in the sequence individually\n    processed_data = []\n    for item in data:\n        if isinstance(item, dict):\n            # Determine color based on price movement for dictionary input\n            color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n            processed_item = item.copy()\n            processed_item[\"color\"] = color  # Add color information\n            processed_data.append(processed_item)\n        else:\n            # For OhlcvData objects, convert to dict and add color\n            item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n            color = (\n                up_color\n                if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                else down_color\n            )\n            item_dict[\"color\"] = color  # Add color information\n            processed_data.append(item_dict)\n\n    # Convert processed data to DataFrame and use from_dataframe factory method\n    processed_dataframe = pd.DataFrame(processed_data)\n    updated_mapping = column_mapping.copy()\n    updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n    # Map volume to value for HistogramSeries compatibility\n    volume_col = column_mapping.get(\"volume\", \"volume\")\n    updated_mapping[\"value\"] = volume_col\n\n    # Create the volume series using the factory method\n    volume_series = cls.from_dataframe(\n        processed_dataframe,\n        column_mapping=updated_mapping,\n        **kwargs,\n    )\n\n    # Disable last value visibility for volume series (typically used as overlay)\n    volume_series._last_value_visible = False\n\n    return volume_series  # type: ignore[return-value]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.LineSeries","title":"LineSeries","text":"<p>Line series for creating continuous line charts in financial visualization.</p> <p>This class represents a line series that displays continuous data points connected by lines. It's commonly used for price charts, technical indicators, trend analysis, and other time-series data visualization in financial applications.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Data points for the line series. Can be a list of LineData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <p>LineOptions instance for all line style options including color, width, style, and animation effects.</p> <code>column_mapping</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <p>The pane index this series belongs to. Defaults to 0.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data\ndata = [\n    LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n    LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n    LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n# Add to chart\nchart = Chart(series=series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/line.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\nclass LineSeries(Series):\n    \"\"\"Line series for creating continuous line charts in financial visualization.\n\n    This class represents a line series that displays continuous data points\n    connected by lines. It's commonly used for price charts, technical\n    indicators, trend analysis, and other time-series data visualization\n    in financial applications.\n\n    Attributes:\n        data: Data points for the line series. Can be a list of LineData\n            objects, a pandas DataFrame, or a pandas Series.\n        line_options: LineOptions instance for all line style options\n            including color, width, style, and animation effects.\n        column_mapping: Optional mapping for DataFrame columns to data fields.\n            Used when data is provided as a DataFrame.\n        visible: Whether the series is visible on the chart. Defaults to True.\n        price_scale_id: ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id: The pane index this series belongs to.\n            Defaults to 0.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data\n        data = [\n            LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n            LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n            LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n        ]\n\n        # Create line series with styling\n        series = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n        # Add to chart\n        chart = Chart(series=series)\n        ```\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = LineData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for line charts.\n        \"\"\"\n        return ChartType.LINE\n\n    def __init__(\n        self,\n        data: Union[List[LineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a LineSeries instance with data and configuration options.\n\n        This constructor initializes a line series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes line-specific styling options with default values.\n\n        Args:\n            data: Data points for the line series. Can be a list of LineData\n                objects, a pandas DataFrame, or a pandas Series. If DataFrame\n                is provided, column_mapping can be used to specify field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        # This sets up data validation, column mapping processing, and basic properties\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n        # Initialize line_options with default styling configuration\n        # This creates an empty LineOptions instance for future customization\n        self._line_options = LineOptions()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.LineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.LineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for line charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.RibbonSeries","title":"RibbonSeries","text":"<p>Ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with a fill area between them. It's commonly used for technical indicators like Bollinger Bands without the middle line, or other envelope indicators.</p> <p>The RibbonSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_color</code> <p>Fill color for the area between upper and lower bands.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/ribbon.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass RibbonSeries(Series):\n    \"\"\"Ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with a fill area between them. It's commonly used for technical indicators\n    like Bollinger Bands without the middle line, or other envelope indicators.\n\n    The RibbonSeries supports various styling options including separate line\n    styling for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_color: Fill color for the area between upper and lower bands.\n        fill_visible: Whether to display the fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = RibbonData\n\n    def __init__(\n        self,\n        data: Union[List[RibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize RibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill color\n        self._fill_color = RIBBON_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.RIBBON\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.RibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.RibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.SignalSeries","title":"SignalSeries","text":"<p>Signal series for background coloring in charts.</p> <p>SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>The series takes signal data with binary or ternary values and maps them to background colors for specific time periods. The background bands appear across all chart panes and provide visual context for the data.</p> <p>Signal data can be: - Binary (0, 1): Only uses neutral_color and signal_color - Ternary (0, 1, negative): Uses all three colors including alert_color</p> <p>Attributes:</p> Name Type Description <code>neutral_color</code> <p>Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")</p> <code>signal_color</code> <p>Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")</p> <code>alert_color</code> <p>Background color for signal value&lt;0 (negative, optional, default: None) Frontend intelligently uses this only when data contains non-boolean values</p> Example <pre><code># Create signal data\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n    SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n]\n\n# Create signal series\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n\n# Add to chart\nchart.add_series(signal_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/signal_series.py</code> <pre><code>@chainable_property(\"neutral_color\", str, validator=\"color\")\n@chainable_property(\"signal_color\", str, validator=\"color\")\n@chainable_property(\"alert_color\", str, validator=\"color\", allow_none=True)\nclass SignalSeries(Series):\n    \"\"\"Signal series for background coloring in charts.\n\n    SignalSeries creates vertical background bands that span the entire chart\n    height, colored based on signal values at specific time points. This is\n    commonly used in financial charts to highlight specific market conditions,\n    trading signals, or events.\n\n    The series takes signal data with binary or ternary values and maps them\n    to background colors for specific time periods. The background bands\n    appear across all chart panes and provide visual context for the data.\n\n    Signal data can be:\n    - Binary (0, 1): Only uses neutral_color and signal_color\n    - Ternary (0, 1, negative): Uses all three colors including alert_color\n\n    Attributes:\n        neutral_color: Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")\n        signal_color: Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")\n        alert_color: Background color for signal value&lt;0 (negative, optional, default: None)\n            Frontend intelligently uses this only when data contains non-boolean values\n\n    Example:\n        ```python\n        # Create signal data\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n            SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n        ]\n\n        # Create signal series\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n\n        # Add to chart\n        chart.add_series(signal_series)\n        ```\n    \"\"\"\n\n    DATA_CLASS = SignalData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: ChartType.SIGNAL indicating this is a signal series.\n        \"\"\"\n        return ChartType.SIGNAL\n\n    def __init__(\n        self,\n        data: Union[List[SignalData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        neutral_color: str = \"rgba(128, 128, 128, 0.1)\",\n        signal_color: str = \"rgba(76, 175, 80, 0.2)\",\n        alert_color: Optional[str] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize SignalSeries.\n\n        Args:\n            data: List of SignalData objects, DataFrame, or Series.\n            column_mapping: Optional column mapping for DataFrame input.\n            neutral_color: Background color for value=0. Defaults to \"rgba(128, 128, 128, 0.1)\".\n            signal_color: Background color for value&gt;0 (positive). Defaults to \"rgba(76, 175, 80, 0.2)\".\n            alert_color: Background color for value&lt;0 (negative). Defaults to None.\n                Frontend intelligently uses this only when needed based on data values.\n            visible: Whether the signal series should be visible. Defaults to True.\n            price_scale_id: Price scale ID. Defaults to \"right\".\n            pane_id: Pane ID for multi-pane charts. Defaults to 0.\n\n        Raises:\n            ValueError: If data is empty or invalid.\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize signal-specific properties with default values\n        self._neutral_color = neutral_color\n        self._signal_color = signal_color\n        self._alert_color = alert_color\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the signal series.\"\"\"\n        return (\n            f\"SignalSeries(data_points={len(self.data)}, neutral_color='{self._neutral_color}',\"\n            f\" signal_color='{self._signal_color}')\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.SignalSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.SignalSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>ChartType.SIGNAL indicating this is a signal series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.TrendFillSeries","title":"TrendFillSeries","text":"<p>Trend fill series for lightweight charts.</p> <p>This class represents a trend fill series that displays fills between trend lines and base lines. It's commonly used for technical indicators like Supertrend, where the fill area changes color based on trend direction.</p> <p>The series properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p> <p>Attributes:</p> Name Type Description <code>uptrend_line</code> <code>LineOptions</code> <p>Line options for the uptrend line.</p> <code>downtrend_line</code> <code>LineOptions</code> <p>Line options for the downtrend line.</p> <code>base_line</code> <code>LineOptions</code> <p>Line options for the base line.</p> <code>uptrend_fill_color</code> <code>str</code> <p>Color for uptrend fills (default: green).</p> <code>downtrend_fill_color</code> <code>str</code> <p>Color for downtrend fills (default: red).</p> <code>fill_visible</code> <code>bool</code> <p>Whether fills are visible.</p> Example <pre><code>from streamlit_lightweight_charts_pro import TrendFillSeries\nfrom streamlit_lightweight_charts_pro.data import TrendFillData\n\n# Create trend fill data\ndata = [\n    TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n    TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n]\n\n# Create series with custom colors\nseries = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/trend_fill.py</code> <pre><code>@chainable_property(\"uptrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"downtrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"base_line\", LineOptions, allow_none=True)\n@chainable_property(\"uptrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"downtrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass TrendFillSeries(Series):\n    \"\"\"Trend fill series for lightweight charts.\n\n    This class represents a trend fill series that displays fills between\n    trend lines and base lines. It's commonly used for technical\n    indicators like Supertrend, where the fill area changes color based on\n    trend direction.\n\n    The series properly handles separate trend lines based on trend direction:\n    - Uptrend (+1): Uses uptrend_line options for trend line above price\n    - Downtrend (-1): Uses downtrend_line options for trend line below price\n\n    Attributes:\n        uptrend_line (LineOptions): Line options for the uptrend line.\n        downtrend_line (LineOptions): Line options for the downtrend line.\n        base_line (LineOptions): Line options for the base line.\n        uptrend_fill_color (str): Color for uptrend fills (default: green).\n        downtrend_fill_color (str): Color for downtrend fills (default: red).\n        fill_visible (bool): Whether fills are visible.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import TrendFillSeries\n        from streamlit_lightweight_charts_pro.data import TrendFillData\n\n        # Create trend fill data\n        data = [\n            TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n            TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n        ]\n\n        # Create series with custom colors\n        series = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n        ```\n    \"\"\"\n\n    DATA_CLASS = TrendFillData\n\n    def __init__(\n        self,\n        data: Union[List[TrendFillData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        uptrend_fill_color: str = \"#4CAF50\",\n        downtrend_fill_color: str = \"#F44336\",\n    ):\n        \"\"\"Initialize TrendFillSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            uptrend_fill_color: Color for uptrend fills (green)\n            downtrend_fill_color: Color for downtrend fills (red)\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Convert colors to rgba with default opacity\n        self._uptrend_fill_color = add_opacity(uptrend_fill_color)\n        self._downtrend_fill_color = add_opacity(downtrend_fill_color)\n\n        # Initialize line options for uptrend line, downtrend line, and base line\n        self._uptrend_line = create_uptrend_line()\n        self._downtrend_line = create_downtrend_line()\n        self._base_line = create_base_line()\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Return the chart type for this series.\"\"\"\n        return ChartType.TREND_FILL\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.TrendFillSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/index.html#streamlit_lightweight_charts_pro.charts.TrendFillSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Return the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html","title":"streamlit_lightweight_charts_pro.charts.chart","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart","title":"chart","text":"<p>Chart implementation for streamlit-lightweight-charts.</p> <p>This module provides the Chart class, which is the primary chart type for displaying financial data in a single pane. It supports multiple series types, annotations, and comprehensive customization options with a fluent API for method chaining.</p> <p>The Chart class serves as the main entry point for creating financial charts in Streamlit applications. It orchestrates multiple managers to handle different aspects of chart functionality:     - SeriesManager: Manages multiple data series (line, candlestick, etc.)     - PriceScaleManager: Handles price scale configuration and overlays     - TradeManager: Manages trade visualization     - SessionStateManager: Handles state persistence across renders     - ChartRenderer: Handles rendering and frontend communication     - AnnotationManager: Manages chart annotations and layers     - TooltipManager: Handles custom tooltip configurations</p> Architecture <p>The Chart uses a manager-based architecture to separate concerns:</p> <p>Chart (Main Orchestrator) \u251c\u2500\u2500 SeriesManager (Data series management) \u251c\u2500\u2500 PriceScaleManager (Price scale configuration) \u251c\u2500\u2500 TradeManager (Trade visualization) \u251c\u2500\u2500 SessionStateManager (State persistence) \u251c\u2500\u2500 ChartRenderer (Rendering pipeline) \u251c\u2500\u2500 AnnotationManager (Annotations and layers) \u2514\u2500\u2500 TooltipManager (Custom tooltips)</p> <p>This design provides: - Clear separation of concerns - Easy testing of individual components - Flexibility for future enhancements - Reduced complexity in the main Chart class</p> Example <p>Basic chart creation::</p> <pre><code>from streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105)\n]\n\n# Create chart with method chaining\nchart = (\n    Chart(series=LineSeries(data))\n    .update_options(height=400)\n    .add_annotation(create_text_annotation(\"2024-01-01\", 100, \"Start\"))\n)\n\n# Render in Streamlit\nchart.render(key=\"my_chart\")\n</code></pre> <p>Multi-series chart::</p> <pre><code>from streamlit_lightweight_charts_pro import (\n    Chart,\n    LineSeries,\n    CandlestickSeries\n)\n\n# Create chart with multiple series\nchart = Chart(\n    series=[\n        CandlestickSeries(ohlc_data),\n        LineSeries(ma_data)\n    ]\n)\n\n# Add more series dynamically\nchart.add_series(HistogramSeries(volume_data))\n\n# Render\nchart.render(key=\"multi_series_chart\")\n</code></pre> Note <p>The Chart class is designed to be immutable after creation in terms of its manager instances, but the chart configuration and data can be modified through the fluent API methods.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart","title":"Chart","text":"<p>Single pane chart for displaying financial data.</p> <p>This class represents a single pane chart that can display multiple series of financial data. It supports various chart types including candlestick, line, area, bar, and histogram series. The chart includes comprehensive annotation support, trade visualization, and method chaining for fluent API usage.</p> <p>The Chart class uses a manager-based architecture where each manager handles a specific aspect of chart functionality. This design provides clear separation of concerns and makes the codebase easier to maintain and extend.</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects to display in the chart. This is exposed for backward compatibility and delegates to SeriesManager internally.</p> <code>options</code> <code>ChartOptions</code> <p>Chart configuration options including layout, grid, time scale, price scale, etc.</p> <code>annotation_manager</code> <code>AnnotationManager</code> <p>Manager for chart annotations and layers. Handles text, arrows, shapes, and other visual elements.</p> <code>force_reinit</code> <code>bool</code> <p>Flag to force frontend re-initialization. Set to True when indicator parameters or other settings change that require the chart to be completely rebuilt on the frontend.</p> Private Attributes <p>_series_manager (SeriesManager): Manages all data series. _price_scale_manager (PriceScaleManager): Manages price scale config. _trade_manager (TradeManager): Manages trade visualization. _session_state_manager (SessionStateManager): Manages state persistence. _chart_renderer (ChartRenderer): Handles rendering pipeline. _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips. _chart_group_id (int): Group ID for chart synchronization. _chart_manager (Optional[Any]): Reference to parent ChartManager.</p> Example <p>Basic usage::</p> <pre><code># Create a simple line chart\nchart = Chart(series=LineSeries(data))\n\n# Configure options\nchart.update_options(height=400, width=800)\n\n# Render in Streamlit\nchart.render(key=\"my_chart\")\n</code></pre> <p>With method chaining::</p> <pre><code>chart = (\n    Chart(series=LineSeries(data))\n    .update_options(height=400)\n    .add_annotation(text_annotation)\n    .add_series(candlestick_series)\n)\nchart.render()\n</code></pre> <p>From DataFrame with price and volume::</p> <pre><code>chart = Chart.from_price_volume_dataframe(\n    df,\n    column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n    price_type=\"candlestick\"\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>class Chart:\n    \"\"\"Single pane chart for displaying financial data.\n\n    This class represents a single pane chart that can display multiple\n    series of financial data. It supports various chart types including\n    candlestick, line, area, bar, and histogram series. The chart includes\n    comprehensive annotation support, trade visualization, and method chaining\n    for fluent API usage.\n\n    The Chart class uses a manager-based architecture where each manager\n    handles a specific aspect of chart functionality. This design provides\n    clear separation of concerns and makes the codebase easier to maintain\n    and extend.\n\n    Attributes:\n        series (List[Series]): List of series objects to display in the chart.\n            This is exposed for backward compatibility and delegates to\n            SeriesManager internally.\n        options (ChartOptions): Chart configuration options including layout,\n            grid, time scale, price scale, etc.\n        annotation_manager (AnnotationManager): Manager for chart annotations\n            and layers. Handles text, arrows, shapes, and other visual elements.\n        force_reinit (bool): Flag to force frontend re-initialization. Set to\n            True when indicator parameters or other settings change that require\n            the chart to be completely rebuilt on the frontend.\n\n    Private Attributes:\n        _series_manager (SeriesManager): Manages all data series.\n        _price_scale_manager (PriceScaleManager): Manages price scale config.\n        _trade_manager (TradeManager): Manages trade visualization.\n        _session_state_manager (SessionStateManager): Manages state persistence.\n        _chart_renderer (ChartRenderer): Handles rendering pipeline.\n        _tooltip_manager (Optional[TooltipManager]): Manages custom tooltips.\n        _chart_group_id (int): Group ID for chart synchronization.\n        _chart_manager (Optional[Any]): Reference to parent ChartManager.\n\n    Example:\n        Basic usage::\n\n            # Create a simple line chart\n            chart = Chart(series=LineSeries(data))\n\n            # Configure options\n            chart.update_options(height=400, width=800)\n\n            # Render in Streamlit\n            chart.render(key=\"my_chart\")\n\n        With method chaining::\n\n            chart = (\n                Chart(series=LineSeries(data))\n                .update_options(height=400)\n                .add_annotation(text_annotation)\n                .add_series(candlestick_series)\n            )\n            chart.render()\n\n        From DataFrame with price and volume::\n\n            chart = Chart.from_price_volume_dataframe(\n                df,\n                column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"},\n                price_type=\"candlestick\"\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        series: Optional[Union[Series, List[Series]]] = None,\n        options: Optional[ChartOptions] = None,\n        annotations: Optional[List[Annotation]] = None,\n        chart_group_id: int = 0,\n        chart_manager: Optional[Any] = None,\n    ):\n        \"\"\"Initialize a single pane chart.\n\n        Creates a new Chart instance with optional series, configuration options,\n        and annotations. The chart can be configured with multiple series types\n        and supports method chaining for fluent API usage.\n\n        The initialization process:\n            1. Set up chart options (use defaults if not provided)\n            2. Initialize all managers for chart functionality\n            3. Set up annotation system\n            4. Configure chart synchronization\n            5. Process initial annotations if provided\n\n        Args:\n            series: Optional single series object or list of series objects to\n                display. Each series represents a different data visualization\n                (line, candlestick, area, etc.). If None, an empty chart is\n                created.\n            options: Optional chart configuration options. If not provided,\n                default options will be used.\n            annotations: Optional list of annotations to add to the chart.\n                Annotations can include text, arrows, shapes, etc.\n            chart_group_id: Group ID for synchronization. Charts with the same\n                group ID will be synchronized. Defaults to 0.\n            chart_manager: Reference to the ChartManager that owns this chart.\n                Used to access sync configuration when rendering individual charts.\n\n        Returns:\n            Chart: Initialized chart instance ready for configuration and rendering.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list, or if\n                annotations is not a list.\n            AnnotationItemsTypeError: If any item in annotations is not an Annotation\n                instance.\n\n        Example:\n            Create empty chart::\n\n                &gt;&gt;&gt; chart = Chart()\n\n            Create chart with single series::\n\n                &gt;&gt;&gt; chart = Chart(series=LineSeries(data))\n\n            Create chart with multiple series::\n\n                &gt;&gt;&gt; chart = Chart(series=[line_series, candlestick_series])\n\n            Create chart with custom options::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     options=ChartOptions(height=600, width=800)\n                ... )\n\n            Create chart with annotations::\n\n                &gt;&gt;&gt; chart = Chart(\n                ...     series=line_series,\n                ...     annotations=[text_ann, arrow_ann]\n                ... )\n        \"\"\"\n        # Step 1: Set up chart configuration\n        # Use provided options or create default ChartOptions instance\n        # ChartOptions contains all chart-level configuration like height,\n        # width, layout, grid, time scale, price scale, etc.\n        self.options = options or ChartOptions()\n\n        # Step 2: Initialize managers for different chart functionalities\n        # Each manager handles a specific aspect of chart behavior\n\n        # SeriesManager: Manages all data series (line, candlestick, etc.)\n        # Handles series validation, ordering, and serialization\n        self._series_manager = SeriesManager(series)\n\n        # PriceScaleManager: Manages price scale configuration\n        # Handles left/right price scales and overlay price scales\n        # Overlay scales are used for volume, indicators, etc.\n        self._price_scale_manager = PriceScaleManager(\n            left_price_scale=self.options.left_price_scale,\n            right_price_scale=self.options.right_price_scale,\n            overlay_price_scales=self.options.overlay_price_scales,\n        )\n\n        # TradeManager: Manages trade visualization\n        # Converts TradeData objects to visual elements (markers, rectangles, etc.)\n        self._trade_manager = TradeManager()\n\n        # SessionStateManager: Handles state persistence across renders\n        # Manages series configurations and user interactions\n        # Stores data in Streamlit session state for persistence\n        self._session_state_manager = SessionStateManager()\n\n        # ChartRenderer: Handles the rendering pipeline\n        # Converts chart configuration to frontend format\n        # Manages component rendering and response handling\n        # Takes reference to chart_manager for sync configuration\n        self._chart_renderer = ChartRenderer(chart_manager_ref=chart_manager)\n\n        # Step 3: Set up annotation system\n        # AnnotationManager handles layers and annotation lifecycle\n        # Supports multiple layers for organizing different annotation types\n        self.annotation_manager = AnnotationManager()\n\n        # Step 4: Initialize tooltip manager for lazy loading\n        # TooltipManager is created on-demand when tooltips are configured\n        # This avoids overhead for charts that don't use custom tooltips\n        self._tooltip_manager: Optional[TooltipManager] = None\n\n        # Step 5: Initialize chart synchronization support\n        # Charts with same group_id are synchronized (crosshair, time range)\n        # This is different from ChartManager's sync_group which manages\n        # multiple charts\n        self._chart_group_id = chart_group_id\n\n        # Store reference to parent ChartManager (if this chart is managed)\n        # Used to access sync configuration when rendering\n        self._chart_manager = chart_manager\n\n        # Step 6: Initialize force re-initialization flag\n        # When True, forces frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        # that can't be updated through normal data updates\n        self.force_reinit: bool = False\n\n        # Step 7: Expose series list for backward compatibility\n        # This allows direct access to series: chart.series[0]\n        # Internally delegates to SeriesManager\n        self.series = self._series_manager.series\n\n        # Step 8: Process initial annotations if provided\n        if annotations is not None:\n            # Validate that annotations is a list\n            if not isinstance(annotations, list):\n                raise TypeValidationError(\"annotations\", \"list\")\n\n            # Validate and add each annotation\n            for annotation in annotations:\n                # Ensure each item is an Annotation instance\n                if not isinstance(annotation, Annotation):\n                    raise AnnotationItemsTypeError()\n                # Add to default annotation layer\n                self.add_annotation(annotation)\n\n    def get_stored_series_config(\n        self,\n        key: str,\n        series_index: int = 0,\n        pane_id: int = 0,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get stored configuration for a specific series.\n\n        Retrieves the stored configuration for a series from session state.\n        This is useful for applying previously saved configurations when\n        creating new series instances, enabling persistence of user\n        customizations across renders.\n\n        The stored configuration includes user-modified settings like:\n            - Colors and styles\n            - Line widths and types\n            - Visibility settings\n            - Other series-specific options\n\n        Args:\n            key: Component key used to namespace the stored configs. This should\n                match the key used when rendering the chart.\n            series_index: Index of the series (0-based). Defaults to 0.\n            pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n                charts where the same series index may exist in different panes.\n\n        Returns:\n            Dictionary of stored configuration or empty dict if none found.\n            The dictionary keys match the series option property names.\n\n        Example:\n            Get and apply stored config::\n\n                &gt;&gt;&gt; # Get stored config for first series\n                &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Apply to new series\n                &gt;&gt;&gt; if config:\n                ...     line_series = LineSeries(data)\n                ...     if \"color\" in config:\n                ...         line_series.line_options.color = config[\"color\"]\n                ...     if \"lineWidth\" in config:\n                ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n            Restore all series configs::\n\n                &gt;&gt;&gt; for i, series in enumerate(chart.series):\n                ...     config = chart.get_stored_series_config(\"my_chart\", i)\n                ...     if config:\n                ...         apply_config_to_series(series, config)\n        \"\"\"\n        # Delegate to SessionStateManager which handles the actual storage\n        # SessionStateManager uses Streamlit's session_state for persistence\n        return self._session_state_manager.get_stored_series_config(\n            key, series_index, pane_id\n        )\n\n    def add_series(self, series: Series) -&gt; \"Chart\":\n        \"\"\"Add a series to the chart.\n\n        Adds a new series object to the chart's series list. The series will be\n        displayed according to its type (line, candlestick, area, etc.) and\n        configuration options. The method automatically handles price scale\n        configuration for custom price scale IDs.\n\n        When a series is added:\n            1. Series is validated to ensure it's a Series instance\n            2. SeriesManager adds it to the series list\n            3. If series has custom price_scale_id, PriceScaleManager is notified\n            4. Series is assigned a z-index for proper layering\n\n        Args:\n            series: Series object to add to the chart. Must be an instance of a\n                Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n\n        Example:\n            Add a candlestick series::\n\n                &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n            Add a line series with custom options::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n                &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n                &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n            Add series with custom price scale::\n\n                &gt;&gt;&gt; # Series with custom price scale ID\n                &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n                &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add overlay price scale configuration\n                &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Add the series\n                &gt;&gt;&gt; chart.add_series(volume_series)\n        \"\"\"\n        # Delegate to SeriesManager which handles validation and storage\n        # Also pass PriceScaleManager reference so it can be notified of\n        # custom price scale IDs\n        self._series_manager.add_series(series, self._price_scale_manager)\n\n        # Return self to enable method chaining\n        return self\n\n    def update_options(self, **kwargs) -&gt; \"Chart\":\n        \"\"\"Update chart options.\n\n        Updates the chart's configuration options using keyword arguments.\n        Only valid ChartOptions attributes will be updated; invalid attributes\n        are silently ignored to support method chaining and forward compatibility.\n\n        The method performs type checking to ensure new values match the\n        expected types of the chart options. This prevents runtime errors\n        from invalid configurations.\n\n        Args:\n            **kwargs: Chart options to update. Valid options include:\n                - width (Optional[int]): Chart width in pixels\n                - height (int): Chart height in pixels (default: 400)\n                - auto_size (bool): Whether to auto-size the chart\n                - handle_scroll (bool): Whether to enable scroll interactions\n                - handle_scale (bool): Whether to enable scale interactions\n                - add_default_pane (bool): Whether to add a default pane\n                And many more options defined in ChartOptions class.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Update basic dimensions::\n\n                &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n            Update interaction options::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     handle_scroll=True,\n                ...     handle_scale=False,\n                ...     auto_size=True\n                ... )\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n            Update multiple options at once::\n\n                &gt;&gt;&gt; chart.update_options(\n                ...     height=600,\n                ...     width=1200,\n                ...     auto_size=False,\n                ...     handle_scroll=True\n                ... )\n        \"\"\"\n        # Process each keyword argument to update chart options\n        for key, value in kwargs.items():\n            # Step 1: Validate the option exists and value is not None\n            # Check that the attribute exists on ChartOptions instance\n            # and that the new value is not None (None values are ignored)\n            if value is not None and hasattr(self.options, key):\n                # Step 2: Get current attribute value for type checking\n                # This helps ensure type consistency\n                current_value = getattr(self.options, key)\n\n                # Step 3: Validate type compatibility\n                # Allow update if:\n                # - New value type matches current value type, OR\n                # - Current value is None and new value is not None\n                #   (allows setting previously unset options)\n                if isinstance(value, type(current_value)) or (\n                    current_value is None and value is not None\n                ):\n                    # Update the attribute with the validated value\n                    setattr(self.options, key, value)\n\n            # Note: Invalid attributes and None values are silently ignored\n            # This enables method chaining and forward compatibility\n\n        # Return self for method chaining\n        return self\n\n    def add_annotation(\n        self, annotation: Annotation, layer_name: str = \"default\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add an annotation to the chart.\n\n        Adds a single annotation to the specified annotation layer. If the layer\n        doesn't exist, it will be created automatically. Annotations are visual\n        elements like text, arrows, shapes, and lines that provide additional\n        information or highlight specific points on the chart.\n\n        Annotations are organized into layers for better management:\n            - Each layer can contain multiple annotations\n            - Layers can be shown/hidden independently\n            - Layers can be cleared without affecting other layers\n            - Default layer is used if no layer name is specified\n\n        Args:\n            annotation (Annotation): Annotation object to add to the chart.\n                Must be a valid Annotation instance with proper configuration.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". Layer will be created if it doesn't exist.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If annotation is None or layer_name is invalid.\n            TypeValidationError: If annotation is not an Annotation instance.\n\n        Example:\n            Add text annotation::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n                ...     create_text_annotation\n                ... )\n                &gt;&gt;&gt; text_ann = create_text_annotation(\n                ...     \"2024-01-01\", 100, \"Important Event\"\n                ... )\n                &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n            Add annotation to custom layer::\n\n                &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n                &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n            Organize annotations by layer::\n\n                &gt;&gt;&gt; # Technical analysis annotations\n                &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n                &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Trading signals\n                &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n                &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n        \"\"\"\n        # Step 1: Validate annotation is not None\n        if annotation is None:\n            raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n        # Step 2: Validate annotation is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n        # Step 3: Handle layer name validation\n        # Use default layer name if None is provided\n        if layer_name is None:\n            layer_name = \"default\"\n        # Validate layer_name is a non-empty string\n        elif not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Add annotation to the specified layer\n        # AnnotationManager will create the layer if it doesn't exist\n        self.annotation_manager.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def add_annotations(\n        self,\n        annotations: List[Annotation],\n        layer_name: str = \"default\",\n    ) -&gt; \"Chart\":\n        \"\"\"Add multiple annotations to the chart.\n\n        Adds multiple annotation objects to the specified annotation layer. This\n        is more efficient than calling add_annotation multiple times as it\n        processes all annotations in a single operation and provides better\n        performance for bulk annotation operations.\n\n        All annotations are added to the same layer, enabling consistent\n        management (show/hide/clear) of related annotations.\n\n        Args:\n            annotations (List[Annotation]): List of annotation objects to add\n                to the chart. All must be valid Annotation instances.\n            layer_name (str, optional): Name of the annotation layer. Defaults\n                to \"default\". All annotations will be added to this layer.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If annotations is not a list.\n            ValueValidationError: If layer_name is invalid.\n            AnnotationItemsTypeError: If any item in annotations is not an\n                Annotation instance.\n\n        Example:\n            Add multiple annotations at once::\n\n                &gt;&gt;&gt; annotations = [\n                ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n                ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n                ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n                ... ]\n                &gt;&gt;&gt; chart.add_annotations(annotations)\n\n            Add to custom layer::\n\n                &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n                &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n            Bulk operations with method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n                ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n                ...  .update_options(height=600))\n        \"\"\"\n        # Step 1: Validate annotations is not None\n        if annotations is None:\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 2: Validate annotations is a list\n        if not isinstance(annotations, list):\n            raise TypeValidationError(\"annotations\", \"list\")\n\n        # Step 3: Validate layer_name\n        if not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        # Step 4: Validate and add each annotation\n        for annotation in annotations:\n            # Ensure each item is an Annotation instance\n            if not isinstance(annotation, Annotation):\n                raise AnnotationItemsTypeError()\n\n            # Add the annotation to the specified layer\n            # Reuses add_annotation logic for consistency\n            self.add_annotation(annotation, layer_name)\n\n        # Return self for method chaining\n        return self\n\n    def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new annotation layer with the specified name. Annotation layers\n        allow you to organize and manage groups of annotations independently.\n        Each layer can be shown, hidden, or cleared separately, providing\n        flexible control over annotation visibility.\n\n        Common use cases for layers:\n            - Separate technical analysis from trading signals\n            - Organize annotations by timeframe or strategy\n            - Group annotations by type (text, arrows, shapes)\n            - Enable/disable different annotation sets dynamically\n\n        Args:\n            name (str): Name of the annotation layer to create. Must be a\n                non-empty string and should be unique.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If name is None.\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Create custom layers for different types of annotations::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .create_annotation_layer(\"layer1\")\n                ...  .create_annotation_layer(\"layer2\")\n                ...  .add_annotation(ann1, \"layer1\")\n                ...  .add_annotation(ann2, \"layer2\"))\n\n            Organize by strategy::\n\n                &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n                &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n                &gt;&gt;&gt; # Add annotations specific to each strategy\n        \"\"\"\n        # Step 1: Validate name is not None\n        if name is None:\n            raise TypeValidationError(\"name\", \"string\")\n\n        # Step 2: Validate name is a non-empty string\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 3: Create the layer in AnnotationManager\n        # If layer already exists, this operation is idempotent\n        self.annotation_manager.create_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Hide an annotation layer.\n\n        Hides the specified annotation layer, making all annotations in that\n        layer invisible on the chart. The layer and its annotations are preserved\n        and can be shown again using show_annotation_layer. This is useful for\n        temporarily hiding certain annotation groups without removing them.\n\n        Hidden layers:\n            - Remain in memory with all annotations intact\n            - Can be shown again without re-adding annotations\n            - Don't affect other layers' visibility\n            - Are persisted across chart updates\n\n        Args:\n            name (str): Name of the annotation layer to hide.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Hide specific layers::\n\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .hide_annotation_layer(\"layer1\")\n                ...  .hide_annotation_layer(\"layer2\")\n                ...  .show_annotation_layer(\"layer3\"))\n\n            Toggle layer visibility::\n\n                &gt;&gt;&gt; # Hide analysis layer temporarily\n                &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; # ... show chart without analysis\n                &gt;&gt;&gt; # Show analysis layer again\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Hide the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.hide_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Show an annotation layer.\n\n        Makes the specified annotation layer visible on the chart. This will\n        display all annotations that were previously added to this layer.\n        If the layer doesn't exist or is already visible, this method will\n        have no effect.\n\n        This is the counterpart to hide_annotation_layer and enables dynamic\n        control over which annotation groups are visible.\n\n        Args:\n            name (str): Name of the annotation layer to show.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If name is empty or not a string.\n\n        Example:\n            Show specific layers::\n\n                &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n                &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .show_annotation_layer(\"layer1\")\n                ...  .show_annotation_layer(\"layer2\")\n                ...  .hide_annotation_layer(\"layer3\"))\n\n            Conditional visibility::\n\n                &gt;&gt;&gt; # Show different layers based on user selection\n                &gt;&gt;&gt; if show_technical_analysis:\n                ...     chart.show_annotation_layer(\"ta\")\n                &gt;&gt;&gt; if show_trading_signals:\n                ...     chart.show_annotation_layer(\"signals\")\n        \"\"\"\n        # Step 1: Validate layer name\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n        # Step 2: Show the layer through AnnotationManager\n        # If layer doesn't exist, this operation has no effect\n        self.annotation_manager.show_layer(name)\n\n        # Return self for method chaining\n        return self\n\n    def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n        \"\"\"Clear annotations from the chart.\n\n        Removes all annotations from the specified layer or from all layers if\n        no layer name is provided. The layer itself is preserved and can be\n        reused for new annotations. This is useful for refreshing annotations\n        without recreating the entire chart.\n\n        Clearing behavior:\n            - With layer_name: Clears only that specific layer\n            - Without layer_name: Does nothing (for backward compatibility)\n            - Layer structure is preserved (can add new annotations)\n            - Does not affect hidden/shown state of layers\n\n        Args:\n            layer_name (Optional[str]): Name of the layer to clear. If None,\n                no action is taken. Defaults to None.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            ValueValidationError: If layer_name is not None and invalid.\n\n        Example:\n            Clear specific layer::\n\n                &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n            Clear all layers (provide None)::\n\n                &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .clear_annotations(\"layer1\")\n                ...  .add_annotation(new_annotation, \"layer1\"))\n\n            Refresh annotations::\n\n                &gt;&gt;&gt; # Clear old annotations and add new ones\n                &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n                &gt;&gt;&gt; for signal in new_signals:\n                ...     chart.add_annotation(signal, \"signals\")\n        \"\"\"\n        # Step 1: Validate layer_name if provided\n        if layer_name is not None and (\n            not layer_name or not isinstance(layer_name, str)\n        ):\n            raise ValueValidationError(\n                \"layer_name\", \"must be None or a non-empty string\"\n            )\n\n        # Step 2: Clear the specified layer\n        if layer_name is not None:\n            # Clear only the specified layer through AnnotationManager\n            self.annotation_manager.clear_layer(layer_name)\n\n        # Note: If layer_name is None, no action is taken\n        # This maintains backward compatibility with existing code\n\n        # Return self for method chaining\n        return self\n\n    def add_overlay_price_scale(\n        self, scale_id: str, options: \"PriceScaleOptions\"\n    ) -&gt; \"Chart\":\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Adds or updates an overlay price scale configuration for the chart.\n        Overlay price scales allow multiple series to share the same price axis\n        while maintaining independent scaling and positioning. This is commonly\n        used for volume bars, indicators, and other overlays.\n\n        Overlay price scales enable:\n            - Independent vertical positioning (scale margins)\n            - Separate auto-scaling behavior\n            - Different visibility settings\n            - Custom formatting and precision\n\n        Args:\n            scale_id (str): The unique identifier for the custom price scale\n                (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n                by series that use this price scale.\n            options (PriceScaleOptions): A PriceScaleOptions instance containing\n                the configuration for the overlay price scale.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            PriceScaleIdTypeError: If scale_id is not a string.\n            PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n        Example:\n            Add volume overlay price scale::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n                ...     PriceScaleOptions\n                ... )\n                &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n                ...     visible=False,  # Hide the price scale itself\n                ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n                ...     scale_margin_bottom=0,\n                ...     overlay=True,  # Mark as overlay\n                ...     auto_scale=True  # Auto-scale to data\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n            Add indicator overlay::\n\n                &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n                ...     visible=True,\n                ...     scale_margin_top=0.7,\n                ...     scale_margin_bottom=0.1,\n                ...     overlay=True\n                ... )\n                &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_overlay_price_scale('volume', volume_scale)\n                ...  .add_series(volume_series))\n        \"\"\"\n        # Step 1: Add overlay scale through PriceScaleManager\n        # Manager validates scale_id and options internally\n        self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n        # Step 2: Sync back to options for backward compatibility\n        # This ensures options.overlay_price_scales is updated\n        # Some legacy code may access overlay scales directly from options\n        self.options.overlay_price_scales[scale_id] = options\n\n        # Return self for method chaining\n        return self\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series to the chart from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale positioned at the\n        bottom of the chart.\n\n        This is a convenience method that:\n            1. Configures the volume overlay price scale\n            2. Creates price series (candlestick or line)\n            3. Creates volume histogram series\n            4. Adds both series to the chart\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information. Can be a sequence of OhlcvData objects\n                or a pandas DataFrame.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n                Defaults to None (assumes standard column names).\n            price_type (str, optional): Type of price series to create. Options:\n                \"candlestick\" or \"line\". Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration (colors, line width, etc.). Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration (colors, transparency, etc.). Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0. Used in multi-pane charts.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If data type is invalid.\n            ValueError: If column_mapping is invalid or required columns are missing.\n\n        Example:\n            Add candlestick with volume::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n                ...     price_type=\"candlestick\"\n                ... )\n\n            Add line chart with custom volume colors::\n\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     ohlcv_data,\n                ...     price_type=\"line\",\n                ...     volume_kwargs={\n                ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n                ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n                ...     }\n                ... )\n\n            From DataFrame::\n\n                &gt;&gt;&gt; df = pd.DataFrame({\n                ...     'timestamp': [...],\n                ...     'o': [...],\n                ...     'h': [...],\n                ...     'l': [...],\n                ...     'c': [...],\n                ...     'v': [...]\n                ... })\n                &gt;&gt;&gt; chart.add_price_volume_series(\n                ...     df,\n                ...     column_mapping={\n                ...         \"time\": \"timestamp\",\n                ...         \"open\": \"o\",\n                ...         \"high\": \"h\",\n                ...         \"low\": \"l\",\n                ...         \"close\": \"c\",\n                ...         \"volume\": \"v\"\n                ...     }\n                ... )\n        \"\"\"\n        # Step 1: Configure price scale manager for volume visualization\n        # This sets up the overlay price scale with proper margins\n        # Volume typically occupies the bottom 20% of the chart\n        self._price_scale_manager.configure_for_volume()\n\n        # Step 2: Delegate to series manager for actual series creation\n        # SeriesManager handles:\n        # - Data conversion (DataFrame to OhlcvData if needed)\n        # - Price series creation (candlestick or line)\n        # - Volume histogram series creation\n        # - Series configuration from kwargs\n        # - Adding both series to the chart\n        self._series_manager.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n            price_scale_manager=self._price_scale_manager,\n        )\n\n        # Return self for method chaining\n        return self\n\n    def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements and adds them to the chart\n        for visualization. Each trade is displayed with entry/exit markers,\n        connecting lines, profit/loss rectangles, or zones based on the\n        TradeVisualizationOptions.style configuration.\n\n        Trade visualization styles:\n            - \"markers\": Entry and exit markers only\n            - \"rectangle\": Filled rectangle between entry and exit\n            - \"line\": Simple line connecting entry to exit\n            - \"arrow\": Arrow from entry to exit\n            - \"zone\": Highlighted zone with transparency\n\n        The visualization automatically color-codes trades:\n            - Green/profit color for winning trades\n            - Red/loss color for losing trades\n            - Customizable through TradeVisualizationOptions\n\n        Args:\n            trades (List[TradeData]): List of TradeData objects to visualize\n                on the chart. Each trade must have entry_time, entry_price,\n                exit_time, exit_price, and trade_type.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            Add basic trade visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                ...     TradeType\n                ... )\n                &gt;&gt;&gt; trades = [\n                ...     TradeData(\n                ...         entry_time=\"2024-01-01 10:00:00\",\n                ...         entry_price=100.0,\n                ...         exit_time=\"2024-01-01 15:00:00\",\n                ...         exit_price=105.0,\n                ...         quantity=100,\n                ...         trade_type=TradeType.LONG,\n                ...     )\n                ... ]\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            With custom visualization::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n                ...     TradeVisualizationOptions\n                ... )\n                &gt;&gt;&gt; # Configure trade visualization\n                &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n                ...     style=\"rectangle\",\n                ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n                ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n                ... )\n                &gt;&gt;&gt; chart.add_trades(trades)\n\n            Method chaining::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_trades(trades)\n                ...  .update_options(height=600))\n        \"\"\"\n        # Delegate to TradeManager which handles:\n        # - Trade validation\n        # - Conversion to visual elements (markers, rectangles, etc.)\n        # - Profit/loss calculations\n        # - Color coding based on trade outcome\n        # - Annotation creation for visualization\n        self._trade_manager.add_trades(trades)\n\n        # Return self for method chaining\n        return self\n\n    def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n        \"\"\"Set the tooltip manager for the chart.\n\n        Assigns a TooltipManager instance to handle custom tooltip functionality.\n        Tooltips provide additional information when hovering over chart elements.\n\n        Args:\n            tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n        Example:\n            Set custom tooltip manager::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipManager\n                ... )\n                &gt;&gt;&gt; manager = TooltipManager()\n                &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n        \"\"\"\n        # Validate tooltip_manager is a TooltipManager instance\n        if not isinstance(tooltip_manager, TooltipManager):\n            raise TypeValidationError(\n                \"tooltip_manager\", \"TooltipManager instance\"\n            )\n\n        # Assign the tooltip manager\n        self._tooltip_manager = tooltip_manager\n\n        # Return self for method chaining\n        return self\n\n    def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n        \"\"\"Add a tooltip configuration to the chart.\n\n        Adds a named tooltip configuration that defines how tooltips should\n        be displayed for specific data points or series. Multiple tooltip\n        configurations can be registered and used selectively.\n\n        Args:\n            name: Name for the tooltip configuration (unique identifier).\n            config: TooltipConfig instance defining tooltip appearance and behavior.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If config is not a TooltipConfig instance.\n\n        Example:\n            Add custom tooltip configuration::\n\n                &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n                ...     TooltipConfig\n                ... )\n                &gt;&gt;&gt; config = TooltipConfig(\n                ...     title=\"Price Info\",\n                ...     show_time=True,\n                ...     show_value=True\n                ... )\n                &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n        \"\"\"\n        # Validate config is a TooltipConfig instance\n        if not isinstance(config, TooltipConfig):\n            raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n        # Lazy-load tooltip manager if not already set\n        # This avoids creating TooltipManager until actually needed\n        if self._tooltip_manager is None:\n            self._tooltip_manager = TooltipManager()\n\n        # Add the configuration to the tooltip manager\n        self._tooltip_manager.add_config(name, config)\n\n        # Return self for method chaining\n        return self\n\n    def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID which is used for synchronizing multiple charts.\n        Charts with the same group_id will be synchronized with each other,\n        sharing crosshair position and time range changes.\n\n        Note:\n            This is different from ChartManager's sync_group which manages\n            synchronization at a higher level. chart_group_id is used for\n            individual chart synchronization, while sync_group is used for\n            managing groups of charts in ChartManager.\n\n        Args:\n            group_id (int): Group ID for synchronization. Charts with the same\n                group_id will be synchronized.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID::\n\n                &gt;&gt;&gt; chart1.set_chart_group_id(1)\n                &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n            Disable synchronization::\n\n                &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n        \"\"\"\n        # Use property setter which includes validation\n        self.chart_group_id = group_id\n\n        # Return self for method chaining\n        return self\n\n    @property\n    def chart_group_id(self) -&gt; int:\n        \"\"\"Get the chart group ID for synchronization.\n\n        Returns the current chart group ID used for synchronization.\n\n        Returns:\n            int: The chart group ID.\n\n        Example:\n            Get chart group ID::\n\n                &gt;&gt;&gt; group_id = chart.chart_group_id\n                &gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n        \"\"\"\n        # Return the internal chart group ID\n        return self._chart_group_id\n\n    @chart_group_id.setter\n    def chart_group_id(self, group_id: int) -&gt; None:\n        \"\"\"Set the chart group ID for synchronization.\n\n        Sets the chart group ID with validation.\n\n        Args:\n            group_id (int): Group ID for synchronization.\n\n        Raises:\n            TypeValidationError: If group_id is not an integer.\n\n        Example:\n            Set chart group ID via property::\n\n                &gt;&gt;&gt; chart.chart_group_id = 1\n        \"\"\"\n        # Validate group_id is an integer\n        if not isinstance(group_id, int):\n            raise TypeValidationError(\"chart_group_id\", \"integer\")\n\n        # Set the internal chart group ID\n        self._chart_group_id = group_id\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert chart to frontend configuration dictionary.\n\n        Converts the chart and all its components (series, options, annotations,\n        trades, tooltips) to a dictionary format suitable for frontend consumption.\n        This method orchestrates the serialization of all chart elements.\n\n        The serialization process:\n            1. Get series configurations from SeriesManager\n            2. Get base chart options\n            3. Get price scale configuration from PriceScaleManager\n            4. Get annotations configuration from AnnotationManager\n            5. Get trades configuration from TradeManager\n            6. Get tooltip configurations from TooltipManager (if set)\n            7. Generate complete frontend config using ChartRenderer\n            8. Add force_reinit flag if set\n\n        Returns:\n            Dict[str, Any]: Complete chart configuration ready for frontend\n                rendering. The configuration includes:\n                - charts: List of chart objects with series and options\n                - syncConfig: Synchronization settings for multi-chart layouts\n                - annotations: Annotation layers and elements\n                - trades: Trade visualization elements\n                - tooltips: Custom tooltip configurations\n\n        Note:\n            Series are automatically ordered by z-index within each pane to ensure\n            proper layering in the frontend. Series with lower z-index values\n            render behind series with higher z-index values.\n\n        Example:\n            Get frontend configuration::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n            Access specific parts::\n\n                &gt;&gt;&gt; config = chart.to_frontend_config()\n                &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n                &gt;&gt;&gt; series_config = chart_config[\"series\"]\n                &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n        \"\"\"\n        # Step 1: Get series configurations from SeriesManager\n        # SeriesManager handles series ordering by z-index and pane\n        series_configs = self._series_manager.to_frontend_configs()\n\n        # Step 2: Get base chart configuration from ChartOptions\n        # Convert ChartOptions to dictionary for frontend\n        chart_config = (\n            self.options.asdict()\n            if self.options is not None\n            else ChartOptions().asdict()\n        )\n\n        # Step 3: Get price scale configuration from PriceScaleManager\n        # Manager validates scales and returns serialized configuration\n        price_scale_config = self._price_scale_manager.validate_and_serialize()\n        # Merge price scale config into chart config\n        chart_config.update(price_scale_config)\n\n        # Step 4: Get annotations configuration from AnnotationManager\n        # Converts all annotation layers to frontend format\n        annotations_config = self.annotation_manager.asdict()\n\n        # Step 5: Get trades configuration from TradeManager\n        # Converts TradeData objects to visual elements\n        # Uses trade_visualization options from chart options\n        trades_config = self._trade_manager.to_frontend_config(\n            self.options.trade_visualization if self.options else None\n        )\n\n        # Step 6: Get tooltip configurations from TooltipManager\n        tooltip_configs = None\n        if self._tooltip_manager:\n            # Convert each tooltip config to dictionary\n            tooltip_configs = {}\n            for name, tooltip_config in self._tooltip_manager.configs.items():\n                tooltip_configs[name] = tooltip_config.asdict()\n\n        # Step 7: Generate complete frontend configuration using ChartRenderer\n        # ChartRenderer assembles all components into final configuration\n        config = self._chart_renderer.generate_frontend_config(\n            chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n            chart_options=self.options,\n            series_configs=series_configs,\n            annotations_config=annotations_config,\n            trades_config=trades_config,\n            tooltip_configs=tooltip_configs,\n            chart_group_id=self.chart_group_id,\n            price_scale_config=price_scale_config,\n        )\n\n        # Step 8: Add force_reinit flag if set\n        # This tells frontend to completely rebuild the chart\n        # Used when indicator parameters or other settings change\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Return the complete frontend configuration\n        return config\n\n    def render(self, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Converts the chart to frontend configuration and renders it using the\n        Streamlit component. This is the final step in the chart creation process\n        that displays the interactive chart in the Streamlit application.\n\n        The rendering process follows these steps:\n            1. Generate or validate component key\n            2. Reset config application flag for this render cycle\n            3. Load and apply stored series configurations from session state\n            4. Generate frontend configuration (after configs applied)\n            5. Render component using ChartRenderer\n            6. Handle component response and save updated series configs\n\n        The chart configuration is generated fresh on each render, allowing users\n        to control chart lifecycle and state management in their own code if needed.\n\n        Args:\n            key (Optional[str]): Optional unique key for the Streamlit component.\n                This key is used to identify the component instance and is useful\n                for debugging and component state management. If not provided,\n                a unique key will be generated automatically using timestamp and UUID.\n\n        Returns:\n            Any: The rendered Streamlit component that displays the interactive chart.\n                May contain user interaction data if the frontend sends responses.\n\n        Example:\n            Basic rendering::\n\n                &gt;&gt;&gt; chart.render()\n\n            Rendering with custom key::\n\n                &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n            Method chaining with rendering::\n\n                &gt;&gt;&gt; (chart\n                ...  .add_series(line_series)\n                ...  .update_options(height=600)\n                ...  .render(key=\"chart1\"))\n\n            User-managed state (advanced)::\n\n                &gt;&gt;&gt; # Store chart in session state for persistence\n                &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n                ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Render the persisted chart\n                &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n            Dynamic key generation::\n\n                &gt;&gt;&gt; # Key includes timestamp for uniqueness\n                &gt;&gt;&gt; import time\n                &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n        \"\"\"\n        # STEP 1: Generate a unique key if none provided or if it's invalid\n        if key is None or not isinstance(key, str) or not key.strip():\n            # Create unique identifier using timestamp and UUID\n            unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n            timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n            key = f\"chart_{timestamp}_{unique_id}\"\n\n        # STEP 2: Reset config application flag for this render cycle\n        # This ensures configs are only applied once per render\n        # Prevents duplicate application of stored configurations\n        self._session_state_manager.reset_config_applied_flag()\n\n        # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n        # This is critical: we must apply user-modified configs BEFORE\n        # generating the frontend configuration, otherwise the configs\n        # won't be included in the serialized data\n        stored_configs = self._session_state_manager.load_series_configs(key)\n        if stored_configs:\n            # Apply stored configs to all series\n            # This updates series options with user-modified settings\n            self._session_state_manager.apply_stored_configs_to_series(\n                stored_configs,\n                self.series,  # Current series list\n            )\n\n        # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n        # This ensures the frontend config includes all user modifications\n        # The to_frontend_config() method serializes all chart components\n        config = self.to_frontend_config()\n\n        # STEP 5: Render component using ChartRenderer\n        # ChartRenderer handles:\n        # - Component function retrieval\n        # - Configuration serialization to JSON\n        # - Component rendering through Streamlit\n        # - Error handling if component is unavailable\n        result = self._chart_renderer.render(config, key, self.options)\n\n        # STEP 6: Handle component return value and save series configs\n        # The frontend may send back user interactions or config changes\n        if result:\n            # ChartRenderer processes the response and updates session state\n            # This includes saving any user-modified series configurations\n            self._chart_renderer.handle_response(\n                result,\n                key,\n                self._session_state_manager,\n            )\n\n        # Return the component result\n        # This may contain user interaction data or None\n        return result\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for the series settings dialog.\n\n        Retrieves information about all series in a specific pane. This is\n        used by the series settings dialog to display available series and\n        their current configurations.\n\n        Args:\n            _pane_id: The pane ID to get series info for (default: 0).\n\n        Returns:\n            List of series information dictionaries containing:\n                - series_index: Index of the series\n                - series_type: Type of series (line, candlestick, etc.)\n                - series_name: Display name of the series\n                - current_config: Current series configuration\n\n        Example:\n            Get series info::\n\n                &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n                &gt;&gt;&gt; for info in series_info:\n                ...     print(f\"{info['series_name']}: {info['series_type']}\")\n        \"\"\"\n        # Delegate to SeriesManager which has access to all series data\n        return self._series_manager.get_series_info_for_pane(_pane_id)\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        This method supports conversion from various time formats (datetime,\n        string, timestamp) to UNIX timestamp in seconds.\n\n        Args:\n            time_value: Time value in various formats (datetime, string, int, float).\n\n        Returns:\n            Timestamp in seconds or None if conversion fails.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's conversion logic\n        return self._chart_renderer._convert_time_to_timestamp(time_value)\n\n    def _calculate_data_timespan(self) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Calculates the total time range covered by all series data,\n        which is used for auto-ranging and time scale configuration.\n\n        Returns:\n            Timespan in seconds or None if unable to calculate.\n            None may be returned if:\n                - No series have data\n                - Time values are invalid\n                - Serialization fails\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        try:\n            # Get series configurations which include time data\n            series_configs = self._series_manager.to_frontend_configs()\n\n            # Delegate to ChartRenderer to calculate timespan\n            return self._chart_renderer._calculate_data_timespan(series_configs)\n        except Exception:\n            # Catch any error during serialization or calculation\n            # Return None if unable to calculate (invalid time values, etc.)\n            return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\n\n        Delegates to ChartRenderer for backward compatibility with tests.\n        Converts a range configuration (e.g., {\"days\": 7}) to total seconds.\n\n        Args:\n            range_config: Range configuration dictionary with time units.\n                Example: {\"days\": 7, \"hours\": 12}\n\n        Returns:\n            Number of seconds in the range or None for \"ALL\" range.\n\n        Note:\n            This is an internal method used by ChartRenderer and exposed\n            for backward compatibility with existing tests.\n        \"\"\"\n        # Delegate to ChartRenderer's range calculation logic\n        return self._chart_renderer._get_range_seconds(range_config)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.chart_group_id","title":"chart_group_id  <code>property</code> <code>writable</code>","text":"<pre><code>chart_group_id: int\n</code></pre> <p>Get the chart group ID for synchronization.</p> <p>Returns the current chart group ID used for synchronization.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The chart group ID.</p> Example <p>Get chart group ID::</p> <pre><code>&gt;&gt;&gt; group_id = chart.chart_group_id\n&gt;&gt;&gt; print(f\"Chart is in sync group: {group_id}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.get_stored_series_config","title":"get_stored_series_config","text":"<pre><code>get_stored_series_config(key: str, series_index: int = 0, pane_id: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Get stored configuration for a specific series.</p> <p>Retrieves the stored configuration for a series from session state. This is useful for applying previously saved configurations when creating new series instances, enabling persistence of user customizations across renders.</p> The stored configuration includes user-modified settings like <ul> <li>Colors and styles</li> <li>Line widths and types</li> <li>Visibility settings</li> <li>Other series-specific options</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs. This should match the key used when rendering the chart.</p> required <code>series_index</code> <code>int</code> <p>Index of the series (0-based). Defaults to 0.</p> <code>0</code> <code>pane_id</code> <code>int</code> <p>Pane ID for the series. Defaults to 0. Useful for multi-pane charts where the same series index may exist in different panes.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of stored configuration or empty dict if none found.</p> <code>Dict[str, Any]</code> <p>The dictionary keys match the series option property names.</p> Example <p>Get and apply stored config::</p> <pre><code>&gt;&gt;&gt; # Get stored config for first series\n&gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply to new series\n&gt;&gt;&gt; if config:\n...     line_series = LineSeries(data)\n...     if \"color\" in config:\n...         line_series.line_options.color = config[\"color\"]\n...     if \"lineWidth\" in config:\n...         line_series.line_options.line_width = config[\"lineWidth\"]\n</code></pre> <p>Restore all series configs::</p> <pre><code>&gt;&gt;&gt; for i, series in enumerate(chart.series):\n...     config = chart.get_stored_series_config(\"my_chart\", i)\n...     if config:\n...         apply_config_to_series(series, config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_stored_series_config(\n    self,\n    key: str,\n    series_index: int = 0,\n    pane_id: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get stored configuration for a specific series.\n\n    Retrieves the stored configuration for a series from session state.\n    This is useful for applying previously saved configurations when\n    creating new series instances, enabling persistence of user\n    customizations across renders.\n\n    The stored configuration includes user-modified settings like:\n        - Colors and styles\n        - Line widths and types\n        - Visibility settings\n        - Other series-specific options\n\n    Args:\n        key: Component key used to namespace the stored configs. This should\n            match the key used when rendering the chart.\n        series_index: Index of the series (0-based). Defaults to 0.\n        pane_id: Pane ID for the series. Defaults to 0. Useful for multi-pane\n            charts where the same series index may exist in different panes.\n\n    Returns:\n        Dictionary of stored configuration or empty dict if none found.\n        The dictionary keys match the series option property names.\n\n    Example:\n        Get and apply stored config::\n\n            &gt;&gt;&gt; # Get stored config for first series\n            &gt;&gt;&gt; config = chart.get_stored_series_config(\"my_chart\", series_index=0)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Apply to new series\n            &gt;&gt;&gt; if config:\n            ...     line_series = LineSeries(data)\n            ...     if \"color\" in config:\n            ...         line_series.line_options.color = config[\"color\"]\n            ...     if \"lineWidth\" in config:\n            ...         line_series.line_options.line_width = config[\"lineWidth\"]\n\n        Restore all series configs::\n\n            &gt;&gt;&gt; for i, series in enumerate(chart.series):\n            ...     config = chart.get_stored_series_config(\"my_chart\", i)\n            ...     if config:\n            ...         apply_config_to_series(series, config)\n    \"\"\"\n    # Delegate to SessionStateManager which handles the actual storage\n    # SessionStateManager uses Streamlit's session_state for persistence\n    return self._session_state_manager.get_stored_series_config(\n        key, series_index, pane_id\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_series","title":"add_series","text":"<pre><code>add_series(series: Series) -&gt; Chart\n</code></pre> <p>Add a series to the chart.</p> <p>Adds a new series object to the chart's series list. The series will be displayed according to its type (line, candlestick, area, etc.) and configuration options. The method automatically handles price scale configuration for custom price scale IDs.</p> When a series is added <ol> <li>Series is validated to ensure it's a Series instance</li> <li>SeriesManager adds it to the series list</li> <li>If series has custom price_scale_id, PriceScaleManager is notified</li> <li>Series is assigned a z-index for proper layering</li> </ol> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add to the chart. Must be an instance of a Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Example <p>Add a candlestick series::</p> <pre><code>&gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n</code></pre> <p>Add a line series with custom options::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n&gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n&gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n</code></pre> <p>Add series with custom price scale::</p> <pre><code>&gt;&gt;&gt; # Series with custom price scale ID\n&gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n&gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add overlay price scale configuration\n&gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add the series\n&gt;&gt;&gt; chart.add_series(volume_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_series(self, series: Series) -&gt; \"Chart\":\n    \"\"\"Add a series to the chart.\n\n    Adds a new series object to the chart's series list. The series will be\n    displayed according to its type (line, candlestick, area, etc.) and\n    configuration options. The method automatically handles price scale\n    configuration for custom price scale IDs.\n\n    When a series is added:\n        1. Series is validated to ensure it's a Series instance\n        2. SeriesManager adds it to the series list\n        3. If series has custom price_scale_id, PriceScaleManager is notified\n        4. Series is assigned a z-index for proper layering\n\n    Args:\n        series: Series object to add to the chart. Must be an instance of a\n            Series subclass (LineSeries, CandlestickSeries, AreaSeries, etc.).\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n\n    Example:\n        Add a candlestick series::\n\n            &gt;&gt;&gt; chart.add_series(CandlestickSeries(ohlc_data))\n\n        Add a line series with custom options::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.series import LineOptions\n            &gt;&gt;&gt; line_options = LineOptions(color=\"red\", line_width=2)\n            &gt;&gt;&gt; chart.add_series(LineSeries(data, line_options=line_options))\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_series(line_series).add_series(candlestick_series)\n\n        Add series with custom price scale::\n\n            &gt;&gt;&gt; # Series with custom price scale ID\n            &gt;&gt;&gt; volume_series = HistogramSeries(volume_data)\n            &gt;&gt;&gt; volume_series.price_scale_id = \"volume\"\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add overlay price scale configuration\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", volume_scale_options)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Add the series\n            &gt;&gt;&gt; chart.add_series(volume_series)\n    \"\"\"\n    # Delegate to SeriesManager which handles validation and storage\n    # Also pass PriceScaleManager reference so it can be notified of\n    # custom price scale IDs\n    self._series_manager.add_series(series, self._price_scale_manager)\n\n    # Return self to enable method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.update_options","title":"update_options","text":"<pre><code>update_options(**kwargs) -&gt; Chart\n</code></pre> <p>Update chart options.</p> <p>Updates the chart's configuration options using keyword arguments. Only valid ChartOptions attributes will be updated; invalid attributes are silently ignored to support method chaining and forward compatibility.</p> <p>The method performs type checking to ensure new values match the expected types of the chart options. This prevents runtime errors from invalid configurations.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Chart options to update. Valid options include: - width (Optional[int]): Chart width in pixels - height (int): Chart height in pixels (default: 400) - auto_size (bool): Whether to auto-size the chart - handle_scroll (bool): Whether to enable scroll interactions - handle_scale (bool): Whether to enable scale interactions - add_default_pane (bool): Whether to add a default pane And many more options defined in ChartOptions class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Update basic dimensions::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=600, width=800)\n</code></pre> <p>Update interaction options::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     handle_scroll=True,\n...     handle_scale=False,\n...     auto_size=True\n... )\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n</code></pre> <p>Update multiple options at once::</p> <pre><code>&gt;&gt;&gt; chart.update_options(\n...     height=600,\n...     width=1200,\n...     auto_size=False,\n...     handle_scroll=True\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def update_options(self, **kwargs) -&gt; \"Chart\":\n    \"\"\"Update chart options.\n\n    Updates the chart's configuration options using keyword arguments.\n    Only valid ChartOptions attributes will be updated; invalid attributes\n    are silently ignored to support method chaining and forward compatibility.\n\n    The method performs type checking to ensure new values match the\n    expected types of the chart options. This prevents runtime errors\n    from invalid configurations.\n\n    Args:\n        **kwargs: Chart options to update. Valid options include:\n            - width (Optional[int]): Chart width in pixels\n            - height (int): Chart height in pixels (default: 400)\n            - auto_size (bool): Whether to auto-size the chart\n            - handle_scroll (bool): Whether to enable scroll interactions\n            - handle_scale (bool): Whether to enable scale interactions\n            - add_default_pane (bool): Whether to add a default pane\n            And many more options defined in ChartOptions class.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Update basic dimensions::\n\n            &gt;&gt;&gt; chart.update_options(height=600, width=800)\n\n        Update interaction options::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     handle_scroll=True,\n            ...     handle_scale=False,\n            ...     auto_size=True\n            ... )\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.update_options(height=500).update_options(width=1000)\n\n        Update multiple options at once::\n\n            &gt;&gt;&gt; chart.update_options(\n            ...     height=600,\n            ...     width=1200,\n            ...     auto_size=False,\n            ...     handle_scroll=True\n            ... )\n    \"\"\"\n    # Process each keyword argument to update chart options\n    for key, value in kwargs.items():\n        # Step 1: Validate the option exists and value is not None\n        # Check that the attribute exists on ChartOptions instance\n        # and that the new value is not None (None values are ignored)\n        if value is not None and hasattr(self.options, key):\n            # Step 2: Get current attribute value for type checking\n            # This helps ensure type consistency\n            current_value = getattr(self.options, key)\n\n            # Step 3: Validate type compatibility\n            # Allow update if:\n            # - New value type matches current value type, OR\n            # - Current value is None and new value is not None\n            #   (allows setting previously unset options)\n            if isinstance(value, type(current_value)) or (\n                current_value is None and value is not None\n            ):\n                # Update the attribute with the validated value\n                setattr(self.options, key, value)\n\n        # Note: Invalid attributes and None values are silently ignored\n        # This enables method chaining and forward compatibility\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add an annotation to the chart.</p> <p>Adds a single annotation to the specified annotation layer. If the layer doesn't exist, it will be created automatically. Annotations are visual elements like text, arrows, shapes, and lines that provide additional information or highlight specific points on the chart.</p> Annotations are organized into layers for better management <ul> <li>Each layer can contain multiple annotations</li> <li>Layers can be shown/hidden independently</li> <li>Layers can be cleared without affecting other layers</li> <li>Default layer is used if no layer name is specified</li> </ul> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the chart. Must be a valid Annotation instance with proper configuration.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". Layer will be created if it doesn't exist.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If annotation is None or layer_name is invalid.</p> <code>TypeValidationError</code> <p>If annotation is not an Annotation instance.</p> Example <p>Add text annotation::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n...     create_text_annotation\n... )\n&gt;&gt;&gt; text_ann = create_text_annotation(\n...     \"2024-01-01\", 100, \"Important Event\"\n... )\n&gt;&gt;&gt; chart.add_annotation(text_ann)\n</code></pre> <p>Add annotation to custom layer::</p> <pre><code>&gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n&gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n</code></pre> <p>Organize annotations by layer::</p> <pre><code>&gt;&gt;&gt; # Technical analysis annotations\n&gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n&gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Trading signals\n&gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n&gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotation(\n    self, annotation: Annotation, layer_name: str = \"default\"\n) -&gt; \"Chart\":\n    \"\"\"Add an annotation to the chart.\n\n    Adds a single annotation to the specified annotation layer. If the layer\n    doesn't exist, it will be created automatically. Annotations are visual\n    elements like text, arrows, shapes, and lines that provide additional\n    information or highlight specific points on the chart.\n\n    Annotations are organized into layers for better management:\n        - Each layer can contain multiple annotations\n        - Layers can be shown/hidden independently\n        - Layers can be cleared without affecting other layers\n        - Default layer is used if no layer name is specified\n\n    Args:\n        annotation (Annotation): Annotation object to add to the chart.\n            Must be a valid Annotation instance with proper configuration.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". Layer will be created if it doesn't exist.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If annotation is None or layer_name is invalid.\n        TypeValidationError: If annotation is not an Annotation instance.\n\n    Example:\n        Add text annotation::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.annotation import (\n            ...     create_text_annotation\n            ... )\n            &gt;&gt;&gt; text_ann = create_text_annotation(\n            ...     \"2024-01-01\", 100, \"Important Event\"\n            ... )\n            &gt;&gt;&gt; chart.add_annotation(text_ann)\n\n        Add annotation to custom layer::\n\n            &gt;&gt;&gt; arrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Signal\")\n            &gt;&gt;&gt; chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; chart.add_annotation(text_ann).add_annotation(arrow_ann)\n\n        Organize annotations by layer::\n\n            &gt;&gt;&gt; # Technical analysis annotations\n            &gt;&gt;&gt; chart.add_annotation(support_line, layer_name=\"ta\")\n            &gt;&gt;&gt; chart.add_annotation(resistance_line, layer_name=\"ta\")\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Trading signals\n            &gt;&gt;&gt; chart.add_annotation(buy_signal, layer_name=\"signals\")\n            &gt;&gt;&gt; chart.add_annotation(sell_signal, layer_name=\"signals\")\n    \"\"\"\n    # Step 1: Validate annotation is not None\n    if annotation is None:\n        raise ValueValidationError(\"annotation\", \"cannot be None\")\n\n    # Step 2: Validate annotation is an Annotation instance\n    if not isinstance(annotation, Annotation):\n        raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n    # Step 3: Handle layer name validation\n    # Use default layer name if None is provided\n    if layer_name is None:\n        layer_name = \"default\"\n    # Validate layer_name is a non-empty string\n    elif not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Add annotation to the specified layer\n    # AnnotationManager will create the layer if it doesn't exist\n    self.annotation_manager.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_annotations","title":"add_annotations","text":"<pre><code>add_annotations(annotations: List[Annotation], layer_name: str = 'default') -&gt; Chart\n</code></pre> <p>Add multiple annotations to the chart.</p> <p>Adds multiple annotation objects to the specified annotation layer. This is more efficient than calling add_annotation multiple times as it processes all annotations in a single operation and provides better performance for bulk annotation operations.</p> <p>All annotations are added to the same layer, enabling consistent management (show/hide/clear) of related annotations.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects to add to the chart. All must be valid Annotation instances.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\". All annotations will be added to this layer.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If annotations is not a list.</p> <code>ValueValidationError</code> <p>If layer_name is invalid.</p> <code>AnnotationItemsTypeError</code> <p>If any item in annotations is not an Annotation instance.</p> Example <p>Add multiple annotations at once::</p> <pre><code>&gt;&gt;&gt; annotations = [\n...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n... ]\n&gt;&gt;&gt; chart.add_annotations(annotations)\n</code></pre> <p>Add to custom layer::</p> <pre><code>&gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n&gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n</code></pre> <p>Bulk operations with method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_annotations(ta_annotations, layer_name=\"ta\")\n...  .add_annotations(signal_annotations, layer_name=\"signals\")\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotations(\n    self,\n    annotations: List[Annotation],\n    layer_name: str = \"default\",\n) -&gt; \"Chart\":\n    \"\"\"Add multiple annotations to the chart.\n\n    Adds multiple annotation objects to the specified annotation layer. This\n    is more efficient than calling add_annotation multiple times as it\n    processes all annotations in a single operation and provides better\n    performance for bulk annotation operations.\n\n    All annotations are added to the same layer, enabling consistent\n    management (show/hide/clear) of related annotations.\n\n    Args:\n        annotations (List[Annotation]): List of annotation objects to add\n            to the chart. All must be valid Annotation instances.\n        layer_name (str, optional): Name of the annotation layer. Defaults\n            to \"default\". All annotations will be added to this layer.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If annotations is not a list.\n        ValueValidationError: If layer_name is invalid.\n        AnnotationItemsTypeError: If any item in annotations is not an\n            Annotation instance.\n\n    Example:\n        Add multiple annotations at once::\n\n            &gt;&gt;&gt; annotations = [\n            ...     create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n            ...     create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n            ...     create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n            ... ]\n            &gt;&gt;&gt; chart.add_annotations(annotations)\n\n        Add to custom layer::\n\n            &gt;&gt;&gt; analysis_annotations = [support_line, resistance_line, trend_line]\n            &gt;&gt;&gt; chart.add_annotations(analysis_annotations, layer_name=\"analysis\")\n\n        Bulk operations with method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_annotations(ta_annotations, layer_name=\"ta\")\n            ...  .add_annotations(signal_annotations, layer_name=\"signals\")\n            ...  .update_options(height=600))\n    \"\"\"\n    # Step 1: Validate annotations is not None\n    if annotations is None:\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 2: Validate annotations is a list\n    if not isinstance(annotations, list):\n        raise TypeValidationError(\"annotations\", \"list\")\n\n    # Step 3: Validate layer_name\n    if not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    # Step 4: Validate and add each annotation\n    for annotation in annotations:\n        # Ensure each item is an Annotation instance\n        if not isinstance(annotation, Annotation):\n            raise AnnotationItemsTypeError()\n\n        # Add the annotation to the specified layer\n        # Reuses add_annotation logic for consistency\n        self.add_annotation(annotation, layer_name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.create_annotation_layer","title":"create_annotation_layer","text":"<pre><code>create_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new annotation layer with the specified name. Annotation layers allow you to organize and manage groups of annotations independently. Each layer can be shown, hidden, or cleared separately, providing flexible control over annotation visibility.</p> Common use cases for layers <ul> <li>Separate technical analysis from trading signals</li> <li>Organize annotations by timeframe or strategy</li> <li>Group annotations by type (text, arrows, shapes)</li> <li>Enable/disable different annotation sets dynamically</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to create. Must be a non-empty string and should be unique.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If name is None.</p> <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Create custom layers for different types of annotations::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .create_annotation_layer(\"layer1\")\n...  .create_annotation_layer(\"layer2\")\n...  .add_annotation(ann1, \"layer1\")\n...  .add_annotation(ann2, \"layer2\"))\n</code></pre> <p>Organize by strategy::</p> <pre><code>&gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n&gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n&gt;&gt;&gt; # Add annotations specific to each strategy\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new annotation layer with the specified name. Annotation layers\n    allow you to organize and manage groups of annotations independently.\n    Each layer can be shown, hidden, or cleared separately, providing\n    flexible control over annotation visibility.\n\n    Common use cases for layers:\n        - Separate technical analysis from trading signals\n        - Organize annotations by timeframe or strategy\n        - Group annotations by type (text, arrows, shapes)\n        - Enable/disable different annotation sets dynamically\n\n    Args:\n        name (str): Name of the annotation layer to create. Must be a\n            non-empty string and should be unique.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If name is None.\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Create custom layers for different types of annotations::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"signals\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"events\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .create_annotation_layer(\"layer1\")\n            ...  .create_annotation_layer(\"layer2\")\n            ...  .add_annotation(ann1, \"layer1\")\n            ...  .add_annotation(ann2, \"layer2\"))\n\n        Organize by strategy::\n\n            &gt;&gt;&gt; chart.create_annotation_layer(\"momentum_strategy\")\n            &gt;&gt;&gt; chart.create_annotation_layer(\"mean_reversion_strategy\")\n            &gt;&gt;&gt; # Add annotations specific to each strategy\n    \"\"\"\n    # Step 1: Validate name is not None\n    if name is None:\n        raise TypeValidationError(\"name\", \"string\")\n\n    # Step 2: Validate name is a non-empty string\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 3: Create the layer in AnnotationManager\n    # If layer already exists, this operation is idempotent\n    self.annotation_manager.create_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.hide_annotation_layer","title":"hide_annotation_layer","text":"<pre><code>hide_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Hide an annotation layer.</p> <p>Hides the specified annotation layer, making all annotations in that layer invisible on the chart. The layer and its annotations are preserved and can be shown again using show_annotation_layer. This is useful for temporarily hiding certain annotation groups without removing them.</p> Hidden layers <ul> <li>Remain in memory with all annotations intact</li> <li>Can be shown again without re-adding annotations</li> <li>Don't affect other layers' visibility</li> <li>Are persisted across chart updates</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to hide.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Hide specific layers::</p> <pre><code>&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .hide_annotation_layer(\"layer1\")\n...  .hide_annotation_layer(\"layer2\")\n...  .show_annotation_layer(\"layer3\"))\n</code></pre> <p>Toggle layer visibility::</p> <pre><code>&gt;&gt;&gt; # Hide analysis layer temporarily\n&gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n&gt;&gt;&gt; # ... show chart without analysis\n&gt;&gt;&gt; # Show analysis layer again\n&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Hide an annotation layer.\n\n    Hides the specified annotation layer, making all annotations in that\n    layer invisible on the chart. The layer and its annotations are preserved\n    and can be shown again using show_annotation_layer. This is useful for\n    temporarily hiding certain annotation groups without removing them.\n\n    Hidden layers:\n        - Remain in memory with all annotations intact\n        - Can be shown again without re-adding annotations\n        - Don't affect other layers' visibility\n        - Are persisted across chart updates\n\n    Args:\n        name (str): Name of the annotation layer to hide.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Hide specific layers::\n\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .hide_annotation_layer(\"layer1\")\n            ...  .hide_annotation_layer(\"layer2\")\n            ...  .show_annotation_layer(\"layer3\"))\n\n        Toggle layer visibility::\n\n            &gt;&gt;&gt; # Hide analysis layer temporarily\n            &gt;&gt;&gt; chart.hide_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; # ... show chart without analysis\n            &gt;&gt;&gt; # Show analysis layer again\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Hide the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.hide_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.show_annotation_layer","title":"show_annotation_layer","text":"<pre><code>show_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Show an annotation layer.</p> <p>Makes the specified annotation layer visible on the chart. This will display all annotations that were previously added to this layer. If the layer doesn't exist or is already visible, this method will have no effect.</p> <p>This is the counterpart to hide_annotation_layer and enables dynamic control over which annotation groups are visible.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to show.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If name is empty or not a string.</p> Example <p>Show specific layers::</p> <pre><code>&gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n&gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .show_annotation_layer(\"layer1\")\n...  .show_annotation_layer(\"layer2\")\n...  .hide_annotation_layer(\"layer3\"))\n</code></pre> <p>Conditional visibility::</p> <pre><code>&gt;&gt;&gt; # Show different layers based on user selection\n&gt;&gt;&gt; if show_technical_analysis:\n...     chart.show_annotation_layer(\"ta\")\n&gt;&gt;&gt; if show_trading_signals:\n...     chart.show_annotation_layer(\"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Show an annotation layer.\n\n    Makes the specified annotation layer visible on the chart. This will\n    display all annotations that were previously added to this layer.\n    If the layer doesn't exist or is already visible, this method will\n    have no effect.\n\n    This is the counterpart to hide_annotation_layer and enables dynamic\n    control over which annotation groups are visible.\n\n    Args:\n        name (str): Name of the annotation layer to show.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If name is empty or not a string.\n\n    Example:\n        Show specific layers::\n\n            &gt;&gt;&gt; chart.show_annotation_layer(\"analysis\")\n            &gt;&gt;&gt; chart.show_annotation_layer(\"signals\")\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .show_annotation_layer(\"layer1\")\n            ...  .show_annotation_layer(\"layer2\")\n            ...  .hide_annotation_layer(\"layer3\"))\n\n        Conditional visibility::\n\n            &gt;&gt;&gt; # Show different layers based on user selection\n            &gt;&gt;&gt; if show_technical_analysis:\n            ...     chart.show_annotation_layer(\"ta\")\n            &gt;&gt;&gt; if show_trading_signals:\n            ...     chart.show_annotation_layer(\"signals\")\n    \"\"\"\n    # Step 1: Validate layer name\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n\n    # Step 2: Show the layer through AnnotationManager\n    # If layer doesn't exist, this operation has no effect\n    self.annotation_manager.show_layer(name)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations(layer_name: Optional[str] = None) -&gt; Chart\n</code></pre> <p>Clear annotations from the chart.</p> <p>Removes all annotations from the specified layer or from all layers if no layer name is provided. The layer itself is preserved and can be reused for new annotations. This is useful for refreshing annotations without recreating the entire chart.</p> Clearing behavior <ul> <li>With layer_name: Clears only that specific layer</li> <li>Without layer_name: Does nothing (for backward compatibility)</li> <li>Layer structure is preserved (can add new annotations)</li> <li>Does not affect hidden/shown state of layers</li> </ul> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>Optional[str]</code> <p>Name of the layer to clear. If None, no action is taken. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If layer_name is not None and invalid.</p> Example <p>Clear specific layer::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n</code></pre> <p>Clear all layers (provide None)::</p> <pre><code>&gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .clear_annotations(\"layer1\")\n...  .add_annotation(new_annotation, \"layer1\"))\n</code></pre> <p>Refresh annotations::</p> <pre><code>&gt;&gt;&gt; # Clear old annotations and add new ones\n&gt;&gt;&gt; chart.clear_annotations(\"signals\")\n&gt;&gt;&gt; for signal in new_signals:\n...     chart.add_annotation(signal, \"signals\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n    \"\"\"Clear annotations from the chart.\n\n    Removes all annotations from the specified layer or from all layers if\n    no layer name is provided. The layer itself is preserved and can be\n    reused for new annotations. This is useful for refreshing annotations\n    without recreating the entire chart.\n\n    Clearing behavior:\n        - With layer_name: Clears only that specific layer\n        - Without layer_name: Does nothing (for backward compatibility)\n        - Layer structure is preserved (can add new annotations)\n        - Does not affect hidden/shown state of layers\n\n    Args:\n        layer_name (Optional[str]): Name of the layer to clear. If None,\n            no action is taken. Defaults to None.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        ValueValidationError: If layer_name is not None and invalid.\n\n    Example:\n        Clear specific layer::\n\n            &gt;&gt;&gt; chart.clear_annotations(\"analysis\")\n\n        Clear all layers (provide None)::\n\n            &gt;&gt;&gt; chart.clear_annotations()  # No-op for backward compatibility\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .clear_annotations(\"layer1\")\n            ...  .add_annotation(new_annotation, \"layer1\"))\n\n        Refresh annotations::\n\n            &gt;&gt;&gt; # Clear old annotations and add new ones\n            &gt;&gt;&gt; chart.clear_annotations(\"signals\")\n            &gt;&gt;&gt; for signal in new_signals:\n            ...     chart.add_annotation(signal, \"signals\")\n    \"\"\"\n    # Step 1: Validate layer_name if provided\n    if layer_name is not None and (\n        not layer_name or not isinstance(layer_name, str)\n    ):\n        raise ValueValidationError(\n            \"layer_name\", \"must be None or a non-empty string\"\n        )\n\n    # Step 2: Clear the specified layer\n    if layer_name is not None:\n        # Clear only the specified layer through AnnotationManager\n        self.annotation_manager.clear_layer(layer_name)\n\n    # Note: If layer_name is None, no action is taken\n    # This maintains backward compatibility with existing code\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_overlay_price_scale","title":"add_overlay_price_scale","text":"<pre><code>add_overlay_price_scale(scale_id: str, options: PriceScaleOptions) -&gt; Chart\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Adds or updates an overlay price scale configuration for the chart. Overlay price scales allow multiple series to share the same price axis while maintaining independent scaling and positioning. This is commonly used for volume bars, indicators, and other overlays.</p> Overlay price scales enable <ul> <li>Independent vertical positioning (scale margins)</li> <li>Separate auto-scaling behavior</li> <li>Different visibility settings</li> <li>Custom formatting and precision</li> </ul> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced by series that use this price scale.</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration for the overlay price scale.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>PriceScaleIdTypeError</code> <p>If scale_id is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If options is not a PriceScaleOptions instance.</p> Example <p>Add volume overlay price scale::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n...     PriceScaleOptions\n... )\n&gt;&gt;&gt; volume_scale = PriceScaleOptions(\n...     visible=False,  # Hide the price scale itself\n...     scale_margin_top=0.8,  # Volume takes bottom 20%\n...     scale_margin_bottom=0,\n...     overlay=True,  # Mark as overlay\n...     auto_scale=True  # Auto-scale to data\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n</code></pre> <p>Add indicator overlay::</p> <pre><code>&gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n...     visible=True,\n...     scale_margin_top=0.7,\n...     scale_margin_bottom=0.1,\n...     overlay=True\n... )\n&gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_overlay_price_scale('volume', volume_scale)\n...  .add_series(volume_series))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_overlay_price_scale(\n    self, scale_id: str, options: \"PriceScaleOptions\"\n) -&gt; \"Chart\":\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Adds or updates an overlay price scale configuration for the chart.\n    Overlay price scales allow multiple series to share the same price axis\n    while maintaining independent scaling and positioning. This is commonly\n    used for volume bars, indicators, and other overlays.\n\n    Overlay price scales enable:\n        - Independent vertical positioning (scale margins)\n        - Separate auto-scaling behavior\n        - Different visibility settings\n        - Custom formatting and precision\n\n    Args:\n        scale_id (str): The unique identifier for the custom price scale\n            (e.g., 'volume', 'indicator1', 'overlay'). This ID is referenced\n            by series that use this price scale.\n        options (PriceScaleOptions): A PriceScaleOptions instance containing\n            the configuration for the overlay price scale.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        PriceScaleIdTypeError: If scale_id is not a string.\n        PriceScaleOptionsTypeError: If options is not a PriceScaleOptions instance.\n\n    Example:\n        Add volume overlay price scale::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.charts.options import (\n            ...     PriceScaleOptions\n            ... )\n            &gt;&gt;&gt; volume_scale = PriceScaleOptions(\n            ...     visible=False,  # Hide the price scale itself\n            ...     scale_margin_top=0.8,  # Volume takes bottom 20%\n            ...     scale_margin_bottom=0,\n            ...     overlay=True,  # Mark as overlay\n            ...     auto_scale=True  # Auto-scale to data\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('volume', volume_scale)\n\n        Add indicator overlay::\n\n            &gt;&gt;&gt; indicator_scale = PriceScaleOptions(\n            ...     visible=True,\n            ...     scale_margin_top=0.7,\n            ...     scale_margin_bottom=0.1,\n            ...     overlay=True\n            ... )\n            &gt;&gt;&gt; chart.add_overlay_price_scale('rsi', indicator_scale)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_overlay_price_scale('volume', volume_scale)\n            ...  .add_series(volume_series))\n    \"\"\"\n    # Step 1: Add overlay scale through PriceScaleManager\n    # Manager validates scale_id and options internally\n    self._price_scale_manager.add_overlay_scale(scale_id, options)\n\n    # Step 2: Sync back to options for backward compatibility\n    # This ensures options.overlay_price_scales is updated\n    # Some legacy code may access overlay scales directly from options\n    self.options.overlay_price_scales[scale_id] = options\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series to the chart from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale positioned at the bottom of the chart.</p> This is a convenience method that <ol> <li>Configures the volume overlay price scale</li> <li>Creates price series (candlestick or line)</li> <li>Creates volume histogram series</li> <li>Adds both series to the chart</li> </ol> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information. Can be a sequence of OhlcvData objects or a pandas DataFrame.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\". Defaults to None (assumes standard column names).</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series to create. Options: \"candlestick\" or \"line\". Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration (colors, line width, etc.). Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration (colors, transparency, etc.). Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0. Used in multi-pane charts.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If data type is invalid.</p> <code>ValueError</code> <p>If column_mapping is invalid or required columns are missing.</p> Example <p>Add candlestick with volume::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n...     price_type=\"candlestick\"\n... )\n</code></pre> <p>Add line chart with custom volume colors::</p> <pre><code>&gt;&gt;&gt; chart.add_price_volume_series(\n...     ohlcv_data,\n...     price_type=\"line\",\n...     volume_kwargs={\n...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n...     }\n... )\n</code></pre> <p>From DataFrame::</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'timestamp': [...],\n...     'o': [...],\n...     'h': [...],\n...     'l': [...],\n...     'c': [...],\n...     'v': [...]\n... })\n&gt;&gt;&gt; chart.add_price_volume_series(\n...     df,\n...     column_mapping={\n...         \"time\": \"timestamp\",\n...         \"open\": \"o\",\n...         \"high\": \"h\",\n...         \"low\": \"l\",\n...         \"close\": \"c\",\n...         \"volume\": \"v\"\n...     }\n... )\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series to the chart from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale positioned at the\n    bottom of the chart.\n\n    This is a convenience method that:\n        1. Configures the volume overlay price scale\n        2. Creates price series (candlestick or line)\n        3. Creates volume histogram series\n        4. Adds both series to the chart\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information. Can be a sequence of OhlcvData objects\n            or a pandas DataFrame.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Keys: \"time\", \"open\", \"high\", \"low\", \"close\", \"volume\".\n            Defaults to None (assumes standard column names).\n        price_type (str, optional): Type of price series to create. Options:\n            \"candlestick\" or \"line\". Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration (colors, line width, etc.). Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration (colors, transparency, etc.). Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0. Used in multi-pane charts.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If data type is invalid.\n        ValueError: If column_mapping is invalid or required columns are missing.\n\n    Example:\n        Add candlestick with volume::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n            ...     price_type=\"candlestick\"\n            ... )\n\n        Add line chart with custom volume colors::\n\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     ohlcv_data,\n            ...     price_type=\"line\",\n            ...     volume_kwargs={\n            ...         \"up_color\": \"rgba(0, 255, 0, 0.3)\",\n            ...         \"down_color\": \"rgba(255, 0, 0, 0.3)\"\n            ...     }\n            ... )\n\n        From DataFrame::\n\n            &gt;&gt;&gt; df = pd.DataFrame({\n            ...     'timestamp': [...],\n            ...     'o': [...],\n            ...     'h': [...],\n            ...     'l': [...],\n            ...     'c': [...],\n            ...     'v': [...]\n            ... })\n            &gt;&gt;&gt; chart.add_price_volume_series(\n            ...     df,\n            ...     column_mapping={\n            ...         \"time\": \"timestamp\",\n            ...         \"open\": \"o\",\n            ...         \"high\": \"h\",\n            ...         \"low\": \"l\",\n            ...         \"close\": \"c\",\n            ...         \"volume\": \"v\"\n            ...     }\n            ... )\n    \"\"\"\n    # Step 1: Configure price scale manager for volume visualization\n    # This sets up the overlay price scale with proper margins\n    # Volume typically occupies the bottom 20% of the chart\n    self._price_scale_manager.configure_for_volume()\n\n    # Step 2: Delegate to series manager for actual series creation\n    # SeriesManager handles:\n    # - Data conversion (DataFrame to OhlcvData if needed)\n    # - Price series creation (candlestick or line)\n    # - Volume histogram series creation\n    # - Series configuration from kwargs\n    # - Adding both series to the chart\n    self._series_manager.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n        price_scale_manager=self._price_scale_manager,\n    )\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; Chart\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements and adds them to the chart for visualization. Each trade is displayed with entry/exit markers, connecting lines, profit/loss rectangles, or zones based on the TradeVisualizationOptions.style configuration.</p> Trade visualization styles <ul> <li>\"markers\": Entry and exit markers only</li> <li>\"rectangle\": Filled rectangle between entry and exit</li> <li>\"line\": Simple line connecting entry to exit</li> <li>\"arrow\": Arrow from entry to exit</li> <li>\"zone\": Highlighted zone with transparency</li> </ul> The visualization automatically color-codes trades <ul> <li>Green/profit color for winning trades</li> <li>Red/loss color for losing trades</li> <li>Customizable through TradeVisualizationOptions</li> </ul> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart. Each trade must have entry_time, entry_price, exit_time, exit_price, and trade_type.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <p>Add basic trade visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n&gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n...     TradeType\n... )\n&gt;&gt;&gt; trades = [\n...     TradeData(\n...         entry_time=\"2024-01-01 10:00:00\",\n...         entry_price=100.0,\n...         exit_time=\"2024-01-01 15:00:00\",\n...         exit_price=105.0,\n...         quantity=100,\n...         trade_type=TradeType.LONG,\n...     )\n... ]\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>With custom visualization::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n...     TradeVisualizationOptions\n... )\n&gt;&gt;&gt; # Configure trade visualization\n&gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n...     style=\"rectangle\",\n...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n... )\n&gt;&gt;&gt; chart.add_trades(trades)\n</code></pre> <p>Method chaining::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_trades(trades)\n...  .update_options(height=600))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements and adds them to the chart\n    for visualization. Each trade is displayed with entry/exit markers,\n    connecting lines, profit/loss rectangles, or zones based on the\n    TradeVisualizationOptions.style configuration.\n\n    Trade visualization styles:\n        - \"markers\": Entry and exit markers only\n        - \"rectangle\": Filled rectangle between entry and exit\n        - \"line\": Simple line connecting entry to exit\n        - \"arrow\": Arrow from entry to exit\n        - \"zone\": Highlighted zone with transparency\n\n    The visualization automatically color-codes trades:\n        - Green/profit color for winning trades\n        - Red/loss color for losing trades\n        - Customizable through TradeVisualizationOptions\n\n    Args:\n        trades (List[TradeData]): List of TradeData objects to visualize\n            on the chart. Each trade must have entry_time, entry_price,\n            exit_time, exit_price, and trade_type.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        Add basic trade visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data import TradeData\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            ...     TradeType\n            ... )\n            &gt;&gt;&gt; trades = [\n            ...     TradeData(\n            ...         entry_time=\"2024-01-01 10:00:00\",\n            ...         entry_price=100.0,\n            ...         exit_time=\"2024-01-01 15:00:00\",\n            ...         exit_price=105.0,\n            ...         quantity=100,\n            ...         trade_type=TradeType.LONG,\n            ...     )\n            ... ]\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        With custom visualization::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.trade import (\n            ...     TradeVisualizationOptions\n            ... )\n            &gt;&gt;&gt; # Configure trade visualization\n            &gt;&gt;&gt; chart.options.trade_visualization = TradeVisualizationOptions(\n            ...     style=\"rectangle\",\n            ...     profit_color=\"rgba(0, 255, 0, 0.2)\",\n            ...     loss_color=\"rgba(255, 0, 0, 0.2)\"\n            ... )\n            &gt;&gt;&gt; chart.add_trades(trades)\n\n        Method chaining::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_trades(trades)\n            ...  .update_options(height=600))\n    \"\"\"\n    # Delegate to TradeManager which handles:\n    # - Trade validation\n    # - Conversion to visual elements (markers, rectangles, etc.)\n    # - Profit/loss calculations\n    # - Color coding based on trade outcome\n    # - Annotation creation for visualization\n    self._trade_manager.add_trades(trades)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.set_tooltip_manager","title":"set_tooltip_manager","text":"<pre><code>set_tooltip_manager(tooltip_manager) -&gt; Chart\n</code></pre> <p>Set the tooltip manager for the chart.</p> <p>Assigns a TooltipManager instance to handle custom tooltip functionality. Tooltips provide additional information when hovering over chart elements.</p> <p>Parameters:</p> Name Type Description Default <code>tooltip_manager</code> <p>TooltipManager instance to handle tooltip functionality.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If tooltip_manager is not a TooltipManager instance.</p> Example <p>Set custom tooltip manager::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipManager\n... )\n&gt;&gt;&gt; manager = TooltipManager()\n&gt;&gt;&gt; chart.set_tooltip_manager(manager)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n    \"\"\"Set the tooltip manager for the chart.\n\n    Assigns a TooltipManager instance to handle custom tooltip functionality.\n    Tooltips provide additional information when hovering over chart elements.\n\n    Args:\n        tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If tooltip_manager is not a TooltipManager instance.\n\n    Example:\n        Set custom tooltip manager::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipManager\n            ... )\n            &gt;&gt;&gt; manager = TooltipManager()\n            &gt;&gt;&gt; chart.set_tooltip_manager(manager)\n    \"\"\"\n    # Validate tooltip_manager is a TooltipManager instance\n    if not isinstance(tooltip_manager, TooltipManager):\n        raise TypeValidationError(\n            \"tooltip_manager\", \"TooltipManager instance\"\n        )\n\n    # Assign the tooltip manager\n    self._tooltip_manager = tooltip_manager\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_tooltip_config","title":"add_tooltip_config","text":"<pre><code>add_tooltip_config(name: str, config) -&gt; Chart\n</code></pre> <p>Add a tooltip configuration to the chart.</p> <p>Adds a named tooltip configuration that defines how tooltips should be displayed for specific data points or series. Multiple tooltip configurations can be registered and used selectively.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the tooltip configuration (unique identifier).</p> required <code>config</code> <p>TooltipConfig instance defining tooltip appearance and behavior.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If config is not a TooltipConfig instance.</p> Example <p>Add custom tooltip configuration::</p> <pre><code>&gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n...     TooltipConfig\n... )\n&gt;&gt;&gt; config = TooltipConfig(\n...     title=\"Price Info\",\n...     show_time=True,\n...     show_value=True\n... )\n&gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n    \"\"\"Add a tooltip configuration to the chart.\n\n    Adds a named tooltip configuration that defines how tooltips should\n    be displayed for specific data points or series. Multiple tooltip\n    configurations can be registered and used selectively.\n\n    Args:\n        name: Name for the tooltip configuration (unique identifier).\n        config: TooltipConfig instance defining tooltip appearance and behavior.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If config is not a TooltipConfig instance.\n\n    Example:\n        Add custom tooltip configuration::\n\n            &gt;&gt;&gt; from streamlit_lightweight_charts_pro.data.tooltip import (\n            ...     TooltipConfig\n            ... )\n            &gt;&gt;&gt; config = TooltipConfig(\n            ...     title=\"Price Info\",\n            ...     show_time=True,\n            ...     show_value=True\n            ... )\n            &gt;&gt;&gt; chart.add_tooltip_config(\"price_tooltip\", config)\n    \"\"\"\n    # Validate config is a TooltipConfig instance\n    if not isinstance(config, TooltipConfig):\n        raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n    # Lazy-load tooltip manager if not already set\n    # This avoids creating TooltipManager until actually needed\n    if self._tooltip_manager is None:\n        self._tooltip_manager = TooltipManager()\n\n    # Add the configuration to the tooltip manager\n    self._tooltip_manager.add_config(name, config)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.set_chart_group_id","title":"set_chart_group_id","text":"<pre><code>set_chart_group_id(group_id: int) -&gt; Chart\n</code></pre> <p>Set the chart group ID for synchronization.</p> <p>Sets the chart group ID which is used for synchronizing multiple charts. Charts with the same group_id will be synchronized with each other, sharing crosshair position and time range changes.</p> Note <p>This is different from ChartManager's sync_group which manages synchronization at a higher level. chart_group_id is used for individual chart synchronization, while sync_group is used for managing groups of charts in ChartManager.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>int</code> <p>Group ID for synchronization. Charts with the same group_id will be synchronized.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If group_id is not an integer.</p> Example <p>Set chart group ID::</p> <pre><code>&gt;&gt;&gt; chart1.set_chart_group_id(1)\n&gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n</code></pre> <p>Disable synchronization::</p> <pre><code>&gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n    \"\"\"Set the chart group ID for synchronization.\n\n    Sets the chart group ID which is used for synchronizing multiple charts.\n    Charts with the same group_id will be synchronized with each other,\n    sharing crosshair position and time range changes.\n\n    Note:\n        This is different from ChartManager's sync_group which manages\n        synchronization at a higher level. chart_group_id is used for\n        individual chart synchronization, while sync_group is used for\n        managing groups of charts in ChartManager.\n\n    Args:\n        group_id (int): Group ID for synchronization. Charts with the same\n            group_id will be synchronized.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If group_id is not an integer.\n\n    Example:\n        Set chart group ID::\n\n            &gt;&gt;&gt; chart1.set_chart_group_id(1)\n            &gt;&gt;&gt; chart2.set_chart_group_id(1)  # Will sync with chart1\n\n        Disable synchronization::\n\n            &gt;&gt;&gt; chart.set_chart_group_id(0)  # Group 0 = no sync\n    \"\"\"\n    # Use property setter which includes validation\n    self.chart_group_id = group_id\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert chart to frontend configuration dictionary.</p> <p>Converts the chart and all its components (series, options, annotations, trades, tooltips) to a dictionary format suitable for frontend consumption. This method orchestrates the serialization of all chart elements.</p> The serialization process <ol> <li>Get series configurations from SeriesManager</li> <li>Get base chart options</li> <li>Get price scale configuration from PriceScaleManager</li> <li>Get annotations configuration from AnnotationManager</li> <li>Get trades configuration from TradeManager</li> <li>Get tooltip configurations from TooltipManager (if set)</li> <li>Generate complete frontend config using ChartRenderer</li> <li>Add force_reinit flag if set</li> </ol> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Complete chart configuration ready for frontend rendering. The configuration includes: - charts: List of chart objects with series and options - syncConfig: Synchronization settings for multi-chart layouts - annotations: Annotation layers and elements - trades: Trade visualization elements - tooltips: Custom tooltip configurations</p> Note <p>Series are automatically ordered by z-index within each pane to ensure proper layering in the frontend. Series with lower z-index values render behind series with higher z-index values.</p> Example <p>Get frontend configuration::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; print(json.dumps(config, indent=2))\n</code></pre> <p>Access specific parts::</p> <pre><code>&gt;&gt;&gt; config = chart.to_frontend_config()\n&gt;&gt;&gt; chart_config = config[\"charts\"][0]\n&gt;&gt;&gt; series_config = chart_config[\"series\"]\n&gt;&gt;&gt; options_config = chart_config[\"chart\"]\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert chart to frontend configuration dictionary.\n\n    Converts the chart and all its components (series, options, annotations,\n    trades, tooltips) to a dictionary format suitable for frontend consumption.\n    This method orchestrates the serialization of all chart elements.\n\n    The serialization process:\n        1. Get series configurations from SeriesManager\n        2. Get base chart options\n        3. Get price scale configuration from PriceScaleManager\n        4. Get annotations configuration from AnnotationManager\n        5. Get trades configuration from TradeManager\n        6. Get tooltip configurations from TooltipManager (if set)\n        7. Generate complete frontend config using ChartRenderer\n        8. Add force_reinit flag if set\n\n    Returns:\n        Dict[str, Any]: Complete chart configuration ready for frontend\n            rendering. The configuration includes:\n            - charts: List of chart objects with series and options\n            - syncConfig: Synchronization settings for multi-chart layouts\n            - annotations: Annotation layers and elements\n            - trades: Trade visualization elements\n            - tooltips: Custom tooltip configurations\n\n    Note:\n        Series are automatically ordered by z-index within each pane to ensure\n        proper layering in the frontend. Series with lower z-index values\n        render behind series with higher z-index values.\n\n    Example:\n        Get frontend configuration::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; print(json.dumps(config, indent=2))\n\n        Access specific parts::\n\n            &gt;&gt;&gt; config = chart.to_frontend_config()\n            &gt;&gt;&gt; chart_config = config[\"charts\"][0]\n            &gt;&gt;&gt; series_config = chart_config[\"series\"]\n            &gt;&gt;&gt; options_config = chart_config[\"chart\"]\n    \"\"\"\n    # Step 1: Get series configurations from SeriesManager\n    # SeriesManager handles series ordering by z-index and pane\n    series_configs = self._series_manager.to_frontend_configs()\n\n    # Step 2: Get base chart configuration from ChartOptions\n    # Convert ChartOptions to dictionary for frontend\n    chart_config = (\n        self.options.asdict()\n        if self.options is not None\n        else ChartOptions().asdict()\n    )\n\n    # Step 3: Get price scale configuration from PriceScaleManager\n    # Manager validates scales and returns serialized configuration\n    price_scale_config = self._price_scale_manager.validate_and_serialize()\n    # Merge price scale config into chart config\n    chart_config.update(price_scale_config)\n\n    # Step 4: Get annotations configuration from AnnotationManager\n    # Converts all annotation layers to frontend format\n    annotations_config = self.annotation_manager.asdict()\n\n    # Step 5: Get trades configuration from TradeManager\n    # Converts TradeData objects to visual elements\n    # Uses trade_visualization options from chart options\n    trades_config = self._trade_manager.to_frontend_config(\n        self.options.trade_visualization if self.options else None\n    )\n\n    # Step 6: Get tooltip configurations from TooltipManager\n    tooltip_configs = None\n    if self._tooltip_manager:\n        # Convert each tooltip config to dictionary\n        tooltip_configs = {}\n        for name, tooltip_config in self._tooltip_manager.configs.items():\n            tooltip_configs[name] = tooltip_config.asdict()\n\n    # Step 7: Generate complete frontend configuration using ChartRenderer\n    # ChartRenderer assembles all components into final configuration\n    config = self._chart_renderer.generate_frontend_config(\n        chart_id=f\"chart-{id(self)}\",  # Unique ID based on object ID\n        chart_options=self.options,\n        series_configs=series_configs,\n        annotations_config=annotations_config,\n        trades_config=trades_config,\n        tooltip_configs=tooltip_configs,\n        chart_group_id=self.chart_group_id,\n        price_scale_config=price_scale_config,\n    )\n\n    # Step 8: Add force_reinit flag if set\n    # This tells frontend to completely rebuild the chart\n    # Used when indicator parameters or other settings change\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Return the complete frontend configuration\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.render","title":"render","text":"<pre><code>render(key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Converts the chart to frontend configuration and renders it using the Streamlit component. This is the final step in the chart creation process that displays the interactive chart in the Streamlit application.</p> The rendering process follows these steps <ol> <li>Generate or validate component key</li> <li>Reset config application flag for this render cycle</li> <li>Load and apply stored series configurations from session state</li> <li>Generate frontend configuration (after configs applied)</li> <li>Render component using ChartRenderer</li> <li>Handle component response and save updated series configs</li> </ol> <p>The chart configuration is generated fresh on each render, allowing users to control chart lifecycle and state management in their own code if needed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional unique key for the Streamlit component. This key is used to identify the component instance and is useful for debugging and component state management. If not provided, a unique key will be generated automatically using timestamp and UUID.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The rendered Streamlit component that displays the interactive chart. May contain user interaction data if the frontend sends responses.</p> Example <p>Basic rendering::</p> <pre><code>&gt;&gt;&gt; chart.render()\n</code></pre> <p>Rendering with custom key::</p> <pre><code>&gt;&gt;&gt; chart.render(key=\"my_chart\")\n</code></pre> <p>Method chaining with rendering::</p> <pre><code>&gt;&gt;&gt; (chart\n...  .add_series(line_series)\n...  .update_options(height=600)\n...  .render(key=\"chart1\"))\n</code></pre> <p>User-managed state (advanced)::</p> <pre><code>&gt;&gt;&gt; # Store chart in session state for persistence\n&gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n...     st.session_state.my_chart = Chart(series=LineSeries(data))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Render the persisted chart\n&gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n</code></pre> <p>Dynamic key generation::</p> <pre><code>&gt;&gt;&gt; # Key includes timestamp for uniqueness\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def render(self, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Converts the chart to frontend configuration and renders it using the\n    Streamlit component. This is the final step in the chart creation process\n    that displays the interactive chart in the Streamlit application.\n\n    The rendering process follows these steps:\n        1. Generate or validate component key\n        2. Reset config application flag for this render cycle\n        3. Load and apply stored series configurations from session state\n        4. Generate frontend configuration (after configs applied)\n        5. Render component using ChartRenderer\n        6. Handle component response and save updated series configs\n\n    The chart configuration is generated fresh on each render, allowing users\n    to control chart lifecycle and state management in their own code if needed.\n\n    Args:\n        key (Optional[str]): Optional unique key for the Streamlit component.\n            This key is used to identify the component instance and is useful\n            for debugging and component state management. If not provided,\n            a unique key will be generated automatically using timestamp and UUID.\n\n    Returns:\n        Any: The rendered Streamlit component that displays the interactive chart.\n            May contain user interaction data if the frontend sends responses.\n\n    Example:\n        Basic rendering::\n\n            &gt;&gt;&gt; chart.render()\n\n        Rendering with custom key::\n\n            &gt;&gt;&gt; chart.render(key=\"my_chart\")\n\n        Method chaining with rendering::\n\n            &gt;&gt;&gt; (chart\n            ...  .add_series(line_series)\n            ...  .update_options(height=600)\n            ...  .render(key=\"chart1\"))\n\n        User-managed state (advanced)::\n\n            &gt;&gt;&gt; # Store chart in session state for persistence\n            &gt;&gt;&gt; if \"my_chart\" not in st.session_state:\n            ...     st.session_state.my_chart = Chart(series=LineSeries(data))\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Render the persisted chart\n            &gt;&gt;&gt; st.session_state.my_chart.render(key=\"persistent_chart\")\n\n        Dynamic key generation::\n\n            &gt;&gt;&gt; # Key includes timestamp for uniqueness\n            &gt;&gt;&gt; import time\n            &gt;&gt;&gt; chart.render(key=f\"chart_{int(time.time())}\")\n    \"\"\"\n    # STEP 1: Generate a unique key if none provided or if it's invalid\n    if key is None or not isinstance(key, str) or not key.strip():\n        # Create unique identifier using timestamp and UUID\n        unique_id = str(uuid.uuid4())[:8]  # First 8 chars of UUID\n        timestamp = int(time.time() * 1000)  # Milliseconds since epoch\n        key = f\"chart_{timestamp}_{unique_id}\"\n\n    # STEP 2: Reset config application flag for this render cycle\n    # This ensures configs are only applied once per render\n    # Prevents duplicate application of stored configurations\n    self._session_state_manager.reset_config_applied_flag()\n\n    # STEP 3: Load and apply stored configs IMMEDIATELY before serialization\n    # This is critical: we must apply user-modified configs BEFORE\n    # generating the frontend configuration, otherwise the configs\n    # won't be included in the serialized data\n    stored_configs = self._session_state_manager.load_series_configs(key)\n    if stored_configs:\n        # Apply stored configs to all series\n        # This updates series options with user-modified settings\n        self._session_state_manager.apply_stored_configs_to_series(\n            stored_configs,\n            self.series,  # Current series list\n        )\n\n    # STEP 4: Generate chart configuration ONLY AFTER configs are applied\n    # This ensures the frontend config includes all user modifications\n    # The to_frontend_config() method serializes all chart components\n    config = self.to_frontend_config()\n\n    # STEP 5: Render component using ChartRenderer\n    # ChartRenderer handles:\n    # - Component function retrieval\n    # - Configuration serialization to JSON\n    # - Component rendering through Streamlit\n    # - Error handling if component is unavailable\n    result = self._chart_renderer.render(config, key, self.options)\n\n    # STEP 6: Handle component return value and save series configs\n    # The frontend may send back user interactions or config changes\n    if result:\n        # ChartRenderer processes the response and updates session state\n        # This includes saving any user-modified series configurations\n        self._chart_renderer.handle_response(\n            result,\n            key,\n            self._session_state_manager,\n        )\n\n    # Return the component result\n    # This may contain user interaction data or None\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for the series settings dialog.</p> <p>Retrieves information about all series in a specific pane. This is used by the series settings dialog to display available series and their current configurations.</p> <p>Parameters:</p> Name Type Description Default <code>_pane_id</code> <code>int</code> <p>The pane ID to get series info for (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries containing: - series_index: Index of the series - series_type: Type of series (line, candlestick, etc.) - series_name: Display name of the series - current_config: Current series configuration</p> Example <p>Get series info::</p> <pre><code>&gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n&gt;&gt;&gt; for info in series_info:\n...     print(f\"{info['series_name']}: {info['series_type']}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for the series settings dialog.\n\n    Retrieves information about all series in a specific pane. This is\n    used by the series settings dialog to display available series and\n    their current configurations.\n\n    Args:\n        _pane_id: The pane ID to get series info for (default: 0).\n\n    Returns:\n        List of series information dictionaries containing:\n            - series_index: Index of the series\n            - series_type: Type of series (line, candlestick, etc.)\n            - series_name: Display name of the series\n            - current_config: Current series configuration\n\n    Example:\n        Get series info::\n\n            &gt;&gt;&gt; series_info = chart.get_series_info_for_pane(pane_id=0)\n            &gt;&gt;&gt; for info in series_info:\n            ...     print(f\"{info['series_name']}: {info['series_type']}\")\n    \"\"\"\n    # Delegate to SeriesManager which has access to all series data\n    return self._series_manager.get_series_info_for_pane(_pane_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html","title":"streamlit_lightweight_charts_pro.charts.chart_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager","title":"chart_manager","text":"<p>Chart Manager Module for managing multiple synchronized charts.</p> <p>This module provides the ChartManager class for managing multiple Chart instances with synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> The module includes <ul> <li>ChartManager: Main class for managing multiple charts</li> <li>Chart synchronization and group management</li> <li>Batch rendering and configuration capabilities</li> <li>Cross-chart communication and state management</li> </ul> Key Features <ul> <li>Multiple chart management with unique identifiers</li> <li>Synchronization groups for coordinated chart behavior</li> <li>Crosshair and time range synchronization</li> <li>Batch rendering with consistent configuration</li> <li>Chart lifecycle management (add, remove, update)</li> <li>Automatic sync group assignment and management</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager and add charts\nmanager = ChartManager()\n\n# Create data for multiple charts\ndata1 = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\ndata2 = [SingleValueData(\"2024-01-01\", 200), SingleValueData(\"2024-01-02\", 195)]\n\n# Add charts to manager\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render synchronized charts\nmanager.render_all_charts()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager","title":"ChartManager","text":"<p>Manager for multiple synchronized charts.</p> <p>This class provides comprehensive functionality to manage multiple Chart instances with advanced synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> <p>The ChartManager maintains a registry of charts with unique identifiers and manages synchronization groups that allow charts to share crosshair position, time ranges, and other interactive states. This is particularly useful for creating multi-pane financial dashboards with coordinated chart behavior.</p> <p>Attributes:</p> Name Type Description <code>charts</code> <code>Dict[str, Chart]</code> <p>Dictionary mapping chart IDs to Chart instances.</p> <code>sync_groups</code> <code>Dict[str, SyncOptions]</code> <p>Dictionary mapping chart IDs to their synchronization group options.</p> <code>default_sync</code> <code>SyncOptions</code> <p>Default synchronization options applied to new charts when no specific group is assigned.</p> Example <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager\nmanager = ChartManager()\n\n# Add charts with unique IDs\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization groups\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render all charts with synchronization\nmanager.render_all_charts()\n</code></pre> Note <ul> <li>Charts must have unique IDs within the manager</li> <li>Synchronization groups allow coordinated behavior between charts</li> <li>Individual charts can be rendered or all charts can be rendered together</li> <li>The manager handles component lifecycle and state management</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>class ChartManager:\n    \"\"\"Manager for multiple synchronized charts.\n\n    This class provides comprehensive functionality to manage multiple Chart instances\n    with advanced synchronization capabilities. It enables coordinated display of\n    multiple charts with shared time ranges, crosshair synchronization, and group-based\n    configuration management.\n\n    The ChartManager maintains a registry of charts with unique identifiers and\n    manages synchronization groups that allow charts to share crosshair position,\n    time ranges, and other interactive states. This is particularly useful for\n    creating multi-pane financial dashboards with coordinated chart behavior.\n\n    Attributes:\n        charts (Dict[str, Chart]): Dictionary mapping chart IDs to Chart instances.\n        sync_groups (Dict[str, SyncOptions]): Dictionary mapping chart IDs to their\n            synchronization group options.\n        default_sync (SyncOptions): Default synchronization options applied to\n            new charts when no specific group is assigned.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create manager\n        manager = ChartManager()\n\n        # Add charts with unique IDs\n        manager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\n        manager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n        # Configure synchronization groups\n        manager.set_sync_group(\"price_chart\", \"main_group\")\n        manager.set_sync_group(\"volume_chart\", \"main_group\")\n\n        # Render all charts with synchronization\n        manager.render_all_charts()\n        ```\n\n    Note:\n        - Charts must have unique IDs within the manager\n        - Synchronization groups allow coordinated behavior between charts\n        - Individual charts can be rendered or all charts can be rendered together\n        - The manager handles component lifecycle and state management\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ChartManager.\n\n        Creates a new ChartManager with empty chart registry and default\n        synchronization settings. The manager starts with no charts and uses\n        default sync options for new charts.\n        \"\"\"\n        # Initialize chart registry - maps chart IDs to Chart instances\n        self.charts: Dict[str, Chart] = {}\n\n        # Initialize sync groups - maps chart IDs to their sync configuration\n        self.sync_groups: Dict[str, SyncOptions] = {}\n\n        # Set default sync options for new charts without specific group assignment\n        self.default_sync: SyncOptions = SyncOptions()\n\n        # Flag to force frontend re-initialization (for indicator/parameter changes)\n        self.force_reinit: bool = False\n\n        # Metadata for change detection (symbol/interval)\n        # These are used by frontend to detect when data context changes\n        self.symbol: Optional[str] = None\n        self.display_interval: Optional[str] = None\n\n    def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n        \"\"\"Add a chart to the manager.\n\n        Adds a Chart instance to the manager with a unique identifier. The chart\n        is registered in the manager's chart registry and can participate in\n        synchronization groups. If no chart ID is provided, one is automatically\n        generated.\n\n        Args:\n            chart (Chart): The Chart instance to add to the manager.\n            chart_id (Optional[str]): Optional unique identifier for the chart.\n                If not provided, an auto-generated ID in the format \"chart_N\"\n                will be assigned.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Raises:\n            DuplicateError: If a chart with the specified ID already exists.\n\n        Example:\n            ```python\n            manager = ChartManager()\n            chart = Chart(series=LineSeries(data))\n\n            # Add chart with auto-generated ID\n            manager.add_chart(chart)\n\n            # Add chart with custom ID\n            manager.add_chart(chart, \"price_chart\")\n            ```\n        \"\"\"\n        # Generate unique chart ID if not provided\n        if chart_id is None:\n            chart_id = f\"chart_{len(self.charts) + 1}\"\n\n        # Validate that chart ID is unique within the manager\n        if chart_id in self.charts:\n            raise DuplicateError(\"Chart\", chart_id)\n\n        # Set the ChartManager reference on the chart for bidirectional communication\n        # This allows the chart to access manager configuration and sync settings\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add chart to the registry with its unique identifier\n        self.charts[chart_id] = chart\n        return self\n\n    def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n        \"\"\"Remove a chart from the manager.\n\n        Args:\n            chart_id: ID of the chart to remove\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        del self.charts[chart_id]\n        return self\n\n    def get_chart(self, chart_id: str) -&gt; Chart:\n        \"\"\"Get a chart by ID.\n\n        Args:\n            chart_id: ID of the chart to retrieve\n\n        Returns:\n            The Chart instance\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        return self.charts[chart_id]\n\n    def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n        This method renders a single chart while preserving the ChartManager's\n        sync configuration and group settings. This ensures that individual\n        charts can still participate in group synchronization.\n\n        Args:\n            chart_id: The ID of the chart to render\n            key: Optional key for the Streamlit component\n\n        Returns:\n            The rendered component\n\n        Raises:\n            ValueError: If chart_id is not found\n\n        Example:\n            ```python\n            manager = ChartManager()\n            manager.add_chart(chart1, \"chart1\")\n            manager.add_chart(chart2, \"chart2\")\n\n            col1, col2 = st.columns(2)\n            with col1:\n                manager.render_chart(\"chart1\")\n            with col2:\n                manager.render_chart(\"chart2\")\n            ```\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        # Get the chart and render it (sync config is automatically included)\n        chart = self.charts[chart_id]\n        return chart.render(key=key)\n\n    def get_chart_ids(self) -&gt; List[str]:\n        \"\"\"Get all chart IDs.\n\n        Returns:\n            List of chart IDs\n        \"\"\"\n        return list(self.charts.keys())\n\n    def clear_charts(self) -&gt; \"ChartManager\":\n        \"\"\"Remove all charts from the manager.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self.charts.clear()\n        return self\n\n    def set_sync_group_config(\n        self,\n        group_id: Union[int, str],\n        sync_options: SyncOptions,\n    ) -&gt; \"ChartManager\":\n        \"\"\"Set synchronization configuration for a specific group.\n\n        This method allows you to configure synchronization options for a\n        specific group of charts. Groups enable you to have multiple independent\n        sets of synchronized charts within the same ChartManager.\n\n        For example, you might want to:\n        - Synchronize price and volume charts in one group\n        - Synchronize indicator charts in another group\n        - Keep some charts completely independent\n\n        Args:\n            group_id: The sync group ID (int or str). Charts with the same\n                group_id will be synchronized according to these options.\n            sync_options: The SyncOptions configuration object for this group,\n                specifying which synchronization features to enable.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n            manager = ChartManager()\n\n            # Configure group \"price_charts\" with full sync\n            price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n            manager.set_sync_group_config(\"price_charts\", price_sync)\n\n            # Configure group \"indicators\" with crosshair only\n            indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n            manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n            # Add charts to different groups\n            manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n            manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n            ```\n        \"\"\"\n        self.sync_groups[str(group_id)] = sync_options\n        return self\n\n    def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n        \"\"\"Get synchronization configuration for a specific group.\n\n        Retrieves the current synchronization options for a specified group.\n        This is useful for inspecting or modifying existing group configurations.\n\n        Args:\n            group_id: The sync group ID (int or str) to retrieve configuration for.\n\n        Returns:\n            SyncOptions: The sync configuration for the group, or None if the\n                group hasn't been configured yet.\n\n        Example:\n            ```python\n            # Get configuration for a group\n            config = manager.get_sync_group_config(\"price_charts\")\n            if config:\n                print(f\"Crosshair sync: {config.crosshair}\")\n                print(f\"Time range sync: {config.time_range}\")\n\n            # Check if group exists before modifying\n            if manager.get_sync_group_config(\"indicators\") is None:\n                manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n            ```\n        \"\"\"\n        return self.sync_groups.get(str(group_id))\n\n    def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable crosshair synchronization for linked charts.\n\n        When enabled, moving the crosshair on one chart will synchronize the\n        crosshair position across all charts in the same synchronization group.\n        This creates a coordinated viewing experience where users can see\n        corresponding data points across multiple charts simultaneously.\n\n        The synchronization uses a robust implementation with debouncing and\n        flag-based protection to prevent race conditions and feedback loops,\n        even during rapid user interactions.\n\n        Args:\n            group_id: Optional group ID to enable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n                Groups allow you to have multiple independent sets of\n                synchronized charts.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_crosshair_sync()\n\n            # Enable for specific group\n            manager.enable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_crosshair()\n        else:\n            self.default_sync.enable_crosshair()\n        return self\n\n    def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable crosshair synchronization for linked charts.\n\n        When disabled, crosshair movements will not be synchronized across\n        charts. Each chart will have an independent crosshair that only\n        responds to mouse movements over that specific chart.\n\n        Args:\n            group_id: Optional group ID to disable crosshair sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_crosshair_sync()\n\n            # Disable for specific group\n            manager.disable_crosshair_sync(group_id=\"price_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_crosshair()\n        else:\n            self.default_sync.disable_crosshair()\n        return self\n\n    def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n        When enabled, zooming or panning the time range on one chart will\n        synchronize the visible time range across all charts in the same\n        synchronization group. This allows users to maintain consistent\n        time alignment while analyzing multiple charts.\n\n        The synchronization includes:\n        - Zoom operations (pinch, scroll wheel, double-click)\n        - Pan/scroll operations (drag, arrow keys)\n        - Programmatic range changes\n\n        Implementation uses throttling (16ms ~60fps) to ensure smooth\n        performance and prevent race conditions during rapid interactions.\n\n        Args:\n            group_id: Optional group ID to enable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable for default group (all charts)\n            manager.enable_time_range_sync()\n\n            # Enable for specific group\n            manager.enable_time_range_sync(group_id=\"indicators\")\n\n            # Enable both crosshair and time range\n            manager.enable_crosshair_sync().enable_time_range_sync()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_time_range()\n        else:\n            self.default_sync.enable_time_range()\n        return self\n\n    def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n        When disabled, zoom and pan operations will not be synchronized across\n        charts. Each chart can be zoomed and panned independently.\n\n        Args:\n            group_id: Optional group ID to disable time range sync for a specific\n                group. If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable for default group\n            manager.disable_time_range_sync()\n\n            # Disable for specific group\n            manager.disable_time_range_sync(group_id=\"indicators\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_time_range()\n        else:\n            self.default_sync.disable_time_range()\n        return self\n\n    def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable all synchronization features for linked charts.\n\n        This is a convenience method that enables both crosshair and time range\n        synchronization in a single call. It's the most common configuration for\n        creating fully synchronized multi-chart dashboards.\n\n        When all synchronization is enabled:\n        - Crosshair movements are synchronized across all charts\n        - Zoom/pan operations are synchronized across all charts\n        - Users get a fully coordinated viewing experience\n\n        Args:\n            group_id: Optional group ID to enable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Enable all sync for default group\n            manager.enable_all_sync()\n\n            # Enable all sync for specific group\n            manager.enable_all_sync(group_id=\"main_charts\")\n\n            # Create fully synchronized dashboard\n            manager = ChartManager()\n            manager.add_chart(price_chart, \"price\")\n            manager.add_chart(volume_chart, \"volume\")\n            manager.add_chart(indicator_chart, \"indicator\")\n            manager.enable_all_sync()\n            manager.render()\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_all()\n        else:\n            self.default_sync.enable_all()\n        return self\n\n    def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable all synchronization features for linked charts.\n\n        This is a convenience method that disables both crosshair and time range\n        synchronization in a single call. Use this when you want charts to\n        operate completely independently.\n\n        When all synchronization is disabled:\n        - Each chart has its own independent crosshair\n        - Each chart can be zoomed/panned independently\n        - No coordination between charts\n\n        Args:\n            group_id: Optional group ID to disable all sync for a specific group.\n                If None, applies to the default synchronization group.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Example:\n            ```python\n            # Disable all sync for default group\n            manager.disable_all_sync()\n\n            # Disable all sync for specific group\n            manager.disable_all_sync(group_id=\"main_charts\")\n            ```\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_all()\n        else:\n            self.default_sync.disable_all()\n        return self\n\n    def from_price_volume_dataframe(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        chart_id: str = \"main_chart\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Create a chart from OHLCV data with price and volume series.\n\n        Factory method that creates a new Chart instance with both price and volume\n        series from OHLCV data. This is a convenient way to create a complete\n        price-volume chart in a single operation.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Defaults to None.\n            price_type (str, optional): Type of price series ('candlestick' or 'line').\n                Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration. Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration. Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0.\n\n        Returns:\n            Chart: A new Chart instance with price and volume series.\n\n        Example:\n            ```python\n            # Create chart from DataFrame\n            chart = Chart.from_price_volume_dataframe(\n                df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n            )\n\n            # Create chart from OHLCV data\n            chart = Chart.from_price_volume_dataframe(\n                ohlcv_data,\n                price_type=\"line\",\n                volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n            )\n            ```\n        \"\"\"\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)):\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n        chart = Chart()\n        chart.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n        )\n\n        # Set the ChartManager reference on the chart\n        chart._chart_manager = self  # pylint: disable=protected-access\n\n        # Add the chart to the manager with an ID\n        self.add_chart(chart, chart_id=chart_id)\n\n        return chart\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the chart manager to frontend configuration.\n\n        Returns:\n            Dictionary containing the frontend configuration\n        \"\"\"\n        if not self.charts:\n            return {\n                \"charts\": [],\n                \"syncConfig\": self.default_sync.asdict(),\n            }\n\n        chart_configs = []\n        for chart_id, chart in self.charts.items():\n            chart_config = chart.to_frontend_config()\n            if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n                chart_obj = chart_config[\"charts\"][0]\n                chart_obj[\"chartId\"] = chart_id\n                chart_configs.append(chart_obj)\n            else:\n                # Skip charts with invalid configuration\n                continue\n\n        # Build sync configuration\n        sync_config = self.default_sync.asdict()\n\n        # Add group-specific sync configurations\n        if self.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.sync_groups.items():\n                sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n        config = {\n            \"charts\": chart_configs,\n            \"syncConfig\": sync_config,\n        }\n\n        # Add force_reinit flag if set\n        if self.force_reinit:\n            config[\"forceReinit\"] = True\n\n        # Add metadata for frontend change detection\n        # This allows frontend to detect symbol/interval changes\n        if self.symbol is not None:\n            config[\"symbol\"] = self.symbol\n        if self.display_interval is not None:\n            config[\"displayInterval\"] = str(self.display_interval)\n\n        return config\n\n    def _auto_detect_changes(self, key: str) -&gt; None:\n        \"\"\"\n        Automatically detect changes and set force_reinit if needed.\n\n        This is internal library logic - the user should never call this.\n        It compares current state with previous render to detect changes.\n\n        Args:\n            key: Component key for state storage\n        \"\"\"\n        import hashlib  # pylint: disable=import-outside-toplevel\n        import json  # pylint: disable=import-outside-toplevel\n\n        import streamlit as st  # pylint: disable=import-outside-toplevel\n\n        # Build state key for this chart\n        state_key = f\"_lwc_chart_state_{key}\"\n\n        # Get previous state\n        prev_state = st.session_state.get(state_key)\n\n        # Build current state signature\n        # Include: symbol, interval, chart count, series structure\n        current_state = {\n            \"symbol\": self.symbol,\n            \"interval\": self.display_interval,\n            \"chart_count\": len(self.charts),\n            \"series_structure\": [],\n        }\n\n        # Add series structure fingerprint (types, data length, and full data hash)\n        for chart in self.charts.values():\n            for _idx, series in enumerate(chart.series):\n                # Calculate hash of entire data array for 100% accurate change detection\n                # This is cheap (~1ms for 10K points) and catches ALL data changes\n                data_hash = None\n                if hasattr(series, \"data\") and series.data:\n                    try:\n                        # Hash the entire data array\n                        data_str = str(series.data)\n                        data_hash = hashlib.md5(data_str.encode()).hexdigest()[:8]  # noqa: S324\n                    except Exception:\n                        # Fallback to None if serialization fails\n                        data_hash = None\n\n                series_info = {\n                    \"type\": type(series).__name__,\n                    \"data_length\": len(series.data)\n                    if hasattr(series, \"data\") and series.data\n                    else 0,\n                    \"data_hash\": data_hash,  # Full data hash - catches ALL changes!\n                }\n                current_state[\"series_structure\"].append(series_info)\n\n        # Calculate hash for comparison\n        current_hash = hashlib.md5(  # noqa: S324\n            json.dumps(current_state, sort_keys=True, default=str).encode()\n        ).hexdigest()[:8]\n\n        # AUTO-DETECT if reinit needed\n        # Check if there's a pending reinit from previous run (handles Streamlit multiple reruns)\n        pending_reinit_key = f\"{state_key}_pending_reinit\"\n        pending_reinit = st.session_state.get(pending_reinit_key, False)\n\n        if prev_state is None:\n            # First render - no reinit needed\n            self.force_reinit = False\n            st.session_state[pending_reinit_key] = False\n        elif prev_state != current_hash:\n            # State changed - force reinit and mark as pending for next rerun\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = True\n        elif pending_reinit:\n            # Hash is same but there's a pending reinit from previous run\n            # This handles Streamlit's multiple reruns after a change\n            self.force_reinit = True\n            st.session_state[pending_reinit_key] = False  # Clear the flag\n        else:\n            # Same hash, no pending reinit - no changes detected\n            self.force_reinit = False\n\n        # Store current state for next render\n        st.session_state[state_key] = current_hash\n\n    def render(\n        self,\n        key: Optional[str] = None,\n        symbol: Optional[str] = None,\n        interval: Optional[str] = None,\n    ) -&gt; Any:\n        \"\"\"Render the chart manager with automatic change detection.\n\n        The library automatically detects changes in symbol, interval, series structure,\n        and data, and reinitializes the chart only when needed while preserving\n        customizations.\n\n        Args:\n            key: Optional key for the Streamlit component\n            symbol: Optional symbol name for automatic change detection and metadata\n            interval: Optional interval for automatic change detection and metadata\n\n        Returns:\n            The rendered component\n\n        Raises:\n            RuntimeError: If no charts have been added to the manager\n\n        Note:\n            The library handles change detection internally. You don't need to:\n            - Calculate hashes\n            - Track previous values\n            - Set force_reinit manually\n            - Clear caches\n\n            Just call render() with current symbol/interval and the library\n            handles the rest!\n        \"\"\"\n        if not self.charts:\n            raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n        # STEP 0: Set metadata if provided (before change detection)\n        if symbol is not None:\n            self.symbol = symbol\n        if interval is not None:\n            self.display_interval = interval\n\n        # STEP 1: Generate/validate key (same as Chart.render())\n        if key is None or not isinstance(key, str) or not key.strip():\n            unique_id = str(uuid.uuid4())[:8]\n            key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n        # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n        # This makes the library handle change detection instead of the user\n        self._auto_detect_changes(key)\n\n        # STEP 2: For each chart, reset config flag and load/apply stored configs\n        # This ensures user changes from series dialog persist across reruns\n        # Use the same key for loading/saving so customizations persist\n        for chart in self.charts.values():\n            # Reset config application flag for this render cycle\n            chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n            # Load stored configs from session state using the component key\n            stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n            # Apply configs to series objects BEFORE serialization\n            if stored_configs:\n                chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                    stored_configs,\n                    chart.series,\n                )\n\n        # STEP 3: Generate frontend configuration AFTER configs are applied\n        config = self.to_frontend_config()\n\n        # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n        # Get the first chart's renderer since they all use the same implementation\n        first_chart = next(iter(self.charts.values()))\n        result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n            config,\n            key,\n            None,  # ChartManager doesn't have global chart_options\n        )\n\n        # STEP 5: Handle component return value and save series configs\n        # This ensures changes from frontend are saved to session state\n        # Use same key for saving so configs persist\n        if result:\n            for chart in self.charts.values():\n                chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                    result,\n                    key,  # Use same key for consistency\n                    chart._session_state_manager,  # pylint: disable=protected-access\n                )\n\n        return result\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of charts in the manager.\"\"\"\n        return len(self.charts)\n\n    def __contains__(self, chart_id: str) -&gt; bool:\n        \"\"\"Check if a chart ID exists in the manager.\"\"\"\n        return chart_id in self.charts\n\n    def __iter__(self):\n        \"\"\"Iterate over chart IDs in the manager.\"\"\"\n        return iter(self.charts.keys())\n\n    def keys(self):\n        \"\"\"Return chart IDs in the manager.\"\"\"\n        return self.charts.keys()\n\n    def values(self):\n        \"\"\"Return chart instances in the manager.\"\"\"\n        return self.charts.values()\n\n    def items(self):\n        \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n        return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.add_chart","title":"add_chart","text":"<pre><code>add_chart(chart: Chart, chart_id: Optional[str] = None) -&gt; ChartManager\n</code></pre> <p>Add a chart to the manager.</p> <p>Adds a Chart instance to the manager with a unique identifier. The chart is registered in the manager's chart registry and can participate in synchronization groups. If no chart ID is provided, one is automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>Chart</code> <p>The Chart instance to add to the manager.</p> required <code>chart_id</code> <code>Optional[str]</code> <p>Optional unique identifier for the chart. If not provided, an auto-generated ID in the format \"chart_N\" will be assigned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>DuplicateError</code> <p>If a chart with the specified ID already exists.</p> Example <pre><code>manager = ChartManager()\nchart = Chart(series=LineSeries(data))\n\n# Add chart with auto-generated ID\nmanager.add_chart(chart)\n\n# Add chart with custom ID\nmanager.add_chart(chart, \"price_chart\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n    \"\"\"Add a chart to the manager.\n\n    Adds a Chart instance to the manager with a unique identifier. The chart\n    is registered in the manager's chart registry and can participate in\n    synchronization groups. If no chart ID is provided, one is automatically\n    generated.\n\n    Args:\n        chart (Chart): The Chart instance to add to the manager.\n        chart_id (Optional[str]): Optional unique identifier for the chart.\n            If not provided, an auto-generated ID in the format \"chart_N\"\n            will be assigned.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Raises:\n        DuplicateError: If a chart with the specified ID already exists.\n\n    Example:\n        ```python\n        manager = ChartManager()\n        chart = Chart(series=LineSeries(data))\n\n        # Add chart with auto-generated ID\n        manager.add_chart(chart)\n\n        # Add chart with custom ID\n        manager.add_chart(chart, \"price_chart\")\n        ```\n    \"\"\"\n    # Generate unique chart ID if not provided\n    if chart_id is None:\n        chart_id = f\"chart_{len(self.charts) + 1}\"\n\n    # Validate that chart ID is unique within the manager\n    if chart_id in self.charts:\n        raise DuplicateError(\"Chart\", chart_id)\n\n    # Set the ChartManager reference on the chart for bidirectional communication\n    # This allows the chart to access manager configuration and sync settings\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add chart to the registry with its unique identifier\n    self.charts[chart_id] = chart\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.remove_chart","title":"remove_chart","text":"<pre><code>remove_chart(chart_id: str) -&gt; ChartManager\n</code></pre> <p>Remove a chart from the manager.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to remove</p> required <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n    \"\"\"Remove a chart from the manager.\n\n    Args:\n        chart_id: ID of the chart to remove\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    del self.charts[chart_id]\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_chart","title":"get_chart","text":"<pre><code>get_chart(chart_id: str) -&gt; Chart\n</code></pre> <p>Get a chart by ID.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to retrieve</p> required <p>Returns:</p> Type Description <code>Chart</code> <p>The Chart instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart(self, chart_id: str) -&gt; Chart:\n    \"\"\"Get a chart by ID.\n\n    Args:\n        chart_id: ID of the chart to retrieve\n\n    Returns:\n        The Chart instance\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    return self.charts[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.render_chart","title":"render_chart","text":"<pre><code>render_chart(chart_id: str, key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render a specific chart from the manager with proper sync configuration.</p> <p>This method renders a single chart while preserving the ChartManager's sync configuration and group settings. This ensures that individual charts can still participate in group synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>The ID of the chart to render</p> required <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chart_id is not found</p> Example <pre><code>manager = ChartManager()\nmanager.add_chart(chart1, \"chart1\")\nmanager.add_chart(chart2, \"chart2\")\n\ncol1, col2 = st.columns(2)\nwith col1:\n    manager.render_chart(\"chart1\")\nwith col2:\n    manager.render_chart(\"chart2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n    This method renders a single chart while preserving the ChartManager's\n    sync configuration and group settings. This ensures that individual\n    charts can still participate in group synchronization.\n\n    Args:\n        chart_id: The ID of the chart to render\n        key: Optional key for the Streamlit component\n\n    Returns:\n        The rendered component\n\n    Raises:\n        ValueError: If chart_id is not found\n\n    Example:\n        ```python\n        manager = ChartManager()\n        manager.add_chart(chart1, \"chart1\")\n        manager.add_chart(chart2, \"chart2\")\n\n        col1, col2 = st.columns(2)\n        with col1:\n            manager.render_chart(\"chart1\")\n        with col2:\n            manager.render_chart(\"chart2\")\n        ```\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    # Get the chart and render it (sync config is automatically included)\n    chart = self.charts[chart_id]\n    return chart.render(key=key)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_chart_ids","title":"get_chart_ids","text":"<pre><code>get_chart_ids() -&gt; List[str]\n</code></pre> <p>Get all chart IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of chart IDs</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart_ids(self) -&gt; List[str]:\n    \"\"\"Get all chart IDs.\n\n    Returns:\n        List of chart IDs\n    \"\"\"\n    return list(self.charts.keys())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.clear_charts","title":"clear_charts","text":"<pre><code>clear_charts() -&gt; ChartManager\n</code></pre> <p>Remove all charts from the manager.</p> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def clear_charts(self) -&gt; \"ChartManager\":\n    \"\"\"Remove all charts from the manager.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.charts.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.set_sync_group_config","title":"set_sync_group_config","text":"<pre><code>set_sync_group_config(group_id: Union[int, str], sync_options: SyncOptions) -&gt; ChartManager\n</code></pre> <p>Set synchronization configuration for a specific group.</p> <p>This method allows you to configure synchronization options for a specific group of charts. Groups enable you to have multiple independent sets of synchronized charts within the same ChartManager.</p> <p>For example, you might want to: - Synchronize price and volume charts in one group - Synchronize indicator charts in another group - Keep some charts completely independent</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str). Charts with the same group_id will be synchronized according to these options.</p> required <code>sync_options</code> <code>SyncOptions</code> <p>The SyncOptions configuration object for this group, specifying which synchronization features to enable.</p> required <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\nmanager = ChartManager()\n\n# Configure group \"price_charts\" with full sync\nprice_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\nmanager.set_sync_group_config(\"price_charts\", price_sync)\n\n# Configure group \"indicators\" with crosshair only\nindicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\nmanager.set_sync_group_config(\"indicators\", indicator_sync)\n\n# Add charts to different groups\nmanager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\nmanager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def set_sync_group_config(\n    self,\n    group_id: Union[int, str],\n    sync_options: SyncOptions,\n) -&gt; \"ChartManager\":\n    \"\"\"Set synchronization configuration for a specific group.\n\n    This method allows you to configure synchronization options for a\n    specific group of charts. Groups enable you to have multiple independent\n    sets of synchronized charts within the same ChartManager.\n\n    For example, you might want to:\n    - Synchronize price and volume charts in one group\n    - Synchronize indicator charts in another group\n    - Keep some charts completely independent\n\n    Args:\n        group_id: The sync group ID (int or str). Charts with the same\n            group_id will be synchronized according to these options.\n        sync_options: The SyncOptions configuration object for this group,\n            specifying which synchronization features to enable.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n        manager = ChartManager()\n\n        # Configure group \"price_charts\" with full sync\n        price_sync = SyncOptions(enabled=True, crosshair=True, time_range=True)\n        manager.set_sync_group_config(\"price_charts\", price_sync)\n\n        # Configure group \"indicators\" with crosshair only\n        indicator_sync = SyncOptions(enabled=True, crosshair=True, time_range=False)\n        manager.set_sync_group_config(\"indicators\", indicator_sync)\n\n        # Add charts to different groups\n        manager.add_chart(price_chart, \"price\")  # Will use \"price_charts\" group\n        manager.add_chart(indicator_chart, \"ind\")  # Will use \"indicators\" group\n        ```\n    \"\"\"\n    self.sync_groups[str(group_id)] = sync_options\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_sync_group_config","title":"get_sync_group_config","text":"<pre><code>get_sync_group_config(group_id: Union[int, str]) -&gt; Optional[SyncOptions]\n</code></pre> <p>Get synchronization configuration for a specific group.</p> <p>Retrieves the current synchronization options for a specified group. This is useful for inspecting or modifying existing group configurations.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str) to retrieve configuration for.</p> required <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>Optional[SyncOptions]</code> <p>The sync configuration for the group, or None if the group hasn't been configured yet.</p> Example <pre><code># Get configuration for a group\nconfig = manager.get_sync_group_config(\"price_charts\")\nif config:\n    print(f\"Crosshair sync: {config.crosshair}\")\n    print(f\"Time range sync: {config.time_range}\")\n\n# Check if group exists before modifying\nif manager.get_sync_group_config(\"indicators\") is None:\n    manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n    \"\"\"Get synchronization configuration for a specific group.\n\n    Retrieves the current synchronization options for a specified group.\n    This is useful for inspecting or modifying existing group configurations.\n\n    Args:\n        group_id: The sync group ID (int or str) to retrieve configuration for.\n\n    Returns:\n        SyncOptions: The sync configuration for the group, or None if the\n            group hasn't been configured yet.\n\n    Example:\n        ```python\n        # Get configuration for a group\n        config = manager.get_sync_group_config(\"price_charts\")\n        if config:\n            print(f\"Crosshair sync: {config.crosshair}\")\n            print(f\"Time range sync: {config.time_range}\")\n\n        # Check if group exists before modifying\n        if manager.get_sync_group_config(\"indicators\") is None:\n            manager.set_sync_group_config(\"indicators\", SyncOptions(...))\n        ```\n    \"\"\"\n    return self.sync_groups.get(str(group_id))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_crosshair_sync","title":"enable_crosshair_sync","text":"<pre><code>enable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable crosshair synchronization for linked charts.</p> <p>When enabled, moving the crosshair on one chart will synchronize the crosshair position across all charts in the same synchronization group. This creates a coordinated viewing experience where users can see corresponding data points across multiple charts simultaneously.</p> <p>The synchronization uses a robust implementation with debouncing and flag-based protection to prevent race conditions and feedback loops, even during rapid user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable crosshair sync for a specific group. If None, applies to the default synchronization group. Groups allow you to have multiple independent sets of synchronized charts.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_crosshair_sync()\n\n# Enable for specific group\nmanager.enable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable crosshair synchronization for linked charts.\n\n    When enabled, moving the crosshair on one chart will synchronize the\n    crosshair position across all charts in the same synchronization group.\n    This creates a coordinated viewing experience where users can see\n    corresponding data points across multiple charts simultaneously.\n\n    The synchronization uses a robust implementation with debouncing and\n    flag-based protection to prevent race conditions and feedback loops,\n    even during rapid user interactions.\n\n    Args:\n        group_id: Optional group ID to enable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n            Groups allow you to have multiple independent sets of\n            synchronized charts.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_crosshair_sync()\n\n        # Enable for specific group\n        manager.enable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_crosshair()\n    else:\n        self.default_sync.enable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_crosshair_sync","title":"disable_crosshair_sync","text":"<pre><code>disable_crosshair_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable crosshair synchronization for linked charts.</p> <p>When disabled, crosshair movements will not be synchronized across charts. Each chart will have an independent crosshair that only responds to mouse movements over that specific chart.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable crosshair sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_crosshair_sync()\n\n# Disable for specific group\nmanager.disable_crosshair_sync(group_id=\"price_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable crosshair synchronization for linked charts.\n\n    When disabled, crosshair movements will not be synchronized across\n    charts. Each chart will have an independent crosshair that only\n    responds to mouse movements over that specific chart.\n\n    Args:\n        group_id: Optional group ID to disable crosshair sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_crosshair_sync()\n\n        # Disable for specific group\n        manager.disable_crosshair_sync(group_id=\"price_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_crosshair()\n    else:\n        self.default_sync.disable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_time_range_sync","title":"enable_time_range_sync","text":"<pre><code>enable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable time range (zoom/scroll) synchronization for linked charts.</p> <p>When enabled, zooming or panning the time range on one chart will synchronize the visible time range across all charts in the same synchronization group. This allows users to maintain consistent time alignment while analyzing multiple charts.</p> <p>The synchronization includes: - Zoom operations (pinch, scroll wheel, double-click) - Pan/scroll operations (drag, arrow keys) - Programmatic range changes</p> <p>Implementation uses throttling (16ms ~60fps) to ensure smooth performance and prevent race conditions during rapid interactions.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable for default group (all charts)\nmanager.enable_time_range_sync()\n\n# Enable for specific group\nmanager.enable_time_range_sync(group_id=\"indicators\")\n\n# Enable both crosshair and time range\nmanager.enable_crosshair_sync().enable_time_range_sync()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable time range (zoom/scroll) synchronization for linked charts.\n\n    When enabled, zooming or panning the time range on one chart will\n    synchronize the visible time range across all charts in the same\n    synchronization group. This allows users to maintain consistent\n    time alignment while analyzing multiple charts.\n\n    The synchronization includes:\n    - Zoom operations (pinch, scroll wheel, double-click)\n    - Pan/scroll operations (drag, arrow keys)\n    - Programmatic range changes\n\n    Implementation uses throttling (16ms ~60fps) to ensure smooth\n    performance and prevent race conditions during rapid interactions.\n\n    Args:\n        group_id: Optional group ID to enable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable for default group (all charts)\n        manager.enable_time_range_sync()\n\n        # Enable for specific group\n        manager.enable_time_range_sync(group_id=\"indicators\")\n\n        # Enable both crosshair and time range\n        manager.enable_crosshair_sync().enable_time_range_sync()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_time_range()\n    else:\n        self.default_sync.enable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_time_range_sync","title":"disable_time_range_sync","text":"<pre><code>disable_time_range_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable time range (zoom/scroll) synchronization for linked charts.</p> <p>When disabled, zoom and pan operations will not be synchronized across charts. Each chart can be zoomed and panned independently.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable time range sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable for default group\nmanager.disable_time_range_sync()\n\n# Disable for specific group\nmanager.disable_time_range_sync(group_id=\"indicators\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable time range (zoom/scroll) synchronization for linked charts.\n\n    When disabled, zoom and pan operations will not be synchronized across\n    charts. Each chart can be zoomed and panned independently.\n\n    Args:\n        group_id: Optional group ID to disable time range sync for a specific\n            group. If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable for default group\n        manager.disable_time_range_sync()\n\n        # Disable for specific group\n        manager.disable_time_range_sync(group_id=\"indicators\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_time_range()\n    else:\n        self.default_sync.disable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_all_sync","title":"enable_all_sync","text":"<pre><code>enable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Enable all synchronization features for linked charts.</p> <p>This is a convenience method that enables both crosshair and time range synchronization in a single call. It's the most common configuration for creating fully synchronized multi-chart dashboards.</p> <p>When all synchronization is enabled: - Crosshair movements are synchronized across all charts - Zoom/pan operations are synchronized across all charts - Users get a fully coordinated viewing experience</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to enable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Enable all sync for default group\nmanager.enable_all_sync()\n\n# Enable all sync for specific group\nmanager.enable_all_sync(group_id=\"main_charts\")\n\n# Create fully synchronized dashboard\nmanager = ChartManager()\nmanager.add_chart(price_chart, \"price\")\nmanager.add_chart(volume_chart, \"volume\")\nmanager.add_chart(indicator_chart, \"indicator\")\nmanager.enable_all_sync()\nmanager.render()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable all synchronization features for linked charts.\n\n    This is a convenience method that enables both crosshair and time range\n    synchronization in a single call. It's the most common configuration for\n    creating fully synchronized multi-chart dashboards.\n\n    When all synchronization is enabled:\n    - Crosshair movements are synchronized across all charts\n    - Zoom/pan operations are synchronized across all charts\n    - Users get a fully coordinated viewing experience\n\n    Args:\n        group_id: Optional group ID to enable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Enable all sync for default group\n        manager.enable_all_sync()\n\n        # Enable all sync for specific group\n        manager.enable_all_sync(group_id=\"main_charts\")\n\n        # Create fully synchronized dashboard\n        manager = ChartManager()\n        manager.add_chart(price_chart, \"price\")\n        manager.add_chart(volume_chart, \"volume\")\n        manager.add_chart(indicator_chart, \"indicator\")\n        manager.enable_all_sync()\n        manager.render()\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_all()\n    else:\n        self.default_sync.enable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_all_sync","title":"disable_all_sync","text":"<pre><code>disable_all_sync(group_id: Optional[Union[int, str]] = None) -&gt; ChartManager\n</code></pre> <p>Disable all synchronization features for linked charts.</p> <p>This is a convenience method that disables both crosshair and time range synchronization in a single call. Use this when you want charts to operate completely independently.</p> <p>When all synchronization is disabled: - Each chart has its own independent crosshair - Each chart can be zoomed/panned independently - No coordination between charts</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID to disable all sync for a specific group. If None, applies to the default synchronization group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> Example <pre><code># Disable all sync for default group\nmanager.disable_all_sync()\n\n# Disable all sync for specific group\nmanager.disable_all_sync(group_id=\"main_charts\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable all synchronization features for linked charts.\n\n    This is a convenience method that disables both crosshair and time range\n    synchronization in a single call. Use this when you want charts to\n    operate completely independently.\n\n    When all synchronization is disabled:\n    - Each chart has its own independent crosshair\n    - Each chart can be zoomed/panned independently\n    - No coordination between charts\n\n    Args:\n        group_id: Optional group ID to disable all sync for a specific group.\n            If None, applies to the default synchronization group.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Example:\n        ```python\n        # Disable all sync for default group\n        manager.disable_all_sync()\n\n        # Disable all sync for specific group\n        manager.disable_all_sync(group_id=\"main_charts\")\n        ```\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_all()\n    else:\n        self.default_sync.disable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.from_price_volume_dataframe","title":"from_price_volume_dataframe","text":"<pre><code>from_price_volume_dataframe(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict] = None, price_type: str = 'candlestick', chart_id: str = 'main_chart', price_kwargs=None, volume_kwargs=None, pane_id: int = 0) -&gt; Chart\n</code></pre> <p>Create a chart from OHLCV data with price and volume series.</p> <p>Factory method that creates a new Chart instance with both price and volume series from OHLCV data. This is a convenient way to create a complete price-volume chart in a single operation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Defaults to None.</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line'). Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration. Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration. Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>A new Chart instance with price and volume series.</p> Example <pre><code># Create chart from DataFrame\nchart = Chart.from_price_volume_dataframe(\n    df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n)\n\n# Create chart from OHLCV data\nchart = Chart.from_price_volume_dataframe(\n    ohlcv_data,\n    price_type=\"line\",\n    volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def from_price_volume_dataframe(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    chart_id: str = \"main_chart\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Create a chart from OHLCV data with price and volume series.\n\n    Factory method that creates a new Chart instance with both price and volume\n    series from OHLCV data. This is a convenient way to create a complete\n    price-volume chart in a single operation.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Defaults to None.\n        price_type (str, optional): Type of price series ('candlestick' or 'line').\n            Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration. Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration. Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0.\n\n    Returns:\n        Chart: A new Chart instance with price and volume series.\n\n    Example:\n        ```python\n        # Create chart from DataFrame\n        chart = Chart.from_price_volume_dataframe(\n            df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n        )\n\n        # Create chart from OHLCV data\n        chart = Chart.from_price_volume_dataframe(\n            ohlcv_data,\n            price_type=\"line\",\n            volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n        )\n        ```\n    \"\"\"\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)):\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n    chart = Chart()\n    chart.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n    )\n\n    # Set the ChartManager reference on the chart\n    chart._chart_manager = self  # pylint: disable=protected-access\n\n    # Add the chart to the manager with an ID\n    self.add_chart(chart, chart_id=chart_id)\n\n    return chart\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert the chart manager to frontend configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing the frontend configuration</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the chart manager to frontend configuration.\n\n    Returns:\n        Dictionary containing the frontend configuration\n    \"\"\"\n    if not self.charts:\n        return {\n            \"charts\": [],\n            \"syncConfig\": self.default_sync.asdict(),\n        }\n\n    chart_configs = []\n    for chart_id, chart in self.charts.items():\n        chart_config = chart.to_frontend_config()\n        if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n            chart_obj = chart_config[\"charts\"][0]\n            chart_obj[\"chartId\"] = chart_id\n            chart_configs.append(chart_obj)\n        else:\n            # Skip charts with invalid configuration\n            continue\n\n    # Build sync configuration\n    sync_config = self.default_sync.asdict()\n\n    # Add group-specific sync configurations\n    if self.sync_groups:\n        sync_config[\"groups\"] = {}\n        for group_id, group_sync in self.sync_groups.items():\n            sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n    config = {\n        \"charts\": chart_configs,\n        \"syncConfig\": sync_config,\n    }\n\n    # Add force_reinit flag if set\n    if self.force_reinit:\n        config[\"forceReinit\"] = True\n\n    # Add metadata for frontend change detection\n    # This allows frontend to detect symbol/interval changes\n    if self.symbol is not None:\n        config[\"symbol\"] = self.symbol\n    if self.display_interval is not None:\n        config[\"displayInterval\"] = str(self.display_interval)\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.render","title":"render","text":"<pre><code>render(key: Optional[str] = None, symbol: Optional[str] = None, interval: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart manager with automatic change detection.</p> <p>The library automatically detects changes in symbol, interval, series structure, and data, and reinitializes the chart only when needed while preserving customizations.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <code>symbol</code> <code>Optional[str]</code> <p>Optional symbol name for automatic change detection and metadata</p> <code>None</code> <code>interval</code> <code>Optional[str]</code> <p>Optional interval for automatic change detection and metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no charts have been added to the manager</p> Note <p>The library handles change detection internally. You don't need to: - Calculate hashes - Track previous values - Set force_reinit manually - Clear caches</p> <p>Just call render() with current symbol/interval and the library handles the rest!</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render(\n    self,\n    key: Optional[str] = None,\n    symbol: Optional[str] = None,\n    interval: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Render the chart manager with automatic change detection.\n\n    The library automatically detects changes in symbol, interval, series structure,\n    and data, and reinitializes the chart only when needed while preserving\n    customizations.\n\n    Args:\n        key: Optional key for the Streamlit component\n        symbol: Optional symbol name for automatic change detection and metadata\n        interval: Optional interval for automatic change detection and metadata\n\n    Returns:\n        The rendered component\n\n    Raises:\n        RuntimeError: If no charts have been added to the manager\n\n    Note:\n        The library handles change detection internally. You don't need to:\n        - Calculate hashes\n        - Track previous values\n        - Set force_reinit manually\n        - Clear caches\n\n        Just call render() with current symbol/interval and the library\n        handles the rest!\n    \"\"\"\n    if not self.charts:\n        raise RuntimeError(\"Cannot render ChartManager with no charts\")\n\n    # STEP 0: Set metadata if provided (before change detection)\n    if symbol is not None:\n        self.symbol = symbol\n    if interval is not None:\n        self.display_interval = interval\n\n    # STEP 1: Generate/validate key (same as Chart.render())\n    if key is None or not isinstance(key, str) or not key.strip():\n        unique_id = str(uuid.uuid4())[:8]\n        key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n\n    # STEP 1.5: AUTO-DETECT changes (internal logic - transparent to user)\n    # This makes the library handle change detection instead of the user\n    self._auto_detect_changes(key)\n\n    # STEP 2: For each chart, reset config flag and load/apply stored configs\n    # This ensures user changes from series dialog persist across reruns\n    # Use the same key for loading/saving so customizations persist\n    for chart in self.charts.values():\n        # Reset config application flag for this render cycle\n        chart._session_state_manager.reset_config_applied_flag()  # pylint: disable=protected-access\n\n        # Load stored configs from session state using the component key\n        stored_configs = chart._session_state_manager.load_series_configs(key)  # pylint: disable=protected-access\n\n        # Apply configs to series objects BEFORE serialization\n        if stored_configs:\n            chart._session_state_manager.apply_stored_configs_to_series(  # pylint: disable=protected-access\n                stored_configs,\n                chart.series,\n            )\n\n    # STEP 3: Generate frontend configuration AFTER configs are applied\n    config = self.to_frontend_config()\n\n    # STEP 4: Render using ChartRenderer (DRY - reuse existing code)\n    # Get the first chart's renderer since they all use the same implementation\n    first_chart = next(iter(self.charts.values()))\n    result = first_chart._chart_renderer.render(  # pylint: disable=protected-access\n        config,\n        key,\n        None,  # ChartManager doesn't have global chart_options\n    )\n\n    # STEP 5: Handle component return value and save series configs\n    # This ensures changes from frontend are saved to session state\n    # Use same key for saving so configs persist\n    if result:\n        for chart in self.charts.values():\n            chart._chart_renderer.handle_response(  # pylint: disable=protected-access\n                result,\n                key,  # Use same key for consistency\n                chart._session_state_manager,  # pylint: disable=protected-access\n            )\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return chart IDs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def keys(self):\n    \"\"\"Return chart IDs in the manager.\"\"\"\n    return self.charts.keys()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return chart instances in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def values(self):\n    \"\"\"Return chart instances in the manager.\"\"\"\n    return self.charts.values()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return chart ID and instance pairs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def items(self):\n    \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n    return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html","title":"streamlit_lightweight_charts_pro.charts.series_settings_api","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api","title":"series_settings_api","text":"<p>Series Settings API for Streamlit Backend Integration.</p> <p>This module provides the backend API for handling series settings requests from the React frontend. It manages persistence of series configurations in Streamlit session state and provides methods for: - Getting current pane/series state - Updating series settings with patches - Resetting series to defaults - Batch operations for multiple settings changes</p> <p>The API integrates with the existing Chart and Series classes and maintains compatibility with the series configuration system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI","title":"SeriesSettingsAPI","text":"<p>Backend API for handling series settings from the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>class SeriesSettingsAPI:\n    \"\"\"Backend API for handling series settings from the frontend.\"\"\"\n\n    def __init__(self, chart_id: str = \"default\"):\n        \"\"\"Initialize the API with a chart ID.\n\n        Args:\n            chart_id: Unique identifier for the chart instance\n        \"\"\"\n        self.chart_id = chart_id\n        self._session_key = f\"chart_model_{chart_id}\"\n        self._ensure_session_state()\n\n    def _ensure_session_state(self) -&gt; None:\n        \"\"\"Ensure session state is initialized for this chart.\"\"\"\n        if self._session_key not in st.session_state:\n            st.session_state[self._session_key] = {\n                \"panes\": {},  # {pane_id: {series_id: SeriesConfigState}}\n                \"series_refs\": {},  # {series_id: Series instance}\n                \"last_update\": time.time(),\n            }\n\n    def _get_chart_state(self) -&gt; Dict[str, Any]:\n        \"\"\"Get the current chart state from session.\"\"\"\n        # Initialize state if it doesn't exist\n        if self._session_key not in st.session_state:\n            self._ensure_session_state()\n        return st.session_state[self._session_key]\n\n    def _update_last_modified(self) -&gt; None:\n        \"\"\"Update the last modified timestamp.\"\"\"\n        st.session_state[self._session_key][\"last_update\"] = time.time()\n\n    def register_series(\n        self,\n        pane_id: int,\n        series: Series,\n        series_index: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Register a series instance with the API.\n\n        Args:\n            pane_id: The pane ID where the series belongs\n            series: The series instance to register\n            series_index: Optional series index for generating consistent series IDs.\n                If provided, generates ID as \"pane-{paneId}-series-{index}\".\n                If not provided, falls back to legacy format.\n        \"\"\"\n        chart_state = self._get_chart_state()\n\n        # Initialize pane if it doesn't exist\n        if str(pane_id) not in chart_state[\"panes\"]:\n            chart_state[\"panes\"][str(pane_id)] = {}\n\n        # CRITICAL FIX: Generate series ID in same format as frontend expects\n        # Frontend uses: \"pane-{paneId}-series-{index}\"\n        # This ensures storage and retrieval keys match\n        if series_index is not None:\n            series_id = f\"pane-{pane_id}-series-{series_index}\"\n        else:\n            # Fallback to legacy format for backward compatibility\n            series_id = getattr(series, \"id\", f\"series_{len(chart_state['series_refs'])}\")\n\n        chart_state[\"series_refs\"][series_id] = series\n\n        # Check if series config already exists (from previous interaction)\n        pane_key = str(pane_id)\n        if series_id in chart_state[\"panes\"][pane_key]:\n            # Config exists from previous interaction - apply it to the series\n            existing_config = chart_state[\"panes\"][pane_key][series_id]\n            if isinstance(existing_config, SeriesConfigState):\n                stored_config = existing_config.config\n                # Apply stored config to series to preserve user changes\n                if hasattr(series, \"update\") and callable(series.update):\n                    series.update(stored_config)\n                else:\n                    # Fallback: set attributes directly\n                    for key, value in stored_config.items():\n                        if hasattr(series, key):\n                            setattr(series, key, value)\n        else:\n            # First time registration - initialize with EMPTY config\n            # We only store user changes, not the default series state\n            # This prevents conflicts between stored defaults and user modifications\n            chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                config={},  # Start empty - only store user changes\n                series_type=series.__class__.__name__.lower(),\n                last_modified=int(time.time()),\n            )\n\n        self._update_last_modified()\n\n    def get_pane_state(self, pane_id: int) -&gt; Dict[str, Any]:\n        \"\"\"Get current state for a specific pane.\n\n        Args:\n            pane_id: The pane ID to get state for\n\n        Returns:\n            Dictionary containing pane state with series configurations\n        \"\"\"\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n\n        if pane_key not in chart_state[\"panes\"]:\n            return {\"paneId\": pane_id, \"series\": {}}\n\n        # Convert SeriesConfigState objects to dicts\n        pane_series = {}\n        for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n            if isinstance(config_state, SeriesConfigState):\n                pane_series[series_id] = config_state.asdict()\n            else:\n                pane_series[series_id] = config_state\n\n        return {\n            \"paneId\": pane_id,\n            \"series\": pane_series,\n        }\n\n    def update_series_settings(\n        self,\n        pane_id: int,\n        series_id: str,\n        config_patch: Dict[str, Any],\n    ) -&gt; bool:\n        \"\"\"Update series settings with a configuration patch.\n\n        Args:\n            pane_id: The pane ID containing the series\n            series_id: The series ID to update\n            config_patch: Dictionary containing configuration updates\n\n        Returns:\n            True if update was successful, False otherwise\n        \"\"\"\n        try:\n            chart_state = self._get_chart_state()\n            pane_key = str(pane_id)\n\n            # Ensure pane exists\n            if pane_key not in chart_state[\"panes\"]:\n                chart_state[\"panes\"][pane_key] = {}\n\n            # Ensure series config exists\n            if series_id not in chart_state[\"panes\"][pane_key]:\n                chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                    config={},\n                    series_type=\"unknown\",\n                    last_modified=int(time.time()),\n                )\n\n            # Get current config\n            current_state = chart_state[\"panes\"][pane_key][series_id]\n            if isinstance(current_state, SeriesConfigState):\n                current_config = current_state.config.copy()\n            else:\n                current_config = current_state.get(\"config\", {}).copy()\n\n            # Apply patch - handle nested structures like mainLine\n            for key, value in config_patch.items():\n                if isinstance(value, dict) and key in (\"mainLine\", \"lineOptions\", \"options\"):\n                    # Flatten nested line options to top-level properties\n                    for nested_key, nested_value in value.items():\n                        current_config[nested_key] = nested_value\n                else:\n                    current_config[key] = value\n\n            # Clean up config: remove problematic nested structures and data\n            # We only want to store user-changeable UI properties, not data or defaults\n            cleaned_config = {\n                key: value\n                for key, value in current_config.items()\n                if key not in (\"data\", \"options\", \"lineOptions\", \"mainLine\")\n            }\n\n            # Update the stored configuration\n            chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                config=cleaned_config,\n                series_type=(\n                    current_state.series_type\n                    if isinstance(current_state, SeriesConfigState)\n                    else \"unknown\"\n                ),\n                last_modified=int(time.time()),\n            )\n\n            # Update the actual series object if available\n            if series_id in chart_state[\"series_refs\"]:\n                series_instance = chart_state[\"series_refs\"][series_id]\n                try:\n                    # Use update() method which all Series classes have\n                    if hasattr(series_instance, \"update\") and callable(series_instance.update):\n                        series_instance.update(config_patch)\n                    else:\n                        # Fallback to setting attributes directly\n                        for key, value in config_patch.items():\n                            if hasattr(series_instance, key):\n                                setattr(series_instance, key, value)\n\n                except Exception as e:\n                    logger.warning(\"Failed to update series instance %s: %s\", series_id, e)\n\n            self._update_last_modified()\n        except Exception:\n            logger.exception(\"Failed to update series settings\")\n            return False\n        else:\n            return True\n\n    def reset_series_to_defaults(\n        self,\n        pane_id: int,\n        series_id: str,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Reset a series to its default configuration.\n\n        Args:\n            pane_id: The pane ID containing the series\n            series_id: The series ID to reset\n\n        Returns:\n            Dictionary containing the default configuration, or None if failed\n        \"\"\"\n        try:\n            chart_state = self._get_chart_state()\n\n            # Get the series instance to determine defaults\n            if series_id in chart_state[\"series_refs\"]:\n                series_instance = chart_state[\"series_refs\"][series_id]\n\n                # Get default configuration based on series type\n                default_config = self._get_series_defaults(series_instance)\n\n                # Update the stored configuration\n                pane_key = str(pane_id)\n                if pane_key in chart_state[\"panes\"] and series_id in chart_state[\"panes\"][pane_key]:\n                    chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                        config=default_config,\n                        series_type=series_instance.__class__.__name__.lower(),\n                        last_modified=int(time.time()),\n                    )\n\n                    # Update the series instance\n                    if hasattr(series_instance, \"update\") and callable(series_instance.update):\n                        series_instance.update(default_config)\n\n                    self._update_last_modified()\n                    return default_config\n\n        except Exception:\n            logger.exception(\"Failed to reset series to defaults\")\n\n        return None\n\n    def _get_series_defaults(self, series_instance: Series) -&gt; Dict[str, Any]:\n        \"\"\"Get default configuration for a series type.\n\n        Args:\n            series_instance: The series instance to get defaults for\n\n        Returns:\n            Dictionary containing default configuration\n        \"\"\"\n        series_type = series_instance.__class__.__name__.lower()\n\n        # Common defaults for all series types\n        defaults: Dict[str, Any] = {\n            \"visible\": True,\n            \"markers\": False,\n            \"last_value_visible\": True,\n            \"price_line\": True,\n        }\n\n        # Series-specific defaults\n        if \"ribbon\" in series_type:\n            defaults.update(\n                {\n                    \"upper_line\": {\n                        \"color\": \"#4CAF50\",\n                        \"line_style\": \"solid\",\n                        \"line_width\": 2,\n                    },\n                    \"lower_line\": {\n                        \"color\": \"#F44336\",\n                        \"line_style\": \"solid\",\n                        \"line_width\": 2,\n                    },\n                    \"fill\": True,\n                    \"fill_color\": \"#2196F3\",\n                    \"fill_opacity\": 20,\n                },\n            )\n        elif \"line\" in series_type:\n            defaults.update(\n                {\n                    \"color\": \"#2196F3\",\n                    \"line_style\": \"solid\",\n                    \"line_width\": 1,\n                },\n            )\n        elif \"candlestick\" in series_type:\n            defaults.update(\n                {\n                    \"upColor\": \"#4CAF50\",\n                    \"downColor\": \"#F44336\",\n                    \"wickUpColor\": \"#4CAF50\",\n                    \"wickDownColor\": \"#F44336\",\n                },\n            )\n        elif \"area\" in series_type:\n            defaults.update(\n                {\n                    \"topColor\": \"#2196F3\",\n                    \"bottomColor\": \"rgba(33, 150, 243, 0.1)\",\n                    \"lineColor\": \"#2196F3\",\n                    \"lineWidth\": 2,\n                },\n            )\n\n        return defaults\n\n    def update_multiple_settings(\n        self,\n        patches: List[Dict[str, Any]],\n    ) -&gt; bool:\n        \"\"\"Update multiple series settings in a batch operation.\n\n        Args:\n            patches: List of setting patches, each containing paneId, seriesId, and config\n\n        Returns:\n            True if all updates were successful, False otherwise\n        \"\"\"\n        try:\n            success = True\n            for patch in patches:\n                pane_id = patch.get(\"paneId\", 0)\n                series_id = patch.get(\"seriesId\", \"\")\n                config = patch.get(\"config\", {})\n\n                if not self.update_series_settings(pane_id, series_id, config):\n                    success = False\n                    logger.warning(\"Failed to update series %s in pane %s\", series_id, pane_id)\n\n        except Exception:\n            logger.exception(\"Failed to update multiple settings\")\n            return False\n        else:\n            return success\n\n    def get_all_series_info(self, pane_id: int) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get information about all series in a pane.\n\n        Args:\n            pane_id: The pane ID to get series info for\n\n        Returns:\n            List of dictionaries containing series information\n        \"\"\"\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n        series_info = []\n\n        if pane_key in chart_state[\"panes\"]:\n            for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n                # Get series instance for display name\n                series_instance = chart_state[\"series_refs\"].get(series_id)\n                display_name = series_id\n\n                if series_instance:\n                    # Try to get a more user-friendly name\n                    if hasattr(series_instance, \"name\") and series_instance.name:\n                        display_name = series_instance.name\n                    elif hasattr(series_instance, \"title\") and series_instance.title:\n                        display_name = series_instance.title\n\n                series_type = (\n                    config_state.series_type\n                    if isinstance(config_state, SeriesConfigState)\n                    else \"unknown\"\n                )\n\n                series_info.append(\n                    {\n                        \"id\": series_id,\n                        \"displayName\": display_name,\n                        \"type\": series_type,\n                    },\n                )\n\n        return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.register_series","title":"register_series","text":"<pre><code>register_series(pane_id: int, series: Series, series_index: Optional[int] = None) -&gt; None\n</code></pre> <p>Register a series instance with the API.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID where the series belongs</p> required <code>series</code> <code>Series</code> <p>The series instance to register</p> required <code>series_index</code> <code>Optional[int]</code> <p>Optional series index for generating consistent series IDs. If provided, generates ID as \"pane-{paneId}-series-{index}\". If not provided, falls back to legacy format.</p> <code>None</code> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def register_series(\n    self,\n    pane_id: int,\n    series: Series,\n    series_index: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Register a series instance with the API.\n\n    Args:\n        pane_id: The pane ID where the series belongs\n        series: The series instance to register\n        series_index: Optional series index for generating consistent series IDs.\n            If provided, generates ID as \"pane-{paneId}-series-{index}\".\n            If not provided, falls back to legacy format.\n    \"\"\"\n    chart_state = self._get_chart_state()\n\n    # Initialize pane if it doesn't exist\n    if str(pane_id) not in chart_state[\"panes\"]:\n        chart_state[\"panes\"][str(pane_id)] = {}\n\n    # CRITICAL FIX: Generate series ID in same format as frontend expects\n    # Frontend uses: \"pane-{paneId}-series-{index}\"\n    # This ensures storage and retrieval keys match\n    if series_index is not None:\n        series_id = f\"pane-{pane_id}-series-{series_index}\"\n    else:\n        # Fallback to legacy format for backward compatibility\n        series_id = getattr(series, \"id\", f\"series_{len(chart_state['series_refs'])}\")\n\n    chart_state[\"series_refs\"][series_id] = series\n\n    # Check if series config already exists (from previous interaction)\n    pane_key = str(pane_id)\n    if series_id in chart_state[\"panes\"][pane_key]:\n        # Config exists from previous interaction - apply it to the series\n        existing_config = chart_state[\"panes\"][pane_key][series_id]\n        if isinstance(existing_config, SeriesConfigState):\n            stored_config = existing_config.config\n            # Apply stored config to series to preserve user changes\n            if hasattr(series, \"update\") and callable(series.update):\n                series.update(stored_config)\n            else:\n                # Fallback: set attributes directly\n                for key, value in stored_config.items():\n                    if hasattr(series, key):\n                        setattr(series, key, value)\n    else:\n        # First time registration - initialize with EMPTY config\n        # We only store user changes, not the default series state\n        # This prevents conflicts between stored defaults and user modifications\n        chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n            config={},  # Start empty - only store user changes\n            series_type=series.__class__.__name__.lower(),\n            last_modified=int(time.time()),\n        )\n\n    self._update_last_modified()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.get_pane_state","title":"get_pane_state","text":"<pre><code>get_pane_state(pane_id: int) -&gt; Dict[str, Any]\n</code></pre> <p>Get current state for a specific pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to get state for</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing pane state with series configurations</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_pane_state(self, pane_id: int) -&gt; Dict[str, Any]:\n    \"\"\"Get current state for a specific pane.\n\n    Args:\n        pane_id: The pane ID to get state for\n\n    Returns:\n        Dictionary containing pane state with series configurations\n    \"\"\"\n    chart_state = self._get_chart_state()\n    pane_key = str(pane_id)\n\n    if pane_key not in chart_state[\"panes\"]:\n        return {\"paneId\": pane_id, \"series\": {}}\n\n    # Convert SeriesConfigState objects to dicts\n    pane_series = {}\n    for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n        if isinstance(config_state, SeriesConfigState):\n            pane_series[series_id] = config_state.asdict()\n        else:\n            pane_series[series_id] = config_state\n\n    return {\n        \"paneId\": pane_id,\n        \"series\": pane_series,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.update_series_settings","title":"update_series_settings","text":"<pre><code>update_series_settings(pane_id: int, series_id: str, config_patch: Dict[str, Any]) -&gt; bool\n</code></pre> <p>Update series settings with a configuration patch.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID containing the series</p> required <code>series_id</code> <code>str</code> <p>The series ID to update</p> required <code>config_patch</code> <code>Dict[str, Any]</code> <p>Dictionary containing configuration updates</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if update was successful, False otherwise</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def update_series_settings(\n    self,\n    pane_id: int,\n    series_id: str,\n    config_patch: Dict[str, Any],\n) -&gt; bool:\n    \"\"\"Update series settings with a configuration patch.\n\n    Args:\n        pane_id: The pane ID containing the series\n        series_id: The series ID to update\n        config_patch: Dictionary containing configuration updates\n\n    Returns:\n        True if update was successful, False otherwise\n    \"\"\"\n    try:\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n\n        # Ensure pane exists\n        if pane_key not in chart_state[\"panes\"]:\n            chart_state[\"panes\"][pane_key] = {}\n\n        # Ensure series config exists\n        if series_id not in chart_state[\"panes\"][pane_key]:\n            chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                config={},\n                series_type=\"unknown\",\n                last_modified=int(time.time()),\n            )\n\n        # Get current config\n        current_state = chart_state[\"panes\"][pane_key][series_id]\n        if isinstance(current_state, SeriesConfigState):\n            current_config = current_state.config.copy()\n        else:\n            current_config = current_state.get(\"config\", {}).copy()\n\n        # Apply patch - handle nested structures like mainLine\n        for key, value in config_patch.items():\n            if isinstance(value, dict) and key in (\"mainLine\", \"lineOptions\", \"options\"):\n                # Flatten nested line options to top-level properties\n                for nested_key, nested_value in value.items():\n                    current_config[nested_key] = nested_value\n            else:\n                current_config[key] = value\n\n        # Clean up config: remove problematic nested structures and data\n        # We only want to store user-changeable UI properties, not data or defaults\n        cleaned_config = {\n            key: value\n            for key, value in current_config.items()\n            if key not in (\"data\", \"options\", \"lineOptions\", \"mainLine\")\n        }\n\n        # Update the stored configuration\n        chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n            config=cleaned_config,\n            series_type=(\n                current_state.series_type\n                if isinstance(current_state, SeriesConfigState)\n                else \"unknown\"\n            ),\n            last_modified=int(time.time()),\n        )\n\n        # Update the actual series object if available\n        if series_id in chart_state[\"series_refs\"]:\n            series_instance = chart_state[\"series_refs\"][series_id]\n            try:\n                # Use update() method which all Series classes have\n                if hasattr(series_instance, \"update\") and callable(series_instance.update):\n                    series_instance.update(config_patch)\n                else:\n                    # Fallback to setting attributes directly\n                    for key, value in config_patch.items():\n                        if hasattr(series_instance, key):\n                            setattr(series_instance, key, value)\n\n            except Exception as e:\n                logger.warning(\"Failed to update series instance %s: %s\", series_id, e)\n\n        self._update_last_modified()\n    except Exception:\n        logger.exception(\"Failed to update series settings\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.reset_series_to_defaults","title":"reset_series_to_defaults","text":"<pre><code>reset_series_to_defaults(pane_id: int, series_id: str) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Reset a series to its default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID containing the series</p> required <code>series_id</code> <code>str</code> <p>The series ID to reset</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary containing the default configuration, or None if failed</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def reset_series_to_defaults(\n    self,\n    pane_id: int,\n    series_id: str,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Reset a series to its default configuration.\n\n    Args:\n        pane_id: The pane ID containing the series\n        series_id: The series ID to reset\n\n    Returns:\n        Dictionary containing the default configuration, or None if failed\n    \"\"\"\n    try:\n        chart_state = self._get_chart_state()\n\n        # Get the series instance to determine defaults\n        if series_id in chart_state[\"series_refs\"]:\n            series_instance = chart_state[\"series_refs\"][series_id]\n\n            # Get default configuration based on series type\n            default_config = self._get_series_defaults(series_instance)\n\n            # Update the stored configuration\n            pane_key = str(pane_id)\n            if pane_key in chart_state[\"panes\"] and series_id in chart_state[\"panes\"][pane_key]:\n                chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                    config=default_config,\n                    series_type=series_instance.__class__.__name__.lower(),\n                    last_modified=int(time.time()),\n                )\n\n                # Update the series instance\n                if hasattr(series_instance, \"update\") and callable(series_instance.update):\n                    series_instance.update(default_config)\n\n                self._update_last_modified()\n                return default_config\n\n    except Exception:\n        logger.exception(\"Failed to reset series to defaults\")\n\n    return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.update_multiple_settings","title":"update_multiple_settings","text":"<pre><code>update_multiple_settings(patches: List[Dict[str, Any]]) -&gt; bool\n</code></pre> <p>Update multiple series settings in a batch operation.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>List[Dict[str, Any]]</code> <p>List of setting patches, each containing paneId, seriesId, and config</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all updates were successful, False otherwise</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def update_multiple_settings(\n    self,\n    patches: List[Dict[str, Any]],\n) -&gt; bool:\n    \"\"\"Update multiple series settings in a batch operation.\n\n    Args:\n        patches: List of setting patches, each containing paneId, seriesId, and config\n\n    Returns:\n        True if all updates were successful, False otherwise\n    \"\"\"\n    try:\n        success = True\n        for patch in patches:\n            pane_id = patch.get(\"paneId\", 0)\n            series_id = patch.get(\"seriesId\", \"\")\n            config = patch.get(\"config\", {})\n\n            if not self.update_series_settings(pane_id, series_id, config):\n                success = False\n                logger.warning(\"Failed to update series %s in pane %s\", series_id, pane_id)\n\n    except Exception:\n        logger.exception(\"Failed to update multiple settings\")\n        return False\n    else:\n        return success\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.get_all_series_info","title":"get_all_series_info","text":"<pre><code>get_all_series_info(pane_id: int) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get information about all series in a pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to get series info for</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries containing series information</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_all_series_info(self, pane_id: int) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get information about all series in a pane.\n\n    Args:\n        pane_id: The pane ID to get series info for\n\n    Returns:\n        List of dictionaries containing series information\n    \"\"\"\n    chart_state = self._get_chart_state()\n    pane_key = str(pane_id)\n    series_info = []\n\n    if pane_key in chart_state[\"panes\"]:\n        for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n            # Get series instance for display name\n            series_instance = chart_state[\"series_refs\"].get(series_id)\n            display_name = series_id\n\n            if series_instance:\n                # Try to get a more user-friendly name\n                if hasattr(series_instance, \"name\") and series_instance.name:\n                    display_name = series_instance.name\n                elif hasattr(series_instance, \"title\") and series_instance.title:\n                    display_name = series_instance.title\n\n            series_type = (\n                config_state.series_type\n                if isinstance(config_state, SeriesConfigState)\n                else \"unknown\"\n            )\n\n            series_info.append(\n                {\n                    \"id\": series_id,\n                    \"displayName\": display_name,\n                    \"type\": series_type,\n                },\n            )\n\n    return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.create_series_settings_api","title":"create_series_settings_api","text":"<pre><code>create_series_settings_api(chart_id: str = 'default') -&gt; SeriesSettingsAPI\n</code></pre> <p>Create a SeriesSettingsAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart</p> <code>'default'</code> <p>Returns:</p> Type Description <code>SeriesSettingsAPI</code> <p>SeriesSettingsAPI instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def create_series_settings_api(chart_id: str = \"default\") -&gt; SeriesSettingsAPI:\n    \"\"\"Create a SeriesSettingsAPI instance.\n\n    Args:\n        chart_id: Unique identifier for the chart\n\n    Returns:\n        SeriesSettingsAPI instance\n    \"\"\"\n    return SeriesSettingsAPI(chart_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.get_series_settings_api","title":"get_series_settings_api","text":"<pre><code>get_series_settings_api(chart_id: str = 'default') -&gt; SeriesSettingsAPI\n</code></pre> <p>Get or create a SeriesSettingsAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart</p> <code>'default'</code> <p>Returns:</p> Type Description <code>SeriesSettingsAPI</code> <p>SeriesSettingsAPI instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_series_settings_api(chart_id: str = \"default\") -&gt; SeriesSettingsAPI:\n    \"\"\"Get or create a SeriesSettingsAPI instance.\n\n    Args:\n        chart_id: Unique identifier for the chart\n\n    Returns:\n        SeriesSettingsAPI instance\n    \"\"\"\n    if chart_id not in _api_instances:\n        _api_instances[chart_id] = SeriesSettingsAPI(chart_id)\n    return _api_instances[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html","title":"streamlit_lightweight_charts_pro.charts.managers","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers","title":"managers","text":"<p>Manager classes for Chart component.</p> <p>This module provides specialized manager classes that handle different aspects of chart functionality, promoting separation of concerns and maintainability.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.ChartRenderer","title":"ChartRenderer","text":"<p>Manages chart rendering and frontend configuration.</p> <p>This class handles all rendering operations including: - Converting chart data to frontend configuration - Rendering the Streamlit component - Handling frontend responses - Managing data-aware range filtering</p> <p>Attributes:</p> Name Type Description <code>chart_manager_ref</code> <p>Optional reference to ChartManager for sync config.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>class ChartRenderer:\n    \"\"\"Manages chart rendering and frontend configuration.\n\n    This class handles all rendering operations including:\n    - Converting chart data to frontend configuration\n    - Rendering the Streamlit component\n    - Handling frontend responses\n    - Managing data-aware range filtering\n\n    Attributes:\n        chart_manager_ref: Optional reference to ChartManager for sync config.\n    \"\"\"\n\n    def __init__(self, chart_manager_ref: Optional[Any] = None):\n        \"\"\"Initialize the ChartRenderer.\n\n        Args:\n            chart_manager_ref: Optional reference to ChartManager for\n                synchronization configuration.\n        \"\"\"\n        self.chart_manager_ref = chart_manager_ref\n\n    def generate_frontend_config(\n        self,\n        chart_id: str,\n        chart_options: Any,\n        series_configs: List[Dict[str, Any]],\n        annotations_config: Dict[str, Any],\n        trades_config: Optional[Dict[str, Any]],\n        tooltip_configs: Optional[Dict[str, Any]],\n        chart_group_id: int,\n        price_scale_config: Dict[str, Any],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generate the complete frontend configuration.\n\n        Args:\n            chart_id: Unique identifier for the chart.\n            chart_options: Chart options configuration.\n            series_configs: List of series configurations.\n            annotations_config: Annotations configuration.\n            trades_config: Optional trades configuration.\n            tooltip_configs: Optional tooltip configurations.\n            chart_group_id: Chart group ID for synchronization.\n            price_scale_config: Price scale configurations.\n\n        Returns:\n            Complete frontend configuration dictionary.\n        \"\"\"\n        chart_config = chart_options.asdict() if chart_options is not None else {}\n\n        # Merge price scale configuration\n        chart_config.update(price_scale_config)\n\n        # Apply data-aware range filtering\n        chart_config = self._filter_range_switcher_by_data(\n            chart_config,\n            series_configs,\n        )\n\n        chart_obj: Dict[str, Any] = {\n            \"chartId\": chart_id,\n            \"chart\": chart_config,\n            \"series\": series_configs,\n            \"annotations\": annotations_config,\n        }\n\n        # Add trades configuration if present\n        if trades_config:\n            chart_obj.update(trades_config)\n\n        # Add tooltip configurations if present\n        if tooltip_configs:\n            chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n        # Add chart group ID\n        chart_obj[\"chartGroupId\"] = chart_group_id\n\n        config: Dict[str, Any] = {\n            \"charts\": [chart_obj],\n        }\n\n        # Add sync configuration if ChartManager reference is available\n        if self.chart_manager_ref is not None:\n            config[\"syncConfig\"] = self._get_sync_config(chart_group_id)\n\n        return config\n\n    def _get_sync_config(self, chart_group_id: int) -&gt; Dict[str, Any]:\n        \"\"\"Get synchronization configuration from ChartManager.\n\n        Args:\n            chart_group_id: Chart group ID to get sync config for.\n\n        Returns:\n            Synchronization configuration dictionary.\n        \"\"\"\n        group_sync_enabled = False\n        group_sync_config = None\n\n        if (\n            self.chart_manager_ref.sync_groups\n            and str(chart_group_id) in self.chart_manager_ref.sync_groups\n        ):\n            group_sync_config = self.chart_manager_ref.sync_groups[str(chart_group_id)]\n            group_sync_enabled = group_sync_config.enabled\n\n        sync_enabled = self.chart_manager_ref.default_sync.enabled or group_sync_enabled\n\n        sync_config: Dict[str, Any] = {\n            \"enabled\": sync_enabled,\n            \"crosshair\": self.chart_manager_ref.default_sync.crosshair,\n            \"timeRange\": self.chart_manager_ref.default_sync.time_range,\n        }\n\n        # Add group-specific sync configurations\n        if self.chart_manager_ref.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.chart_manager_ref.sync_groups.items():\n                sync_config[\"groups\"][str(group_id)] = {\n                    \"enabled\": group_sync.enabled,\n                    \"crosshair\": group_sync.crosshair,\n                    \"timeRange\": group_sync.time_range,\n                }\n\n        return sync_config\n\n    def _filter_range_switcher_by_data(\n        self,\n        chart_config: Dict[str, Any],\n        series_configs: List[Dict[str, Any]],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Filter range switcher options based on available data timespan.\n\n        Args:\n            chart_config: The chart configuration dictionary.\n            series_configs: List of series configurations.\n\n        Returns:\n            Modified chart configuration with filtered range options.\n        \"\"\"\n        # Only process if range switcher is configured\n        if not (chart_config.get(\"rangeSwitcher\") and chart_config[\"rangeSwitcher\"].get(\"ranges\")):\n            return chart_config\n\n        # Calculate data timespan from all series\n        data_timespan_seconds = self._calculate_data_timespan(series_configs)\n        if data_timespan_seconds is None:\n            return chart_config\n\n        # Filter ranges based on data timespan\n        original_ranges = chart_config[\"rangeSwitcher\"][\"ranges\"]\n        filtered_ranges = []\n\n        for range_config in original_ranges:\n            range_seconds = self._get_range_seconds(range_config)\n\n            # Keep range if it's \"All\" or within data timespan\n            if range_seconds is None or range_seconds &lt;= data_timespan_seconds * 1.1:\n                filtered_ranges.append(range_config)\n\n        chart_config[\"rangeSwitcher\"][\"ranges\"] = filtered_ranges\n        return chart_config\n\n    def _calculate_data_timespan(\n        self,\n        series_configs: List[Dict[str, Any]],\n    ) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\n\n        Args:\n            series_configs: List of series configurations with data.\n\n        Returns:\n            Timespan in seconds or None if unable to calculate.\n        \"\"\"\n        min_time = None\n        max_time = None\n\n        for series_config in series_configs:\n            data = series_config.get(\"data\", [])\n            if not data:\n                continue\n\n            for data_point in data:\n                time_value = None\n\n                # Extract time from various data formats\n                if isinstance(data_point, dict) and \"time\" in data_point:\n                    time_value = data_point[\"time\"]\n                elif hasattr(data_point, \"time\"):\n                    time_value = data_point.time\n\n                if time_value is None:\n                    continue\n\n                # Convert time to timestamp\n                timestamp = self._convert_time_to_timestamp(time_value)\n                if timestamp is None:\n                    continue\n\n                if min_time is None or timestamp &lt; min_time:\n                    min_time = timestamp\n                if max_time is None or timestamp &gt; max_time:\n                    max_time = timestamp\n\n        if min_time is None or max_time is None:\n            return None\n\n        return max_time - min_time\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\n\n        Args:\n            time_value: Time value in various formats.\n\n        Returns:\n            Timestamp in seconds or None if conversion fails.\n        \"\"\"\n        if isinstance(time_value, (int, float)):\n            return float(time_value)\n        if isinstance(time_value, str):\n            try:\n                dt = datetime.fromisoformat(time_value.replace(\"Z\", \"+00:00\"))\n                return dt.timestamp()\n            except (ValueError, AttributeError):\n                try:\n                    dt = datetime.strptime(time_value, \"%Y-%m-%d\")\n                    return dt.timestamp()\n                except ValueError:\n                    return None\n        elif hasattr(time_value, \"timestamp\"):\n            return time_value.timestamp()\n        return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\n\n        Args:\n            range_config: Range configuration dictionary.\n\n        Returns:\n            Number of seconds in the range or None for \"ALL\".\n        \"\"\"\n        range_value = range_config.get(\"range\")\n\n        if range_value is None or range_value == \"ALL\":\n            return None\n\n        range_seconds_map = {\n            \"FIVE_MINUTES\": 300,\n            \"FIFTEEN_MINUTES\": 900,\n            \"THIRTY_MINUTES\": 1800,\n            \"ONE_HOUR\": 3600,\n            \"FOUR_HOURS\": 14400,\n            \"ONE_DAY\": 86400,\n            \"ONE_WEEK\": 604800,\n            \"TWO_WEEKS\": 1209600,\n            \"ONE_MONTH\": 2592000,\n            \"THREE_MONTHS\": 7776000,\n            \"SIX_MONTHS\": 15552000,\n            \"ONE_YEAR\": 31536000,\n            \"TWO_YEARS\": 63072000,\n            \"FIVE_YEARS\": 157680000,\n        }\n\n        if isinstance(range_value, str) and range_value in range_seconds_map:\n            return range_seconds_map[range_value]\n        if isinstance(range_value, (int, float)):\n            return float(range_value)\n\n        return None\n\n    def render(\n        self,\n        config: Dict[str, Any],\n        key: str,\n        chart_options: Any,\n    ) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Args:\n            config: Complete frontend configuration.\n            key: Unique key for the Streamlit component (already validated).\n            chart_options: Chart options for extracting height/width.\n\n        Returns:\n            The rendered Streamlit component.\n\n        Raises:\n            ComponentNotAvailableError: If component cannot be loaded.\n        \"\"\"\n        # Get component function\n        component_func = get_component_func()\n\n        if component_func is None:\n            if reinitialize_component():\n                component_func = get_component_func()\n\n            if component_func is None:\n                raise ComponentNotAvailableError()\n\n        # Build component kwargs\n        kwargs: Dict[str, Any] = {\"config\": config}\n\n        # Extract height and width from chart options\n        if chart_options:\n            if hasattr(chart_options, \"height\") and chart_options.height is not None:\n                kwargs[\"height\"] = chart_options.height\n            if hasattr(chart_options, \"width\") and chart_options.width is not None:\n                kwargs[\"width\"] = chart_options.width\n\n        kwargs[\"key\"] = key\n        kwargs[\"default\"] = None\n\n        # Render component\n        return component_func(**kwargs)\n\n    def handle_response(\n        self,\n        response: Any,\n        key: str,\n        session_state_manager: Any,\n    ) -&gt; None:\n        \"\"\"Handle component return value and save series configs.\n\n        Args:\n            response: Response data from the frontend component.\n            key: Component key for session state.\n            session_state_manager: SessionStateManager for config persistence.\n        \"\"\"\n        if response and isinstance(response, dict):\n            # Check if we have series config changes from the frontend\n            if response.get(\"type\") == \"series_config_changes\":\n                changes = response.get(\"changes\", [])\n                if changes:\n                    # Build a dictionary of all current series configs\n                    series_configs = {}\n                    for change in changes:\n                        series_id = change.get(\"seriesId\")\n                        config = change.get(\"config\")\n                        if series_id and config:\n                            series_configs[series_id] = config\n\n                    # Save to session state\n                    if series_configs:\n                        session_state_manager.save_series_configs(key, series_configs)\n\n            # Handle series settings API responses\n            series_api = get_series_settings_api(key)\n            self._handle_series_settings_response(response, series_api)\n\n    def _handle_series_settings_response(self, response: dict, series_api) -&gt; None:\n        \"\"\"Handle series settings API responses from the frontend.\n\n        Args:\n            response: Response data from the frontend component.\n            series_api: SeriesSettingsAPI instance for this chart.\n        \"\"\"\n        try:\n            if response.get(\"type\") == \"get_pane_state\":\n                pane_id = response.get(\"paneId\", 0)\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    pane_state = series_api.get_pane_state(pane_id)\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": True, \"data\": pane_state})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"update_series_settings\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                config = response.get(\"config\", {})\n                message_id = response.get(\"messageId\")\n\n                success = series_api.update_series_settings(pane_id, series_id, config)\n\n                if message_id:\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"reset_series_defaults\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    defaults = series_api.reset_series_to_defaults(pane_id, series_id)\n                    success = defaults is not None\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success, \"data\": defaults or {}})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"series_config_changes\":\n                changes = response.get(\"changes\", [])\n\n                for change in changes:\n                    pane_id = change.get(\"paneId\", 0)\n                    series_id = change.get(\"seriesId\", \"\")\n                    config = change.get(\"config\", {})\n\n                    if series_id and config:\n                        success = series_api.update_series_settings(pane_id, series_id, config)\n                        if not success:\n                            logger.warning(\"Failed to store config for series %s\", series_id)\n                    else:\n                        logger.warning(\"Skipping invalid change (missing seriesId or config)\")\n\n        except Exception:\n            logger.exception(\"Error handling series settings response\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.ChartRenderer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.ChartRenderer.generate_frontend_config","title":"generate_frontend_config","text":"<pre><code>generate_frontend_config(chart_id: str, chart_options: Any, series_configs: List[Dict[str, Any]], annotations_config: Dict[str, Any], trades_config: Optional[Dict[str, Any]], tooltip_configs: Optional[Dict[str, Any]], chart_group_id: int, price_scale_config: Dict[str, Any]) -&gt; Dict[str, Any]\n</code></pre> <p>Generate the complete frontend configuration.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart.</p> required <code>chart_options</code> <code>Any</code> <p>Chart options configuration.</p> required <code>series_configs</code> <code>List[Dict[str, Any]]</code> <p>List of series configurations.</p> required <code>annotations_config</code> <code>Dict[str, Any]</code> <p>Annotations configuration.</p> required <code>trades_config</code> <code>Optional[Dict[str, Any]]</code> <p>Optional trades configuration.</p> required <code>tooltip_configs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional tooltip configurations.</p> required <code>chart_group_id</code> <code>int</code> <p>Chart group ID for synchronization.</p> required <code>price_scale_config</code> <code>Dict[str, Any]</code> <p>Price scale configurations.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Complete frontend configuration dictionary.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def generate_frontend_config(\n    self,\n    chart_id: str,\n    chart_options: Any,\n    series_configs: List[Dict[str, Any]],\n    annotations_config: Dict[str, Any],\n    trades_config: Optional[Dict[str, Any]],\n    tooltip_configs: Optional[Dict[str, Any]],\n    chart_group_id: int,\n    price_scale_config: Dict[str, Any],\n) -&gt; Dict[str, Any]:\n    \"\"\"Generate the complete frontend configuration.\n\n    Args:\n        chart_id: Unique identifier for the chart.\n        chart_options: Chart options configuration.\n        series_configs: List of series configurations.\n        annotations_config: Annotations configuration.\n        trades_config: Optional trades configuration.\n        tooltip_configs: Optional tooltip configurations.\n        chart_group_id: Chart group ID for synchronization.\n        price_scale_config: Price scale configurations.\n\n    Returns:\n        Complete frontend configuration dictionary.\n    \"\"\"\n    chart_config = chart_options.asdict() if chart_options is not None else {}\n\n    # Merge price scale configuration\n    chart_config.update(price_scale_config)\n\n    # Apply data-aware range filtering\n    chart_config = self._filter_range_switcher_by_data(\n        chart_config,\n        series_configs,\n    )\n\n    chart_obj: Dict[str, Any] = {\n        \"chartId\": chart_id,\n        \"chart\": chart_config,\n        \"series\": series_configs,\n        \"annotations\": annotations_config,\n    }\n\n    # Add trades configuration if present\n    if trades_config:\n        chart_obj.update(trades_config)\n\n    # Add tooltip configurations if present\n    if tooltip_configs:\n        chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n    # Add chart group ID\n    chart_obj[\"chartGroupId\"] = chart_group_id\n\n    config: Dict[str, Any] = {\n        \"charts\": [chart_obj],\n    }\n\n    # Add sync configuration if ChartManager reference is available\n    if self.chart_manager_ref is not None:\n        config[\"syncConfig\"] = self._get_sync_config(chart_group_id)\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.ChartRenderer.render","title":"render","text":"<pre><code>render(config: Dict[str, Any], key: str, chart_options: Any) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, Any]</code> <p>Complete frontend configuration.</p> required <code>key</code> <code>str</code> <p>Unique key for the Streamlit component (already validated).</p> required <code>chart_options</code> <code>Any</code> <p>Chart options for extracting height/width.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The rendered Streamlit component.</p> <p>Raises:</p> Type Description <code>ComponentNotAvailableError</code> <p>If component cannot be loaded.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def render(\n    self,\n    config: Dict[str, Any],\n    key: str,\n    chart_options: Any,\n) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Args:\n        config: Complete frontend configuration.\n        key: Unique key for the Streamlit component (already validated).\n        chart_options: Chart options for extracting height/width.\n\n    Returns:\n        The rendered Streamlit component.\n\n    Raises:\n        ComponentNotAvailableError: If component cannot be loaded.\n    \"\"\"\n    # Get component function\n    component_func = get_component_func()\n\n    if component_func is None:\n        if reinitialize_component():\n            component_func = get_component_func()\n\n        if component_func is None:\n            raise ComponentNotAvailableError()\n\n    # Build component kwargs\n    kwargs: Dict[str, Any] = {\"config\": config}\n\n    # Extract height and width from chart options\n    if chart_options:\n        if hasattr(chart_options, \"height\") and chart_options.height is not None:\n            kwargs[\"height\"] = chart_options.height\n        if hasattr(chart_options, \"width\") and chart_options.width is not None:\n            kwargs[\"width\"] = chart_options.width\n\n    kwargs[\"key\"] = key\n    kwargs[\"default\"] = None\n\n    # Render component\n    return component_func(**kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.ChartRenderer.handle_response","title":"handle_response","text":"<pre><code>handle_response(response: Any, key: str, session_state_manager: Any) -&gt; None\n</code></pre> <p>Handle component return value and save series configs.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Any</code> <p>Response data from the frontend component.</p> required <code>key</code> <code>str</code> <p>Component key for session state.</p> required <code>session_state_manager</code> <code>Any</code> <p>SessionStateManager for config persistence.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def handle_response(\n    self,\n    response: Any,\n    key: str,\n    session_state_manager: Any,\n) -&gt; None:\n    \"\"\"Handle component return value and save series configs.\n\n    Args:\n        response: Response data from the frontend component.\n        key: Component key for session state.\n        session_state_manager: SessionStateManager for config persistence.\n    \"\"\"\n    if response and isinstance(response, dict):\n        # Check if we have series config changes from the frontend\n        if response.get(\"type\") == \"series_config_changes\":\n            changes = response.get(\"changes\", [])\n            if changes:\n                # Build a dictionary of all current series configs\n                series_configs = {}\n                for change in changes:\n                    series_id = change.get(\"seriesId\")\n                    config = change.get(\"config\")\n                    if series_id and config:\n                        series_configs[series_id] = config\n\n                # Save to session state\n                if series_configs:\n                    session_state_manager.save_series_configs(key, series_configs)\n\n        # Handle series settings API responses\n        series_api = get_series_settings_api(key)\n        self._handle_series_settings_response(response, series_api)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager","title":"PriceScaleManager","text":"<p>Manages price scale configurations for a Chart.</p> <p>This class handles all price scale operations including: - Managing left and right price scales - Managing overlay price scales - Validating price scale configurations</p> <p>Attributes:</p> Name Type Description <code>left_price_scale</code> <p>Left price scale configuration.</p> <code>right_price_scale</code> <p>Right price scale configuration.</p> <code>overlay_price_scales</code> <p>Dictionary of overlay price scale configurations.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>class PriceScaleManager:\n    \"\"\"Manages price scale configurations for a Chart.\n\n    This class handles all price scale operations including:\n    - Managing left and right price scales\n    - Managing overlay price scales\n    - Validating price scale configurations\n\n    Attributes:\n        left_price_scale: Left price scale configuration.\n        right_price_scale: Right price scale configuration.\n        overlay_price_scales: Dictionary of overlay price scale configurations.\n    \"\"\"\n\n    def __init__(\n        self,\n        left_price_scale: Optional[PriceScaleOptions] = None,\n        right_price_scale: Optional[PriceScaleOptions] = None,\n        overlay_price_scales: Optional[Dict[str, PriceScaleOptions]] = None,\n    ):\n        \"\"\"Initialize the PriceScaleManager.\n\n        Args:\n            left_price_scale: Optional left price scale configuration.\n            right_price_scale: Optional right price scale configuration.\n            overlay_price_scales: Optional dictionary of overlay price scales.\n        \"\"\"\n        self.left_price_scale = left_price_scale\n        self.right_price_scale = right_price_scale\n        self.overlay_price_scales = overlay_price_scales or {}\n\n    def add_overlay_scale(\n        self,\n        scale_id: str,\n        options: PriceScaleOptions,\n    ) -&gt; None:\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Args:\n            scale_id: The unique identifier for the custom price scale.\n            options: A PriceScaleOptions instance containing the configuration.\n\n        Raises:\n            ValueValidationError: If scale_id is not a non-empty string.\n            TypeValidationError: If options is None or not a PriceScaleOptions instance.\n        \"\"\"\n        if not scale_id or not isinstance(scale_id, str):\n            raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n        if options is None:\n            raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n        if not isinstance(options, PriceScaleOptions):\n            raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n        # Ensure the price_scale_id field matches the scale_id parameter\n        options.price_scale_id = scale_id\n\n        # Update or add the overlay price scale\n        self.overlay_price_scales[scale_id] = options\n\n    def has_overlay_scale(self, scale_id: str) -&gt; bool:\n        \"\"\"Check if an overlay price scale exists.\n\n        Args:\n            scale_id: The unique identifier for the custom price scale.\n\n        Returns:\n            True if the overlay price scale exists, False otherwise.\n        \"\"\"\n        return scale_id in self.overlay_price_scales\n\n    def configure_for_volume(self) -&gt; None:\n        \"\"\"Configure right price scale margins for volume overlay.\n\n        Sets the right price scale margins to leave space for volume\n        visualization at the bottom of the chart.\n        \"\"\"\n        if self.right_price_scale is not None:\n            # Explicitly set visible=True to ensure it's serialized\n            self.right_price_scale.visible = True\n            self.right_price_scale.scale_margins = PriceScaleMargins(\n                top=0.1,  # 10% margin at top\n                bottom=0.25,  # 25% margin at bottom (leaves room for volume overlay)\n            )\n\n    def validate_and_serialize(self) -&gt; Dict[str, any]:\n        \"\"\"Validate and serialize price scale configurations.\n\n        Returns:\n            Dictionary of serialized price scale configurations.\n\n        Raises:\n            PriceScaleIdTypeError: If price_scale_id is not a string.\n            PriceScaleOptionsTypeError: If price scale is not a valid type.\n        \"\"\"\n        result = {}\n\n        # Serialize right price scale\n        if self.right_price_scale is not None:\n            try:\n                result[\"rightPriceScale\"] = self.right_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.right_price_scale.price_scale_id is not None and not isinstance(\n                    self.right_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"right_price_scale\",\n                        type(self.right_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.right_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"right_price_scale\",\n                        type(self.right_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale),\n                ) from e\n\n        # Serialize left price scale\n        if self.left_price_scale is not None:\n            try:\n                result[\"leftPriceScale\"] = self.left_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.left_price_scale.price_scale_id is not None and not isinstance(\n                    self.left_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"left_price_scale\",\n                        type(self.left_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.left_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"left_price_scale\",\n                        type(self.left_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale),\n                ) from e\n\n        # Serialize overlay price scales\n        if self.overlay_price_scales:\n            result[\"overlayPriceScales\"] = {\n                k: v.asdict() if hasattr(v, \"asdict\") else v\n                for k, v in self.overlay_price_scales.items()\n            }\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager.add_overlay_scale","title":"add_overlay_scale","text":"<pre><code>add_overlay_scale(scale_id: str, options: PriceScaleOptions) -&gt; None\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale.</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration.</p> required <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If scale_id is not a non-empty string.</p> <code>TypeValidationError</code> <p>If options is None or not a PriceScaleOptions instance.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def add_overlay_scale(\n    self,\n    scale_id: str,\n    options: PriceScaleOptions,\n) -&gt; None:\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Args:\n        scale_id: The unique identifier for the custom price scale.\n        options: A PriceScaleOptions instance containing the configuration.\n\n    Raises:\n        ValueValidationError: If scale_id is not a non-empty string.\n        TypeValidationError: If options is None or not a PriceScaleOptions instance.\n    \"\"\"\n    if not scale_id or not isinstance(scale_id, str):\n        raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n    if options is None:\n        raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n    if not isinstance(options, PriceScaleOptions):\n        raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n    # Ensure the price_scale_id field matches the scale_id parameter\n    options.price_scale_id = scale_id\n\n    # Update or add the overlay price scale\n    self.overlay_price_scales[scale_id] = options\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager.has_overlay_scale","title":"has_overlay_scale","text":"<pre><code>has_overlay_scale(scale_id: str) -&gt; bool\n</code></pre> <p>Check if an overlay price scale exists.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the overlay price scale exists, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def has_overlay_scale(self, scale_id: str) -&gt; bool:\n    \"\"\"Check if an overlay price scale exists.\n\n    Args:\n        scale_id: The unique identifier for the custom price scale.\n\n    Returns:\n        True if the overlay price scale exists, False otherwise.\n    \"\"\"\n    return scale_id in self.overlay_price_scales\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager.configure_for_volume","title":"configure_for_volume","text":"<pre><code>configure_for_volume() -&gt; None\n</code></pre> <p>Configure right price scale margins for volume overlay.</p> <p>Sets the right price scale margins to leave space for volume visualization at the bottom of the chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def configure_for_volume(self) -&gt; None:\n    \"\"\"Configure right price scale margins for volume overlay.\n\n    Sets the right price scale margins to leave space for volume\n    visualization at the bottom of the chart.\n    \"\"\"\n    if self.right_price_scale is not None:\n        # Explicitly set visible=True to ensure it's serialized\n        self.right_price_scale.visible = True\n        self.right_price_scale.scale_margins = PriceScaleMargins(\n            top=0.1,  # 10% margin at top\n            bottom=0.25,  # 25% margin at bottom (leaves room for volume overlay)\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.PriceScaleManager.validate_and_serialize","title":"validate_and_serialize","text":"<pre><code>validate_and_serialize() -&gt; Dict[str, any]\n</code></pre> <p>Validate and serialize price scale configurations.</p> <p>Returns:</p> Type Description <code>Dict[str, any]</code> <p>Dictionary of serialized price scale configurations.</p> <p>Raises:</p> Type Description <code>PriceScaleIdTypeError</code> <p>If price_scale_id is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale is not a valid type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def validate_and_serialize(self) -&gt; Dict[str, any]:\n    \"\"\"Validate and serialize price scale configurations.\n\n    Returns:\n        Dictionary of serialized price scale configurations.\n\n    Raises:\n        PriceScaleIdTypeError: If price_scale_id is not a string.\n        PriceScaleOptionsTypeError: If price scale is not a valid type.\n    \"\"\"\n    result = {}\n\n    # Serialize right price scale\n    if self.right_price_scale is not None:\n        try:\n            result[\"rightPriceScale\"] = self.right_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.right_price_scale.price_scale_id is not None and not isinstance(\n                self.right_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.right_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale),\n            ) from e\n\n    # Serialize left price scale\n    if self.left_price_scale is not None:\n        try:\n            result[\"leftPriceScale\"] = self.left_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.left_price_scale.price_scale_id is not None and not isinstance(\n                self.left_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.left_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale),\n            ) from e\n\n    # Serialize overlay price scales\n    if self.overlay_price_scales:\n        result[\"overlayPriceScales\"] = {\n            k: v.asdict() if hasattr(v, \"asdict\") else v\n            for k, v in self.overlay_price_scales.items()\n        }\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager","title":"SeriesManager","text":"<p>Manages series operations for a Chart.</p> <p>This class handles all series-related operations including: - Adding and validating series - Managing series list - Handling series configuration - Creating complex series combinations (e.g., price + volume)</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects managed by this instance.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>class SeriesManager:\n    \"\"\"Manages series operations for a Chart.\n\n    This class handles all series-related operations including:\n    - Adding and validating series\n    - Managing series list\n    - Handling series configuration\n    - Creating complex series combinations (e.g., price + volume)\n\n    Attributes:\n        series (List[Series]): List of series objects managed by this instance.\n    \"\"\"\n\n    def __init__(self, series: Optional[Union[Series, List[Series]]] = None):\n        \"\"\"Initialize the SeriesManager.\n\n        Args:\n            series: Optional single series object or list of series objects.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list.\n        \"\"\"\n        # Handle series input - convert to list for uniform processing\n        if series is None:\n            self.series = []\n        elif isinstance(series, Series):\n            self.series = [series]\n        elif isinstance(series, list):\n            for item in series:\n                if not isinstance(item, Series):\n                    raise SeriesItemsTypeError()\n            self.series = series\n        else:\n            raise TypeValidationError(\"series\", \"Series instance or list\")\n\n    def add_series(\n        self,\n        series: Series,\n        price_scale_manager: Optional[Any] = None,\n        auto_create_price_scales: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a series to the managed list.\n\n        This method now supports auto-creation of price scales to align with\n        TradingView's official API behavior. When a series references a custom\n        price_scale_id that doesn't exist, it will be automatically created with\n        smart defaults based on context (overlay vs separate pane).\n\n        Args:\n            series: Series object to add.\n            price_scale_manager: Optional PriceScaleManager to handle custom\n                price scales.\n            auto_create_price_scales: Whether to auto-create price scales when\n                series references non-existent scale IDs (default: True).\n                This aligns with TradingView's official API behavior.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n        \"\"\"\n        if not isinstance(series, Series):\n            raise TypeValidationError(\"series\", \"Series instance\")\n\n        # Check for custom price scale configuration needs\n        price_scale_id = series.price_scale_id  # type: ignore[attr-defined]\n\n        # Handle custom price scale setup with manager if provided\n        if (\n            price_scale_id\n            and price_scale_id not in [\"left\", \"right\", \"\"]\n            and price_scale_manager is not None\n            and not price_scale_manager.has_overlay_scale(price_scale_id)\n        ):\n            if auto_create_price_scales:\n                # Auto-create price scale if it doesn't exist (TradingView API behavior)\n                # Create price scale with smart defaults\n                auto_scale = self._create_auto_price_scale(series, price_scale_id)\n                price_scale_manager.add_overlay_scale(price_scale_id, auto_scale)\n\n                logger.info(\n                    \"Auto-created price scale '%s' for series (visible=%s, \"\n                    \"auto_scale=%s). This aligns with TradingView's official API behavior.\",\n                    price_scale_id,\n                    auto_scale.visible,\n                    auto_scale.auto_scale,\n                )\n            else:\n                # Fallback to old behavior (empty scale with warning)\n                logger.warning(\n                    \"Series with price_scale_id '%s' does not have a corresponding \"\n                    \"overlay price scale configuration. Creating empty price scale object.\",\n                    price_scale_id,\n                )\n                empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n                price_scale_manager.add_overlay_scale(price_scale_id, empty_scale)\n\n        self.series.append(series)\n\n    def _create_auto_price_scale(\n        self,\n        series: Series,\n        scale_id: str,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale with smart defaults based on series type and pane.\n\n        This method implements TradingView's auto-creation behavior by analyzing\n        the context to determine if this is an overlay series or a separate pane series.\n\n        Args:\n            series: The series being added.\n            scale_id: The price scale ID to create.\n\n        Returns:\n            PriceScaleOptions configured with smart defaults.\n        \"\"\"\n        # Determine if this is an overlay or separate pane\n        is_overlay = self._is_overlay_series(series)\n\n        # Create price scale with context-aware defaults\n        return PriceScaleOptions(\n            price_scale_id=scale_id,\n            visible=not is_overlay,  # Hide for overlays, show for separate panes\n            auto_scale=True,\n            mode=PriceScaleMode.NORMAL,\n            scale_margins=PriceScaleMargins(\n                top=0.8 if is_overlay else 0.1,  # Large top margin for overlays\n                bottom=0.0 if is_overlay else 0.1,\n            ),\n        )\n\n    def _is_overlay_series(self, series: Series) -&gt; bool:\n        \"\"\"Determine if series is an overlay in same pane as another series.\n\n        A series is considered an overlay if:\n        - It's in the same pane as an existing series\n        - That existing series uses a built-in scale ('left', 'right', '')\n        - The new series uses a different scale ID\n\n        Args:\n            series: The series to check.\n\n        Returns:\n            True if series is an overlay, False if it's in a separate pane.\n        \"\"\"\n        series_pane_id = getattr(series, \"pane_id\", 0)\n        series_price_scale_id = getattr(series, \"price_scale_id\", \"\")\n\n        # Check if there's already a series in same pane with different scale\n        for existing in self.series:\n            existing_pane_id = getattr(existing, \"pane_id\", 0)\n            existing_price_scale_id = getattr(existing, \"price_scale_id\", \"\")\n\n            if (\n                existing_pane_id == series_pane_id\n                and existing_price_scale_id != series_price_scale_id\n                and existing_price_scale_id in (\"left\", \"right\", \"\")\n            ):\n                return True  # This is an overlay\n\n        return False  # This is the primary series in its pane\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict],\n        price_type: str = \"candlestick\",\n        price_kwargs: Optional[dict] = None,\n        volume_kwargs: Optional[dict] = None,\n        pane_id: int = 0,\n        price_scale_manager: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale.\n\n        Args:\n            data: OHLCV data containing price and volume information.\n            column_mapping: Mapping of column names for DataFrame conversion.\n            price_type: Type of price series ('candlestick' or 'line').\n            price_kwargs: Additional arguments for price series configuration.\n            volume_kwargs: Additional arguments for volume series configuration.\n            pane_id: Pane ID for both price and volume series.\n            price_scale_manager: Optional PriceScaleManager for price scale config.\n\n        Raises:\n            TypeValidationError: If data or column_mapping is invalid.\n            ValueValidationError: If data is empty or price_type is invalid.\n        \"\"\"\n        # Validate inputs\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)) or (\n            isinstance(data, list) and len(data) == 0\n        ):\n            raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n        if column_mapping is None:\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n        if not isinstance(column_mapping, dict):\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n\n        if pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n        price_kwargs = price_kwargs or {}\n        volume_kwargs = volume_kwargs or {}\n\n        # Price series creation\n        price_series: Union[CandlestickSeries, LineSeries]\n        if price_type == \"candlestick\":\n            price_column_mapping = {\n                k: v\n                for k, v in column_mapping.items()\n                if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n            }\n            price_series = CandlestickSeries(\n                data=data,\n                column_mapping=price_column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n        elif price_type == \"line\":\n            price_series = LineSeries(\n                data=data,\n                column_mapping=column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n        else:\n            raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n        price_series._display_name = \"Price\"  # pylint: disable=protected-access\n\n        # Extract volume-specific kwargs\n        volume_up_color = volume_kwargs.get(\"up_color\", HISTOGRAM_UP_COLOR_DEFAULT)\n        volume_down_color = volume_kwargs.get(\"down_color\", HISTOGRAM_DOWN_COLOR_DEFAULT)\n        volume_base = volume_kwargs.get(\"base\", 0)\n\n        # Configure volume price scale through manager if provided\n        if price_scale_manager is not None:\n            volume_price_scale = PriceScaleOptions(\n                visible=False,\n                auto_scale=True,\n                border_visible=False,\n                mode=PriceScaleMode.NORMAL,\n                scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n                price_scale_id=ColumnNames.VOLUME.value,\n            )\n            price_scale_manager.add_overlay_scale(ColumnNames.VOLUME.value, volume_price_scale)\n\n        # Ensure volume mapping includes 'value' key\n        if \"value\" not in column_mapping:\n            column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n        # Create histogram series for volume\n        volume_series = HistogramSeries.create_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            up_color=volume_up_color,\n            down_color=volume_down_color,\n            pane_id=pane_id,\n            price_scale_id=ColumnNames.VOLUME.value,\n        )\n\n        # Set volume-specific properties\n        volume_series.base = volume_base  # type: ignore[attr-defined]\n        volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}  # type: ignore[attr-defined]\n        volume_series._display_name = \"Volume\"  # pylint: disable=protected-access\n\n        # Add both series\n        self.add_series(price_series, price_scale_manager)\n        self.add_series(volume_series, price_scale_manager)\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for a specific pane.\n\n        Args:\n            pane_id: The pane ID to get series info for (default: 0).\n\n        Returns:\n            List of series information dictionaries.\n        \"\"\"\n        series_info = []\n\n        for i, series in enumerate(self.series):\n            # Get series ID\n            series_id = getattr(series, \"id\", f\"series_{i}\")\n\n            # Get display name\n            display_name = series_id\n            if hasattr(series, \"name\") and series.name:\n                display_name = series.name\n            elif hasattr(series, \"title\") and series.title:\n                display_name = series.title\n\n            # Get series type\n            series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n            series_info.append(\n                {\n                    \"id\": series_id,\n                    \"displayName\": display_name,\n                    \"type\": series_type,\n                },\n            )\n\n        return series_info\n\n    def to_frontend_configs(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Convert all series to frontend configuration dictionaries.\n\n        Groups series by pane and sorts by z-index for proper layering.\n\n        Returns:\n            List of series configuration dictionaries.\n        \"\"\"\n        # Group series by pane_id and sort by z_index within each pane\n        series_by_pane: Dict[int, List[Dict[str, Any]]] = {}\n\n        for series in self.series:\n            series_config = series.asdict()\n\n            # Handle case where asdict() returns invalid data\n            if not isinstance(series_config, dict):\n                logger.warning(\n                    \"Series %s returned invalid configuration from asdict(): %s. \"\n                    \"Skipping z-index ordering for this series.\",\n                    type(series).__name__,\n                    series_config,\n                )\n                # Add to default pane with default z-index\n                if 0 not in series_by_pane:\n                    series_by_pane[0] = []\n                series_by_pane[0].append(series_config)\n                continue\n\n            pane_id = series_config.get(\"paneId\", 0)\n\n            if pane_id not in series_by_pane:\n                series_by_pane[pane_id] = []\n\n            series_by_pane[pane_id].append(series_config)\n\n        # Sort series within each pane by z_index\n        for series_list in series_by_pane.values():\n            series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n        # Flatten sorted series back to a single list, maintaining pane order\n        series_configs = []\n        for pane_id in sorted(series_by_pane.keys()):\n            series_configs.extend(series_by_pane[pane_id])\n\n        return series_configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager.add_series","title":"add_series","text":"<pre><code>add_series(series: Series, price_scale_manager: Optional[Any] = None, auto_create_price_scales: bool = True) -&gt; None\n</code></pre> <p>Add a series to the managed list.</p> <p>This method now supports auto-creation of price scales to align with TradingView's official API behavior. When a series references a custom price_scale_id that doesn't exist, it will be automatically created with smart defaults based on context (overlay vs separate pane).</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add.</p> required <code>price_scale_manager</code> <code>Optional[Any]</code> <p>Optional PriceScaleManager to handle custom price scales.</p> <code>None</code> <code>auto_create_price_scales</code> <code>bool</code> <p>Whether to auto-create price scales when series references non-existent scale IDs (default: True). This aligns with TradingView's official API behavior.</p> <code>True</code> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def add_series(\n    self,\n    series: Series,\n    price_scale_manager: Optional[Any] = None,\n    auto_create_price_scales: bool = True,\n) -&gt; None:\n    \"\"\"Add a series to the managed list.\n\n    This method now supports auto-creation of price scales to align with\n    TradingView's official API behavior. When a series references a custom\n    price_scale_id that doesn't exist, it will be automatically created with\n    smart defaults based on context (overlay vs separate pane).\n\n    Args:\n        series: Series object to add.\n        price_scale_manager: Optional PriceScaleManager to handle custom\n            price scales.\n        auto_create_price_scales: Whether to auto-create price scales when\n            series references non-existent scale IDs (default: True).\n            This aligns with TradingView's official API behavior.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n    \"\"\"\n    if not isinstance(series, Series):\n        raise TypeValidationError(\"series\", \"Series instance\")\n\n    # Check for custom price scale configuration needs\n    price_scale_id = series.price_scale_id  # type: ignore[attr-defined]\n\n    # Handle custom price scale setup with manager if provided\n    if (\n        price_scale_id\n        and price_scale_id not in [\"left\", \"right\", \"\"]\n        and price_scale_manager is not None\n        and not price_scale_manager.has_overlay_scale(price_scale_id)\n    ):\n        if auto_create_price_scales:\n            # Auto-create price scale if it doesn't exist (TradingView API behavior)\n            # Create price scale with smart defaults\n            auto_scale = self._create_auto_price_scale(series, price_scale_id)\n            price_scale_manager.add_overlay_scale(price_scale_id, auto_scale)\n\n            logger.info(\n                \"Auto-created price scale '%s' for series (visible=%s, \"\n                \"auto_scale=%s). This aligns with TradingView's official API behavior.\",\n                price_scale_id,\n                auto_scale.visible,\n                auto_scale.auto_scale,\n            )\n        else:\n            # Fallback to old behavior (empty scale with warning)\n            logger.warning(\n                \"Series with price_scale_id '%s' does not have a corresponding \"\n                \"overlay price scale configuration. Creating empty price scale object.\",\n                price_scale_id,\n            )\n            empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n            price_scale_manager.add_overlay_scale(price_scale_id, empty_scale)\n\n    self.series.append(series)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict], price_type: str = 'candlestick', price_kwargs: Optional[dict] = None, volume_kwargs: Optional[dict] = None, pane_id: int = 0, price_scale_manager: Optional[Any] = None) -&gt; None\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>Optional[dict]</code> <p>Mapping of column names for DataFrame conversion.</p> required <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line').</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>Optional[dict]</code> <p>Additional arguments for price series configuration.</p> <code>None</code> <code>volume_kwargs</code> <code>Optional[dict]</code> <p>Additional arguments for volume series configuration.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series.</p> <code>0</code> <code>price_scale_manager</code> <code>Optional[Any]</code> <p>Optional PriceScaleManager for price scale config.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If data or column_mapping is invalid.</p> <code>ValueValidationError</code> <p>If data is empty or price_type is invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict],\n    price_type: str = \"candlestick\",\n    price_kwargs: Optional[dict] = None,\n    volume_kwargs: Optional[dict] = None,\n    pane_id: int = 0,\n    price_scale_manager: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale.\n\n    Args:\n        data: OHLCV data containing price and volume information.\n        column_mapping: Mapping of column names for DataFrame conversion.\n        price_type: Type of price series ('candlestick' or 'line').\n        price_kwargs: Additional arguments for price series configuration.\n        volume_kwargs: Additional arguments for volume series configuration.\n        pane_id: Pane ID for both price and volume series.\n        price_scale_manager: Optional PriceScaleManager for price scale config.\n\n    Raises:\n        TypeValidationError: If data or column_mapping is invalid.\n        ValueValidationError: If data is empty or price_type is invalid.\n    \"\"\"\n    # Validate inputs\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)) or (\n        isinstance(data, list) and len(data) == 0\n    ):\n        raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n    if column_mapping is None:\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n    if not isinstance(column_mapping, dict):\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n\n    if pane_id &lt; 0:\n        raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n    price_kwargs = price_kwargs or {}\n    volume_kwargs = volume_kwargs or {}\n\n    # Price series creation\n    price_series: Union[CandlestickSeries, LineSeries]\n    if price_type == \"candlestick\":\n        price_column_mapping = {\n            k: v\n            for k, v in column_mapping.items()\n            if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n        }\n        price_series = CandlestickSeries(\n            data=data,\n            column_mapping=price_column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n    elif price_type == \"line\":\n        price_series = LineSeries(\n            data=data,\n            column_mapping=column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n    else:\n        raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n    price_series._display_name = \"Price\"  # pylint: disable=protected-access\n\n    # Extract volume-specific kwargs\n    volume_up_color = volume_kwargs.get(\"up_color\", HISTOGRAM_UP_COLOR_DEFAULT)\n    volume_down_color = volume_kwargs.get(\"down_color\", HISTOGRAM_DOWN_COLOR_DEFAULT)\n    volume_base = volume_kwargs.get(\"base\", 0)\n\n    # Configure volume price scale through manager if provided\n    if price_scale_manager is not None:\n        volume_price_scale = PriceScaleOptions(\n            visible=False,\n            auto_scale=True,\n            border_visible=False,\n            mode=PriceScaleMode.NORMAL,\n            scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n            price_scale_id=ColumnNames.VOLUME.value,\n        )\n        price_scale_manager.add_overlay_scale(ColumnNames.VOLUME.value, volume_price_scale)\n\n    # Ensure volume mapping includes 'value' key\n    if \"value\" not in column_mapping:\n        column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n    # Create histogram series for volume\n    volume_series = HistogramSeries.create_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        up_color=volume_up_color,\n        down_color=volume_down_color,\n        pane_id=pane_id,\n        price_scale_id=ColumnNames.VOLUME.value,\n    )\n\n    # Set volume-specific properties\n    volume_series.base = volume_base  # type: ignore[attr-defined]\n    volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}  # type: ignore[attr-defined]\n    volume_series._display_name = \"Volume\"  # pylint: disable=protected-access\n\n    # Add both series\n    self.add_series(price_series, price_scale_manager)\n    self.add_series(volume_series, price_scale_manager)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for a specific pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <p>The pane ID to get series info for (default: 0).</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for a specific pane.\n\n    Args:\n        pane_id: The pane ID to get series info for (default: 0).\n\n    Returns:\n        List of series information dictionaries.\n    \"\"\"\n    series_info = []\n\n    for i, series in enumerate(self.series):\n        # Get series ID\n        series_id = getattr(series, \"id\", f\"series_{i}\")\n\n        # Get display name\n        display_name = series_id\n        if hasattr(series, \"name\") and series.name:\n            display_name = series.name\n        elif hasattr(series, \"title\") and series.title:\n            display_name = series.title\n\n        # Get series type\n        series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n        series_info.append(\n            {\n                \"id\": series_id,\n                \"displayName\": display_name,\n                \"type\": series_type,\n            },\n        )\n\n    return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SeriesManager.to_frontend_configs","title":"to_frontend_configs","text":"<pre><code>to_frontend_configs() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Convert all series to frontend configuration dictionaries.</p> <p>Groups series by pane and sorts by z-index for proper layering.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of series configuration dictionaries.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def to_frontend_configs(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Convert all series to frontend configuration dictionaries.\n\n    Groups series by pane and sorts by z-index for proper layering.\n\n    Returns:\n        List of series configuration dictionaries.\n    \"\"\"\n    # Group series by pane_id and sort by z_index within each pane\n    series_by_pane: Dict[int, List[Dict[str, Any]]] = {}\n\n    for series in self.series:\n        series_config = series.asdict()\n\n        # Handle case where asdict() returns invalid data\n        if not isinstance(series_config, dict):\n            logger.warning(\n                \"Series %s returned invalid configuration from asdict(): %s. \"\n                \"Skipping z-index ordering for this series.\",\n                type(series).__name__,\n                series_config,\n            )\n            # Add to default pane with default z-index\n            if 0 not in series_by_pane:\n                series_by_pane[0] = []\n            series_by_pane[0].append(series_config)\n            continue\n\n        pane_id = series_config.get(\"paneId\", 0)\n\n        if pane_id not in series_by_pane:\n            series_by_pane[pane_id] = []\n\n        series_by_pane[pane_id].append(series_config)\n\n    # Sort series within each pane by z_index\n    for series_list in series_by_pane.values():\n        series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n    # Flatten sorted series back to a single list, maintaining pane order\n    series_configs = []\n    for pane_id in sorted(series_by_pane.keys()):\n        series_configs.extend(series_by_pane[pane_id])\n\n    return series_configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager","title":"SessionStateManager","text":"<p>Manages session state persistence for chart configurations.</p> <p>This class handles all session state operations including: - Saving series configurations - Loading series configurations - Applying stored configurations to series</p> <p>Attributes:</p> Name Type Description <code>configs_applied</code> <p>Flag to track if configs have been applied in current cycle.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>class SessionStateManager:\n    \"\"\"Manages session state persistence for chart configurations.\n\n    This class handles all session state operations including:\n    - Saving series configurations\n    - Loading series configurations\n    - Applying stored configurations to series\n\n    Attributes:\n        configs_applied: Flag to track if configs have been applied in current cycle.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the SessionStateManager.\"\"\"\n        self.configs_applied = False\n\n    def save_series_configs(self, key: str, configs: Dict[str, Any]) -&gt; None:\n        \"\"\"Save series configurations to Streamlit session state.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n            configs: Dictionary of series configurations to save.\n        \"\"\"\n        if not key:\n            return\n\n        session_key = f\"_chart_series_configs_{key}\"\n        st.session_state[session_key] = configs\n\n    def load_series_configs(self, key: str) -&gt; Dict[str, Any]:\n        \"\"\"Load series configurations from Streamlit session state.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n\n        Returns:\n            Dictionary of series configurations or empty dict if none found.\n        \"\"\"\n        if not key:\n            return {}\n\n        session_key = f\"_chart_series_configs_{key}\"\n        return st.session_state.get(session_key, {})\n\n    def get_stored_series_config(\n        self,\n        key: str,\n        series_index: int = 0,\n        pane_id: int = 0,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get stored configuration for a specific series.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n            series_index: Index of the series (default: 0).\n            pane_id: Pane ID for the series (default: 0).\n\n        Returns:\n            Dictionary of stored configuration or empty dict if none found.\n        \"\"\"\n        session_key = f\"_chart_series_configs_{key}\"\n        stored_configs = st.session_state.get(session_key, {})\n        series_id = f\"pane-{pane_id}-series-{series_index}\"\n        return stored_configs.get(series_id, {})\n\n    def apply_stored_configs_to_series(\n        self,\n        stored_configs: Dict[str, Any],\n        series_list: List[Any],\n    ) -&gt; None:\n        \"\"\"Apply stored configurations to series objects.\n\n        Optimized to apply all configurations in a single pass to prevent flicker.\n\n        Args:\n            stored_configs: Dictionary mapping series IDs to their configurations.\n            series_list: List of series objects to apply configurations to.\n        \"\"\"\n        if not stored_configs:\n            return\n\n        # Check if configs have already been applied in this render cycle\n        if self.configs_applied:\n            return\n\n        for i, series in enumerate(series_list):\n            # Generate the expected series ID\n            pane_id = getattr(series, \"pane_id\", 0) or 0\n            series_id = f\"pane-{pane_id}-series-{i}\"\n\n            if series_id in stored_configs:\n                config = stored_configs[series_id]\n\n                logger.debug(\"Applying stored config to %s: %s\", series_id, config)\n\n                try:\n                    # Separate configs for line_options vs general series properties\n                    line_options_config = {}\n                    series_config = {}\n\n                    for key, value in config.items():\n                        # Skip data and internal metadata\n                        if key in (\n                            \"data\",\n                            \"type\",\n                            \"paneId\",\n                            \"priceScaleId\",\n                            \"zIndex\",\n                            \"_seriesType\",\n                        ):\n                            continue\n\n                        # Line-specific properties go to line_options\n                        if key in (\n                            \"color\",\n                            \"lineWidth\",\n                            \"lineStyle\",\n                            \"lineType\",\n                            \"lineVisible\",\n                            \"pointMarkersVisible\",\n                            \"pointMarkersRadius\",\n                            \"crosshairMarkerVisible\",\n                            \"crosshairMarkerRadius\",\n                            \"crosshairMarkerBorderColor\",\n                            \"crosshairMarkerBackgroundColor\",\n                            \"crosshairMarkerBorderWidth\",\n                            \"lastPriceAnimation\",\n                        ):\n                            line_options_config[key] = value\n                        else:\n                            series_config[key] = value\n\n                    # Apply line options config if available\n                    if (\n                        hasattr(series, \"line_options\")\n                        and series.line_options\n                        and line_options_config\n                    ):\n                        logger.debug(\n                            \"Applying line_options config to %s: %s\",\n                            series_id,\n                            line_options_config,\n                        )\n                        series.line_options.update(line_options_config)\n\n                    # Apply general series config\n                    if series_config and hasattr(series, \"update\") and callable(series.update):\n                        logger.debug(\"Applying series config to %s: %s\", series_id, series_config)\n                        series.update(series_config)\n\n                except Exception:\n                    logger.exception(\"Failed to apply config to series %s\", series_id)\n\n        # Mark configs as applied for this render cycle\n        self.configs_applied = True\n\n    def reset_config_applied_flag(self) -&gt; None:\n        \"\"\"Reset the config application flag for a new render cycle.\"\"\"\n        self.configs_applied = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager.save_series_configs","title":"save_series_configs","text":"<pre><code>save_series_configs(key: str, configs: Dict[str, Any]) -&gt; None\n</code></pre> <p>Save series configurations to Streamlit session state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <code>configs</code> <code>Dict[str, Any]</code> <p>Dictionary of series configurations to save.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def save_series_configs(self, key: str, configs: Dict[str, Any]) -&gt; None:\n    \"\"\"Save series configurations to Streamlit session state.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n        configs: Dictionary of series configurations to save.\n    \"\"\"\n    if not key:\n        return\n\n    session_key = f\"_chart_series_configs_{key}\"\n    st.session_state[session_key] = configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager.load_series_configs","title":"load_series_configs","text":"<pre><code>load_series_configs(key: str) -&gt; Dict[str, Any]\n</code></pre> <p>Load series configurations from Streamlit session state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of series configurations or empty dict if none found.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def load_series_configs(self, key: str) -&gt; Dict[str, Any]:\n    \"\"\"Load series configurations from Streamlit session state.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n\n    Returns:\n        Dictionary of series configurations or empty dict if none found.\n    \"\"\"\n    if not key:\n        return {}\n\n    session_key = f\"_chart_series_configs_{key}\"\n    return st.session_state.get(session_key, {})\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager.get_stored_series_config","title":"get_stored_series_config","text":"<pre><code>get_stored_series_config(key: str, series_index: int = 0, pane_id: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Get stored configuration for a specific series.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <code>series_index</code> <code>int</code> <p>Index of the series (default: 0).</p> <code>0</code> <code>pane_id</code> <code>int</code> <p>Pane ID for the series (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of stored configuration or empty dict if none found.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def get_stored_series_config(\n    self,\n    key: str,\n    series_index: int = 0,\n    pane_id: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get stored configuration for a specific series.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n        series_index: Index of the series (default: 0).\n        pane_id: Pane ID for the series (default: 0).\n\n    Returns:\n        Dictionary of stored configuration or empty dict if none found.\n    \"\"\"\n    session_key = f\"_chart_series_configs_{key}\"\n    stored_configs = st.session_state.get(session_key, {})\n    series_id = f\"pane-{pane_id}-series-{series_index}\"\n    return stored_configs.get(series_id, {})\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager.apply_stored_configs_to_series","title":"apply_stored_configs_to_series","text":"<pre><code>apply_stored_configs_to_series(stored_configs: Dict[str, Any], series_list: List[Any]) -&gt; None\n</code></pre> <p>Apply stored configurations to series objects.</p> <p>Optimized to apply all configurations in a single pass to prevent flicker.</p> <p>Parameters:</p> Name Type Description Default <code>stored_configs</code> <code>Dict[str, Any]</code> <p>Dictionary mapping series IDs to their configurations.</p> required <code>series_list</code> <code>List[Any]</code> <p>List of series objects to apply configurations to.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def apply_stored_configs_to_series(\n    self,\n    stored_configs: Dict[str, Any],\n    series_list: List[Any],\n) -&gt; None:\n    \"\"\"Apply stored configurations to series objects.\n\n    Optimized to apply all configurations in a single pass to prevent flicker.\n\n    Args:\n        stored_configs: Dictionary mapping series IDs to their configurations.\n        series_list: List of series objects to apply configurations to.\n    \"\"\"\n    if not stored_configs:\n        return\n\n    # Check if configs have already been applied in this render cycle\n    if self.configs_applied:\n        return\n\n    for i, series in enumerate(series_list):\n        # Generate the expected series ID\n        pane_id = getattr(series, \"pane_id\", 0) or 0\n        series_id = f\"pane-{pane_id}-series-{i}\"\n\n        if series_id in stored_configs:\n            config = stored_configs[series_id]\n\n            logger.debug(\"Applying stored config to %s: %s\", series_id, config)\n\n            try:\n                # Separate configs for line_options vs general series properties\n                line_options_config = {}\n                series_config = {}\n\n                for key, value in config.items():\n                    # Skip data and internal metadata\n                    if key in (\n                        \"data\",\n                        \"type\",\n                        \"paneId\",\n                        \"priceScaleId\",\n                        \"zIndex\",\n                        \"_seriesType\",\n                    ):\n                        continue\n\n                    # Line-specific properties go to line_options\n                    if key in (\n                        \"color\",\n                        \"lineWidth\",\n                        \"lineStyle\",\n                        \"lineType\",\n                        \"lineVisible\",\n                        \"pointMarkersVisible\",\n                        \"pointMarkersRadius\",\n                        \"crosshairMarkerVisible\",\n                        \"crosshairMarkerRadius\",\n                        \"crosshairMarkerBorderColor\",\n                        \"crosshairMarkerBackgroundColor\",\n                        \"crosshairMarkerBorderWidth\",\n                        \"lastPriceAnimation\",\n                    ):\n                        line_options_config[key] = value\n                    else:\n                        series_config[key] = value\n\n                # Apply line options config if available\n                if (\n                    hasattr(series, \"line_options\")\n                    and series.line_options\n                    and line_options_config\n                ):\n                    logger.debug(\n                        \"Applying line_options config to %s: %s\",\n                        series_id,\n                        line_options_config,\n                    )\n                    series.line_options.update(line_options_config)\n\n                # Apply general series config\n                if series_config and hasattr(series, \"update\") and callable(series.update):\n                    logger.debug(\"Applying series config to %s: %s\", series_id, series_config)\n                    series.update(series_config)\n\n            except Exception:\n                logger.exception(\"Failed to apply config to series %s\", series_id)\n\n    # Mark configs as applied for this render cycle\n    self.configs_applied = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.SessionStateManager.reset_config_applied_flag","title":"reset_config_applied_flag","text":"<pre><code>reset_config_applied_flag() -&gt; None\n</code></pre> <p>Reset the config application flag for a new render cycle.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def reset_config_applied_flag(self) -&gt; None:\n    \"\"\"Reset the config application flag for a new render cycle.\"\"\"\n    self.configs_applied = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.TradeManager","title":"TradeManager","text":"<p>Manages trade data and visualization for a Chart.</p> <p>This class handles all trade-related operations including: - Storing trade data - Validating trade data - Serializing trade data for frontend</p> <p>Attributes:</p> Name Type Description <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to be visualized.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>class TradeManager:\n    \"\"\"Manages trade data and visualization for a Chart.\n\n    This class handles all trade-related operations including:\n    - Storing trade data\n    - Validating trade data\n    - Serializing trade data for frontend\n\n    Attributes:\n        trades: List of TradeData objects to be visualized.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the TradeManager.\"\"\"\n        self.trades: List[TradeData] = []\n\n    def add_trades(self, trades: List[TradeData]) -&gt; None:\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements. Each trade will be\n        displayed with entry and exit markers, rectangles, lines, arrows, or\n        zones based on TradeVisualizationOptions configuration.\n\n        Args:\n            trades: List of TradeData objects to visualize on the chart.\n\n        Raises:\n            TypeValidationError: If trades is not a list.\n            ValueValidationError: If any item in trades is not a TradeData object.\n        \"\"\"\n        if trades is None:\n            raise TypeValidationError(\"trades\", \"list\")\n        if not isinstance(trades, list):\n            raise TypeValidationError(\"trades\", \"list\")\n\n        # Validate that all items are TradeData objects\n        for trade in trades:\n            if not isinstance(trade, TradeData):\n                raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n        # Store trades for frontend processing\n        self.trades = trades\n\n    def has_trades(self) -&gt; bool:\n        \"\"\"Check if there are any trades to visualize.\n\n        Returns:\n            True if there are trades, False otherwise.\n        \"\"\"\n        return len(self.trades) &gt; 0\n\n    def to_frontend_config(\n        self,\n        trade_visualization_options: Optional[Any] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Convert trades to frontend configuration.\n\n        Args:\n            trade_visualization_options: Optional TradeVisualizationOptions\n                configuration.\n\n        Returns:\n            Dictionary with trade configuration or None if no trades exist.\n        \"\"\"\n        if not self.has_trades():\n            return None\n\n        result: Dict[str, Any] = {\n            \"trades\": [trade.asdict() for trade in self.trades],\n        }\n\n        # Add trade visualization options if they exist\n        if trade_visualization_options:\n            result[\"tradeVisualizationOptions\"] = trade_visualization_options.asdict()\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.TradeManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.TradeManager.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; None\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements. Each trade will be displayed with entry and exit markers, rectangles, lines, arrows, or zones based on TradeVisualizationOptions configuration.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart.</p> required <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If trades is not a list.</p> <code>ValueValidationError</code> <p>If any item in trades is not a TradeData object.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; None:\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements. Each trade will be\n    displayed with entry and exit markers, rectangles, lines, arrows, or\n    zones based on TradeVisualizationOptions configuration.\n\n    Args:\n        trades: List of TradeData objects to visualize on the chart.\n\n    Raises:\n        TypeValidationError: If trades is not a list.\n        ValueValidationError: If any item in trades is not a TradeData object.\n    \"\"\"\n    if trades is None:\n        raise TypeValidationError(\"trades\", \"list\")\n    if not isinstance(trades, list):\n        raise TypeValidationError(\"trades\", \"list\")\n\n    # Validate that all items are TradeData objects\n    for trade in trades:\n        if not isinstance(trade, TradeData):\n            raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n    # Store trades for frontend processing\n    self.trades = trades\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.TradeManager.has_trades","title":"has_trades","text":"<pre><code>has_trades() -&gt; bool\n</code></pre> <p>Check if there are any trades to visualize.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there are trades, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def has_trades(self) -&gt; bool:\n    \"\"\"Check if there are any trades to visualize.\n\n    Returns:\n        True if there are trades, False otherwise.\n    \"\"\"\n    return len(self.trades) &gt; 0\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/index.html#streamlit_lightweight_charts_pro.charts.managers.TradeManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config(trade_visualization_options: Optional[Any] = None) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Convert trades to frontend configuration.</p> <p>Parameters:</p> Name Type Description Default <code>trade_visualization_options</code> <code>Optional[Any]</code> <p>Optional TradeVisualizationOptions configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary with trade configuration or None if no trades exist.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def to_frontend_config(\n    self,\n    trade_visualization_options: Optional[Any] = None,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Convert trades to frontend configuration.\n\n    Args:\n        trade_visualization_options: Optional TradeVisualizationOptions\n            configuration.\n\n    Returns:\n        Dictionary with trade configuration or None if no trades exist.\n    \"\"\"\n    if not self.has_trades():\n        return None\n\n    result: Dict[str, Any] = {\n        \"trades\": [trade.asdict() for trade in self.trades],\n    }\n\n    # Add trade visualization options if they exist\n    if trade_visualization_options:\n        result[\"tradeVisualizationOptions\"] = trade_visualization_options.asdict()\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html","title":"streamlit_lightweight_charts_pro.charts.managers.chart_renderer","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer","title":"chart_renderer","text":"<p>Chart rendering and frontend configuration for Chart component.</p> <p>This module handles the generation of frontend configuration and rendering of chart components in Streamlit.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer.ChartRenderer","title":"ChartRenderer","text":"<p>Manages chart rendering and frontend configuration.</p> <p>This class handles all rendering operations including: - Converting chart data to frontend configuration - Rendering the Streamlit component - Handling frontend responses - Managing data-aware range filtering</p> <p>Attributes:</p> Name Type Description <code>chart_manager_ref</code> <p>Optional reference to ChartManager for sync config.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>class ChartRenderer:\n    \"\"\"Manages chart rendering and frontend configuration.\n\n    This class handles all rendering operations including:\n    - Converting chart data to frontend configuration\n    - Rendering the Streamlit component\n    - Handling frontend responses\n    - Managing data-aware range filtering\n\n    Attributes:\n        chart_manager_ref: Optional reference to ChartManager for sync config.\n    \"\"\"\n\n    def __init__(self, chart_manager_ref: Optional[Any] = None):\n        \"\"\"Initialize the ChartRenderer.\n\n        Args:\n            chart_manager_ref: Optional reference to ChartManager for\n                synchronization configuration.\n        \"\"\"\n        self.chart_manager_ref = chart_manager_ref\n\n    def generate_frontend_config(\n        self,\n        chart_id: str,\n        chart_options: Any,\n        series_configs: List[Dict[str, Any]],\n        annotations_config: Dict[str, Any],\n        trades_config: Optional[Dict[str, Any]],\n        tooltip_configs: Optional[Dict[str, Any]],\n        chart_group_id: int,\n        price_scale_config: Dict[str, Any],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generate the complete frontend configuration.\n\n        Args:\n            chart_id: Unique identifier for the chart.\n            chart_options: Chart options configuration.\n            series_configs: List of series configurations.\n            annotations_config: Annotations configuration.\n            trades_config: Optional trades configuration.\n            tooltip_configs: Optional tooltip configurations.\n            chart_group_id: Chart group ID for synchronization.\n            price_scale_config: Price scale configurations.\n\n        Returns:\n            Complete frontend configuration dictionary.\n        \"\"\"\n        chart_config = chart_options.asdict() if chart_options is not None else {}\n\n        # Merge price scale configuration\n        chart_config.update(price_scale_config)\n\n        # Apply data-aware range filtering\n        chart_config = self._filter_range_switcher_by_data(\n            chart_config,\n            series_configs,\n        )\n\n        chart_obj: Dict[str, Any] = {\n            \"chartId\": chart_id,\n            \"chart\": chart_config,\n            \"series\": series_configs,\n            \"annotations\": annotations_config,\n        }\n\n        # Add trades configuration if present\n        if trades_config:\n            chart_obj.update(trades_config)\n\n        # Add tooltip configurations if present\n        if tooltip_configs:\n            chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n        # Add chart group ID\n        chart_obj[\"chartGroupId\"] = chart_group_id\n\n        config: Dict[str, Any] = {\n            \"charts\": [chart_obj],\n        }\n\n        # Add sync configuration if ChartManager reference is available\n        if self.chart_manager_ref is not None:\n            config[\"syncConfig\"] = self._get_sync_config(chart_group_id)\n\n        return config\n\n    def _get_sync_config(self, chart_group_id: int) -&gt; Dict[str, Any]:\n        \"\"\"Get synchronization configuration from ChartManager.\n\n        Args:\n            chart_group_id: Chart group ID to get sync config for.\n\n        Returns:\n            Synchronization configuration dictionary.\n        \"\"\"\n        group_sync_enabled = False\n        group_sync_config = None\n\n        if (\n            self.chart_manager_ref.sync_groups\n            and str(chart_group_id) in self.chart_manager_ref.sync_groups\n        ):\n            group_sync_config = self.chart_manager_ref.sync_groups[str(chart_group_id)]\n            group_sync_enabled = group_sync_config.enabled\n\n        sync_enabled = self.chart_manager_ref.default_sync.enabled or group_sync_enabled\n\n        sync_config: Dict[str, Any] = {\n            \"enabled\": sync_enabled,\n            \"crosshair\": self.chart_manager_ref.default_sync.crosshair,\n            \"timeRange\": self.chart_manager_ref.default_sync.time_range,\n        }\n\n        # Add group-specific sync configurations\n        if self.chart_manager_ref.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.chart_manager_ref.sync_groups.items():\n                sync_config[\"groups\"][str(group_id)] = {\n                    \"enabled\": group_sync.enabled,\n                    \"crosshair\": group_sync.crosshair,\n                    \"timeRange\": group_sync.time_range,\n                }\n\n        return sync_config\n\n    def _filter_range_switcher_by_data(\n        self,\n        chart_config: Dict[str, Any],\n        series_configs: List[Dict[str, Any]],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Filter range switcher options based on available data timespan.\n\n        Args:\n            chart_config: The chart configuration dictionary.\n            series_configs: List of series configurations.\n\n        Returns:\n            Modified chart configuration with filtered range options.\n        \"\"\"\n        # Only process if range switcher is configured\n        if not (chart_config.get(\"rangeSwitcher\") and chart_config[\"rangeSwitcher\"].get(\"ranges\")):\n            return chart_config\n\n        # Calculate data timespan from all series\n        data_timespan_seconds = self._calculate_data_timespan(series_configs)\n        if data_timespan_seconds is None:\n            return chart_config\n\n        # Filter ranges based on data timespan\n        original_ranges = chart_config[\"rangeSwitcher\"][\"ranges\"]\n        filtered_ranges = []\n\n        for range_config in original_ranges:\n            range_seconds = self._get_range_seconds(range_config)\n\n            # Keep range if it's \"All\" or within data timespan\n            if range_seconds is None or range_seconds &lt;= data_timespan_seconds * 1.1:\n                filtered_ranges.append(range_config)\n\n        chart_config[\"rangeSwitcher\"][\"ranges\"] = filtered_ranges\n        return chart_config\n\n    def _calculate_data_timespan(\n        self,\n        series_configs: List[Dict[str, Any]],\n    ) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\n\n        Args:\n            series_configs: List of series configurations with data.\n\n        Returns:\n            Timespan in seconds or None if unable to calculate.\n        \"\"\"\n        min_time = None\n        max_time = None\n\n        for series_config in series_configs:\n            data = series_config.get(\"data\", [])\n            if not data:\n                continue\n\n            for data_point in data:\n                time_value = None\n\n                # Extract time from various data formats\n                if isinstance(data_point, dict) and \"time\" in data_point:\n                    time_value = data_point[\"time\"]\n                elif hasattr(data_point, \"time\"):\n                    time_value = data_point.time\n\n                if time_value is None:\n                    continue\n\n                # Convert time to timestamp\n                timestamp = self._convert_time_to_timestamp(time_value)\n                if timestamp is None:\n                    continue\n\n                if min_time is None or timestamp &lt; min_time:\n                    min_time = timestamp\n                if max_time is None or timestamp &gt; max_time:\n                    max_time = timestamp\n\n        if min_time is None or max_time is None:\n            return None\n\n        return max_time - min_time\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\n\n        Args:\n            time_value: Time value in various formats.\n\n        Returns:\n            Timestamp in seconds or None if conversion fails.\n        \"\"\"\n        if isinstance(time_value, (int, float)):\n            return float(time_value)\n        if isinstance(time_value, str):\n            try:\n                dt = datetime.fromisoformat(time_value.replace(\"Z\", \"+00:00\"))\n                return dt.timestamp()\n            except (ValueError, AttributeError):\n                try:\n                    dt = datetime.strptime(time_value, \"%Y-%m-%d\")\n                    return dt.timestamp()\n                except ValueError:\n                    return None\n        elif hasattr(time_value, \"timestamp\"):\n            return time_value.timestamp()\n        return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\n\n        Args:\n            range_config: Range configuration dictionary.\n\n        Returns:\n            Number of seconds in the range or None for \"ALL\".\n        \"\"\"\n        range_value = range_config.get(\"range\")\n\n        if range_value is None or range_value == \"ALL\":\n            return None\n\n        range_seconds_map = {\n            \"FIVE_MINUTES\": 300,\n            \"FIFTEEN_MINUTES\": 900,\n            \"THIRTY_MINUTES\": 1800,\n            \"ONE_HOUR\": 3600,\n            \"FOUR_HOURS\": 14400,\n            \"ONE_DAY\": 86400,\n            \"ONE_WEEK\": 604800,\n            \"TWO_WEEKS\": 1209600,\n            \"ONE_MONTH\": 2592000,\n            \"THREE_MONTHS\": 7776000,\n            \"SIX_MONTHS\": 15552000,\n            \"ONE_YEAR\": 31536000,\n            \"TWO_YEARS\": 63072000,\n            \"FIVE_YEARS\": 157680000,\n        }\n\n        if isinstance(range_value, str) and range_value in range_seconds_map:\n            return range_seconds_map[range_value]\n        if isinstance(range_value, (int, float)):\n            return float(range_value)\n\n        return None\n\n    def render(\n        self,\n        config: Dict[str, Any],\n        key: str,\n        chart_options: Any,\n    ) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Args:\n            config: Complete frontend configuration.\n            key: Unique key for the Streamlit component (already validated).\n            chart_options: Chart options for extracting height/width.\n\n        Returns:\n            The rendered Streamlit component.\n\n        Raises:\n            ComponentNotAvailableError: If component cannot be loaded.\n        \"\"\"\n        # Get component function\n        component_func = get_component_func()\n\n        if component_func is None:\n            if reinitialize_component():\n                component_func = get_component_func()\n\n            if component_func is None:\n                raise ComponentNotAvailableError()\n\n        # Build component kwargs\n        kwargs: Dict[str, Any] = {\"config\": config}\n\n        # Extract height and width from chart options\n        if chart_options:\n            if hasattr(chart_options, \"height\") and chart_options.height is not None:\n                kwargs[\"height\"] = chart_options.height\n            if hasattr(chart_options, \"width\") and chart_options.width is not None:\n                kwargs[\"width\"] = chart_options.width\n\n        kwargs[\"key\"] = key\n        kwargs[\"default\"] = None\n\n        # Render component\n        return component_func(**kwargs)\n\n    def handle_response(\n        self,\n        response: Any,\n        key: str,\n        session_state_manager: Any,\n    ) -&gt; None:\n        \"\"\"Handle component return value and save series configs.\n\n        Args:\n            response: Response data from the frontend component.\n            key: Component key for session state.\n            session_state_manager: SessionStateManager for config persistence.\n        \"\"\"\n        if response and isinstance(response, dict):\n            # Check if we have series config changes from the frontend\n            if response.get(\"type\") == \"series_config_changes\":\n                changes = response.get(\"changes\", [])\n                if changes:\n                    # Build a dictionary of all current series configs\n                    series_configs = {}\n                    for change in changes:\n                        series_id = change.get(\"seriesId\")\n                        config = change.get(\"config\")\n                        if series_id and config:\n                            series_configs[series_id] = config\n\n                    # Save to session state\n                    if series_configs:\n                        session_state_manager.save_series_configs(key, series_configs)\n\n            # Handle series settings API responses\n            series_api = get_series_settings_api(key)\n            self._handle_series_settings_response(response, series_api)\n\n    def _handle_series_settings_response(self, response: dict, series_api) -&gt; None:\n        \"\"\"Handle series settings API responses from the frontend.\n\n        Args:\n            response: Response data from the frontend component.\n            series_api: SeriesSettingsAPI instance for this chart.\n        \"\"\"\n        try:\n            if response.get(\"type\") == \"get_pane_state\":\n                pane_id = response.get(\"paneId\", 0)\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    pane_state = series_api.get_pane_state(pane_id)\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": True, \"data\": pane_state})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"update_series_settings\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                config = response.get(\"config\", {})\n                message_id = response.get(\"messageId\")\n\n                success = series_api.update_series_settings(pane_id, series_id, config)\n\n                if message_id:\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"reset_series_defaults\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    defaults = series_api.reset_series_to_defaults(pane_id, series_id)\n                    success = defaults is not None\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success, \"data\": defaults or {}})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"series_config_changes\":\n                changes = response.get(\"changes\", [])\n\n                for change in changes:\n                    pane_id = change.get(\"paneId\", 0)\n                    series_id = change.get(\"seriesId\", \"\")\n                    config = change.get(\"config\", {})\n\n                    if series_id and config:\n                        success = series_api.update_series_settings(pane_id, series_id, config)\n                        if not success:\n                            logger.warning(\"Failed to store config for series %s\", series_id)\n                    else:\n                        logger.warning(\"Skipping invalid change (missing seriesId or config)\")\n\n        except Exception:\n            logger.exception(\"Error handling series settings response\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer.ChartRenderer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer.ChartRenderer.generate_frontend_config","title":"generate_frontend_config","text":"<pre><code>generate_frontend_config(chart_id: str, chart_options: Any, series_configs: List[Dict[str, Any]], annotations_config: Dict[str, Any], trades_config: Optional[Dict[str, Any]], tooltip_configs: Optional[Dict[str, Any]], chart_group_id: int, price_scale_config: Dict[str, Any]) -&gt; Dict[str, Any]\n</code></pre> <p>Generate the complete frontend configuration.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart.</p> required <code>chart_options</code> <code>Any</code> <p>Chart options configuration.</p> required <code>series_configs</code> <code>List[Dict[str, Any]]</code> <p>List of series configurations.</p> required <code>annotations_config</code> <code>Dict[str, Any]</code> <p>Annotations configuration.</p> required <code>trades_config</code> <code>Optional[Dict[str, Any]]</code> <p>Optional trades configuration.</p> required <code>tooltip_configs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional tooltip configurations.</p> required <code>chart_group_id</code> <code>int</code> <p>Chart group ID for synchronization.</p> required <code>price_scale_config</code> <code>Dict[str, Any]</code> <p>Price scale configurations.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Complete frontend configuration dictionary.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def generate_frontend_config(\n    self,\n    chart_id: str,\n    chart_options: Any,\n    series_configs: List[Dict[str, Any]],\n    annotations_config: Dict[str, Any],\n    trades_config: Optional[Dict[str, Any]],\n    tooltip_configs: Optional[Dict[str, Any]],\n    chart_group_id: int,\n    price_scale_config: Dict[str, Any],\n) -&gt; Dict[str, Any]:\n    \"\"\"Generate the complete frontend configuration.\n\n    Args:\n        chart_id: Unique identifier for the chart.\n        chart_options: Chart options configuration.\n        series_configs: List of series configurations.\n        annotations_config: Annotations configuration.\n        trades_config: Optional trades configuration.\n        tooltip_configs: Optional tooltip configurations.\n        chart_group_id: Chart group ID for synchronization.\n        price_scale_config: Price scale configurations.\n\n    Returns:\n        Complete frontend configuration dictionary.\n    \"\"\"\n    chart_config = chart_options.asdict() if chart_options is not None else {}\n\n    # Merge price scale configuration\n    chart_config.update(price_scale_config)\n\n    # Apply data-aware range filtering\n    chart_config = self._filter_range_switcher_by_data(\n        chart_config,\n        series_configs,\n    )\n\n    chart_obj: Dict[str, Any] = {\n        \"chartId\": chart_id,\n        \"chart\": chart_config,\n        \"series\": series_configs,\n        \"annotations\": annotations_config,\n    }\n\n    # Add trades configuration if present\n    if trades_config:\n        chart_obj.update(trades_config)\n\n    # Add tooltip configurations if present\n    if tooltip_configs:\n        chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n    # Add chart group ID\n    chart_obj[\"chartGroupId\"] = chart_group_id\n\n    config: Dict[str, Any] = {\n        \"charts\": [chart_obj],\n    }\n\n    # Add sync configuration if ChartManager reference is available\n    if self.chart_manager_ref is not None:\n        config[\"syncConfig\"] = self._get_sync_config(chart_group_id)\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer.ChartRenderer.render","title":"render","text":"<pre><code>render(config: Dict[str, Any], key: str, chart_options: Any) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, Any]</code> <p>Complete frontend configuration.</p> required <code>key</code> <code>str</code> <p>Unique key for the Streamlit component (already validated).</p> required <code>chart_options</code> <code>Any</code> <p>Chart options for extracting height/width.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The rendered Streamlit component.</p> <p>Raises:</p> Type Description <code>ComponentNotAvailableError</code> <p>If component cannot be loaded.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def render(\n    self,\n    config: Dict[str, Any],\n    key: str,\n    chart_options: Any,\n) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Args:\n        config: Complete frontend configuration.\n        key: Unique key for the Streamlit component (already validated).\n        chart_options: Chart options for extracting height/width.\n\n    Returns:\n        The rendered Streamlit component.\n\n    Raises:\n        ComponentNotAvailableError: If component cannot be loaded.\n    \"\"\"\n    # Get component function\n    component_func = get_component_func()\n\n    if component_func is None:\n        if reinitialize_component():\n            component_func = get_component_func()\n\n        if component_func is None:\n            raise ComponentNotAvailableError()\n\n    # Build component kwargs\n    kwargs: Dict[str, Any] = {\"config\": config}\n\n    # Extract height and width from chart options\n    if chart_options:\n        if hasattr(chart_options, \"height\") and chart_options.height is not None:\n            kwargs[\"height\"] = chart_options.height\n        if hasattr(chart_options, \"width\") and chart_options.width is not None:\n            kwargs[\"width\"] = chart_options.width\n\n    kwargs[\"key\"] = key\n    kwargs[\"default\"] = None\n\n    # Render component\n    return component_func(**kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer.ChartRenderer.handle_response","title":"handle_response","text":"<pre><code>handle_response(response: Any, key: str, session_state_manager: Any) -&gt; None\n</code></pre> <p>Handle component return value and save series configs.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Any</code> <p>Response data from the frontend component.</p> required <code>key</code> <code>str</code> <p>Component key for session state.</p> required <code>session_state_manager</code> <code>Any</code> <p>SessionStateManager for config persistence.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/chart_renderer.py</code> <pre><code>def handle_response(\n    self,\n    response: Any,\n    key: str,\n    session_state_manager: Any,\n) -&gt; None:\n    \"\"\"Handle component return value and save series configs.\n\n    Args:\n        response: Response data from the frontend component.\n        key: Component key for session state.\n        session_state_manager: SessionStateManager for config persistence.\n    \"\"\"\n    if response and isinstance(response, dict):\n        # Check if we have series config changes from the frontend\n        if response.get(\"type\") == \"series_config_changes\":\n            changes = response.get(\"changes\", [])\n            if changes:\n                # Build a dictionary of all current series configs\n                series_configs = {}\n                for change in changes:\n                    series_id = change.get(\"seriesId\")\n                    config = change.get(\"config\")\n                    if series_id and config:\n                        series_configs[series_id] = config\n\n                # Save to session state\n                if series_configs:\n                    session_state_manager.save_series_configs(key, series_configs)\n\n        # Handle series settings API responses\n        series_api = get_series_settings_api(key)\n        self._handle_series_settings_response(response, series_api)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/chart_renderer.html#streamlit_lightweight_charts_pro.charts.managers.chart_renderer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html","title":"streamlit_lightweight_charts_pro.charts.managers.price_scale_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager","title":"price_scale_manager","text":"<p>Price scale management for Chart component.</p> <p>This module handles price scale configuration and overlay price scales for chart series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager","title":"PriceScaleManager","text":"<p>Manages price scale configurations for a Chart.</p> <p>This class handles all price scale operations including: - Managing left and right price scales - Managing overlay price scales - Validating price scale configurations</p> <p>Attributes:</p> Name Type Description <code>left_price_scale</code> <p>Left price scale configuration.</p> <code>right_price_scale</code> <p>Right price scale configuration.</p> <code>overlay_price_scales</code> <p>Dictionary of overlay price scale configurations.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>class PriceScaleManager:\n    \"\"\"Manages price scale configurations for a Chart.\n\n    This class handles all price scale operations including:\n    - Managing left and right price scales\n    - Managing overlay price scales\n    - Validating price scale configurations\n\n    Attributes:\n        left_price_scale: Left price scale configuration.\n        right_price_scale: Right price scale configuration.\n        overlay_price_scales: Dictionary of overlay price scale configurations.\n    \"\"\"\n\n    def __init__(\n        self,\n        left_price_scale: Optional[PriceScaleOptions] = None,\n        right_price_scale: Optional[PriceScaleOptions] = None,\n        overlay_price_scales: Optional[Dict[str, PriceScaleOptions]] = None,\n    ):\n        \"\"\"Initialize the PriceScaleManager.\n\n        Args:\n            left_price_scale: Optional left price scale configuration.\n            right_price_scale: Optional right price scale configuration.\n            overlay_price_scales: Optional dictionary of overlay price scales.\n        \"\"\"\n        self.left_price_scale = left_price_scale\n        self.right_price_scale = right_price_scale\n        self.overlay_price_scales = overlay_price_scales or {}\n\n    def add_overlay_scale(\n        self,\n        scale_id: str,\n        options: PriceScaleOptions,\n    ) -&gt; None:\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Args:\n            scale_id: The unique identifier for the custom price scale.\n            options: A PriceScaleOptions instance containing the configuration.\n\n        Raises:\n            ValueValidationError: If scale_id is not a non-empty string.\n            TypeValidationError: If options is None or not a PriceScaleOptions instance.\n        \"\"\"\n        if not scale_id or not isinstance(scale_id, str):\n            raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n        if options is None:\n            raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n        if not isinstance(options, PriceScaleOptions):\n            raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n        # Ensure the price_scale_id field matches the scale_id parameter\n        options.price_scale_id = scale_id\n\n        # Update or add the overlay price scale\n        self.overlay_price_scales[scale_id] = options\n\n    def has_overlay_scale(self, scale_id: str) -&gt; bool:\n        \"\"\"Check if an overlay price scale exists.\n\n        Args:\n            scale_id: The unique identifier for the custom price scale.\n\n        Returns:\n            True if the overlay price scale exists, False otherwise.\n        \"\"\"\n        return scale_id in self.overlay_price_scales\n\n    def configure_for_volume(self) -&gt; None:\n        \"\"\"Configure right price scale margins for volume overlay.\n\n        Sets the right price scale margins to leave space for volume\n        visualization at the bottom of the chart.\n        \"\"\"\n        if self.right_price_scale is not None:\n            # Explicitly set visible=True to ensure it's serialized\n            self.right_price_scale.visible = True\n            self.right_price_scale.scale_margins = PriceScaleMargins(\n                top=0.1,  # 10% margin at top\n                bottom=0.25,  # 25% margin at bottom (leaves room for volume overlay)\n            )\n\n    def validate_and_serialize(self) -&gt; Dict[str, any]:\n        \"\"\"Validate and serialize price scale configurations.\n\n        Returns:\n            Dictionary of serialized price scale configurations.\n\n        Raises:\n            PriceScaleIdTypeError: If price_scale_id is not a string.\n            PriceScaleOptionsTypeError: If price scale is not a valid type.\n        \"\"\"\n        result = {}\n\n        # Serialize right price scale\n        if self.right_price_scale is not None:\n            try:\n                result[\"rightPriceScale\"] = self.right_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.right_price_scale.price_scale_id is not None and not isinstance(\n                    self.right_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"right_price_scale\",\n                        type(self.right_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.right_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"right_price_scale\",\n                        type(self.right_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale),\n                ) from e\n\n        # Serialize left price scale\n        if self.left_price_scale is not None:\n            try:\n                result[\"leftPriceScale\"] = self.left_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.left_price_scale.price_scale_id is not None and not isinstance(\n                    self.left_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"left_price_scale\",\n                        type(self.left_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.left_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"left_price_scale\",\n                        type(self.left_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale),\n                ) from e\n\n        # Serialize overlay price scales\n        if self.overlay_price_scales:\n            result[\"overlayPriceScales\"] = {\n                k: v.asdict() if hasattr(v, \"asdict\") else v\n                for k, v in self.overlay_price_scales.items()\n            }\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager.add_overlay_scale","title":"add_overlay_scale","text":"<pre><code>add_overlay_scale(scale_id: str, options: PriceScaleOptions) -&gt; None\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale.</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration.</p> required <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If scale_id is not a non-empty string.</p> <code>TypeValidationError</code> <p>If options is None or not a PriceScaleOptions instance.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def add_overlay_scale(\n    self,\n    scale_id: str,\n    options: PriceScaleOptions,\n) -&gt; None:\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Args:\n        scale_id: The unique identifier for the custom price scale.\n        options: A PriceScaleOptions instance containing the configuration.\n\n    Raises:\n        ValueValidationError: If scale_id is not a non-empty string.\n        TypeValidationError: If options is None or not a PriceScaleOptions instance.\n    \"\"\"\n    if not scale_id or not isinstance(scale_id, str):\n        raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n    if options is None:\n        raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n    if not isinstance(options, PriceScaleOptions):\n        raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n    # Ensure the price_scale_id field matches the scale_id parameter\n    options.price_scale_id = scale_id\n\n    # Update or add the overlay price scale\n    self.overlay_price_scales[scale_id] = options\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager.has_overlay_scale","title":"has_overlay_scale","text":"<pre><code>has_overlay_scale(scale_id: str) -&gt; bool\n</code></pre> <p>Check if an overlay price scale exists.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the overlay price scale exists, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def has_overlay_scale(self, scale_id: str) -&gt; bool:\n    \"\"\"Check if an overlay price scale exists.\n\n    Args:\n        scale_id: The unique identifier for the custom price scale.\n\n    Returns:\n        True if the overlay price scale exists, False otherwise.\n    \"\"\"\n    return scale_id in self.overlay_price_scales\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager.configure_for_volume","title":"configure_for_volume","text":"<pre><code>configure_for_volume() -&gt; None\n</code></pre> <p>Configure right price scale margins for volume overlay.</p> <p>Sets the right price scale margins to leave space for volume visualization at the bottom of the chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def configure_for_volume(self) -&gt; None:\n    \"\"\"Configure right price scale margins for volume overlay.\n\n    Sets the right price scale margins to leave space for volume\n    visualization at the bottom of the chart.\n    \"\"\"\n    if self.right_price_scale is not None:\n        # Explicitly set visible=True to ensure it's serialized\n        self.right_price_scale.visible = True\n        self.right_price_scale.scale_margins = PriceScaleMargins(\n            top=0.1,  # 10% margin at top\n            bottom=0.25,  # 25% margin at bottom (leaves room for volume overlay)\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager.PriceScaleManager.validate_and_serialize","title":"validate_and_serialize","text":"<pre><code>validate_and_serialize() -&gt; Dict[str, any]\n</code></pre> <p>Validate and serialize price scale configurations.</p> <p>Returns:</p> Type Description <code>Dict[str, any]</code> <p>Dictionary of serialized price scale configurations.</p> <p>Raises:</p> Type Description <code>PriceScaleIdTypeError</code> <p>If price_scale_id is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale is not a valid type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.py</code> <pre><code>def validate_and_serialize(self) -&gt; Dict[str, any]:\n    \"\"\"Validate and serialize price scale configurations.\n\n    Returns:\n        Dictionary of serialized price scale configurations.\n\n    Raises:\n        PriceScaleIdTypeError: If price_scale_id is not a string.\n        PriceScaleOptionsTypeError: If price scale is not a valid type.\n    \"\"\"\n    result = {}\n\n    # Serialize right price scale\n    if self.right_price_scale is not None:\n        try:\n            result[\"rightPriceScale\"] = self.right_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.right_price_scale.price_scale_id is not None and not isinstance(\n                self.right_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.right_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale),\n            ) from e\n\n    # Serialize left price scale\n    if self.left_price_scale is not None:\n        try:\n            result[\"leftPriceScale\"] = self.left_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.left_price_scale.price_scale_id is not None and not isinstance(\n                self.left_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.left_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale),\n            ) from e\n\n    # Serialize overlay price scales\n    if self.overlay_price_scales:\n        result[\"overlayPriceScales\"] = {\n            k: v.asdict() if hasattr(v, \"asdict\") else v\n            for k, v in self.overlay_price_scales.items()\n        }\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/price_scale_manager.html#streamlit_lightweight_charts_pro.charts.managers.price_scale_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html","title":"streamlit_lightweight_charts_pro.charts.managers.series_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager","title":"series_manager","text":"<p>Series management for Chart component.</p> <p>This module handles series list operations, validation, and configuration for chart series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager","title":"SeriesManager","text":"<p>Manages series operations for a Chart.</p> <p>This class handles all series-related operations including: - Adding and validating series - Managing series list - Handling series configuration - Creating complex series combinations (e.g., price + volume)</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects managed by this instance.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>class SeriesManager:\n    \"\"\"Manages series operations for a Chart.\n\n    This class handles all series-related operations including:\n    - Adding and validating series\n    - Managing series list\n    - Handling series configuration\n    - Creating complex series combinations (e.g., price + volume)\n\n    Attributes:\n        series (List[Series]): List of series objects managed by this instance.\n    \"\"\"\n\n    def __init__(self, series: Optional[Union[Series, List[Series]]] = None):\n        \"\"\"Initialize the SeriesManager.\n\n        Args:\n            series: Optional single series object or list of series objects.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list.\n        \"\"\"\n        # Handle series input - convert to list for uniform processing\n        if series is None:\n            self.series = []\n        elif isinstance(series, Series):\n            self.series = [series]\n        elif isinstance(series, list):\n            for item in series:\n                if not isinstance(item, Series):\n                    raise SeriesItemsTypeError()\n            self.series = series\n        else:\n            raise TypeValidationError(\"series\", \"Series instance or list\")\n\n    def add_series(\n        self,\n        series: Series,\n        price_scale_manager: Optional[Any] = None,\n        auto_create_price_scales: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a series to the managed list.\n\n        This method now supports auto-creation of price scales to align with\n        TradingView's official API behavior. When a series references a custom\n        price_scale_id that doesn't exist, it will be automatically created with\n        smart defaults based on context (overlay vs separate pane).\n\n        Args:\n            series: Series object to add.\n            price_scale_manager: Optional PriceScaleManager to handle custom\n                price scales.\n            auto_create_price_scales: Whether to auto-create price scales when\n                series references non-existent scale IDs (default: True).\n                This aligns with TradingView's official API behavior.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n        \"\"\"\n        if not isinstance(series, Series):\n            raise TypeValidationError(\"series\", \"Series instance\")\n\n        # Check for custom price scale configuration needs\n        price_scale_id = series.price_scale_id  # type: ignore[attr-defined]\n\n        # Handle custom price scale setup with manager if provided\n        if (\n            price_scale_id\n            and price_scale_id not in [\"left\", \"right\", \"\"]\n            and price_scale_manager is not None\n            and not price_scale_manager.has_overlay_scale(price_scale_id)\n        ):\n            if auto_create_price_scales:\n                # Auto-create price scale if it doesn't exist (TradingView API behavior)\n                # Create price scale with smart defaults\n                auto_scale = self._create_auto_price_scale(series, price_scale_id)\n                price_scale_manager.add_overlay_scale(price_scale_id, auto_scale)\n\n                logger.info(\n                    \"Auto-created price scale '%s' for series (visible=%s, \"\n                    \"auto_scale=%s). This aligns with TradingView's official API behavior.\",\n                    price_scale_id,\n                    auto_scale.visible,\n                    auto_scale.auto_scale,\n                )\n            else:\n                # Fallback to old behavior (empty scale with warning)\n                logger.warning(\n                    \"Series with price_scale_id '%s' does not have a corresponding \"\n                    \"overlay price scale configuration. Creating empty price scale object.\",\n                    price_scale_id,\n                )\n                empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n                price_scale_manager.add_overlay_scale(price_scale_id, empty_scale)\n\n        self.series.append(series)\n\n    def _create_auto_price_scale(\n        self,\n        series: Series,\n        scale_id: str,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale with smart defaults based on series type and pane.\n\n        This method implements TradingView's auto-creation behavior by analyzing\n        the context to determine if this is an overlay series or a separate pane series.\n\n        Args:\n            series: The series being added.\n            scale_id: The price scale ID to create.\n\n        Returns:\n            PriceScaleOptions configured with smart defaults.\n        \"\"\"\n        # Determine if this is an overlay or separate pane\n        is_overlay = self._is_overlay_series(series)\n\n        # Create price scale with context-aware defaults\n        return PriceScaleOptions(\n            price_scale_id=scale_id,\n            visible=not is_overlay,  # Hide for overlays, show for separate panes\n            auto_scale=True,\n            mode=PriceScaleMode.NORMAL,\n            scale_margins=PriceScaleMargins(\n                top=0.8 if is_overlay else 0.1,  # Large top margin for overlays\n                bottom=0.0 if is_overlay else 0.1,\n            ),\n        )\n\n    def _is_overlay_series(self, series: Series) -&gt; bool:\n        \"\"\"Determine if series is an overlay in same pane as another series.\n\n        A series is considered an overlay if:\n        - It's in the same pane as an existing series\n        - That existing series uses a built-in scale ('left', 'right', '')\n        - The new series uses a different scale ID\n\n        Args:\n            series: The series to check.\n\n        Returns:\n            True if series is an overlay, False if it's in a separate pane.\n        \"\"\"\n        series_pane_id = getattr(series, \"pane_id\", 0)\n        series_price_scale_id = getattr(series, \"price_scale_id\", \"\")\n\n        # Check if there's already a series in same pane with different scale\n        for existing in self.series:\n            existing_pane_id = getattr(existing, \"pane_id\", 0)\n            existing_price_scale_id = getattr(existing, \"price_scale_id\", \"\")\n\n            if (\n                existing_pane_id == series_pane_id\n                and existing_price_scale_id != series_price_scale_id\n                and existing_price_scale_id in (\"left\", \"right\", \"\")\n            ):\n                return True  # This is an overlay\n\n        return False  # This is the primary series in its pane\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict],\n        price_type: str = \"candlestick\",\n        price_kwargs: Optional[dict] = None,\n        volume_kwargs: Optional[dict] = None,\n        pane_id: int = 0,\n        price_scale_manager: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale.\n\n        Args:\n            data: OHLCV data containing price and volume information.\n            column_mapping: Mapping of column names for DataFrame conversion.\n            price_type: Type of price series ('candlestick' or 'line').\n            price_kwargs: Additional arguments for price series configuration.\n            volume_kwargs: Additional arguments for volume series configuration.\n            pane_id: Pane ID for both price and volume series.\n            price_scale_manager: Optional PriceScaleManager for price scale config.\n\n        Raises:\n            TypeValidationError: If data or column_mapping is invalid.\n            ValueValidationError: If data is empty or price_type is invalid.\n        \"\"\"\n        # Validate inputs\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)) or (\n            isinstance(data, list) and len(data) == 0\n        ):\n            raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n        if column_mapping is None:\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n        if not isinstance(column_mapping, dict):\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n\n        if pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n        price_kwargs = price_kwargs or {}\n        volume_kwargs = volume_kwargs or {}\n\n        # Price series creation\n        price_series: Union[CandlestickSeries, LineSeries]\n        if price_type == \"candlestick\":\n            price_column_mapping = {\n                k: v\n                for k, v in column_mapping.items()\n                if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n            }\n            price_series = CandlestickSeries(\n                data=data,\n                column_mapping=price_column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n        elif price_type == \"line\":\n            price_series = LineSeries(\n                data=data,\n                column_mapping=column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n        else:\n            raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n        price_series._display_name = \"Price\"  # pylint: disable=protected-access\n\n        # Extract volume-specific kwargs\n        volume_up_color = volume_kwargs.get(\"up_color\", HISTOGRAM_UP_COLOR_DEFAULT)\n        volume_down_color = volume_kwargs.get(\"down_color\", HISTOGRAM_DOWN_COLOR_DEFAULT)\n        volume_base = volume_kwargs.get(\"base\", 0)\n\n        # Configure volume price scale through manager if provided\n        if price_scale_manager is not None:\n            volume_price_scale = PriceScaleOptions(\n                visible=False,\n                auto_scale=True,\n                border_visible=False,\n                mode=PriceScaleMode.NORMAL,\n                scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n                price_scale_id=ColumnNames.VOLUME.value,\n            )\n            price_scale_manager.add_overlay_scale(ColumnNames.VOLUME.value, volume_price_scale)\n\n        # Ensure volume mapping includes 'value' key\n        if \"value\" not in column_mapping:\n            column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n        # Create histogram series for volume\n        volume_series = HistogramSeries.create_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            up_color=volume_up_color,\n            down_color=volume_down_color,\n            pane_id=pane_id,\n            price_scale_id=ColumnNames.VOLUME.value,\n        )\n\n        # Set volume-specific properties\n        volume_series.base = volume_base  # type: ignore[attr-defined]\n        volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}  # type: ignore[attr-defined]\n        volume_series._display_name = \"Volume\"  # pylint: disable=protected-access\n\n        # Add both series\n        self.add_series(price_series, price_scale_manager)\n        self.add_series(volume_series, price_scale_manager)\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for a specific pane.\n\n        Args:\n            pane_id: The pane ID to get series info for (default: 0).\n\n        Returns:\n            List of series information dictionaries.\n        \"\"\"\n        series_info = []\n\n        for i, series in enumerate(self.series):\n            # Get series ID\n            series_id = getattr(series, \"id\", f\"series_{i}\")\n\n            # Get display name\n            display_name = series_id\n            if hasattr(series, \"name\") and series.name:\n                display_name = series.name\n            elif hasattr(series, \"title\") and series.title:\n                display_name = series.title\n\n            # Get series type\n            series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n            series_info.append(\n                {\n                    \"id\": series_id,\n                    \"displayName\": display_name,\n                    \"type\": series_type,\n                },\n            )\n\n        return series_info\n\n    def to_frontend_configs(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Convert all series to frontend configuration dictionaries.\n\n        Groups series by pane and sorts by z-index for proper layering.\n\n        Returns:\n            List of series configuration dictionaries.\n        \"\"\"\n        # Group series by pane_id and sort by z_index within each pane\n        series_by_pane: Dict[int, List[Dict[str, Any]]] = {}\n\n        for series in self.series:\n            series_config = series.asdict()\n\n            # Handle case where asdict() returns invalid data\n            if not isinstance(series_config, dict):\n                logger.warning(\n                    \"Series %s returned invalid configuration from asdict(): %s. \"\n                    \"Skipping z-index ordering for this series.\",\n                    type(series).__name__,\n                    series_config,\n                )\n                # Add to default pane with default z-index\n                if 0 not in series_by_pane:\n                    series_by_pane[0] = []\n                series_by_pane[0].append(series_config)\n                continue\n\n            pane_id = series_config.get(\"paneId\", 0)\n\n            if pane_id not in series_by_pane:\n                series_by_pane[pane_id] = []\n\n            series_by_pane[pane_id].append(series_config)\n\n        # Sort series within each pane by z_index\n        for series_list in series_by_pane.values():\n            series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n        # Flatten sorted series back to a single list, maintaining pane order\n        series_configs = []\n        for pane_id in sorted(series_by_pane.keys()):\n            series_configs.extend(series_by_pane[pane_id])\n\n        return series_configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager.add_series","title":"add_series","text":"<pre><code>add_series(series: Series, price_scale_manager: Optional[Any] = None, auto_create_price_scales: bool = True) -&gt; None\n</code></pre> <p>Add a series to the managed list.</p> <p>This method now supports auto-creation of price scales to align with TradingView's official API behavior. When a series references a custom price_scale_id that doesn't exist, it will be automatically created with smart defaults based on context (overlay vs separate pane).</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add.</p> required <code>price_scale_manager</code> <code>Optional[Any]</code> <p>Optional PriceScaleManager to handle custom price scales.</p> <code>None</code> <code>auto_create_price_scales</code> <code>bool</code> <p>Whether to auto-create price scales when series references non-existent scale IDs (default: True). This aligns with TradingView's official API behavior.</p> <code>True</code> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def add_series(\n    self,\n    series: Series,\n    price_scale_manager: Optional[Any] = None,\n    auto_create_price_scales: bool = True,\n) -&gt; None:\n    \"\"\"Add a series to the managed list.\n\n    This method now supports auto-creation of price scales to align with\n    TradingView's official API behavior. When a series references a custom\n    price_scale_id that doesn't exist, it will be automatically created with\n    smart defaults based on context (overlay vs separate pane).\n\n    Args:\n        series: Series object to add.\n        price_scale_manager: Optional PriceScaleManager to handle custom\n            price scales.\n        auto_create_price_scales: Whether to auto-create price scales when\n            series references non-existent scale IDs (default: True).\n            This aligns with TradingView's official API behavior.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n    \"\"\"\n    if not isinstance(series, Series):\n        raise TypeValidationError(\"series\", \"Series instance\")\n\n    # Check for custom price scale configuration needs\n    price_scale_id = series.price_scale_id  # type: ignore[attr-defined]\n\n    # Handle custom price scale setup with manager if provided\n    if (\n        price_scale_id\n        and price_scale_id not in [\"left\", \"right\", \"\"]\n        and price_scale_manager is not None\n        and not price_scale_manager.has_overlay_scale(price_scale_id)\n    ):\n        if auto_create_price_scales:\n            # Auto-create price scale if it doesn't exist (TradingView API behavior)\n            # Create price scale with smart defaults\n            auto_scale = self._create_auto_price_scale(series, price_scale_id)\n            price_scale_manager.add_overlay_scale(price_scale_id, auto_scale)\n\n            logger.info(\n                \"Auto-created price scale '%s' for series (visible=%s, \"\n                \"auto_scale=%s). This aligns with TradingView's official API behavior.\",\n                price_scale_id,\n                auto_scale.visible,\n                auto_scale.auto_scale,\n            )\n        else:\n            # Fallback to old behavior (empty scale with warning)\n            logger.warning(\n                \"Series with price_scale_id '%s' does not have a corresponding \"\n                \"overlay price scale configuration. Creating empty price scale object.\",\n                price_scale_id,\n            )\n            empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n            price_scale_manager.add_overlay_scale(price_scale_id, empty_scale)\n\n    self.series.append(series)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: Optional[dict], price_type: str = 'candlestick', price_kwargs: Optional[dict] = None, volume_kwargs: Optional[dict] = None, pane_id: int = 0, price_scale_manager: Optional[Any] = None) -&gt; None\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>Optional[dict]</code> <p>Mapping of column names for DataFrame conversion.</p> required <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line').</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>Optional[dict]</code> <p>Additional arguments for price series configuration.</p> <code>None</code> <code>volume_kwargs</code> <code>Optional[dict]</code> <p>Additional arguments for volume series configuration.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series.</p> <code>0</code> <code>price_scale_manager</code> <code>Optional[Any]</code> <p>Optional PriceScaleManager for price scale config.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If data or column_mapping is invalid.</p> <code>ValueValidationError</code> <p>If data is empty or price_type is invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict],\n    price_type: str = \"candlestick\",\n    price_kwargs: Optional[dict] = None,\n    volume_kwargs: Optional[dict] = None,\n    pane_id: int = 0,\n    price_scale_manager: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale.\n\n    Args:\n        data: OHLCV data containing price and volume information.\n        column_mapping: Mapping of column names for DataFrame conversion.\n        price_type: Type of price series ('candlestick' or 'line').\n        price_kwargs: Additional arguments for price series configuration.\n        volume_kwargs: Additional arguments for volume series configuration.\n        pane_id: Pane ID for both price and volume series.\n        price_scale_manager: Optional PriceScaleManager for price scale config.\n\n    Raises:\n        TypeValidationError: If data or column_mapping is invalid.\n        ValueValidationError: If data is empty or price_type is invalid.\n    \"\"\"\n    # Validate inputs\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)) or (\n        isinstance(data, list) and len(data) == 0\n    ):\n        raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n    if column_mapping is None:\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n    if not isinstance(column_mapping, dict):\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n\n    if pane_id &lt; 0:\n        raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n    price_kwargs = price_kwargs or {}\n    volume_kwargs = volume_kwargs or {}\n\n    # Price series creation\n    price_series: Union[CandlestickSeries, LineSeries]\n    if price_type == \"candlestick\":\n        price_column_mapping = {\n            k: v\n            for k, v in column_mapping.items()\n            if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n        }\n        price_series = CandlestickSeries(\n            data=data,\n            column_mapping=price_column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n    elif price_type == \"line\":\n        price_series = LineSeries(\n            data=data,\n            column_mapping=column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n    else:\n        raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n    price_series._display_name = \"Price\"  # pylint: disable=protected-access\n\n    # Extract volume-specific kwargs\n    volume_up_color = volume_kwargs.get(\"up_color\", HISTOGRAM_UP_COLOR_DEFAULT)\n    volume_down_color = volume_kwargs.get(\"down_color\", HISTOGRAM_DOWN_COLOR_DEFAULT)\n    volume_base = volume_kwargs.get(\"base\", 0)\n\n    # Configure volume price scale through manager if provided\n    if price_scale_manager is not None:\n        volume_price_scale = PriceScaleOptions(\n            visible=False,\n            auto_scale=True,\n            border_visible=False,\n            mode=PriceScaleMode.NORMAL,\n            scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n            price_scale_id=ColumnNames.VOLUME.value,\n        )\n        price_scale_manager.add_overlay_scale(ColumnNames.VOLUME.value, volume_price_scale)\n\n    # Ensure volume mapping includes 'value' key\n    if \"value\" not in column_mapping:\n        column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n    # Create histogram series for volume\n    volume_series = HistogramSeries.create_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        up_color=volume_up_color,\n        down_color=volume_down_color,\n        pane_id=pane_id,\n        price_scale_id=ColumnNames.VOLUME.value,\n    )\n\n    # Set volume-specific properties\n    volume_series.base = volume_base  # type: ignore[attr-defined]\n    volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}  # type: ignore[attr-defined]\n    volume_series._display_name = \"Volume\"  # pylint: disable=protected-access\n\n    # Add both series\n    self.add_series(price_series, price_scale_manager)\n    self.add_series(volume_series, price_scale_manager)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for a specific pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <p>The pane ID to get series info for (default: 0).</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for a specific pane.\n\n    Args:\n        pane_id: The pane ID to get series info for (default: 0).\n\n    Returns:\n        List of series information dictionaries.\n    \"\"\"\n    series_info = []\n\n    for i, series in enumerate(self.series):\n        # Get series ID\n        series_id = getattr(series, \"id\", f\"series_{i}\")\n\n        # Get display name\n        display_name = series_id\n        if hasattr(series, \"name\") and series.name:\n            display_name = series.name\n        elif hasattr(series, \"title\") and series.title:\n            display_name = series.title\n\n        # Get series type\n        series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n        series_info.append(\n            {\n                \"id\": series_id,\n                \"displayName\": display_name,\n                \"type\": series_type,\n            },\n        )\n\n    return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager.SeriesManager.to_frontend_configs","title":"to_frontend_configs","text":"<pre><code>to_frontend_configs() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Convert all series to frontend configuration dictionaries.</p> <p>Groups series by pane and sorts by z-index for proper layering.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of series configuration dictionaries.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/series_manager.py</code> <pre><code>def to_frontend_configs(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Convert all series to frontend configuration dictionaries.\n\n    Groups series by pane and sorts by z-index for proper layering.\n\n    Returns:\n        List of series configuration dictionaries.\n    \"\"\"\n    # Group series by pane_id and sort by z_index within each pane\n    series_by_pane: Dict[int, List[Dict[str, Any]]] = {}\n\n    for series in self.series:\n        series_config = series.asdict()\n\n        # Handle case where asdict() returns invalid data\n        if not isinstance(series_config, dict):\n            logger.warning(\n                \"Series %s returned invalid configuration from asdict(): %s. \"\n                \"Skipping z-index ordering for this series.\",\n                type(series).__name__,\n                series_config,\n            )\n            # Add to default pane with default z-index\n            if 0 not in series_by_pane:\n                series_by_pane[0] = []\n            series_by_pane[0].append(series_config)\n            continue\n\n        pane_id = series_config.get(\"paneId\", 0)\n\n        if pane_id not in series_by_pane:\n            series_by_pane[pane_id] = []\n\n        series_by_pane[pane_id].append(series_config)\n\n    # Sort series within each pane by z_index\n    for series_list in series_by_pane.values():\n        series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n    # Flatten sorted series back to a single list, maintaining pane order\n    series_configs = []\n    for pane_id in sorted(series_by_pane.keys()):\n        series_configs.extend(series_by_pane[pane_id])\n\n    return series_configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/series_manager.html#streamlit_lightweight_charts_pro.charts.managers.series_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html","title":"streamlit_lightweight_charts_pro.charts.managers.session_state_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager","title":"session_state_manager","text":"<p>Session state management for Chart component.</p> <p>This module handles session state persistence for series configurations, allowing chart state to be maintained across Streamlit reruns.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager","title":"SessionStateManager","text":"<p>Manages session state persistence for chart configurations.</p> <p>This class handles all session state operations including: - Saving series configurations - Loading series configurations - Applying stored configurations to series</p> <p>Attributes:</p> Name Type Description <code>configs_applied</code> <p>Flag to track if configs have been applied in current cycle.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>class SessionStateManager:\n    \"\"\"Manages session state persistence for chart configurations.\n\n    This class handles all session state operations including:\n    - Saving series configurations\n    - Loading series configurations\n    - Applying stored configurations to series\n\n    Attributes:\n        configs_applied: Flag to track if configs have been applied in current cycle.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the SessionStateManager.\"\"\"\n        self.configs_applied = False\n\n    def save_series_configs(self, key: str, configs: Dict[str, Any]) -&gt; None:\n        \"\"\"Save series configurations to Streamlit session state.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n            configs: Dictionary of series configurations to save.\n        \"\"\"\n        if not key:\n            return\n\n        session_key = f\"_chart_series_configs_{key}\"\n        st.session_state[session_key] = configs\n\n    def load_series_configs(self, key: str) -&gt; Dict[str, Any]:\n        \"\"\"Load series configurations from Streamlit session state.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n\n        Returns:\n            Dictionary of series configurations or empty dict if none found.\n        \"\"\"\n        if not key:\n            return {}\n\n        session_key = f\"_chart_series_configs_{key}\"\n        return st.session_state.get(session_key, {})\n\n    def get_stored_series_config(\n        self,\n        key: str,\n        series_index: int = 0,\n        pane_id: int = 0,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get stored configuration for a specific series.\n\n        Args:\n            key: Component key used to namespace the stored configs.\n            series_index: Index of the series (default: 0).\n            pane_id: Pane ID for the series (default: 0).\n\n        Returns:\n            Dictionary of stored configuration or empty dict if none found.\n        \"\"\"\n        session_key = f\"_chart_series_configs_{key}\"\n        stored_configs = st.session_state.get(session_key, {})\n        series_id = f\"pane-{pane_id}-series-{series_index}\"\n        return stored_configs.get(series_id, {})\n\n    def apply_stored_configs_to_series(\n        self,\n        stored_configs: Dict[str, Any],\n        series_list: List[Any],\n    ) -&gt; None:\n        \"\"\"Apply stored configurations to series objects.\n\n        Optimized to apply all configurations in a single pass to prevent flicker.\n\n        Args:\n            stored_configs: Dictionary mapping series IDs to their configurations.\n            series_list: List of series objects to apply configurations to.\n        \"\"\"\n        if not stored_configs:\n            return\n\n        # Check if configs have already been applied in this render cycle\n        if self.configs_applied:\n            return\n\n        for i, series in enumerate(series_list):\n            # Generate the expected series ID\n            pane_id = getattr(series, \"pane_id\", 0) or 0\n            series_id = f\"pane-{pane_id}-series-{i}\"\n\n            if series_id in stored_configs:\n                config = stored_configs[series_id]\n\n                logger.debug(\"Applying stored config to %s: %s\", series_id, config)\n\n                try:\n                    # Separate configs for line_options vs general series properties\n                    line_options_config = {}\n                    series_config = {}\n\n                    for key, value in config.items():\n                        # Skip data and internal metadata\n                        if key in (\n                            \"data\",\n                            \"type\",\n                            \"paneId\",\n                            \"priceScaleId\",\n                            \"zIndex\",\n                            \"_seriesType\",\n                        ):\n                            continue\n\n                        # Line-specific properties go to line_options\n                        if key in (\n                            \"color\",\n                            \"lineWidth\",\n                            \"lineStyle\",\n                            \"lineType\",\n                            \"lineVisible\",\n                            \"pointMarkersVisible\",\n                            \"pointMarkersRadius\",\n                            \"crosshairMarkerVisible\",\n                            \"crosshairMarkerRadius\",\n                            \"crosshairMarkerBorderColor\",\n                            \"crosshairMarkerBackgroundColor\",\n                            \"crosshairMarkerBorderWidth\",\n                            \"lastPriceAnimation\",\n                        ):\n                            line_options_config[key] = value\n                        else:\n                            series_config[key] = value\n\n                    # Apply line options config if available\n                    if (\n                        hasattr(series, \"line_options\")\n                        and series.line_options\n                        and line_options_config\n                    ):\n                        logger.debug(\n                            \"Applying line_options config to %s: %s\",\n                            series_id,\n                            line_options_config,\n                        )\n                        series.line_options.update(line_options_config)\n\n                    # Apply general series config\n                    if series_config and hasattr(series, \"update\") and callable(series.update):\n                        logger.debug(\"Applying series config to %s: %s\", series_id, series_config)\n                        series.update(series_config)\n\n                except Exception:\n                    logger.exception(\"Failed to apply config to series %s\", series_id)\n\n        # Mark configs as applied for this render cycle\n        self.configs_applied = True\n\n    def reset_config_applied_flag(self) -&gt; None:\n        \"\"\"Reset the config application flag for a new render cycle.\"\"\"\n        self.configs_applied = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager.save_series_configs","title":"save_series_configs","text":"<pre><code>save_series_configs(key: str, configs: Dict[str, Any]) -&gt; None\n</code></pre> <p>Save series configurations to Streamlit session state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <code>configs</code> <code>Dict[str, Any]</code> <p>Dictionary of series configurations to save.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def save_series_configs(self, key: str, configs: Dict[str, Any]) -&gt; None:\n    \"\"\"Save series configurations to Streamlit session state.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n        configs: Dictionary of series configurations to save.\n    \"\"\"\n    if not key:\n        return\n\n    session_key = f\"_chart_series_configs_{key}\"\n    st.session_state[session_key] = configs\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager.load_series_configs","title":"load_series_configs","text":"<pre><code>load_series_configs(key: str) -&gt; Dict[str, Any]\n</code></pre> <p>Load series configurations from Streamlit session state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of series configurations or empty dict if none found.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def load_series_configs(self, key: str) -&gt; Dict[str, Any]:\n    \"\"\"Load series configurations from Streamlit session state.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n\n    Returns:\n        Dictionary of series configurations or empty dict if none found.\n    \"\"\"\n    if not key:\n        return {}\n\n    session_key = f\"_chart_series_configs_{key}\"\n    return st.session_state.get(session_key, {})\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager.get_stored_series_config","title":"get_stored_series_config","text":"<pre><code>get_stored_series_config(key: str, series_index: int = 0, pane_id: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Get stored configuration for a specific series.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Component key used to namespace the stored configs.</p> required <code>series_index</code> <code>int</code> <p>Index of the series (default: 0).</p> <code>0</code> <code>pane_id</code> <code>int</code> <p>Pane ID for the series (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of stored configuration or empty dict if none found.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def get_stored_series_config(\n    self,\n    key: str,\n    series_index: int = 0,\n    pane_id: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"Get stored configuration for a specific series.\n\n    Args:\n        key: Component key used to namespace the stored configs.\n        series_index: Index of the series (default: 0).\n        pane_id: Pane ID for the series (default: 0).\n\n    Returns:\n        Dictionary of stored configuration or empty dict if none found.\n    \"\"\"\n    session_key = f\"_chart_series_configs_{key}\"\n    stored_configs = st.session_state.get(session_key, {})\n    series_id = f\"pane-{pane_id}-series-{series_index}\"\n    return stored_configs.get(series_id, {})\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager.apply_stored_configs_to_series","title":"apply_stored_configs_to_series","text":"<pre><code>apply_stored_configs_to_series(stored_configs: Dict[str, Any], series_list: List[Any]) -&gt; None\n</code></pre> <p>Apply stored configurations to series objects.</p> <p>Optimized to apply all configurations in a single pass to prevent flicker.</p> <p>Parameters:</p> Name Type Description Default <code>stored_configs</code> <code>Dict[str, Any]</code> <p>Dictionary mapping series IDs to their configurations.</p> required <code>series_list</code> <code>List[Any]</code> <p>List of series objects to apply configurations to.</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def apply_stored_configs_to_series(\n    self,\n    stored_configs: Dict[str, Any],\n    series_list: List[Any],\n) -&gt; None:\n    \"\"\"Apply stored configurations to series objects.\n\n    Optimized to apply all configurations in a single pass to prevent flicker.\n\n    Args:\n        stored_configs: Dictionary mapping series IDs to their configurations.\n        series_list: List of series objects to apply configurations to.\n    \"\"\"\n    if not stored_configs:\n        return\n\n    # Check if configs have already been applied in this render cycle\n    if self.configs_applied:\n        return\n\n    for i, series in enumerate(series_list):\n        # Generate the expected series ID\n        pane_id = getattr(series, \"pane_id\", 0) or 0\n        series_id = f\"pane-{pane_id}-series-{i}\"\n\n        if series_id in stored_configs:\n            config = stored_configs[series_id]\n\n            logger.debug(\"Applying stored config to %s: %s\", series_id, config)\n\n            try:\n                # Separate configs for line_options vs general series properties\n                line_options_config = {}\n                series_config = {}\n\n                for key, value in config.items():\n                    # Skip data and internal metadata\n                    if key in (\n                        \"data\",\n                        \"type\",\n                        \"paneId\",\n                        \"priceScaleId\",\n                        \"zIndex\",\n                        \"_seriesType\",\n                    ):\n                        continue\n\n                    # Line-specific properties go to line_options\n                    if key in (\n                        \"color\",\n                        \"lineWidth\",\n                        \"lineStyle\",\n                        \"lineType\",\n                        \"lineVisible\",\n                        \"pointMarkersVisible\",\n                        \"pointMarkersRadius\",\n                        \"crosshairMarkerVisible\",\n                        \"crosshairMarkerRadius\",\n                        \"crosshairMarkerBorderColor\",\n                        \"crosshairMarkerBackgroundColor\",\n                        \"crosshairMarkerBorderWidth\",\n                        \"lastPriceAnimation\",\n                    ):\n                        line_options_config[key] = value\n                    else:\n                        series_config[key] = value\n\n                # Apply line options config if available\n                if (\n                    hasattr(series, \"line_options\")\n                    and series.line_options\n                    and line_options_config\n                ):\n                    logger.debug(\n                        \"Applying line_options config to %s: %s\",\n                        series_id,\n                        line_options_config,\n                    )\n                    series.line_options.update(line_options_config)\n\n                # Apply general series config\n                if series_config and hasattr(series, \"update\") and callable(series.update):\n                    logger.debug(\"Applying series config to %s: %s\", series_id, series_config)\n                    series.update(series_config)\n\n            except Exception:\n                logger.exception(\"Failed to apply config to series %s\", series_id)\n\n    # Mark configs as applied for this render cycle\n    self.configs_applied = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager.SessionStateManager.reset_config_applied_flag","title":"reset_config_applied_flag","text":"<pre><code>reset_config_applied_flag() -&gt; None\n</code></pre> <p>Reset the config application flag for a new render cycle.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/session_state_manager.py</code> <pre><code>def reset_config_applied_flag(self) -&gt; None:\n    \"\"\"Reset the config application flag for a new render cycle.\"\"\"\n    self.configs_applied = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/session_state_manager.html#streamlit_lightweight_charts_pro.charts.managers.session_state_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html","title":"streamlit_lightweight_charts_pro.charts.managers.trade_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager","title":"trade_manager","text":"<p>Trade management for Chart component.</p> <p>This module handles trade data storage and visualization configuration for chart trades.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager.TradeManager","title":"TradeManager","text":"<p>Manages trade data and visualization for a Chart.</p> <p>This class handles all trade-related operations including: - Storing trade data - Validating trade data - Serializing trade data for frontend</p> <p>Attributes:</p> Name Type Description <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to be visualized.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>class TradeManager:\n    \"\"\"Manages trade data and visualization for a Chart.\n\n    This class handles all trade-related operations including:\n    - Storing trade data\n    - Validating trade data\n    - Serializing trade data for frontend\n\n    Attributes:\n        trades: List of TradeData objects to be visualized.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the TradeManager.\"\"\"\n        self.trades: List[TradeData] = []\n\n    def add_trades(self, trades: List[TradeData]) -&gt; None:\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements. Each trade will be\n        displayed with entry and exit markers, rectangles, lines, arrows, or\n        zones based on TradeVisualizationOptions configuration.\n\n        Args:\n            trades: List of TradeData objects to visualize on the chart.\n\n        Raises:\n            TypeValidationError: If trades is not a list.\n            ValueValidationError: If any item in trades is not a TradeData object.\n        \"\"\"\n        if trades is None:\n            raise TypeValidationError(\"trades\", \"list\")\n        if not isinstance(trades, list):\n            raise TypeValidationError(\"trades\", \"list\")\n\n        # Validate that all items are TradeData objects\n        for trade in trades:\n            if not isinstance(trade, TradeData):\n                raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n        # Store trades for frontend processing\n        self.trades = trades\n\n    def has_trades(self) -&gt; bool:\n        \"\"\"Check if there are any trades to visualize.\n\n        Returns:\n            True if there are trades, False otherwise.\n        \"\"\"\n        return len(self.trades) &gt; 0\n\n    def to_frontend_config(\n        self,\n        trade_visualization_options: Optional[Any] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Convert trades to frontend configuration.\n\n        Args:\n            trade_visualization_options: Optional TradeVisualizationOptions\n                configuration.\n\n        Returns:\n            Dictionary with trade configuration or None if no trades exist.\n        \"\"\"\n        if not self.has_trades():\n            return None\n\n        result: Dict[str, Any] = {\n            \"trades\": [trade.asdict() for trade in self.trades],\n        }\n\n        # Add trade visualization options if they exist\n        if trade_visualization_options:\n            result[\"tradeVisualizationOptions\"] = trade_visualization_options.asdict()\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager.TradeManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager.TradeManager.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; None\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements. Each trade will be displayed with entry and exit markers, rectangles, lines, arrows, or zones based on TradeVisualizationOptions configuration.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart.</p> required <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If trades is not a list.</p> <code>ValueValidationError</code> <p>If any item in trades is not a TradeData object.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; None:\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements. Each trade will be\n    displayed with entry and exit markers, rectangles, lines, arrows, or\n    zones based on TradeVisualizationOptions configuration.\n\n    Args:\n        trades: List of TradeData objects to visualize on the chart.\n\n    Raises:\n        TypeValidationError: If trades is not a list.\n        ValueValidationError: If any item in trades is not a TradeData object.\n    \"\"\"\n    if trades is None:\n        raise TypeValidationError(\"trades\", \"list\")\n    if not isinstance(trades, list):\n        raise TypeValidationError(\"trades\", \"list\")\n\n    # Validate that all items are TradeData objects\n    for trade in trades:\n        if not isinstance(trade, TradeData):\n            raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n    # Store trades for frontend processing\n    self.trades = trades\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager.TradeManager.has_trades","title":"has_trades","text":"<pre><code>has_trades() -&gt; bool\n</code></pre> <p>Check if there are any trades to visualize.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there are trades, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def has_trades(self) -&gt; bool:\n    \"\"\"Check if there are any trades to visualize.\n\n    Returns:\n        True if there are trades, False otherwise.\n    \"\"\"\n    return len(self.trades) &gt; 0\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager.TradeManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config(trade_visualization_options: Optional[Any] = None) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Convert trades to frontend configuration.</p> <p>Parameters:</p> Name Type Description Default <code>trade_visualization_options</code> <code>Optional[Any]</code> <p>Optional TradeVisualizationOptions configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary with trade configuration or None if no trades exist.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/managers/trade_manager.py</code> <pre><code>def to_frontend_config(\n    self,\n    trade_visualization_options: Optional[Any] = None,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Convert trades to frontend configuration.\n\n    Args:\n        trade_visualization_options: Optional TradeVisualizationOptions\n            configuration.\n\n    Returns:\n        Dictionary with trade configuration or None if no trades exist.\n    \"\"\"\n    if not self.has_trades():\n        return None\n\n    result: Dict[str, Any] = {\n        \"trades\": [trade.asdict() for trade in self.trades],\n    }\n\n    # Add trade visualization options if they exist\n    if trade_visualization_options:\n        result[\"tradeVisualizationOptions\"] = trade_visualization_options.asdict()\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/managers/trade_manager.html#streamlit_lightweight_charts_pro.charts.managers.trade_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html","title":"streamlit_lightweight_charts_pro.charts.options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options","title":"options","text":"<p>Chart options package for Streamlit Lightweight Charts Pro.</p> <p>This package contains all chart option classes organized by functionality. These options provide comprehensive customization capabilities for charts, allowing fine-grained control over appearance, behavior, and interaction.</p> The package includes <ul> <li>base_options.py: Base Options class for all option classes</li> <li>chart_options.py: Main ChartOptions class</li> <li>layout_options.py: Layout, Grid, Watermark options</li> <li>interaction_options.py: Crosshair, KineticScroll, TrackingMode options</li> <li>time_scale_options.py: TimeScale options</li> <li>price_scale_options.py: PriceScaleOptions options</li> <li>ui_options.py: Legend and RangeSwitcher options</li> <li>localization_options.py: Localization options</li> <li>trade_visualization_options.py: Trade visualization options</li> <li>line_options.py: Line styling options</li> <li>price_format_options.py: Price formatting options</li> <li>price_line_options.py: Price line options</li> </ul> These options enable comprehensive chart customization including <ul> <li>Visual styling (colors, fonts, layouts)</li> <li>Interaction behavior (crosshairs, scrolling, tracking)</li> <li>Scale configuration (time and price scales)</li> <li>UI elements (legends, watermarks, tooltips)</li> <li>Localization and formatting</li> <li>Trade visualization features</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions,\n    LayoutOptions,\n    GridOptions\n\n# Create chart options\noptions = ChartOptions(\n    layout=LayoutOptions(background_color=\"#ffffff\", text_color=\"#000000\"),\n    grid=GridOptions(\n        vert_lines=GridLineOptions(color=\"#e1e1e1\"), horz_lines=GridLineOptions(color=\"#e1e1e1\")\n    ),\n)\n\n# Apply to chart\nchart = Chart().update_options(options)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.Options","title":"Options  <code>dataclass</code>","text":"<p>Abstract base class for all option classes in financial chart configuration.</p> <p>This class provides common functionality for option classes including automatic camelCase key conversion for frontend serialization, enum value conversion, and standardized validation patterns. All option classes in the library should inherit from this base class to ensure consistent behavior and frontend compatibility.</p> <p>The class implements a sophisticated serialization system that handles: - Automatic snake_case to camelCase key conversion for JavaScript compatibility - Enum value extraction and conversion for proper frontend rendering - Nested option object serialization with recursive processing - List serialization with recursive option handling - Dictionary serialization with recursive Options object detection - Special handling for _options fields with flattening logic - Flexible update mechanism with dictionary-based configuration</p> Key Features <ul> <li>Frontend-compatible serialization with camelCase keys</li> <li>Type-safe validation and error handling</li> <li>Recursive nested object processing</li> <li>Enum value extraction and conversion</li> <li>Method chaining support for fluent API usage</li> <li>Comprehensive logging for debugging</li> </ul> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n@dataclass\nclass MyOptions(Options):\n    background_color: str = \"#ffffff\"\n    text_color: str = \"#000000\"\n    is_visible: bool = True\n\n\n@dataclass\nclass NestedOptions(Options):\n    color: str = \"#ff0000\"\n    width: int = 2\n\n\n@dataclass\nclass ContainerOptions(Options):\n    main_options: MyOptions = None\n    nested_dict: Dict[str, NestedOptions] = None\n\n\n# Create and serialize options\noptions = ContainerOptions(\n    main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n)\nresult = options.asdict()\n# Returns: {\n#     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n#     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n# }\n</code></pre> See also <p>chainable_field: Decorator for creating chainable option properties. snake_to_camel: Utility function for key conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>@dataclass\nclass Options(SerializableMixin, ABC):\n    \"\"\"Abstract base class for all option classes in financial chart configuration.\n\n    This class provides common functionality for option classes including automatic\n    camelCase key conversion for frontend serialization, enum value conversion,\n    and standardized validation patterns. All option classes in the library should\n    inherit from this base class to ensure consistent behavior and frontend compatibility.\n\n    The class implements a sophisticated serialization system that handles:\n    - Automatic snake_case to camelCase key conversion for JavaScript compatibility\n    - Enum value extraction and conversion for proper frontend rendering\n    - Nested option object serialization with recursive processing\n    - List serialization with recursive option handling\n    - Dictionary serialization with recursive Options object detection\n    - Special handling for _options fields with flattening logic\n    - Flexible update mechanism with dictionary-based configuration\n\n    Key Features:\n        - Frontend-compatible serialization with camelCase keys\n        - Type-safe validation and error handling\n        - Recursive nested object processing\n        - Enum value extraction and conversion\n        - Method chaining support for fluent API usage\n        - Comprehensive logging for debugging\n\n    Attributes:\n        Inherited by subclasses with specific option attributes. Each subclass\n        defines its own configuration properties with appropriate default values.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n        @dataclass\n        class MyOptions(Options):\n            background_color: str = \"#ffffff\"\n            text_color: str = \"#000000\"\n            is_visible: bool = True\n\n\n        @dataclass\n        class NestedOptions(Options):\n            color: str = \"#ff0000\"\n            width: int = 2\n\n\n        @dataclass\n        class ContainerOptions(Options):\n            main_options: MyOptions = None\n            nested_dict: Dict[str, NestedOptions] = None\n\n\n        # Create and serialize options\n        options = ContainerOptions(\n            main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n        )\n        result = options.asdict()\n        # Returns: {\n        #     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n        #     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n        # }\n        ```\n\n    See also:\n        chainable_field: Decorator for creating chainable option properties.\n        snake_to_camel: Utility function for key conversion.\n    \"\"\"\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n        \"\"\"Update options with a dictionary of values.\n\n        This method provides a flexible way to update option properties using a dictionary.\n        It handles both simple properties and nested objects, automatically creating\n        nested Options instances when needed.\n\n        Args:\n            updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n                Values can be simple types or dictionaries for nested objects.\n\n        Returns:\n            Options: Self for method chaining.\n\n        Raises:\n            ValueError: If an update key doesn't correspond to a valid field.\n            TypeError: If a value type is incompatible with the field type.\n\n        Example:\n            ```python\n            options = MyOptions()\n\n            # Update simple properties\n            options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n            # Update nested objects\n            options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n            # Method chaining\n            options.update({\"color\": \"red\"}).update({\"width\": 100})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            # Convert camelCase to snake_case for field lookup\n            field_name = self._camel_to_snake(key)\n\n            # Check if field exists\n            if not hasattr(self, field_name):\n                # Try the original key in case it's already snake_case\n                if hasattr(self, key):\n                    field_name = key\n                else:\n                    # Ignore invalid fields instead of raising an error\n\n                    continue\n\n            # Get field info for type checking\n            field_info = None\n            for field in fields(self):\n                if field.name == field_name:\n                    field_info = field\n                    break\n\n            if field_info is None:\n                # Ignore fields not found in dataclass fields\n\n                continue\n\n            # Handle nested Options objects and complex type annotations\n            contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n                field_info.type,\n            )\n\n            if contains_options and isinstance(value, dict):\n                if options_class is not None and not is_dict_type:\n                    # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                    current_value = getattr(self, field_name)\n                    if current_value is None:\n                        current_value = options_class()\n                    current_value.update(value)\n                    setattr(self, field_name, current_value)\n                else:\n                    # Handle Dict[str, Options] or similar complex types\n                    # The value is a dict that should contain Options objects\n                    # We'll process it recursively during asdict() call\n                    setattr(self, field_name, value)\n            else:\n                # Simple value assignment - set the field directly to bypass validation\n                # This is what we want for the update method\n                setattr(self, field_name, value)\n\n        return self\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        This is a convenience wrapper around CaseConverter.camel_to_snake()\n        for backward compatibility with existing code.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n\n        See Also:\n            CaseConverter.camel_to_snake: The main implementation in case_converter.py.\n        \"\"\"\n        return CaseConverter.camel_to_snake(camel_case)\n\n    def _process_dict_recursively(self, data: Any) -&gt; Any:\n        \"\"\"Recursively process data structures to handle Options objects.\n\n        This method traverses through nested data structures (dicts, lists) and\n        converts any Options objects to dictionaries using their asdict() method.\n        It also converts dictionary keys from snake_case to camelCase.\n\n        Args:\n            data: The data to process. Can be any type, but the method specifically\n                handles dict, list, and Options types.\n\n        Returns:\n            The processed data with all Options objects converted to dictionaries\n            and keys converted to camelCase.\n        \"\"\"\n        if isinstance(data, Options):\n            return data.asdict()\n        if isinstance(data, dict):\n            return {\n                snake_to_camel(str(k)): self._process_dict_recursively(v) for k, v in data.items()\n            }\n        if isinstance(data, list):\n            return [self._process_dict_recursively(item) for item in data]\n        return data\n\n    def _analyze_type_for_options(self, field_type: Any) -&gt; tuple[bool, type | None, bool]:\n        \"\"\"Analyze a type annotation to determine if it contains Options objects.\n\n        Args:\n            field_type: The type annotation to analyze.\n\n        Returns:\n            Tuple of (contains_options, options_class, is_dict_type) where:\n            - contains_options: True if the type contains Options objects\n            - options_class: The Options class if found, None otherwise\n            - is_dict_type: True if the type is a Dict type (including Optional[Dict])\n        \"\"\"\n        # Direct Options type\n        if isinstance(field_type, type) and issubclass(field_type, Options):\n            return True, field_type, False\n\n        # Check if it's a generic type with origin\n        if not hasattr(field_type, \"__origin__\") or field_type.__origin__ is None:\n            return False, None, False\n\n        origin = field_type.__origin__\n        args = getattr(field_type, \"__args__\", ())\n\n        # Dict type\n        if origin is dict and args and len(args) &gt;= 2:\n            # Safely access args[1] after explicit length check\n            if len(args) &gt; 1:\n                contains_options, options_class, _ = self._analyze_type_for_options(args[1])\n                if contains_options:\n                    return True, options_class, True\n        elif origin is dict and len(args) == 1:\n            # Handle Dict with only one type arg\n            return False, None, False\n\n        # List type\n        elif origin is list and args:\n            contains_options, options_class, _ = self._analyze_type_for_options(args[0])\n            if contains_options:\n                return True, options_class, False\n\n        # Union type (Optional)\n        elif origin is not None:  # Union types\n            # Check if any non-None arg is a Dict type\n            is_dict_type = any(\n                hasattr(arg, \"__origin__\") and arg.__origin__ is dict\n                for arg in args\n                if arg is not type(None)\n            )\n\n            # Check each non-None argument\n            for arg in args:\n                if arg is type(None):\n                    continue\n                contains_options, options_class, _ = self._analyze_type_for_options(arg)\n                if contains_options:\n                    return True, options_class, is_dict_type\n\n        return False, None, False\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n        This method provides comprehensive serialization of option objects for\n        frontend communication. It handles complex nested structures, enum values,\n        and special field flattening patterns.\n\n        The serialization process:\n        1. Iterates through all dataclass fields\n        2. Skips None values, empty strings, and empty dictionaries\n        3. Converts enum values to their .value property\n        4. Recursively serializes nested Options objects\n        5. Handles lists of Options objects\n        6. Recursively processes dictionaries that may contain Options objects at any level\n        7. Converts field names from snake_case to camelCase\n        8. Applies special flattening logic for _options fields\n\n        Returns:\n            Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n                consumption. All nested structures are properly serialized and\n                enum values are converted to their primitive representations.\n\n        Note:\n            - Empty dictionaries and None values are omitted from output\n            - Enum values are automatically converted to their .value property\n            - Nested Options objects are recursively serialized\n            - Lists containing Options objects are handled recursively\n            - Dictionaries containing Options objects at any nesting level are processed recursively\n            - background_options fields are flattened into the parent result\n        \"\"\"\n        # Use the inherited serialization from SerializableMixin\n        return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.Options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.Options.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Options\n</code></pre> <p>Update options with a dictionary of values.</p> <p>This method provides a flexible way to update option properties using a dictionary. It handles both simple properties and nested objects, automatically creating nested Options instances when needed.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types or dictionaries for nested objects.</p> required <p>Returns:</p> Name Type Description <code>Options</code> <code>Options</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an update key doesn't correspond to a valid field.</p> <code>TypeError</code> <p>If a value type is incompatible with the field type.</p> Example <pre><code>options = MyOptions()\n\n# Update simple properties\noptions.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n# Update nested objects\noptions.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n# Method chaining\noptions.update({\"color\": \"red\"}).update({\"width\": 100})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n    \"\"\"Update options with a dictionary of values.\n\n    This method provides a flexible way to update option properties using a dictionary.\n    It handles both simple properties and nested objects, automatically creating\n    nested Options instances when needed.\n\n    Args:\n        updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n            Values can be simple types or dictionaries for nested objects.\n\n    Returns:\n        Options: Self for method chaining.\n\n    Raises:\n        ValueError: If an update key doesn't correspond to a valid field.\n        TypeError: If a value type is incompatible with the field type.\n\n    Example:\n        ```python\n        options = MyOptions()\n\n        # Update simple properties\n        options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n        # Update nested objects\n        options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n        # Method chaining\n        options.update({\"color\": \"red\"}).update({\"width\": 100})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        # Convert camelCase to snake_case for field lookup\n        field_name = self._camel_to_snake(key)\n\n        # Check if field exists\n        if not hasattr(self, field_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                field_name = key\n            else:\n                # Ignore invalid fields instead of raising an error\n\n                continue\n\n        # Get field info for type checking\n        field_info = None\n        for field in fields(self):\n            if field.name == field_name:\n                field_info = field\n                break\n\n        if field_info is None:\n            # Ignore fields not found in dataclass fields\n\n            continue\n\n        # Handle nested Options objects and complex type annotations\n        contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n            field_info.type,\n        )\n\n        if contains_options and isinstance(value, dict):\n            if options_class is not None and not is_dict_type:\n                # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                current_value = getattr(self, field_name)\n                if current_value is None:\n                    current_value = options_class()\n                current_value.update(value)\n                setattr(self, field_name, current_value)\n            else:\n                # Handle Dict[str, Options] or similar complex types\n                # The value is a dict that should contain Options objects\n                # We'll process it recursively during asdict() call\n                setattr(self, field_name, value)\n        else:\n            # Simple value assignment - set the field directly to bypass validation\n            # This is what we want for the update method\n            setattr(self, field_name, value)\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.Options.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert options to dictionary with camelCase keys for frontend.</p> <p>This method provides comprehensive serialization of option objects for frontend communication. It handles complex nested structures, enum values, and special field flattening patterns.</p> <p>The serialization process: 1. Iterates through all dataclass fields 2. Skips None values, empty strings, and empty dictionaries 3. Converts enum values to their .value property 4. Recursively serializes nested Options objects 5. Handles lists of Options objects 6. Recursively processes dictionaries that may contain Options objects at any level 7. Converts field names from snake_case to camelCase 8. Applies special flattening logic for _options fields</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary with camelCase keys ready for frontend consumption. All nested structures are properly serialized and enum values are converted to their primitive representations.</p> Note <ul> <li>Empty dictionaries and None values are omitted from output</li> <li>Enum values are automatically converted to their .value property</li> <li>Nested Options objects are recursively serialized</li> <li>Lists containing Options objects are handled recursively</li> <li>Dictionaries containing Options objects at any nesting level are processed recursively</li> <li>background_options fields are flattened into the parent result</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n    This method provides comprehensive serialization of option objects for\n    frontend communication. It handles complex nested structures, enum values,\n    and special field flattening patterns.\n\n    The serialization process:\n    1. Iterates through all dataclass fields\n    2. Skips None values, empty strings, and empty dictionaries\n    3. Converts enum values to their .value property\n    4. Recursively serializes nested Options objects\n    5. Handles lists of Options objects\n    6. Recursively processes dictionaries that may contain Options objects at any level\n    7. Converts field names from snake_case to camelCase\n    8. Applies special flattening logic for _options fields\n\n    Returns:\n        Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n            consumption. All nested structures are properly serialized and\n            enum values are converted to their primitive representations.\n\n    Note:\n        - Empty dictionaries and None values are omitted from output\n        - Enum values are automatically converted to their .value property\n        - Nested Options objects are recursively serialized\n        - Lists containing Options objects are handled recursively\n        - Dictionaries containing Options objects at any nesting level are processed recursively\n        - background_options fields are flattened into the parent result\n    \"\"\"\n    # Use the inherited serialization from SerializableMixin\n    return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.ChartOptions","title":"ChartOptions  <code>dataclass</code>","text":"<p>Configuration options for chart display and behavior in financial visualization.</p> <p>This class encapsulates all the configuration options that control how a chart is displayed, including its size, layout, grid settings, and various interactive features. It provides a comprehensive interface for customizing chart appearance and behavior across different chart types and use cases.</p> <p>The ChartOptions class serves as the central configuration container that combines layout, interaction, localization, and visualization settings into a unified configuration object that can be passed to chart instances.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Optional[int]</code> <p>Chart width in pixels. If None, uses 100% of container width. Defaults to None for automatic sizing.</p> <code>height</code> <code>int</code> <p>Chart height in pixels. Defaults to 400.</p> <code>auto_size</code> <code>bool</code> <p>Whether to automatically size the chart to fit its container. Defaults to False.</p> <code>layout</code> <code>LayoutOptions</code> <p>Chart layout configuration including background colors, text styling, and visual appearance settings.</p> <code>left_price_scale</code> <code>Optional[PriceScaleOptions]</code> <p>Left price scale configuration. If None, left price scale is disabled.</p> <code>right_price_scale</code> <code>PriceScaleOptions</code> <p>Right price scale configuration. Defaults to standard right price scale settings.</p> <code>overlay_price_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Overlay price scale configurations for multiple price scales on the same chart.</p> <code>time_scale</code> <code>TimeScaleOptions</code> <p>Time scale configuration including axis settings, time formatting, and time range controls.</p> <code>crosshair</code> <code>CrosshairOptions</code> <p>Crosshair configuration for mouse interactions and data point highlighting.</p> <code>grid</code> <code>GridOptions</code> <p>Grid configuration for horizontal and vertical grid lines.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to enable scroll interactions for time navigation. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to enable scale interactions for zooming. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to enable double-click interactions. Defaults to True.</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to False.</p> <code>kinetic_scroll</code> <code>Optional[KineticScrollOptions]</code> <p>Kinetic scroll options for momentum-based scrolling behavior.</p> <code>tracking_mode</code> <code>Optional[TrackingModeOptions]</code> <p>Mouse tracking mode for crosshair and tooltips. Controls how the chart responds to mouse movement.</p> <code>localization</code> <code>Optional[LocalizationOptions]</code> <p>Localization settings for date/time formatting and locale-specific display options.</p> <code>add_default_pane</code> <code>bool</code> <p>Whether to add a default pane to the chart. Defaults to True.</p> <code>trade_visualization</code> <code>Optional[TradeVisualizationOptions]</code> <p>Trade visualization configuration options for displaying trade markers and annotations.</p> <code>range_switcher</code> <code>Optional[RangeSwitcherOptions]</code> <p>Range switcher configuration for time range selection buttons and presets.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any attribute is assigned an invalid type during initialization.</p> <code>PriceScaleIdTypeError</code> <p>If price scale ID is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale options are not of correct type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800,\n    height=600,\n    layout=LayoutOptions(background_color=\"#ffffff\"),\n    handle_scroll=True,\n    handle_scale=True,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/chart_options.py</code> <pre><code>@dataclass\n@chainable_field(\"width\", int)\n@chainable_field(\"height\", int)\n@chainable_field(\"auto_size\", bool)\n@chainable_field(\"layout\", LayoutOptions)\n@chainable_field(\"left_price_scale\", PriceScaleOptions)\n@chainable_field(\"right_price_scale\", PriceScaleOptions)\n@chainable_field(\"overlay_price_scales\", dict)\n@chainable_field(\"time_scale\", TimeScaleOptions)\n@chainable_field(\"crosshair\", CrosshairOptions)\n@chainable_field(\"grid\", GridOptions)\n@chainable_field(\"handle_scroll\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"kinetic_scroll\", KineticScrollOptions)\n@chainable_field(\"tracking_mode\", TrackingModeOptions)\n@chainable_field(\"localization\", LocalizationOptions)\n@chainable_field(\"add_default_pane\", bool)\n@chainable_field(\"trade_visualization\", TradeVisualizationOptions)\n@chainable_field(\"range_switcher\", RangeSwitcherOptions)\nclass ChartOptions(Options):\n    \"\"\"Configuration options for chart display and behavior in financial visualization.\n\n    This class encapsulates all the configuration options that control how a chart\n    is displayed, including its size, layout, grid settings, and various interactive\n    features. It provides a comprehensive interface for customizing chart appearance\n    and behavior across different chart types and use cases.\n\n    The ChartOptions class serves as the central configuration container that combines\n    layout, interaction, localization, and visualization settings into a unified\n    configuration object that can be passed to chart instances.\n\n    Attributes:\n        width (Optional[int]): Chart width in pixels. If None, uses 100% of container width.\n            Defaults to None for automatic sizing.\n        height (int): Chart height in pixels. Defaults to 400.\n        auto_size (bool): Whether to automatically size the chart to fit its container.\n            Defaults to False.\n        layout (LayoutOptions): Chart layout configuration including background colors,\n            text styling, and visual appearance settings.\n        left_price_scale (Optional[PriceScaleOptions]): Left price scale configuration.\n            If None, left price scale is disabled.\n        right_price_scale (PriceScaleOptions): Right price scale configuration.\n            Defaults to standard right price scale settings.\n        overlay_price_scales (Dict[str, PriceScaleOptions]): Overlay price scale\n            configurations for multiple price scales on the same chart.\n        time_scale (TimeScaleOptions): Time scale configuration including axis settings,\n            time formatting, and time range controls.\n        crosshair (CrosshairOptions): Crosshair configuration for mouse interactions\n            and data point highlighting.\n        grid (GridOptions): Grid configuration for horizontal and vertical grid lines.\n        handle_scroll (bool): Whether to enable scroll interactions for time navigation.\n            Defaults to True.\n        handle_scale (bool): Whether to enable scale interactions for zooming.\n            Defaults to True.\n        handle_double_click (bool): Whether to enable double-click interactions.\n            Defaults to True.\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to False.\n        kinetic_scroll (Optional[KineticScrollOptions]): Kinetic scroll options for\n            momentum-based scrolling behavior.\n        tracking_mode (Optional[TrackingModeOptions]): Mouse tracking mode for crosshair\n            and tooltips. Controls how the chart responds to mouse movement.\n        localization (Optional[LocalizationOptions]): Localization settings for date/time\n            formatting and locale-specific display options.\n        add_default_pane (bool): Whether to add a default pane to the chart.\n            Defaults to True.\n        trade_visualization (Optional[TradeVisualizationOptions]): Trade visualization\n            configuration options for displaying trade markers and annotations.\n        range_switcher (Optional[RangeSwitcherOptions]): Range switcher configuration\n            for time range selection buttons and presets.\n\n    Raises:\n        TypeError: If any attribute is assigned an invalid type during initialization.\n        PriceScaleIdTypeError: If price scale ID is not a string.\n        PriceScaleOptionsTypeError: If price scale options are not of correct type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import ChartOptions\n        from streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n        # Create custom chart options\n        options = ChartOptions(\n            width=800,\n            height=600,\n            layout=LayoutOptions(background_color=\"#ffffff\"),\n            handle_scroll=True,\n            handle_scale=True,\n        )\n        ```\n    \"\"\"\n\n    # Size and layout options\n    width: Optional[int] = None\n    height: int = 400\n    auto_size: bool = True\n\n    # Layout and appearance\n    layout: LayoutOptions = field(default_factory=LayoutOptions)\n    left_price_scale: Optional[PriceScaleOptions] = None\n    right_price_scale: PriceScaleOptions = field(default_factory=PriceScaleOptions)\n    overlay_price_scales: Dict[str, PriceScaleOptions] = field(default_factory=dict)\n    time_scale: TimeScaleOptions = field(default_factory=TimeScaleOptions)\n\n    # Interaction options\n    crosshair: CrosshairOptions = field(default_factory=CrosshairOptions)\n    grid: GridOptions = field(default_factory=GridOptions)\n    handle_scroll: bool = True\n    handle_scale: bool = True\n    handle_double_click: bool = True\n    fit_content_on_load: bool = True\n    kinetic_scroll: Optional[KineticScrollOptions] = None\n    tracking_mode: Optional[TrackingModeOptions] = None\n\n    # Localization and UI\n    localization: Optional[LocalizationOptions] = None\n    add_default_pane: bool = True\n\n    # Trade visualization options\n    trade_visualization: Optional[TradeVisualizationOptions] = None\n\n    # UI options\n    range_switcher: Optional[RangeSwitcherOptions] = None\n\n    # Synchronization options\n\n    def __post_init__(self):\n        \"\"\"Validate chart options after initialization.\"\"\"\n        # Validate price scale types first before accessing attributes\n        if self.right_price_scale is not None and not isinstance(\n            self.right_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"right_price_scale\", type(self.right_price_scale))\n\n        if self.left_price_scale is not None and not isinstance(\n            self.left_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"left_price_scale\", type(self.left_price_scale))\n\n        # CRITICAL FIX: Ensure default price scales have their IDs set\n        # Without this, the empty string price_scale_id gets filtered out during serialization\n        # This causes the frontend to fail matching series to their price scales\n        if self.right_price_scale is not None and self.right_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"right\" if it's None\n            self.right_price_scale.price_scale_id = \"right\"\n\n        if self.left_price_scale is not None and self.left_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"left\" if it's None\n            self.left_price_scale.price_scale_id = \"left\"\n\n        # Validate price scale IDs are strings\n        if (\n            self.right_price_scale is not None\n            and self.right_price_scale.price_scale_id is not None\n            and not isinstance(self.right_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale.price_scale_id),\n            )\n\n        if (\n            self.left_price_scale is not None\n            and self.left_price_scale.price_scale_id is not None\n            and not isinstance(self.left_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale.price_scale_id),\n            )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.CrosshairLineOptions","title":"CrosshairLineOptions  <code>dataclass</code>","text":"<p>Crosshair line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"label_visible\", bool)\nclass CrosshairLineOptions(Options):\n    \"\"\"Crosshair line configuration.\"\"\"\n\n    color: str = \"#758696\"\n    width: int = 1\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = True\n    label_visible: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.CrosshairOptions","title":"CrosshairOptions  <code>dataclass</code>","text":"<p>Crosshair configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"mode\", CrosshairMode)\n@chainable_field(\"vert_line\", CrosshairLineOptions)\n@chainable_field(\"horz_line\", CrosshairLineOptions)\nclass CrosshairOptions(Options):\n    \"\"\"Crosshair configuration for chart.\"\"\"\n\n    mode: CrosshairMode = CrosshairMode.NORMAL\n    vert_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n    horz_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.CrosshairSyncOptions","title":"CrosshairSyncOptions  <code>dataclass</code>","text":"<p>Crosshair synchronization configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"group_id\", int)\n@chainable_field(\"suppress_series_animations\", bool)\nclass CrosshairSyncOptions(Options):\n    \"\"\"Crosshair synchronization configuration.\"\"\"\n\n    group_id: int = 1\n    suppress_series_animations: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.KineticScrollOptions","title":"KineticScrollOptions  <code>dataclass</code>","text":"<p>Kinetic scroll configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"touch\", bool)\n@chainable_field(\"mouse\", bool)\nclass KineticScrollOptions(Options):\n    \"\"\"Kinetic scroll configuration for chart.\"\"\"\n\n    touch: bool = True\n    mouse: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.TrackingModeOptions","title":"TrackingModeOptions  <code>dataclass</code>","text":"<p>Tracking mode configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"exit_on_escape\", bool)\nclass TrackingModeOptions(Options):\n    \"\"\"Tracking mode configuration for chart.\"\"\"\n\n    exit_on_escape: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.GridLineOptions","title":"GridLineOptions  <code>dataclass</code>","text":"<p>Grid line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\nclass GridLineOptions(Options):\n    \"\"\"Grid line configuration.\"\"\"\n\n    color: str = \"#e1e3e6\"\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.GridOptions","title":"GridOptions  <code>dataclass</code>","text":"<p>Grid configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"vert_lines\", GridLineOptions)\n@chainable_field(\"horz_lines\", GridLineOptions)\nclass GridOptions(Options):\n    \"\"\"Grid configuration for chart.\"\"\"\n\n    vert_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=False))\n    horz_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=True))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.LayoutOptions","title":"LayoutOptions  <code>dataclass</code>","text":"<p>Layout configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"background_options\", (BackgroundSolid, BackgroundGradient))\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"font_size\", int)\n@chainable_field(\"font_family\", str)\n@chainable_field(\"pane_options\", PaneOptions)\n@chainable_field(\"pane_heights\", Dict[int, PaneHeightOptions])\n@chainable_field(\"attribution_logo\", bool)\nclass LayoutOptions(Options):\n    \"\"\"Layout configuration for chart.\"\"\"\n\n    background_options: BackgroundSolid = field(\n        default_factory=lambda: BackgroundSolid(color=\"#ffffff\"),\n    )\n    text_color: str = \"#131722\"\n    font_size: int = 11\n    font_family: str = \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\"\n    pane_options: Optional[PaneOptions] = None\n    pane_heights: Optional[Dict[int, PaneHeightOptions]] = None\n    attribution_logo: bool = False\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ValueValidationError(property_name, \"Invalid color format\")\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.PaneHeightOptions","title":"PaneHeightOptions  <code>dataclass</code>","text":"<p>Pane height configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"factor\", float)\nclass PaneHeightOptions(Options):\n    \"\"\"Pane height configuration for chart.\"\"\"\n\n    factor: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate factor value.\"\"\"\n        if self.factor &lt;= 0:\n            raise ValueValidationError.positive_value(\"Pane height factor\", self.factor)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.WatermarkOptions","title":"WatermarkOptions  <code>dataclass</code>","text":"<p>Watermark configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"text\", str)\n@chainable_field(\"font_size\", int)\n@chainable_field(\"horz_align\", HorzAlign)\n@chainable_field(\"vert_align\", VertAlign)\n@chainable_field(\"color\", str, validator=\"color\")\nclass WatermarkOptions(Options):\n    \"\"\"Watermark configuration.\"\"\"\n\n    visible: bool = True\n    text: str = \"\"\n    font_size: int = 96\n    horz_align: HorzAlign = HorzAlign.CENTER\n    vert_align: VertAlign = VertAlign.CENTER\n    color: str = \"rgba(255, 255, 255, 0.1)\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.LineOptions","title":"LineOptions  <code>dataclass</code>","text":"<p>Comprehensive styling options for line series in financial chart visualization.</p> <p>This class encapsulates all the styling options that control how a line series appears on a chart. It mirrors TradingView's LineStyleOptions interface and provides extensive customization capabilities for line visualization.</p> <p>The LineOptions class supports various line styles, marker configurations, animation effects, and visual customization options to create professional-looking line charts for financial data visualization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Line color in hex or rgba format. Defaults to \"#2196f3\" (blue). Must be a valid color format for proper rendering.</p> <code>line_style</code> <code>LineStyle</code> <p>Line style for the series line. Options include SOLID, DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.</p> <code>line_width</code> <code>int</code> <p>Line width in pixels. Defaults to 3. Higher values create thicker lines for better visibility.</p> <code>line_type</code> <code>LineType</code> <p>Line type for connecting data points. Options include SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.</p> <code>line_visible</code> <code>bool</code> <p>Whether to show the series line. Defaults to True. Set to False to show only markers.</p> <code>point_markers_visible</code> <code>bool</code> <p>Whether to show circle markers on each data point. Defaults to False. Useful for highlighting individual data points.</p> <code>point_markers_radius</code> <code>Optional[int]</code> <p>Radius of point markers in pixels. Defaults to None (uses default radius). Only used when point_markers_visible is True.</p> <code>crosshair_marker_visible</code> <code>bool</code> <p>Whether to show the crosshair marker during mouse interactions. Defaults to False. Provides visual feedback during hovering.</p> <code>crosshair_marker_radius</code> <code>int</code> <p>Radius of crosshair marker in pixels. Defaults to 4. Controls the size of the interaction marker.</p> <code>crosshair_marker_border_color</code> <code>str</code> <p>Border color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_background_color</code> <code>str</code> <p>Background color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_border_width</code> <code>int</code> <p>Border width for crosshair marker in pixels. Defaults to 2. Controls the thickness of the marker border.</p> <code>last_price_animation</code> <code>LastPriceAnimationMode</code> <p>Animation mode for last price updates. Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.</p> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If color values are not in valid hex or rgba format.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import LineOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import (\n    LineStyle,\n    LineType,\n    LastPriceAnimationMode,\n)\n\n# Create line options with custom styling\nline_opts = LineOptions(\n    color=\"#FF5722\",\n    line_style=LineStyle.SOLID,\n    line_width=2,\n    line_type=LineType.CURVED,\n    point_markers_visible=True,\n    crosshair_marker_visible=True,\n    last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n)\n\n# Use with line series\nseries = LineSeries(data=data, line_options=line_opts)\n</code></pre> See also <p>TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_type\", LineType)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"point_markers_visible\", bool)\n@chainable_field(\"point_markers_radius\", int)\n@chainable_field(\"crosshair_marker_visible\", bool)\n@chainable_field(\"crosshair_marker_radius\", int)\n@chainable_field(\"crosshair_marker_border_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_background_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_border_width\", int)\n@chainable_field(\"last_price_animation\", LastPriceAnimationMode)\nclass LineOptions(Options):\n    \"\"\"Comprehensive styling options for line series in financial chart visualization.\n\n    This class encapsulates all the styling options that control how a line series\n    appears on a chart. It mirrors TradingView's LineStyleOptions interface and\n    provides extensive customization capabilities for line visualization.\n\n    The LineOptions class supports various line styles, marker configurations,\n    animation effects, and visual customization options to create professional-looking\n    line charts for financial data visualization.\n\n    Attributes:\n        color (str): Line color in hex or rgba format. Defaults to \"#2196f3\" (blue).\n            Must be a valid color format for proper rendering.\n        line_style (LineStyle): Line style for the series line. Options include SOLID,\n            DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.\n        line_width (int): Line width in pixels. Defaults to 3. Higher values create\n            thicker lines for better visibility.\n        line_type (LineType): Line type for connecting data points. Options include\n            SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.\n        line_visible (bool): Whether to show the series line. Defaults to True.\n            Set to False to show only markers.\n        point_markers_visible (bool): Whether to show circle markers on each data point.\n            Defaults to False. Useful for highlighting individual data points.\n        point_markers_radius (Optional[int]): Radius of point markers in pixels.\n            Defaults to None (uses default radius). Only used when point_markers_visible is True.\n        crosshair_marker_visible (bool): Whether to show the crosshair marker during\n            mouse interactions. Defaults to False. Provides visual feedback during hovering.\n        crosshair_marker_radius (int): Radius of crosshair marker in pixels.\n            Defaults to 4. Controls the size of the interaction marker.\n        crosshair_marker_border_color (str): Border color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_background_color (str): Background color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_border_width (int): Border width for crosshair marker in pixels.\n            Defaults to 2. Controls the thickness of the marker border.\n        last_price_animation (LastPriceAnimationMode): Animation mode for last price updates.\n            Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.\n\n    Raises:\n        ColorValidationError: If color values are not in valid hex or rgba format.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import LineOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            LineStyle,\n            LineType,\n            LastPriceAnimationMode,\n        )\n\n        # Create line options with custom styling\n        line_opts = LineOptions(\n            color=\"#FF5722\",\n            line_style=LineStyle.SOLID,\n            line_width=2,\n            line_type=LineType.CURVED,\n            point_markers_visible=True,\n            crosshair_marker_visible=True,\n            last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n        )\n\n        # Use with line series\n        series = LineSeries(data=data, line_options=line_opts)\n        ```\n\n    See also:\n        TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions\n    \"\"\"\n\n    color: str = \"#2196f3\"\n    line_style: LineStyle = LineStyle.SOLID\n    line_width: int = 3\n    line_type: LineType = LineType.SIMPLE\n    line_visible: bool = True\n    point_markers_visible: bool = False\n    point_markers_radius: Optional[int] = None\n    crosshair_marker_visible: bool = False\n    crosshair_marker_radius: int = 4\n    crosshair_marker_border_color: str = \"\"\n    crosshair_marker_background_color: str = \"\"\n    crosshair_marker_border_width: int = 2\n    last_price_animation: LastPriceAnimationMode = LastPriceAnimationMode.DISABLED\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\n\n        Validates that the provided color string is in a valid format (hex or rgba)\n        and raises an appropriate error if validation fails. This method is used\n        by the chainable_field decorator for color validation.\n\n        Args:\n            color (str): Color string to validate in hex or rgba format.\n            property_name (str): Name of the property being validated for error messages.\n\n        Returns:\n            str: The validated color string if valid.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n\n        Example:\n            ```python\n            # Valid colors\n            valid_color = LineOptions._validate_color_static(\"#FF0000\", \"color\")\n            valid_rgba = LineOptions._validate_color_static(\"rgba(255,0,0,0.5)\", \"color\")\n\n            # Invalid color (will raise ColorValidationError)\n            try:\n                invalid_color = LineOptions._validate_color_static(\"invalid\", \"color\")\n            except ColorValidationError as e:\n                print(f\"Invalid color: {e}\")\n            ```\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.LocalizationOptions","title":"LocalizationOptions  <code>dataclass</code>","text":"<p>Localization configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/localization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"locale\", str)\n@chainable_field(\"date_format\", str)\n@chainable_field(\"time_format\", str)\n@chainable_field(\"price_formatter\", allow_none=True)\n@chainable_field(\"percentage_formatter\", allow_none=True)\nclass LocalizationOptions(Options):\n    \"\"\"Localization configuration for chart.\"\"\"\n\n    locale: str = \"en-US\"\n    date_format: str = \"yyyy-MM-dd\"\n    time_format: str = \"HH:mm:ss\"\n    price_formatter: Optional[Callable] = None\n    percentage_formatter: Optional[Callable] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.PriceFormatOptions","title":"PriceFormatOptions  <code>dataclass</code>","text":"<p>Encapsulates price formatting options for a series, matching TradingView's API.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Format type (\"price\", \"volume\", \"percent\", \"custom\").</p> <code>precision</code> <code>int</code> <p>Number of decimal places.</p> <code>min_move</code> <code>float</code> <p>Minimum price movement.</p> <code>formatter</code> <code>Optional[str]</code> <p>Optional custom formatter (string name or function reference).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_format_options.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str, validator=\"price_format_type\")\n@chainable_field(\"precision\", int, validator=\"precision\")\n@chainable_field(\"min_move\", (int, float), validator=\"min_move\")\n@chainable_field(\"formatter\", str)\nclass PriceFormatOptions(Options):\n    \"\"\"Encapsulates price formatting options for a series, matching TradingView's API.\n\n    Attributes:\n        type (str): Format type (\"price\", \"volume\", \"percent\", \"custom\").\n        precision (int): Number of decimal places.\n        min_move (float): Minimum price movement.\n        formatter (Optional[str]): Optional custom formatter (string name or function reference).\n    \"\"\"\n\n    type: str = \"price\"\n    precision: int = 2\n    min_move: float = 0.01\n    formatter: Optional[str] = None\n\n    @staticmethod\n    def _validate_type_static(type_value: str) -&gt; str:\n        \"\"\"Static version of type validator for decorator use.\"\"\"\n        if type_value not in {\"price\", \"volume\", \"percent\", \"custom\"}:\n            raise ValueValidationError(\n                \"type\",\n                f\"must be one of 'price', 'volume', 'percent', 'custom', got {type_value!r}\",\n            )\n        return type_value\n\n    @staticmethod\n    def _validate_precision_static(precision: int) -&gt; int:\n        \"\"\"Static version of precision validator for decorator use.\"\"\"\n        if not isinstance(precision, int) or precision &lt; 0:\n            raise ValueValidationError(\"precision\", \"must be a non-negative integer\")\n        return precision\n\n    @staticmethod\n    def _validate_min_move_static(min_move: float) -&gt; float:\n        \"\"\"Static version of min_move validator for decorator use.\"\"\"\n        if not isinstance(min_move, (int, float)) or min_move &lt;= 0:\n            raise ValueValidationError(\"min_move\", \"must be a positive number\")\n        return min_move\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.PriceLineOptions","title":"PriceLineOptions  <code>dataclass</code>","text":"<p>Encapsulates style and configuration options for a price line.</p> <p>Matching TradingView's PriceLineOptions.</p> <p>See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Optional ID of the price line.</p> <code>price</code> <code>float</code> <p>Price line's value.</p> <code>color</code> <code>str</code> <p>Price line's color (hex or rgba).</p> <code>line_width</code> <code>int</code> <p>Price line's width in pixels.</p> <code>line_style</code> <code>LineStyle</code> <p>Price line's style.</p> <code>line_visible</code> <code>bool</code> <p>Whether the line is displayed.</p> <code>axis_label_visible</code> <code>bool</code> <p>Whether the price value is shown on the price scale.</p> <code>title</code> <code>str</code> <p>Title for the price line on the chart pane.</p> <code>axis_label_color</code> <code>Optional[str]</code> <p>Background color for the axis label.</p> <code>axis_label_text_color</code> <code>Optional[str]</code> <p>Text color for the axis label.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"id\", str)\n@chainable_field(\"price\", (int, float))\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"axis_label_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"axis_label_color\", str, validator=\"color\")\n@chainable_field(\"axis_label_text_color\", str, validator=\"color\")\nclass PriceLineOptions(Options):\n    \"\"\"Encapsulates style and configuration options for a price line.\n\n    Matching TradingView's PriceLineOptions.\n\n    See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions\n\n    Attributes:\n        id (Optional[str]): Optional ID of the price line.\n        price (float): Price line's value.\n        color (str): Price line's color (hex or rgba).\n        line_width (int): Price line's width in pixels.\n        line_style (LineStyle): Price line's style.\n        line_visible (bool): Whether the line is displayed.\n        axis_label_visible (bool): Whether the price value is shown on the price scale.\n        title (str): Title for the price line on the chart pane.\n        axis_label_color (Optional[str]): Background color for the axis label.\n        axis_label_text_color (Optional[str]): Text color for the axis label.\n    \"\"\"\n\n    id: Optional[str] = None\n    price: float = 0.0\n    color: str = \"\"\n    line_width: int = 1\n    line_style: LineStyle = LineStyle.SOLID\n    line_visible: bool = True\n    axis_label_visible: bool = False\n    title: str = \"\"\n    axis_label_color: Optional[str] = None\n    axis_label_text_color: Optional[str] = None\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\"\"\"\n        if color and not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.PriceScaleMargins","title":"PriceScaleMargins  <code>dataclass</code>","text":"<p>Configuration for price scale margins in financial charts.</p> <p>This class defines the margin settings for price scales, controlling the spacing between the chart content and the price scale boundaries. Margins are specified as percentages of the visible price range.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space above the chart.</p> <code>bottom</code> <code>float</code> <p>Bottom margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space below the chart.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n# Create margins with custom spacing\nmargins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n# Use with price scale options\nprice_scale = PriceScaleOptions(scale_margins=margins)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"top\", (int, float))\n@chainable_field(\"bottom\", (int, float))\nclass PriceScaleMargins(Options):\n    \"\"\"Configuration for price scale margins in financial charts.\n\n    This class defines the margin settings for price scales, controlling the\n    spacing between the chart content and the price scale boundaries. Margins\n    are specified as percentages of the visible price range.\n\n    Attributes:\n        top (float): Top margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space above the chart.\n        bottom (float): Bottom margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space below the chart.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n        # Create margins with custom spacing\n        margins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n        # Use with price scale options\n        price_scale = PriceScaleOptions(scale_margins=margins)\n        ```\n    \"\"\"\n\n    top: float = 0.1  # Top margin as percentage of visible price range\n    bottom: float = 0.1  # Bottom margin as percentage of visible price range\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.PriceScaleOptions","title":"PriceScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for price scales in financial charts.</p> <p>This class provides extensive configuration options for price scales, controlling how price values are displayed, formatted, and positioned on the chart. It supports both left and right price scales as well as overlay scales with full customization of appearance, behavior, and interaction.</p> <p>Attributes:</p> Name Type Description <code>visible</code> <code>bool</code> <p>Whether the price scale is visible. Defaults to True.</p> <code>auto_scale</code> <code>bool</code> <p>Whether to automatically scale the price range based on data. Defaults to True. Set to False for manual scale control.</p> <code>mode</code> <code>PriceScaleMode</code> <p>Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE). Defaults to PriceScaleMode.NORMAL for linear scaling.</p> <code>invert_scale</code> <code>bool</code> <p>Whether to invert the price scale (high to low). Defaults to False for normal orientation.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the price scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the price scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>text_color</code> <code>str</code> <p>Color of price scale text and labels. Defaults to dark gray. Must be valid color format (hex or rgba).</p> <code>ticks_visible</code> <code>bool</code> <p>Whether to show tick marks on the price scale. Defaults to True.</p> <code>ensure_edge_tick_marks_visible</code> <code>bool</code> <p>Whether to ensure edge tick marks are always visible. Defaults to False.</p> <code>align_labels</code> <code>bool</code> <p>Whether to align price labels. Defaults to True.</p> <code>entire_text_only</code> <code>bool</code> <p>Whether to show only complete text labels. Defaults to False.</p> <code>minimum_width</code> <code>int</code> <p>Minimum width of the price scale in pixels. Defaults to 72 pixels.</p> <code>scale_margins</code> <code>PriceScaleMargins</code> <p>Margin configuration for the price scale. Defaults to 10% margins on top and bottom.</p> <code>price_scale_id</code> <code>str</code> <p>Unique identifier for the price scale. Defaults to \"\".</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n# Create left price scale with custom styling\nleft_scale = PriceScaleOptions(\n    visible=True,\n    auto_scale=True,\n    mode=PriceScaleMode.NORMAL,\n    border_color=\"#e0e0e0\",\n    text_color=\"#333333\",\n    minimum_width=100,\n)\n\n# Create right price scale for overlay series\nright_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n</code></pre> See also <p>PriceScaleMargins: Configuration class for price scale margins. PriceScaleMode: Enum for different price scale modes.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"auto_scale\", bool)\n@chainable_field(\"mode\", PriceScaleMode)\n@chainable_field(\"invert_scale\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"ticks_visible\", bool)\n@chainable_field(\"ensure_edge_tick_marks_visible\", bool)\n@chainable_field(\"align_labels\", bool)\n@chainable_field(\"entire_text_only\", bool)\n@chainable_field(\"minimum_width\", int)\n@chainable_field(\"scale_margins\", PriceScaleMargins)\n@chainable_field(\"price_scale_id\", str)\nclass PriceScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for price scales in financial charts.\n\n    This class provides extensive configuration options for price scales, controlling\n    how price values are displayed, formatted, and positioned on the chart. It supports\n    both left and right price scales as well as overlay scales with full customization\n    of appearance, behavior, and interaction.\n\n    Attributes:\n        visible (bool): Whether the price scale is visible. Defaults to True.\n        auto_scale (bool): Whether to automatically scale the price range based on data.\n            Defaults to True. Set to False for manual scale control.\n        mode (PriceScaleMode): Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE).\n            Defaults to PriceScaleMode.NORMAL for linear scaling.\n        invert_scale (bool): Whether to invert the price scale (high to low).\n            Defaults to False for normal orientation.\n        border_visible (bool): Whether to show the price scale border. Defaults to True.\n        border_color (str): Color of the price scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        text_color (str): Color of price scale text and labels. Defaults to dark gray.\n            Must be valid color format (hex or rgba).\n        ticks_visible (bool): Whether to show tick marks on the price scale.\n            Defaults to True.\n        ensure_edge_tick_marks_visible (bool): Whether to ensure edge tick marks\n            are always visible. Defaults to False.\n        align_labels (bool): Whether to align price labels. Defaults to True.\n        entire_text_only (bool): Whether to show only complete text labels.\n            Defaults to False.\n        minimum_width (int): Minimum width of the price scale in pixels.\n            Defaults to 72 pixels.\n        scale_margins (PriceScaleMargins): Margin configuration for the price scale.\n            Defaults to 10% margins on top and bottom.\n        price_scale_id (str): Unique identifier for the price scale. Defaults to \"\".\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n        # Create left price scale with custom styling\n        left_scale = PriceScaleOptions(\n            visible=True,\n            auto_scale=True,\n            mode=PriceScaleMode.NORMAL,\n            border_color=\"#e0e0e0\",\n            text_color=\"#333333\",\n            minimum_width=100,\n        )\n\n        # Create right price scale for overlay series\n        right_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n        ```\n\n    See also:\n        PriceScaleMargins: Configuration class for price scale margins.\n        PriceScaleMode: Enum for different price scale modes.\n    \"\"\"\n\n    # Core visibility and behavior settings\n    visible: bool = True  # Whether the price scale is visible\n    auto_scale: bool = True  # Whether to automatically scale based on data\n    mode: PriceScaleMode = PriceScaleMode.NORMAL  # Price scale mode (linear/log/percentage)\n    invert_scale: bool = False  # Whether to invert the scale orientation\n\n    # Visual appearance configuration\n    border_visible: bool = True  # Whether to show the price scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n    text_color: str = \"#131722\"  # Text color (TradingView dark gray)\n\n    # Tick marks and label configuration\n    ticks_visible: bool = True  # Whether to show tick marks\n    ensure_edge_tick_marks_visible: bool = False  # Force edge tick marks to be visible\n    align_labels: bool = True  # Whether to align price labels\n    entire_text_only: bool = False  # Whether to show only complete text labels\n\n    # Size and positioning settings\n    minimum_width: int = 72  # Minimum width in pixels\n    scale_margins: PriceScaleMargins = field(\n        default_factory=PriceScaleMargins,\n    )  # Margin configuration\n\n    # Price scale identification\n    price_scale_id: str = \"\"  # Unique identifier for the price scale\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions","title":"SyncOptions  <code>dataclass</code>","text":"<p>Synchronization options for linked charts.</p> <p>This class provides configuration options for synchronizing multiple charts in a linked chart system. It controls crosshair and time range synchronization behavior across linked charts, including support for chart groups to enable selective synchronization.</p> <p>When synchronization is enabled, user interactions (crosshair movements and zoom/scroll operations) on one chart are propagated to all other charts in the same synchronization group. This creates a coordinated viewing experience across multiple charts.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether synchronization is enabled. When True, enables synchronization features based on crosshair and time_range settings. When False, disables all synchronization. Defaults to False.</p> <code>crosshair</code> <code>bool</code> <p>Whether to synchronize crosshair position across linked charts. When enabled, moving the crosshair on one chart will update the crosshair position on all linked charts. Defaults to False.</p> <code>time_range</code> <code>bool</code> <p>Whether to synchronize time range (zoom/scroll) across linked charts. When enabled, zooming or panning the time range on one chart will update the visible time range on all linked charts. Defaults to False.</p> <code>group_id</code> <code>Optional[str]</code> <p>Optional group identifier for chart synchronization. Charts with the same group_id will be synchronized with each other. If None, all charts in the same ChartManager will be synchronized. Defaults to None.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n# Enable all synchronization\nsync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n# Enable only crosshair synchronization\nsync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n# Use with group synchronization\nsync_options = SyncOptions(\n    enabled=True,\n    crosshair=True,\n    time_range=True,\n    group_id=\"price_charts\"\n)\n</code></pre> Note <p>The synchronization system prevents race conditions and feedback loops through debouncing and flag-based protection mechanisms. This ensures smooth performance even with rapid user interactions.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"crosshair\", bool)\n@chainable_field(\"time_range\", bool)\n@chainable_field(\"group_id\", str)\nclass SyncOptions(Options):\n    \"\"\"Synchronization options for linked charts.\n\n    This class provides configuration options for synchronizing multiple\n    charts in a linked chart system. It controls crosshair and time range\n    synchronization behavior across linked charts, including support for\n    chart groups to enable selective synchronization.\n\n    When synchronization is enabled, user interactions (crosshair movements\n    and zoom/scroll operations) on one chart are propagated to all other\n    charts in the same synchronization group. This creates a coordinated\n    viewing experience across multiple charts.\n\n    Attributes:\n        enabled (bool): Whether synchronization is enabled. When True,\n            enables synchronization features based on crosshair and time_range\n            settings. When False, disables all synchronization. Defaults to False.\n        crosshair (bool): Whether to synchronize crosshair position across\n            linked charts. When enabled, moving the crosshair on one chart\n            will update the crosshair position on all linked charts.\n            Defaults to False.\n        time_range (bool): Whether to synchronize time range (zoom/scroll)\n            across linked charts. When enabled, zooming or panning the time\n            range on one chart will update the visible time range on all\n            linked charts. Defaults to False.\n        group_id (Optional[str]): Optional group identifier for chart\n            synchronization. Charts with the same group_id will be\n            synchronized with each other. If None, all charts in the\n            same ChartManager will be synchronized. Defaults to None.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n        # Enable all synchronization\n        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n        # Enable only crosshair synchronization\n        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n        # Use with group synchronization\n        sync_options = SyncOptions(\n            enabled=True,\n            crosshair=True,\n            time_range=True,\n            group_id=\"price_charts\"\n        )\n        ```\n\n    Note:\n        The synchronization system prevents race conditions and feedback loops\n        through debouncing and flag-based protection mechanisms. This ensures\n        smooth performance even with rapid user interactions.\n    \"\"\"\n\n    enabled: bool = False\n    crosshair: bool = False\n    time_range: bool = False\n    group_id: Optional[str] = None\n\n    def enable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = True\n        self.crosshair = True\n        self.time_range = True\n        return self\n\n    def disable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = False\n        self.crosshair = False\n        self.time_range = False\n        return self\n\n    def enable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = True\n        self.enabled = True\n        return self\n\n    def disable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = False\n        if not self.time_range:\n            self.enabled = False\n        return self\n\n    def enable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = True\n        self.enabled = True\n        return self\n\n    def disable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = False\n        if not self.crosshair:\n            self.enabled = False\n        return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.enable_all","title":"enable_all","text":"<pre><code>enable_all() -&gt; SyncOptions\n</code></pre> <p>Enable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = True\n    self.crosshair = True\n    self.time_range = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.disable_all","title":"disable_all","text":"<pre><code>disable_all() -&gt; SyncOptions\n</code></pre> <p>Disable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = False\n    self.crosshair = False\n    self.time_range = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.enable_crosshair","title":"enable_crosshair","text":"<pre><code>enable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Enable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.disable_crosshair","title":"disable_crosshair","text":"<pre><code>disable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Disable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = False\n    if not self.time_range:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.enable_time_range","title":"enable_time_range","text":"<pre><code>enable_time_range() -&gt; SyncOptions\n</code></pre> <p>Enable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.SyncOptions.disable_time_range","title":"disable_time_range","text":"<pre><code>disable_time_range() -&gt; SyncOptions\n</code></pre> <p>Disable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = False\n    if not self.crosshair:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.TimeScaleOptions","title":"TimeScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for time scales in financial charts.</p> <p>This class provides extensive configuration options for time scales, controlling how time values are displayed, formatted, and positioned on the horizontal axis of the chart. It includes spacing, visibility, interaction, and formatting settings for professional time-based chart visualization.</p> <p>Attributes:</p> Name Type Description <code>right_offset</code> <code>int</code> <p>Right offset in pixels from the chart edge. Defaults to 0.</p> <code>left_offset</code> <code>int</code> <p>Left offset in pixels from the chart edge. Defaults to 0.</p> <code>bar_spacing</code> <code>int</code> <p>Spacing between bars in pixels. Defaults to 6.</p> <code>min_bar_spacing</code> <code>float</code> <p>Minimum spacing between bars in pixels. Defaults to 0.001.</p> <code>visible</code> <code>bool</code> <p>Whether the time scale is visible. Defaults to True.</p> <code>time_visible</code> <code>bool</code> <p>Whether to show time labels on the scale. Defaults to True.</p> <code>seconds_visible</code> <code>bool</code> <p>Whether to show seconds in time labels. Defaults to False.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the time scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the time scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>fix_left_edge</code> <code>bool</code> <p>Whether to fix the left edge of the time range. Defaults to False.</p> <code>fix_right_edge</code> <code>bool</code> <p>Whether to fix the right edge of the time range. Defaults to False.</p> <code>lock_visible_time_range_on_resize</code> <code>bool</code> <p>Whether to lock the visible time range when resizing the chart. Defaults to False.</p> <code>right_bar_stays_on_scroll</code> <code>bool</code> <p>Whether the rightmost bar stays visible during scroll. Defaults to False.</p> <code>shift_visible_range_on_new_bar</code> <code>bool</code> <p>Whether to shift the visible range when a new bar is added. Defaults to False.</p> <code>allow_shift_visible_range_on_whitespace_access</code> <code>bool</code> <p>Whether to allow shifting the visible range when accessing whitespace. Defaults to False.</p> <code>tick_mark_formatter</code> <code>Optional[Callable]</code> <p>Custom formatter function for tick marks. Defaults to None (uses default formatting).</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to handle double-click interactions. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to handle scale interactions. Defaults to True.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to handle scroll interactions. Defaults to True.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n# Create time scale with custom spacing and visibility\ntime_scale = TimeScaleOptions(\n    visible=True,\n    time_visible=True,\n    seconds_visible=False,\n    border_visible=True,\n    bar_spacing=8,\n    right_offset=20,\n    left_offset=10,\n)\n\n# Create time scale with locked edges\nlocked_time_scale = TimeScaleOptions(\n    fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n)\n</code></pre> See also <p>Options: Base class providing common option functionality.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/time_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"right_offset\", int)\n@chainable_field(\"left_offset\", int)\n@chainable_field(\"bar_spacing\", int)\n@chainable_field(\"min_bar_spacing\", float)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"time_visible\", bool)\n@chainable_field(\"seconds_visible\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"fix_left_edge\", bool)\n@chainable_field(\"fix_right_edge\", bool)\n@chainable_field(\"lock_visible_time_range_on_resize\", bool)\n@chainable_field(\"right_bar_stays_on_scroll\", bool)\n@chainable_field(\"shift_visible_range_on_new_bar\", bool)\n@chainable_field(\"allow_shift_visible_range_on_whitespace_access\", bool)\n@chainable_field(\"tick_mark_formatter\", allow_none=True)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_scroll\", bool)\nclass TimeScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for time scales in financial charts.\n\n    This class provides extensive configuration options for time scales, controlling\n    how time values are displayed, formatted, and positioned on the horizontal axis\n    of the chart. It includes spacing, visibility, interaction, and formatting\n    settings for professional time-based chart visualization.\n\n    Attributes:\n        right_offset (int): Right offset in pixels from the chart edge. Defaults to 0.\n        left_offset (int): Left offset in pixels from the chart edge. Defaults to 0.\n        bar_spacing (int): Spacing between bars in pixels. Defaults to 6.\n        min_bar_spacing (float): Minimum spacing between bars in pixels. Defaults to 0.001.\n        visible (bool): Whether the time scale is visible. Defaults to True.\n        time_visible (bool): Whether to show time labels on the scale. Defaults to True.\n        seconds_visible (bool): Whether to show seconds in time labels. Defaults to False.\n        border_visible (bool): Whether to show the time scale border. Defaults to True.\n        border_color (str): Color of the time scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        fix_left_edge (bool): Whether to fix the left edge of the time range. Defaults to False.\n        fix_right_edge (bool): Whether to fix the right edge of the time range. Defaults to False.\n        lock_visible_time_range_on_resize (bool): Whether to lock the visible time range\n            when resizing the chart. Defaults to False.\n        right_bar_stays_on_scroll (bool): Whether the rightmost bar stays visible during scroll.\n            Defaults to False.\n        shift_visible_range_on_new_bar (bool): Whether to shift the visible range when\n            a new bar is added. Defaults to False.\n        allow_shift_visible_range_on_whitespace_access (bool): Whether to allow shifting\n            the visible range when accessing whitespace. Defaults to False.\n        tick_mark_formatter (Optional[Callable]): Custom formatter function for tick marks.\n            Defaults to None (uses default formatting).\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to True.\n        handle_double_click (bool): Whether to handle double-click interactions.\n            Defaults to True.\n        handle_scale (bool): Whether to handle scale interactions. Defaults to True.\n        handle_scroll (bool): Whether to handle scroll interactions. Defaults to True.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n        # Create time scale with custom spacing and visibility\n        time_scale = TimeScaleOptions(\n            visible=True,\n            time_visible=True,\n            seconds_visible=False,\n            border_visible=True,\n            bar_spacing=8,\n            right_offset=20,\n            left_offset=10,\n        )\n\n        # Create time scale with locked edges\n        locked_time_scale = TimeScaleOptions(\n            fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n        )\n        ```\n\n    See also:\n        Options: Base class providing common option functionality.\n    \"\"\"\n\n    # Offset and spacing configuration\n    right_offset: int = 0  # Right offset in pixels from chart edge\n    left_offset: int = 0  # Left offset in pixels from chart edge\n    bar_spacing: int = 6  # Spacing between bars in pixels\n    min_bar_spacing: float = 0.001  # Minimum spacing between bars in pixels\n\n    # Visibility and appearance settings\n    visible: bool = True  # Whether the time scale is visible\n    time_visible: bool = True  # Whether to show time labels\n    seconds_visible: bool = False  # Whether to show seconds in time labels\n    border_visible: bool = True  # Whether to show the time scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n\n    # Time range and scrolling behavior\n    fix_left_edge: bool = False  # Whether to fix the left edge of the time range\n    fix_right_edge: bool = False  # Whether to fix the right edge of the time range\n    lock_visible_time_range_on_resize: bool = False  # Lock visible range on resize\n    right_bar_stays_on_scroll: bool = False  # Keep rightmost bar visible during scroll\n    shift_visible_range_on_new_bar: bool = False  # Shift range when new bar is added\n    allow_shift_visible_range_on_whitespace_access: bool = False  # Allow shifting on whitespace\n\n    # Formatting and interaction settings\n    tick_mark_formatter: Optional[Callable] = None  # Custom formatter for tick marks\n    fit_content_on_load: bool = True  # Fit content to visible area on load\n    handle_double_click: bool = True  # Handle double-click interactions\n    handle_scale: bool = True  # Handle scale interactions\n    handle_scroll: bool = True  # Handle scroll interactions\n\n    def __getitem__(self, key):\n        \"\"\"Get option value by key for dictionary-like access.\n\n        Allows accessing option values using dictionary-style syntax, which\n        is useful for dynamic configuration and testing.\n\n        Args:\n            key (str): The option key to retrieve.\n\n        Returns:\n            Any: The value of the specified option key.\n\n        Example:\n            ```python\n            time_scale = TimeScaleOptions()\n            spacing = time_scale[\"bar_spacing\"]  # Returns 6\n            visible = time_scale[\"visible\"]  # Returns True\n            ```\n        \"\"\"\n        return self.asdict()[key]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.TradeVisualizationOptions","title":"TradeVisualizationOptions  <code>dataclass</code>","text":"<p>Options for trade visualization.</p> <p>This class provides comprehensive configuration options for how trades are displayed on charts, including various visual styles and customization options for markers, rectangles, lines, arrows, and zones.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>TradeVisualization</code> <p>The visualization style to use (markers, rectangles, both, etc.)</p> <code>entry_marker_color_long</code> <code>str</code> <p>Color for long entry markers</p> <code>entry_marker_color_short</code> <code>str</code> <p>Color for short entry markers</p> <code>exit_marker_color_profit</code> <code>str</code> <p>Color for profitable exit markers</p> <code>exit_marker_color_loss</code> <code>str</code> <p>Color for loss exit markers</p> <code>marker_size</code> <code>int</code> <p>Size of markers in pixels</p> <code>show_pnl_in_markers</code> <code>bool</code> <p>Whether to show P&amp;L in marker text</p> <code>rectangle_fill_opacity</code> <code>float</code> <p>Opacity for rectangle fill (0.0 to 1.0)</p> <code>rectangle_border_width</code> <code>int</code> <p>Width of rectangle borders</p> <code>rectangle_color_profit</code> <code>str</code> <p>Color for profitable trade rectangles</p> <code>rectangle_color_loss</code> <code>str</code> <p>Color for loss trade rectangles</p> <code>rectangle_fill_color_profit</code> <code>str</code> <p>Fill color for profitable trade rectangles</p> <code>rectangle_border_color_profit</code> <code>str</code> <p>Border color for profitable trade rectangles</p> <code>rectangle_border_color_loss</code> <code>str</code> <p>Border color for loss trade rectangles</p> <code>line_width</code> <code>int</code> <p>Width of connecting lines</p> <code>line_style</code> <code>str</code> <p>Style of connecting lines (solid, dashed, etc.)</p> <code>line_color_profit</code> <code>str</code> <p>Color for profitable trade lines</p> <code>line_color_loss</code> <code>str</code> <p>Color for loss trade lines</p> <code>arrow_size</code> <code>int</code> <p>Size of arrows in pixels</p> <code>arrow_color_profit</code> <code>str</code> <p>Color for profitable trade arrows</p> <code>arrow_color_loss</code> <code>str</code> <p>Color for loss trade arrows</p> <code>zone_opacity</code> <code>float</code> <p>Opacity for zone fills (0.0 to 1.0)</p> <code>zone_color_long</code> <code>str</code> <p>Color for long trade zones</p> <code>zone_color_short</code> <code>str</code> <p>Color for short trade zones</p> <code>zone_extend_bars</code> <code>int</code> <p>Number of bars to extend zones</p> <code>show_trade_id</code> <code>bool</code> <p>Whether to show trade ID in annotations</p> <code>show_quantity</code> <code>bool</code> <p>Whether to show quantity in annotations</p> <code>show_trade_type</code> <code>bool</code> <p>Whether to show trade type in annotations</p> <code>annotation_font_size</code> <code>int</code> <p>Font size for annotations</p> <code>annotation_background</code> <code>str</code> <p>Background color for annotations</p> <code>rectangle_show_text</code> <code>bool</code> <p>Whether to show text on rectangles</p> <code>rectangle_text_position</code> <code>str</code> <p>Position of text on rectangles (inside, above, below)</p> <code>rectangle_text_font_size</code> <code>int</code> <p>Font size for rectangle text</p> <code>rectangle_text_color</code> <code>str</code> <p>Color for rectangle text</p> <code>rectangle_text_background</code> <code>str</code> <p>Background color for rectangle text</p> <code>tooltip_template</code> <code>str</code> <p>Custom HTML template for tooltips with placeholders</p> <code>marker_template</code> <code>str</code> <p>Deprecated - use entry_marker_template and exit_marker_template</p> <code>entry_marker_template</code> <code>str</code> <p>Custom HTML template for entry marker text</p> <code>exit_marker_template</code> <code>str</code> <p>Custom HTML template for exit marker text</p> <code>entry_marker_shape</code> <code>str</code> <p>Shape for entry markers (arrow_up, arrow_down, circle, square)</p> <code>exit_marker_shape</code> <code>str</code> <p>Shape for exit markers (arrow_up, arrow_down, circle, square)</p> <code>entry_marker_position</code> <code>str</code> <p>Position for entry markers (above, below)</p> <code>exit_marker_position</code> <code>str</code> <p>Position for exit markers (above, below)</p> <code>show_marker_text</code> <code>bool</code> <p>Whether to show text on markers</p> Template Placeholders <p>For tooltips and markers, you can use these placeholders in your HTML templates. All fields from TradeData.additional_data are also available: - \\(\\(id\\)\\): Trade ID - \\(\\(entry_price\\)\\): Entry price value - \\(\\(exit_price\\)\\): Exit price value - \\(\\(is_profitable\\)\\): Boolean profitability flag - \\(\\(pnl\\)\\): Profit/Loss amount - \\(\\(pnl_percentage\\)\\): Profit/Loss percentage - \\(\\(trade_type\\)\\): LONG or SHORT (from additional_data) - \\(\\(quantity\\)\\): Trade quantity (from additional_data) - \\(\\(notes\\)\\): Trade notes (from additional_data) - Any custom field from additional_data: \\(\\(strategy\\)\\), \\(\\(risk_level\\)\\), etc.</p> Example templates <p>tooltip_template: \"\\(\\(trade_type\\)\\)Entry: \\(\\(entry_price\\)\\)Exit: \\(\\(exit_price\\)\\)P&amp;L: \\(\\(pnl\\)\\) (\\(\\(pnl_percentage\\)\\)%)\" entry_marker_template: \"\u2191 \\(\\(trade_type\\)\\)\\((\\(entry_price\\)\\)\" exit_marker_template: \"\u2193 ((\\(exit_price\\)\\)&lt;br/&gt;(\\)\\)pnl_percentage$$%)\"</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", TradeVisualization)\n@chainable_field(\"entry_marker_color_long\", str, validator=\"color\")\n@chainable_field(\"entry_marker_color_short\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_profit\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_loss\", str, validator=\"color\")\n@chainable_field(\"marker_size\", int)\n@chainable_field(\"show_pnl_in_markers\", bool)\n@chainable_field(\"rectangle_fill_opacity\", float)\n@chainable_field(\"rectangle_border_width\", int)\n@chainable_field(\"rectangle_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_color_loss\", str, validator=\"color\")\n@chainable_field(\"rectangle_fill_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_loss\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"line_color_profit\", str, validator=\"color\")\n@chainable_field(\"line_color_loss\", str, validator=\"color\")\n@chainable_field(\"arrow_size\", int)\n@chainable_field(\"arrow_color_profit\", str, validator=\"color\")\n@chainable_field(\"arrow_color_loss\", str, validator=\"color\")\n@chainable_field(\"zone_opacity\", float)\n@chainable_field(\"zone_color_long\", str, validator=\"color\")\n@chainable_field(\"zone_color_short\", str, validator=\"color\")\n@chainable_field(\"zone_extend_bars\", int)\n@chainable_field(\"show_trade_id\", bool)\n@chainable_field(\"show_quantity\", bool)\n@chainable_field(\"show_trade_type\", bool)\n@chainable_field(\"annotation_font_size\", int)\n@chainable_field(\"annotation_background\", str, validator=\"color\")\n@chainable_field(\"rectangle_show_text\", bool)\n@chainable_field(\"rectangle_text_position\", str)\n@chainable_field(\"rectangle_text_font_size\", int)\n@chainable_field(\"rectangle_text_color\", str, validator=\"color\")\n@chainable_field(\"rectangle_text_background\", str, validator=\"color\")\n@chainable_field(\"tooltip_template\", str)\n@chainable_field(\"marker_template\", str)\n@chainable_field(\"entry_marker_template\", str)\n@chainable_field(\"exit_marker_template\", str)\n@chainable_field(\"entry_marker_shape\", str)\n@chainable_field(\"exit_marker_shape\", str)\n@chainable_field(\"entry_marker_position\", str)\n@chainable_field(\"exit_marker_position\", str)\n@chainable_field(\"show_marker_text\", bool)\nclass TradeVisualizationOptions(Options):\n    \"\"\"Options for trade visualization.\n\n    This class provides comprehensive configuration options for how trades\n    are displayed on charts, including various visual styles and customization\n    options for markers, rectangles, lines, arrows, and zones.\n\n    Attributes:\n        style: The visualization style to use (markers, rectangles, both, etc.)\n        entry_marker_color_long: Color for long entry markers\n        entry_marker_color_short: Color for short entry markers\n        exit_marker_color_profit: Color for profitable exit markers\n        exit_marker_color_loss: Color for loss exit markers\n        marker_size: Size of markers in pixels\n        show_pnl_in_markers: Whether to show P&amp;L in marker text\n        rectangle_fill_opacity: Opacity for rectangle fill (0.0 to 1.0)\n        rectangle_border_width: Width of rectangle borders\n        rectangle_color_profit: Color for profitable trade rectangles\n        rectangle_color_loss: Color for loss trade rectangles\n        rectangle_fill_color_profit: Fill color for profitable trade rectangles\n        rectangle_border_color_profit: Border color for profitable trade rectangles\n        rectangle_border_color_loss: Border color for loss trade rectangles\n        line_width: Width of connecting lines\n        line_style: Style of connecting lines (solid, dashed, etc.)\n        line_color_profit: Color for profitable trade lines\n        line_color_loss: Color for loss trade lines\n        arrow_size: Size of arrows in pixels\n        arrow_color_profit: Color for profitable trade arrows\n        arrow_color_loss: Color for loss trade arrows\n        zone_opacity: Opacity for zone fills (0.0 to 1.0)\n        zone_color_long: Color for long trade zones\n        zone_color_short: Color for short trade zones\n        zone_extend_bars: Number of bars to extend zones\n        show_trade_id: Whether to show trade ID in annotations\n        show_quantity: Whether to show quantity in annotations\n        show_trade_type: Whether to show trade type in annotations\n        annotation_font_size: Font size for annotations\n        annotation_background: Background color for annotations\n        rectangle_show_text: Whether to show text on rectangles\n        rectangle_text_position: Position of text on rectangles (inside, above, below)\n        rectangle_text_font_size: Font size for rectangle text\n        rectangle_text_color: Color for rectangle text\n        rectangle_text_background: Background color for rectangle text\n        tooltip_template: Custom HTML template for tooltips with placeholders\n        marker_template: Deprecated - use entry_marker_template and exit_marker_template\n        entry_marker_template: Custom HTML template for entry marker text\n        exit_marker_template: Custom HTML template for exit marker text\n        entry_marker_shape: Shape for entry markers (arrow_up, arrow_down, circle, square)\n        exit_marker_shape: Shape for exit markers (arrow_up, arrow_down, circle, square)\n        entry_marker_position: Position for entry markers (above, below)\n        exit_marker_position: Position for exit markers (above, below)\n        show_marker_text: Whether to show text on markers\n\n    Template Placeholders:\n        For tooltips and markers, you can use these placeholders in your HTML templates.\n        All fields from TradeData.additional_data are also available:\n        - $$id$$: Trade ID\n        - $$entry_price$$: Entry price value\n        - $$exit_price$$: Exit price value\n        - $$is_profitable$$: Boolean profitability flag\n        - $$pnl$$: Profit/Loss amount\n        - $$pnl_percentage$$: Profit/Loss percentage\n        - $$trade_type$$: LONG or SHORT (from additional_data)\n        - $$quantity$$: Trade quantity (from additional_data)\n        - $$notes$$: Trade notes (from additional_data)\n        - Any custom field from additional_data: $$strategy$$, $$risk_level$$, etc.\n\n    Example templates:\n        tooltip_template: \"&lt;div&gt;&lt;strong&gt;$$trade_type$$&lt;/strong&gt;&lt;br/&gt;Entry: $$entry_price$$&lt;br/&gt;Exit: $$exit_price$$&lt;br/&gt;P&amp;L: $$pnl$$ ($$pnl_percentage$$%)&lt;/div&gt;\"\n        entry_marker_template: \"\u2191 $$trade_type$$&lt;br/&gt;$$$entry_price$$\"\n        exit_marker_template: \"\u2193 $$$exit_price$$&lt;br/&gt;($$pnl_percentage$$%)\"\n    \"\"\"\n\n    style: TradeVisualization = TradeVisualization.RECTANGLES\n\n    # Marker options\n    entry_marker_color_long: str = \"#2196F3\"\n    entry_marker_color_short: str = \"#FF9800\"\n    exit_marker_color_profit: str = \"#4CAF50\"\n    exit_marker_color_loss: str = \"#F44336\"\n    marker_size: int = 5\n    show_pnl_in_markers: bool = False\n\n    # Rectangle options\n    rectangle_fill_opacity: float = 0.1\n    rectangle_border_width: int = 1\n    rectangle_color_profit: str = \"#4CAF50\"\n    rectangle_color_loss: str = \"#F44336\"\n    rectangle_fill_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_loss: str = \"#F44336\"\n\n    # Line options\n    line_width: int = 2\n    line_style: str = \"dashed\"\n    line_color_profit: str = \"#4CAF50\"\n    line_color_loss: str = \"#F44336\"\n\n    # Arrow options\n    arrow_size: int = 10\n    arrow_color_profit: str = \"#4CAF50\"\n    arrow_color_loss: str = \"#F44336\"\n\n    # Zone options\n    zone_opacity: float = 0.1\n    zone_color_long: str = \"#2196F3\"\n    zone_color_short: str = \"#FF9800\"\n    zone_extend_bars: int = 2  # Extend zone by this many bars\n\n    # Annotation options\n    show_trade_id: bool = False\n    show_quantity: bool = True\n    show_trade_type: bool = True\n    annotation_font_size: int = 12\n    annotation_background: str = \"rgba(255, 255, 255, 0.8)\"\n\n    # Rectangle text options\n    rectangle_show_text: bool = False\n    rectangle_text_position: str = \"inside\"  # inside, above, below\n    rectangle_text_font_size: int = 10\n    rectangle_text_color: str = \"#FFFFFF\"\n    rectangle_text_background: str = \"rgba(0, 0, 0, 0.7)\"\n\n    # Template options\n    tooltip_template: str = \"\"  # Custom HTML template for tooltips\n    marker_template: str = \"\"  # Deprecated - use entry/exit templates\n    entry_marker_template: str = \"\"  # Custom HTML template for entry markers\n    exit_marker_template: str = \"\"  # Custom HTML template for exit markers\n\n    # Marker shape and position options\n    entry_marker_shape: str = \"arrowUp\"  # arrowUp, arrowDown, circle, square\n    exit_marker_shape: str = \"arrowDown\"  # arrowUp, arrowDown, circle, square\n    entry_marker_position: str = \"belowBar\"  # belowBar, aboveBar\n    exit_marker_position: str = \"aboveBar\"  # belowBar, aboveBar\n    show_marker_text: bool = True  # Whether to show text on markers\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize options.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates all configuration values and sets defaults for invalid values.\n\n        Raises:\n            ValueError: If the style string cannot be converted to TradeVisualization enum.\n        \"\"\"\n        # Step 1: Convert style to enum if it's a string\n        # Allows users to pass \"rectangles\" instead of TradeVisualization.RECTANGLES\n        if isinstance(self.style, str):\n            self.style = TradeVisualization(self.style.lower())\n\n        # Step 2: Validate rectangle text position\n        # Ensures only valid positions are used (inside, above, below)\n        valid_positions = [\"inside\", \"above\", \"below\"]\n        if self.rectangle_text_position.lower() not in valid_positions:\n            # Default to \"inside\" if invalid position provided\n            self.rectangle_text_position = \"inside\"\n\n        # Step 3: Validate marker shapes\n        # Ensures only TradingView-supported shapes are used\n        valid_shapes = [\"arrowUp\", \"arrowDown\", \"circle\", \"square\"]\n        if self.entry_marker_shape not in valid_shapes:\n            # Default to arrowUp for entry if invalid shape provided\n            self.entry_marker_shape = \"arrowUp\"\n        if self.exit_marker_shape not in valid_shapes:\n            # Default to arrowDown for exit if invalid shape provided\n            self.exit_marker_shape = \"arrowDown\"\n\n        # Step 4: Validate marker positions\n        # Ensures only valid positions are used (belowBar, aboveBar)\n        valid_marker_positions = [\"belowBar\", \"aboveBar\"]\n        if self.entry_marker_position not in valid_marker_positions:\n            # Default to belowBar for entry (typical for long trades)\n            self.entry_marker_position = \"belowBar\"\n        if self.exit_marker_position not in valid_marker_positions:\n            # Default to aboveBar for exit (typical for long trades)\n            self.exit_marker_position = \"aboveBar\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.LegendOptions","title":"LegendOptions  <code>dataclass</code>","text":"<p>Legend configuration with support for custom HTML templates and dynamic value display.</p> <p>The text supports a single placeholder that will be replaced by the frontend: - \\(\\(value\\)\\): Current value of the series at crosshair position</p> <p>Note: Title and color should be handled directly in your HTML template using the series title and color from your series configuration. This avoids conflicts with Python's f-string syntax and other templating systems.</p> <p>Dynamic Value Display: When show_values=True, the legend will automatically display current values at the crosshair position without needing to specify a custom template.</p> <p>Example templates: - \"MA20: \\(\\(value\\)\\)\" - \"PriceValue: \\(\\(value\\)\\)\" - \"RSI: \\(\\(value\\)\\)\"</p> <p>Example with dynamic values: LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"position\", str)\n@chainable_field(\"symbol_name\", str)\n@chainable_field(\"background_color\", str)\n@chainable_field(\"border_color\", str)\n@chainable_field(\"border_width\", int)\n@chainable_field(\"border_radius\", int)\n@chainable_field(\"padding\", int)\n@chainable_field(\"margin\", int)\n@chainable_field(\"z_index\", int)\n@chainable_field(\"price_format\", str)\n@chainable_field(\"text\", str)\n@chainable_field(\"show_values\", bool)\n@chainable_field(\"value_format\", str)\n@chainable_field(\"update_on_crosshair\", bool)\nclass LegendOptions(Options):\n    \"\"\"Legend configuration with support for custom HTML templates and dynamic value display.\n\n    The text supports a single placeholder that will be replaced by the frontend:\n    - $$value$$: Current value of the series at crosshair position\n\n    Note: Title and color should be handled directly in your HTML template using\n    the series title and color from your series configuration. This avoids\n    conflicts with Python's f-string syntax and other templating systems.\n\n    Dynamic Value Display:\n    When show_values=True, the legend will automatically display current values\n    at the crosshair position without needing to specify a custom template.\n\n    Example templates:\n    - \"&lt;span style='color: #2196f3'&gt;MA20: $$value$$&lt;/span&gt;\"\n    - \"&lt;div&gt;&lt;strong&gt;Price&lt;/strong&gt;&lt;br/&gt;Value: $$value$$&lt;/div&gt;\"\n    - \"&lt;span class='legend-item'&gt;RSI: $$value$$&lt;/span&gt;\"\n\n    Example with dynamic values:\n    LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)\n    \"\"\"\n\n    visible: bool = True\n    position: str = \"top-left\"\n    symbol_name: str = \"\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    margin: int = 0  # No margin - spacing handled by layout manager\n    z_index: int = 1000\n    price_format: str = \".2f\"\n    text: str = \"\"\n    show_values: bool = True\n    value_format: str = \".2f\"\n    update_on_crosshair: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.RangeConfig","title":"RangeConfig  <code>dataclass</code>","text":"<p>Range configuration for range switcher.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"text\", str)\n@chainable_field(\"tooltip\", str)\n@chainable_field(\"range\", TimeRange)\nclass RangeConfig(Options):\n    \"\"\"Range configuration for range switcher.\"\"\"\n\n    text: str = \"\"\n    tooltip: str = \"\"\n    range: TimeRange = TimeRange.ONE_DAY\n\n    @property\n    def seconds(self) -&gt; int | None:\n        \"\"\"Get the time range in seconds.\"\"\"\n        return self.range.value if self.range else None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.RangeConfig-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.RangeConfig.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: int | None\n</code></pre> <p>Get the time range in seconds.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/index.html#streamlit_lightweight_charts_pro.charts.options.RangeSwitcherOptions","title":"RangeSwitcherOptions  <code>dataclass</code>","text":"<p>Range switcher configuration.</p> <p>Range switcher supports only corner positions: top-left, top-right, bottom-left, bottom-right. Center positions are not supported.</p> <p>Range buttons are automatically hidden when they exceed the available data timespan, providing a better user experience.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"ranges\", list)\n@chainable_field(\"position\", str)\nclass RangeSwitcherOptions(Options):\n    \"\"\"Range switcher configuration.\n\n    Range switcher supports only corner positions: top-left, top-right,\n    bottom-left, bottom-right. Center positions are not supported.\n\n    Range buttons are automatically hidden when they exceed the available\n    data timespan, providing a better user experience.\n    \"\"\"\n\n    visible: bool = True\n    ranges: List[RangeConfig] = field(default_factory=list)\n    position: Literal[\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"] = \"bottom-right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html","title":"streamlit_lightweight_charts_pro.charts.options.base_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options","title":"base_options","text":"<p>Base options class for streamlit-lightweight-charts.</p> <p>This module provides the base Options class that all option classes should inherit from. It provides common functionality for serialization, validation, and frontend communication through standardized dictionary conversion with camelCase key formatting.</p> <p>The Options class serves as the foundation for all configuration classes in the library, ensuring consistent behavior across different option types and providing a unified interface for frontend serialization and validation.</p> Key Features <ul> <li>Automatic snake_case to camelCase key conversion for frontend compatibility</li> <li>Enum value extraction and conversion for proper serialization</li> <li>Nested option object serialization with recursive handling</li> <li>Dictionary and list serialization with type-aware processing</li> <li>Special handling for _options fields with flattening logic</li> <li>Flexible update mechanism with dictionary-based configuration</li> <li>Comprehensive validation and error handling</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options.base_options import Options\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass MyOptions(Options):\n    background_color: str = \"#ffffff\"\n    text_color: str = \"#000000\"\n    is_visible: bool = True\n\n\n# Create and serialize options\noptions = MyOptions()\nserialized = options.asdict()\n# Returns: {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options","title":"Options  <code>dataclass</code>","text":"<p>Abstract base class for all option classes in financial chart configuration.</p> <p>This class provides common functionality for option classes including automatic camelCase key conversion for frontend serialization, enum value conversion, and standardized validation patterns. All option classes in the library should inherit from this base class to ensure consistent behavior and frontend compatibility.</p> <p>The class implements a sophisticated serialization system that handles: - Automatic snake_case to camelCase key conversion for JavaScript compatibility - Enum value extraction and conversion for proper frontend rendering - Nested option object serialization with recursive processing - List serialization with recursive option handling - Dictionary serialization with recursive Options object detection - Special handling for _options fields with flattening logic - Flexible update mechanism with dictionary-based configuration</p> Key Features <ul> <li>Frontend-compatible serialization with camelCase keys</li> <li>Type-safe validation and error handling</li> <li>Recursive nested object processing</li> <li>Enum value extraction and conversion</li> <li>Method chaining support for fluent API usage</li> <li>Comprehensive logging for debugging</li> </ul> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n@dataclass\nclass MyOptions(Options):\n    background_color: str = \"#ffffff\"\n    text_color: str = \"#000000\"\n    is_visible: bool = True\n\n\n@dataclass\nclass NestedOptions(Options):\n    color: str = \"#ff0000\"\n    width: int = 2\n\n\n@dataclass\nclass ContainerOptions(Options):\n    main_options: MyOptions = None\n    nested_dict: Dict[str, NestedOptions] = None\n\n\n# Create and serialize options\noptions = ContainerOptions(\n    main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n)\nresult = options.asdict()\n# Returns: {\n#     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n#     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n# }\n</code></pre> See also <p>chainable_field: Decorator for creating chainable option properties. snake_to_camel: Utility function for key conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>@dataclass\nclass Options(SerializableMixin, ABC):\n    \"\"\"Abstract base class for all option classes in financial chart configuration.\n\n    This class provides common functionality for option classes including automatic\n    camelCase key conversion for frontend serialization, enum value conversion,\n    and standardized validation patterns. All option classes in the library should\n    inherit from this base class to ensure consistent behavior and frontend compatibility.\n\n    The class implements a sophisticated serialization system that handles:\n    - Automatic snake_case to camelCase key conversion for JavaScript compatibility\n    - Enum value extraction and conversion for proper frontend rendering\n    - Nested option object serialization with recursive processing\n    - List serialization with recursive option handling\n    - Dictionary serialization with recursive Options object detection\n    - Special handling for _options fields with flattening logic\n    - Flexible update mechanism with dictionary-based configuration\n\n    Key Features:\n        - Frontend-compatible serialization with camelCase keys\n        - Type-safe validation and error handling\n        - Recursive nested object processing\n        - Enum value extraction and conversion\n        - Method chaining support for fluent API usage\n        - Comprehensive logging for debugging\n\n    Attributes:\n        Inherited by subclasses with specific option attributes. Each subclass\n        defines its own configuration properties with appropriate default values.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n        @dataclass\n        class MyOptions(Options):\n            background_color: str = \"#ffffff\"\n            text_color: str = \"#000000\"\n            is_visible: bool = True\n\n\n        @dataclass\n        class NestedOptions(Options):\n            color: str = \"#ff0000\"\n            width: int = 2\n\n\n        @dataclass\n        class ContainerOptions(Options):\n            main_options: MyOptions = None\n            nested_dict: Dict[str, NestedOptions] = None\n\n\n        # Create and serialize options\n        options = ContainerOptions(\n            main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n        )\n        result = options.asdict()\n        # Returns: {\n        #     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n        #     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n        # }\n        ```\n\n    See also:\n        chainable_field: Decorator for creating chainable option properties.\n        snake_to_camel: Utility function for key conversion.\n    \"\"\"\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n        \"\"\"Update options with a dictionary of values.\n\n        This method provides a flexible way to update option properties using a dictionary.\n        It handles both simple properties and nested objects, automatically creating\n        nested Options instances when needed.\n\n        Args:\n            updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n                Values can be simple types or dictionaries for nested objects.\n\n        Returns:\n            Options: Self for method chaining.\n\n        Raises:\n            ValueError: If an update key doesn't correspond to a valid field.\n            TypeError: If a value type is incompatible with the field type.\n\n        Example:\n            ```python\n            options = MyOptions()\n\n            # Update simple properties\n            options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n            # Update nested objects\n            options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n            # Method chaining\n            options.update({\"color\": \"red\"}).update({\"width\": 100})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            # Convert camelCase to snake_case for field lookup\n            field_name = self._camel_to_snake(key)\n\n            # Check if field exists\n            if not hasattr(self, field_name):\n                # Try the original key in case it's already snake_case\n                if hasattr(self, key):\n                    field_name = key\n                else:\n                    # Ignore invalid fields instead of raising an error\n\n                    continue\n\n            # Get field info for type checking\n            field_info = None\n            for field in fields(self):\n                if field.name == field_name:\n                    field_info = field\n                    break\n\n            if field_info is None:\n                # Ignore fields not found in dataclass fields\n\n                continue\n\n            # Handle nested Options objects and complex type annotations\n            contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n                field_info.type,\n            )\n\n            if contains_options and isinstance(value, dict):\n                if options_class is not None and not is_dict_type:\n                    # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                    current_value = getattr(self, field_name)\n                    if current_value is None:\n                        current_value = options_class()\n                    current_value.update(value)\n                    setattr(self, field_name, current_value)\n                else:\n                    # Handle Dict[str, Options] or similar complex types\n                    # The value is a dict that should contain Options objects\n                    # We'll process it recursively during asdict() call\n                    setattr(self, field_name, value)\n            else:\n                # Simple value assignment - set the field directly to bypass validation\n                # This is what we want for the update method\n                setattr(self, field_name, value)\n\n        return self\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        This is a convenience wrapper around CaseConverter.camel_to_snake()\n        for backward compatibility with existing code.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n\n        See Also:\n            CaseConverter.camel_to_snake: The main implementation in case_converter.py.\n        \"\"\"\n        return CaseConverter.camel_to_snake(camel_case)\n\n    def _process_dict_recursively(self, data: Any) -&gt; Any:\n        \"\"\"Recursively process data structures to handle Options objects.\n\n        This method traverses through nested data structures (dicts, lists) and\n        converts any Options objects to dictionaries using their asdict() method.\n        It also converts dictionary keys from snake_case to camelCase.\n\n        Args:\n            data: The data to process. Can be any type, but the method specifically\n                handles dict, list, and Options types.\n\n        Returns:\n            The processed data with all Options objects converted to dictionaries\n            and keys converted to camelCase.\n        \"\"\"\n        if isinstance(data, Options):\n            return data.asdict()\n        if isinstance(data, dict):\n            return {\n                snake_to_camel(str(k)): self._process_dict_recursively(v) for k, v in data.items()\n            }\n        if isinstance(data, list):\n            return [self._process_dict_recursively(item) for item in data]\n        return data\n\n    def _analyze_type_for_options(self, field_type: Any) -&gt; tuple[bool, type | None, bool]:\n        \"\"\"Analyze a type annotation to determine if it contains Options objects.\n\n        Args:\n            field_type: The type annotation to analyze.\n\n        Returns:\n            Tuple of (contains_options, options_class, is_dict_type) where:\n            - contains_options: True if the type contains Options objects\n            - options_class: The Options class if found, None otherwise\n            - is_dict_type: True if the type is a Dict type (including Optional[Dict])\n        \"\"\"\n        # Direct Options type\n        if isinstance(field_type, type) and issubclass(field_type, Options):\n            return True, field_type, False\n\n        # Check if it's a generic type with origin\n        if not hasattr(field_type, \"__origin__\") or field_type.__origin__ is None:\n            return False, None, False\n\n        origin = field_type.__origin__\n        args = getattr(field_type, \"__args__\", ())\n\n        # Dict type\n        if origin is dict and args and len(args) &gt;= 2:\n            # Safely access args[1] after explicit length check\n            if len(args) &gt; 1:\n                contains_options, options_class, _ = self._analyze_type_for_options(args[1])\n                if contains_options:\n                    return True, options_class, True\n        elif origin is dict and len(args) == 1:\n            # Handle Dict with only one type arg\n            return False, None, False\n\n        # List type\n        elif origin is list and args:\n            contains_options, options_class, _ = self._analyze_type_for_options(args[0])\n            if contains_options:\n                return True, options_class, False\n\n        # Union type (Optional)\n        elif origin is not None:  # Union types\n            # Check if any non-None arg is a Dict type\n            is_dict_type = any(\n                hasattr(arg, \"__origin__\") and arg.__origin__ is dict\n                for arg in args\n                if arg is not type(None)\n            )\n\n            # Check each non-None argument\n            for arg in args:\n                if arg is type(None):\n                    continue\n                contains_options, options_class, _ = self._analyze_type_for_options(arg)\n                if contains_options:\n                    return True, options_class, is_dict_type\n\n        return False, None, False\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n        This method provides comprehensive serialization of option objects for\n        frontend communication. It handles complex nested structures, enum values,\n        and special field flattening patterns.\n\n        The serialization process:\n        1. Iterates through all dataclass fields\n        2. Skips None values, empty strings, and empty dictionaries\n        3. Converts enum values to their .value property\n        4. Recursively serializes nested Options objects\n        5. Handles lists of Options objects\n        6. Recursively processes dictionaries that may contain Options objects at any level\n        7. Converts field names from snake_case to camelCase\n        8. Applies special flattening logic for _options fields\n\n        Returns:\n            Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n                consumption. All nested structures are properly serialized and\n                enum values are converted to their primitive representations.\n\n        Note:\n            - Empty dictionaries and None values are omitted from output\n            - Enum values are automatically converted to their .value property\n            - Nested Options objects are recursively serialized\n            - Lists containing Options objects are handled recursively\n            - Dictionaries containing Options objects at any nesting level are processed recursively\n            - background_options fields are flattened into the parent result\n        \"\"\"\n        # Use the inherited serialization from SerializableMixin\n        return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Options\n</code></pre> <p>Update options with a dictionary of values.</p> <p>This method provides a flexible way to update option properties using a dictionary. It handles both simple properties and nested objects, automatically creating nested Options instances when needed.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types or dictionaries for nested objects.</p> required <p>Returns:</p> Name Type Description <code>Options</code> <code>Options</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an update key doesn't correspond to a valid field.</p> <code>TypeError</code> <p>If a value type is incompatible with the field type.</p> Example <pre><code>options = MyOptions()\n\n# Update simple properties\noptions.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n# Update nested objects\noptions.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n# Method chaining\noptions.update({\"color\": \"red\"}).update({\"width\": 100})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n    \"\"\"Update options with a dictionary of values.\n\n    This method provides a flexible way to update option properties using a dictionary.\n    It handles both simple properties and nested objects, automatically creating\n    nested Options instances when needed.\n\n    Args:\n        updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n            Values can be simple types or dictionaries for nested objects.\n\n    Returns:\n        Options: Self for method chaining.\n\n    Raises:\n        ValueError: If an update key doesn't correspond to a valid field.\n        TypeError: If a value type is incompatible with the field type.\n\n    Example:\n        ```python\n        options = MyOptions()\n\n        # Update simple properties\n        options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n        # Update nested objects\n        options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n        # Method chaining\n        options.update({\"color\": \"red\"}).update({\"width\": 100})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        # Convert camelCase to snake_case for field lookup\n        field_name = self._camel_to_snake(key)\n\n        # Check if field exists\n        if not hasattr(self, field_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                field_name = key\n            else:\n                # Ignore invalid fields instead of raising an error\n\n                continue\n\n        # Get field info for type checking\n        field_info = None\n        for field in fields(self):\n            if field.name == field_name:\n                field_info = field\n                break\n\n        if field_info is None:\n            # Ignore fields not found in dataclass fields\n\n            continue\n\n        # Handle nested Options objects and complex type annotations\n        contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n            field_info.type,\n        )\n\n        if contains_options and isinstance(value, dict):\n            if options_class is not None and not is_dict_type:\n                # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                current_value = getattr(self, field_name)\n                if current_value is None:\n                    current_value = options_class()\n                current_value.update(value)\n                setattr(self, field_name, current_value)\n            else:\n                # Handle Dict[str, Options] or similar complex types\n                # The value is a dict that should contain Options objects\n                # We'll process it recursively during asdict() call\n                setattr(self, field_name, value)\n        else:\n            # Simple value assignment - set the field directly to bypass validation\n            # This is what we want for the update method\n            setattr(self, field_name, value)\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert options to dictionary with camelCase keys for frontend.</p> <p>This method provides comprehensive serialization of option objects for frontend communication. It handles complex nested structures, enum values, and special field flattening patterns.</p> <p>The serialization process: 1. Iterates through all dataclass fields 2. Skips None values, empty strings, and empty dictionaries 3. Converts enum values to their .value property 4. Recursively serializes nested Options objects 5. Handles lists of Options objects 6. Recursively processes dictionaries that may contain Options objects at any level 7. Converts field names from snake_case to camelCase 8. Applies special flattening logic for _options fields</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary with camelCase keys ready for frontend consumption. All nested structures are properly serialized and enum values are converted to their primitive representations.</p> Note <ul> <li>Empty dictionaries and None values are omitted from output</li> <li>Enum values are automatically converted to their .value property</li> <li>Nested Options objects are recursively serialized</li> <li>Lists containing Options objects are handled recursively</li> <li>Dictionaries containing Options objects at any nesting level are processed recursively</li> <li>background_options fields are flattened into the parent result</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n    This method provides comprehensive serialization of option objects for\n    frontend communication. It handles complex nested structures, enum values,\n    and special field flattening patterns.\n\n    The serialization process:\n    1. Iterates through all dataclass fields\n    2. Skips None values, empty strings, and empty dictionaries\n    3. Converts enum values to their .value property\n    4. Recursively serializes nested Options objects\n    5. Handles lists of Options objects\n    6. Recursively processes dictionaries that may contain Options objects at any level\n    7. Converts field names from snake_case to camelCase\n    8. Applies special flattening logic for _options fields\n\n    Returns:\n        Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n            consumption. All nested structures are properly serialized and\n            enum values are converted to their primitive representations.\n\n    Note:\n        - Empty dictionaries and None values are omitted from output\n        - Enum values are automatically converted to their .value property\n        - Nested Options objects are recursively serialized\n        - Lists containing Options objects are handled recursively\n        - Dictionaries containing Options objects at any nesting level are processed recursively\n        - background_options fields are flattened into the parent result\n    \"\"\"\n    # Use the inherited serialization from SerializableMixin\n    return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html","title":"streamlit_lightweight_charts_pro.charts.options.chart_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options","title":"chart_options","text":"<p>Chart options configuration for streamlit-lightweight-charts.</p> <p>This module provides the main ChartOptions class for configuring chart display, behavior, and appearance. ChartOptions serves as the central configuration container for all chart-related settings including layout, interaction, localization, and trade visualization features.</p> Key Features <ul> <li>Comprehensive chart configuration management</li> <li>Layout and sizing options for responsive design</li> <li>Price scale configuration for multi-scale charts</li> <li>Time scale customization for different timeframes</li> <li>Interactive features like crosshair and tracking modes</li> <li>Grid and visual styling options</li> <li>Localization support for international markets</li> <li>Trade visualization and range switching capabilities</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800, height=400, auto_size=True, layout=LayoutOptions(text_color=\"#000000\")\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options.ChartOptions","title":"ChartOptions  <code>dataclass</code>","text":"<p>Configuration options for chart display and behavior in financial visualization.</p> <p>This class encapsulates all the configuration options that control how a chart is displayed, including its size, layout, grid settings, and various interactive features. It provides a comprehensive interface for customizing chart appearance and behavior across different chart types and use cases.</p> <p>The ChartOptions class serves as the central configuration container that combines layout, interaction, localization, and visualization settings into a unified configuration object that can be passed to chart instances.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Optional[int]</code> <p>Chart width in pixels. If None, uses 100% of container width. Defaults to None for automatic sizing.</p> <code>height</code> <code>int</code> <p>Chart height in pixels. Defaults to 400.</p> <code>auto_size</code> <code>bool</code> <p>Whether to automatically size the chart to fit its container. Defaults to False.</p> <code>layout</code> <code>LayoutOptions</code> <p>Chart layout configuration including background colors, text styling, and visual appearance settings.</p> <code>left_price_scale</code> <code>Optional[PriceScaleOptions]</code> <p>Left price scale configuration. If None, left price scale is disabled.</p> <code>right_price_scale</code> <code>PriceScaleOptions</code> <p>Right price scale configuration. Defaults to standard right price scale settings.</p> <code>overlay_price_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Overlay price scale configurations for multiple price scales on the same chart.</p> <code>time_scale</code> <code>TimeScaleOptions</code> <p>Time scale configuration including axis settings, time formatting, and time range controls.</p> <code>crosshair</code> <code>CrosshairOptions</code> <p>Crosshair configuration for mouse interactions and data point highlighting.</p> <code>grid</code> <code>GridOptions</code> <p>Grid configuration for horizontal and vertical grid lines.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to enable scroll interactions for time navigation. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to enable scale interactions for zooming. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to enable double-click interactions. Defaults to True.</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to False.</p> <code>kinetic_scroll</code> <code>Optional[KineticScrollOptions]</code> <p>Kinetic scroll options for momentum-based scrolling behavior.</p> <code>tracking_mode</code> <code>Optional[TrackingModeOptions]</code> <p>Mouse tracking mode for crosshair and tooltips. Controls how the chart responds to mouse movement.</p> <code>localization</code> <code>Optional[LocalizationOptions]</code> <p>Localization settings for date/time formatting and locale-specific display options.</p> <code>add_default_pane</code> <code>bool</code> <p>Whether to add a default pane to the chart. Defaults to True.</p> <code>trade_visualization</code> <code>Optional[TradeVisualizationOptions]</code> <p>Trade visualization configuration options for displaying trade markers and annotations.</p> <code>range_switcher</code> <code>Optional[RangeSwitcherOptions]</code> <p>Range switcher configuration for time range selection buttons and presets.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any attribute is assigned an invalid type during initialization.</p> <code>PriceScaleIdTypeError</code> <p>If price scale ID is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale options are not of correct type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800,\n    height=600,\n    layout=LayoutOptions(background_color=\"#ffffff\"),\n    handle_scroll=True,\n    handle_scale=True,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/chart_options.py</code> <pre><code>@dataclass\n@chainable_field(\"width\", int)\n@chainable_field(\"height\", int)\n@chainable_field(\"auto_size\", bool)\n@chainable_field(\"layout\", LayoutOptions)\n@chainable_field(\"left_price_scale\", PriceScaleOptions)\n@chainable_field(\"right_price_scale\", PriceScaleOptions)\n@chainable_field(\"overlay_price_scales\", dict)\n@chainable_field(\"time_scale\", TimeScaleOptions)\n@chainable_field(\"crosshair\", CrosshairOptions)\n@chainable_field(\"grid\", GridOptions)\n@chainable_field(\"handle_scroll\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"kinetic_scroll\", KineticScrollOptions)\n@chainable_field(\"tracking_mode\", TrackingModeOptions)\n@chainable_field(\"localization\", LocalizationOptions)\n@chainable_field(\"add_default_pane\", bool)\n@chainable_field(\"trade_visualization\", TradeVisualizationOptions)\n@chainable_field(\"range_switcher\", RangeSwitcherOptions)\nclass ChartOptions(Options):\n    \"\"\"Configuration options for chart display and behavior in financial visualization.\n\n    This class encapsulates all the configuration options that control how a chart\n    is displayed, including its size, layout, grid settings, and various interactive\n    features. It provides a comprehensive interface for customizing chart appearance\n    and behavior across different chart types and use cases.\n\n    The ChartOptions class serves as the central configuration container that combines\n    layout, interaction, localization, and visualization settings into a unified\n    configuration object that can be passed to chart instances.\n\n    Attributes:\n        width (Optional[int]): Chart width in pixels. If None, uses 100% of container width.\n            Defaults to None for automatic sizing.\n        height (int): Chart height in pixels. Defaults to 400.\n        auto_size (bool): Whether to automatically size the chart to fit its container.\n            Defaults to False.\n        layout (LayoutOptions): Chart layout configuration including background colors,\n            text styling, and visual appearance settings.\n        left_price_scale (Optional[PriceScaleOptions]): Left price scale configuration.\n            If None, left price scale is disabled.\n        right_price_scale (PriceScaleOptions): Right price scale configuration.\n            Defaults to standard right price scale settings.\n        overlay_price_scales (Dict[str, PriceScaleOptions]): Overlay price scale\n            configurations for multiple price scales on the same chart.\n        time_scale (TimeScaleOptions): Time scale configuration including axis settings,\n            time formatting, and time range controls.\n        crosshair (CrosshairOptions): Crosshair configuration for mouse interactions\n            and data point highlighting.\n        grid (GridOptions): Grid configuration for horizontal and vertical grid lines.\n        handle_scroll (bool): Whether to enable scroll interactions for time navigation.\n            Defaults to True.\n        handle_scale (bool): Whether to enable scale interactions for zooming.\n            Defaults to True.\n        handle_double_click (bool): Whether to enable double-click interactions.\n            Defaults to True.\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to False.\n        kinetic_scroll (Optional[KineticScrollOptions]): Kinetic scroll options for\n            momentum-based scrolling behavior.\n        tracking_mode (Optional[TrackingModeOptions]): Mouse tracking mode for crosshair\n            and tooltips. Controls how the chart responds to mouse movement.\n        localization (Optional[LocalizationOptions]): Localization settings for date/time\n            formatting and locale-specific display options.\n        add_default_pane (bool): Whether to add a default pane to the chart.\n            Defaults to True.\n        trade_visualization (Optional[TradeVisualizationOptions]): Trade visualization\n            configuration options for displaying trade markers and annotations.\n        range_switcher (Optional[RangeSwitcherOptions]): Range switcher configuration\n            for time range selection buttons and presets.\n\n    Raises:\n        TypeError: If any attribute is assigned an invalid type during initialization.\n        PriceScaleIdTypeError: If price scale ID is not a string.\n        PriceScaleOptionsTypeError: If price scale options are not of correct type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import ChartOptions\n        from streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n        # Create custom chart options\n        options = ChartOptions(\n            width=800,\n            height=600,\n            layout=LayoutOptions(background_color=\"#ffffff\"),\n            handle_scroll=True,\n            handle_scale=True,\n        )\n        ```\n    \"\"\"\n\n    # Size and layout options\n    width: Optional[int] = None\n    height: int = 400\n    auto_size: bool = True\n\n    # Layout and appearance\n    layout: LayoutOptions = field(default_factory=LayoutOptions)\n    left_price_scale: Optional[PriceScaleOptions] = None\n    right_price_scale: PriceScaleOptions = field(default_factory=PriceScaleOptions)\n    overlay_price_scales: Dict[str, PriceScaleOptions] = field(default_factory=dict)\n    time_scale: TimeScaleOptions = field(default_factory=TimeScaleOptions)\n\n    # Interaction options\n    crosshair: CrosshairOptions = field(default_factory=CrosshairOptions)\n    grid: GridOptions = field(default_factory=GridOptions)\n    handle_scroll: bool = True\n    handle_scale: bool = True\n    handle_double_click: bool = True\n    fit_content_on_load: bool = True\n    kinetic_scroll: Optional[KineticScrollOptions] = None\n    tracking_mode: Optional[TrackingModeOptions] = None\n\n    # Localization and UI\n    localization: Optional[LocalizationOptions] = None\n    add_default_pane: bool = True\n\n    # Trade visualization options\n    trade_visualization: Optional[TradeVisualizationOptions] = None\n\n    # UI options\n    range_switcher: Optional[RangeSwitcherOptions] = None\n\n    # Synchronization options\n\n    def __post_init__(self):\n        \"\"\"Validate chart options after initialization.\"\"\"\n        # Validate price scale types first before accessing attributes\n        if self.right_price_scale is not None and not isinstance(\n            self.right_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"right_price_scale\", type(self.right_price_scale))\n\n        if self.left_price_scale is not None and not isinstance(\n            self.left_price_scale, PriceScaleOptions\n        ):\n            raise PriceScaleOptionsTypeError(\"left_price_scale\", type(self.left_price_scale))\n\n        # CRITICAL FIX: Ensure default price scales have their IDs set\n        # Without this, the empty string price_scale_id gets filtered out during serialization\n        # This causes the frontend to fail matching series to their price scales\n        if self.right_price_scale is not None and self.right_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"right\" if it's None\n            self.right_price_scale.price_scale_id = \"right\"\n\n        if self.left_price_scale is not None and self.left_price_scale.price_scale_id is None:\n            # Set the price_scale_id to \"left\" if it's None\n            self.left_price_scale.price_scale_id = \"left\"\n\n        # Validate price scale IDs are strings\n        if (\n            self.right_price_scale is not None\n            and self.right_price_scale.price_scale_id is not None\n            and not isinstance(self.right_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale.price_scale_id),\n            )\n\n        if (\n            self.left_price_scale is not None\n            and self.left_price_scale.price_scale_id is not None\n            and not isinstance(self.left_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale.price_scale_id),\n            )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html","title":"streamlit_lightweight_charts_pro.charts.options.interaction_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options","title":"interaction_options","text":"<p>Interaction options configuration for streamlit-lightweight-charts.</p> <p>This module provides interaction-related option classes for configuring crosshair behavior, kinetic scrolling, and tracking modes.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairLineOptions","title":"CrosshairLineOptions  <code>dataclass</code>","text":"<p>Crosshair line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"label_visible\", bool)\nclass CrosshairLineOptions(Options):\n    \"\"\"Crosshair line configuration.\"\"\"\n\n    color: str = \"#758696\"\n    width: int = 1\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = True\n    label_visible: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairSyncOptions","title":"CrosshairSyncOptions  <code>dataclass</code>","text":"<p>Crosshair synchronization configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"group_id\", int)\n@chainable_field(\"suppress_series_animations\", bool)\nclass CrosshairSyncOptions(Options):\n    \"\"\"Crosshair synchronization configuration.\"\"\"\n\n    group_id: int = 1\n    suppress_series_animations: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairOptions","title":"CrosshairOptions  <code>dataclass</code>","text":"<p>Crosshair configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"mode\", CrosshairMode)\n@chainable_field(\"vert_line\", CrosshairLineOptions)\n@chainable_field(\"horz_line\", CrosshairLineOptions)\nclass CrosshairOptions(Options):\n    \"\"\"Crosshair configuration for chart.\"\"\"\n\n    mode: CrosshairMode = CrosshairMode.NORMAL\n    vert_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n    horz_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.KineticScrollOptions","title":"KineticScrollOptions  <code>dataclass</code>","text":"<p>Kinetic scroll configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"touch\", bool)\n@chainable_field(\"mouse\", bool)\nclass KineticScrollOptions(Options):\n    \"\"\"Kinetic scroll configuration for chart.\"\"\"\n\n    touch: bool = True\n    mouse: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.TrackingModeOptions","title":"TrackingModeOptions  <code>dataclass</code>","text":"<p>Tracking mode configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"exit_on_escape\", bool)\nclass TrackingModeOptions(Options):\n    \"\"\"Tracking mode configuration for chart.\"\"\"\n\n    exit_on_escape: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html","title":"streamlit_lightweight_charts_pro.charts.options.layout_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options","title":"layout_options","text":"<p>Layout options configuration for streamlit-lightweight-charts.</p> <p>This module provides layout-related option classes for configuring chart appearance, grid settings, panes, and watermarks.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.GridLineOptions","title":"GridLineOptions  <code>dataclass</code>","text":"<p>Grid line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\nclass GridLineOptions(Options):\n    \"\"\"Grid line configuration.\"\"\"\n\n    color: str = \"#e1e3e6\"\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.GridOptions","title":"GridOptions  <code>dataclass</code>","text":"<p>Grid configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"vert_lines\", GridLineOptions)\n@chainable_field(\"horz_lines\", GridLineOptions)\nclass GridOptions(Options):\n    \"\"\"Grid configuration for chart.\"\"\"\n\n    vert_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=False))\n    horz_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=True))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.PaneOptions","title":"PaneOptions  <code>dataclass</code>","text":"<p>Pane configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"separator_color\", str, validator=\"color\")\n@chainable_field(\"separator_hover_color\", str, validator=\"color\")\n@chainable_field(\"enable_resize\", bool)\nclass PaneOptions(Options):\n    \"\"\"Pane configuration for chart.\"\"\"\n\n    separator_color: str = \"#e1e3ea\"\n    separator_hover_color: str = \"#ffffff\"\n    enable_resize: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.PaneHeightOptions","title":"PaneHeightOptions  <code>dataclass</code>","text":"<p>Pane height configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"factor\", float)\nclass PaneHeightOptions(Options):\n    \"\"\"Pane height configuration for chart.\"\"\"\n\n    factor: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate factor value.\"\"\"\n        if self.factor &lt;= 0:\n            raise ValueValidationError.positive_value(\"Pane height factor\", self.factor)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.LayoutOptions","title":"LayoutOptions  <code>dataclass</code>","text":"<p>Layout configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"background_options\", (BackgroundSolid, BackgroundGradient))\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"font_size\", int)\n@chainable_field(\"font_family\", str)\n@chainable_field(\"pane_options\", PaneOptions)\n@chainable_field(\"pane_heights\", Dict[int, PaneHeightOptions])\n@chainable_field(\"attribution_logo\", bool)\nclass LayoutOptions(Options):\n    \"\"\"Layout configuration for chart.\"\"\"\n\n    background_options: BackgroundSolid = field(\n        default_factory=lambda: BackgroundSolid(color=\"#ffffff\"),\n    )\n    text_color: str = \"#131722\"\n    font_size: int = 11\n    font_family: str = \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\"\n    pane_options: Optional[PaneOptions] = None\n    pane_heights: Optional[Dict[int, PaneHeightOptions]] = None\n    attribution_logo: bool = False\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ValueValidationError(property_name, \"Invalid color format\")\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.WatermarkOptions","title":"WatermarkOptions  <code>dataclass</code>","text":"<p>Watermark configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"text\", str)\n@chainable_field(\"font_size\", int)\n@chainable_field(\"horz_align\", HorzAlign)\n@chainable_field(\"vert_align\", VertAlign)\n@chainable_field(\"color\", str, validator=\"color\")\nclass WatermarkOptions(Options):\n    \"\"\"Watermark configuration.\"\"\"\n\n    visible: bool = True\n    text: str = \"\"\n    font_size: int = 96\n    horz_align: HorzAlign = HorzAlign.CENTER\n    vert_align: VertAlign = VertAlign.CENTER\n    color: str = \"rgba(255, 255, 255, 0.1)\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html","title":"streamlit_lightweight_charts_pro.charts.options.line_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options","title":"line_options","text":"<p>Line options configuration for streamlit-lightweight-charts.</p> <p>This module provides line styling option classes for configuring the appearance of line series on charts. It includes comprehensive styling options for line visualization including colors, styles, markers, and animation effects.</p> Key Features <ul> <li>Line color, style, and width customization</li> <li>Point marker configuration for data points</li> <li>Crosshair marker styling for interaction</li> <li>Animation effects for price updates</li> <li>Line type options (simple, curved, stepped)</li> <li>Visibility controls for different line elements</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import LineOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import LineStyle, LineType\n\n# Create line options with custom styling\nline_opts = LineOptions(\n    color=\"#2196F3\", line_style=LineStyle.SOLID, line_width=2, point_markers_visible=True\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options.LineOptions","title":"LineOptions  <code>dataclass</code>","text":"<p>Comprehensive styling options for line series in financial chart visualization.</p> <p>This class encapsulates all the styling options that control how a line series appears on a chart. It mirrors TradingView's LineStyleOptions interface and provides extensive customization capabilities for line visualization.</p> <p>The LineOptions class supports various line styles, marker configurations, animation effects, and visual customization options to create professional-looking line charts for financial data visualization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Line color in hex or rgba format. Defaults to \"#2196f3\" (blue). Must be a valid color format for proper rendering.</p> <code>line_style</code> <code>LineStyle</code> <p>Line style for the series line. Options include SOLID, DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.</p> <code>line_width</code> <code>int</code> <p>Line width in pixels. Defaults to 3. Higher values create thicker lines for better visibility.</p> <code>line_type</code> <code>LineType</code> <p>Line type for connecting data points. Options include SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.</p> <code>line_visible</code> <code>bool</code> <p>Whether to show the series line. Defaults to True. Set to False to show only markers.</p> <code>point_markers_visible</code> <code>bool</code> <p>Whether to show circle markers on each data point. Defaults to False. Useful for highlighting individual data points.</p> <code>point_markers_radius</code> <code>Optional[int]</code> <p>Radius of point markers in pixels. Defaults to None (uses default radius). Only used when point_markers_visible is True.</p> <code>crosshair_marker_visible</code> <code>bool</code> <p>Whether to show the crosshair marker during mouse interactions. Defaults to False. Provides visual feedback during hovering.</p> <code>crosshair_marker_radius</code> <code>int</code> <p>Radius of crosshair marker in pixels. Defaults to 4. Controls the size of the interaction marker.</p> <code>crosshair_marker_border_color</code> <code>str</code> <p>Border color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_background_color</code> <code>str</code> <p>Background color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_border_width</code> <code>int</code> <p>Border width for crosshair marker in pixels. Defaults to 2. Controls the thickness of the marker border.</p> <code>last_price_animation</code> <code>LastPriceAnimationMode</code> <p>Animation mode for last price updates. Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.</p> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If color values are not in valid hex or rgba format.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import LineOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import (\n    LineStyle,\n    LineType,\n    LastPriceAnimationMode,\n)\n\n# Create line options with custom styling\nline_opts = LineOptions(\n    color=\"#FF5722\",\n    line_style=LineStyle.SOLID,\n    line_width=2,\n    line_type=LineType.CURVED,\n    point_markers_visible=True,\n    crosshair_marker_visible=True,\n    last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n)\n\n# Use with line series\nseries = LineSeries(data=data, line_options=line_opts)\n</code></pre> See also <p>TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_type\", LineType)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"point_markers_visible\", bool)\n@chainable_field(\"point_markers_radius\", int)\n@chainable_field(\"crosshair_marker_visible\", bool)\n@chainable_field(\"crosshair_marker_radius\", int)\n@chainable_field(\"crosshair_marker_border_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_background_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_border_width\", int)\n@chainable_field(\"last_price_animation\", LastPriceAnimationMode)\nclass LineOptions(Options):\n    \"\"\"Comprehensive styling options for line series in financial chart visualization.\n\n    This class encapsulates all the styling options that control how a line series\n    appears on a chart. It mirrors TradingView's LineStyleOptions interface and\n    provides extensive customization capabilities for line visualization.\n\n    The LineOptions class supports various line styles, marker configurations,\n    animation effects, and visual customization options to create professional-looking\n    line charts for financial data visualization.\n\n    Attributes:\n        color (str): Line color in hex or rgba format. Defaults to \"#2196f3\" (blue).\n            Must be a valid color format for proper rendering.\n        line_style (LineStyle): Line style for the series line. Options include SOLID,\n            DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.\n        line_width (int): Line width in pixels. Defaults to 3. Higher values create\n            thicker lines for better visibility.\n        line_type (LineType): Line type for connecting data points. Options include\n            SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.\n        line_visible (bool): Whether to show the series line. Defaults to True.\n            Set to False to show only markers.\n        point_markers_visible (bool): Whether to show circle markers on each data point.\n            Defaults to False. Useful for highlighting individual data points.\n        point_markers_radius (Optional[int]): Radius of point markers in pixels.\n            Defaults to None (uses default radius). Only used when point_markers_visible is True.\n        crosshair_marker_visible (bool): Whether to show the crosshair marker during\n            mouse interactions. Defaults to False. Provides visual feedback during hovering.\n        crosshair_marker_radius (int): Radius of crosshair marker in pixels.\n            Defaults to 4. Controls the size of the interaction marker.\n        crosshair_marker_border_color (str): Border color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_background_color (str): Background color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_border_width (int): Border width for crosshair marker in pixels.\n            Defaults to 2. Controls the thickness of the marker border.\n        last_price_animation (LastPriceAnimationMode): Animation mode for last price updates.\n            Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.\n\n    Raises:\n        ColorValidationError: If color values are not in valid hex or rgba format.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import LineOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            LineStyle,\n            LineType,\n            LastPriceAnimationMode,\n        )\n\n        # Create line options with custom styling\n        line_opts = LineOptions(\n            color=\"#FF5722\",\n            line_style=LineStyle.SOLID,\n            line_width=2,\n            line_type=LineType.CURVED,\n            point_markers_visible=True,\n            crosshair_marker_visible=True,\n            last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n        )\n\n        # Use with line series\n        series = LineSeries(data=data, line_options=line_opts)\n        ```\n\n    See also:\n        TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions\n    \"\"\"\n\n    color: str = \"#2196f3\"\n    line_style: LineStyle = LineStyle.SOLID\n    line_width: int = 3\n    line_type: LineType = LineType.SIMPLE\n    line_visible: bool = True\n    point_markers_visible: bool = False\n    point_markers_radius: Optional[int] = None\n    crosshair_marker_visible: bool = False\n    crosshair_marker_radius: int = 4\n    crosshair_marker_border_color: str = \"\"\n    crosshair_marker_background_color: str = \"\"\n    crosshair_marker_border_width: int = 2\n    last_price_animation: LastPriceAnimationMode = LastPriceAnimationMode.DISABLED\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\n\n        Validates that the provided color string is in a valid format (hex or rgba)\n        and raises an appropriate error if validation fails. This method is used\n        by the chainable_field decorator for color validation.\n\n        Args:\n            color (str): Color string to validate in hex or rgba format.\n            property_name (str): Name of the property being validated for error messages.\n\n        Returns:\n            str: The validated color string if valid.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n\n        Example:\n            ```python\n            # Valid colors\n            valid_color = LineOptions._validate_color_static(\"#FF0000\", \"color\")\n            valid_rgba = LineOptions._validate_color_static(\"rgba(255,0,0,0.5)\", \"color\")\n\n            # Invalid color (will raise ColorValidationError)\n            try:\n                invalid_color = LineOptions._validate_color_static(\"invalid\", \"color\")\n            except ColorValidationError as e:\n                print(f\"Invalid color: {e}\")\n            ```\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html","title":"streamlit_lightweight_charts_pro.charts.options.localization_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options","title":"localization_options","text":"<p>Localization option classes for streamlit-lightweight-charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options.LocalizationOptions","title":"LocalizationOptions  <code>dataclass</code>","text":"<p>Localization configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/localization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"locale\", str)\n@chainable_field(\"date_format\", str)\n@chainable_field(\"time_format\", str)\n@chainable_field(\"price_formatter\", allow_none=True)\n@chainable_field(\"percentage_formatter\", allow_none=True)\nclass LocalizationOptions(Options):\n    \"\"\"Localization configuration for chart.\"\"\"\n\n    locale: str = \"en-US\"\n    date_format: str = \"yyyy-MM-dd\"\n    time_format: str = \"HH:mm:ss\"\n    price_formatter: Optional[Callable] = None\n    percentage_formatter: Optional[Callable] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_format_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options","title":"price_format_options","text":"<p>Price format options configuration for streamlit-lightweight-charts.</p> <p>This module provides price formatting option classes for configuring how price values are displayed on charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options.PriceFormatOptions","title":"PriceFormatOptions  <code>dataclass</code>","text":"<p>Encapsulates price formatting options for a series, matching TradingView's API.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Format type (\"price\", \"volume\", \"percent\", \"custom\").</p> <code>precision</code> <code>int</code> <p>Number of decimal places.</p> <code>min_move</code> <code>float</code> <p>Minimum price movement.</p> <code>formatter</code> <code>Optional[str]</code> <p>Optional custom formatter (string name or function reference).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_format_options.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str, validator=\"price_format_type\")\n@chainable_field(\"precision\", int, validator=\"precision\")\n@chainable_field(\"min_move\", (int, float), validator=\"min_move\")\n@chainable_field(\"formatter\", str)\nclass PriceFormatOptions(Options):\n    \"\"\"Encapsulates price formatting options for a series, matching TradingView's API.\n\n    Attributes:\n        type (str): Format type (\"price\", \"volume\", \"percent\", \"custom\").\n        precision (int): Number of decimal places.\n        min_move (float): Minimum price movement.\n        formatter (Optional[str]): Optional custom formatter (string name or function reference).\n    \"\"\"\n\n    type: str = \"price\"\n    precision: int = 2\n    min_move: float = 0.01\n    formatter: Optional[str] = None\n\n    @staticmethod\n    def _validate_type_static(type_value: str) -&gt; str:\n        \"\"\"Static version of type validator for decorator use.\"\"\"\n        if type_value not in {\"price\", \"volume\", \"percent\", \"custom\"}:\n            raise ValueValidationError(\n                \"type\",\n                f\"must be one of 'price', 'volume', 'percent', 'custom', got {type_value!r}\",\n            )\n        return type_value\n\n    @staticmethod\n    def _validate_precision_static(precision: int) -&gt; int:\n        \"\"\"Static version of precision validator for decorator use.\"\"\"\n        if not isinstance(precision, int) or precision &lt; 0:\n            raise ValueValidationError(\"precision\", \"must be a non-negative integer\")\n        return precision\n\n    @staticmethod\n    def _validate_min_move_static(min_move: float) -&gt; float:\n        \"\"\"Static version of min_move validator for decorator use.\"\"\"\n        if not isinstance(min_move, (int, float)) or min_move &lt;= 0:\n            raise ValueValidationError(\"min_move\", \"must be a positive number\")\n        return min_move\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_line_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options","title":"price_line_options","text":"<p>Price line options configuration for streamlit-lightweight-charts.</p> <p>This module provides price line option classes for configuring horizontal price lines on charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options.PriceLineOptions","title":"PriceLineOptions  <code>dataclass</code>","text":"<p>Encapsulates style and configuration options for a price line.</p> <p>Matching TradingView's PriceLineOptions.</p> <p>See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Optional ID of the price line.</p> <code>price</code> <code>float</code> <p>Price line's value.</p> <code>color</code> <code>str</code> <p>Price line's color (hex or rgba).</p> <code>line_width</code> <code>int</code> <p>Price line's width in pixels.</p> <code>line_style</code> <code>LineStyle</code> <p>Price line's style.</p> <code>line_visible</code> <code>bool</code> <p>Whether the line is displayed.</p> <code>axis_label_visible</code> <code>bool</code> <p>Whether the price value is shown on the price scale.</p> <code>title</code> <code>str</code> <p>Title for the price line on the chart pane.</p> <code>axis_label_color</code> <code>Optional[str]</code> <p>Background color for the axis label.</p> <code>axis_label_text_color</code> <code>Optional[str]</code> <p>Text color for the axis label.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"id\", str)\n@chainable_field(\"price\", (int, float))\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"axis_label_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"axis_label_color\", str, validator=\"color\")\n@chainable_field(\"axis_label_text_color\", str, validator=\"color\")\nclass PriceLineOptions(Options):\n    \"\"\"Encapsulates style and configuration options for a price line.\n\n    Matching TradingView's PriceLineOptions.\n\n    See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions\n\n    Attributes:\n        id (Optional[str]): Optional ID of the price line.\n        price (float): Price line's value.\n        color (str): Price line's color (hex or rgba).\n        line_width (int): Price line's width in pixels.\n        line_style (LineStyle): Price line's style.\n        line_visible (bool): Whether the line is displayed.\n        axis_label_visible (bool): Whether the price value is shown on the price scale.\n        title (str): Title for the price line on the chart pane.\n        axis_label_color (Optional[str]): Background color for the axis label.\n        axis_label_text_color (Optional[str]): Text color for the axis label.\n    \"\"\"\n\n    id: Optional[str] = None\n    price: float = 0.0\n    color: str = \"\"\n    line_width: int = 1\n    line_style: LineStyle = LineStyle.SOLID\n    line_visible: bool = True\n    axis_label_visible: bool = False\n    title: str = \"\"\n    axis_label_color: Optional[str] = None\n    axis_label_text_color: Optional[str] = None\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\"\"\"\n        if color and not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_scale_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options","title":"price_scale_options","text":"<p>Price scale option classes for streamlit-lightweight-charts.</p> <p>This module provides comprehensive configuration options for price scales in financial charts. Price scales control how price values are displayed, formatted, and positioned on the chart, including both left and right price scales as well as overlay scales.</p> Key Features <ul> <li>Price scale visibility and behavior configuration</li> <li>Auto-scaling and manual scale control options</li> <li>Visual appearance customization (colors, borders, text)</li> <li>Tick marks and label positioning options</li> <li>Scale margins and minimum width settings</li> <li>Price scale identification and management</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n# Create price scale options\nprice_scale = PriceScaleOptions(\n    visible=True,\n    auto_scale=True,\n    mode=PriceScaleMode.NORMAL,\n    border_color=\"#e0e0e0\",\n    text_color=\"#333333\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options.PriceScaleMargins","title":"PriceScaleMargins  <code>dataclass</code>","text":"<p>Configuration for price scale margins in financial charts.</p> <p>This class defines the margin settings for price scales, controlling the spacing between the chart content and the price scale boundaries. Margins are specified as percentages of the visible price range.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space above the chart.</p> <code>bottom</code> <code>float</code> <p>Bottom margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space below the chart.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n# Create margins with custom spacing\nmargins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n# Use with price scale options\nprice_scale = PriceScaleOptions(scale_margins=margins)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"top\", (int, float))\n@chainable_field(\"bottom\", (int, float))\nclass PriceScaleMargins(Options):\n    \"\"\"Configuration for price scale margins in financial charts.\n\n    This class defines the margin settings for price scales, controlling the\n    spacing between the chart content and the price scale boundaries. Margins\n    are specified as percentages of the visible price range.\n\n    Attributes:\n        top (float): Top margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space above the chart.\n        bottom (float): Bottom margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space below the chart.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n        # Create margins with custom spacing\n        margins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n        # Use with price scale options\n        price_scale = PriceScaleOptions(scale_margins=margins)\n        ```\n    \"\"\"\n\n    top: float = 0.1  # Top margin as percentage of visible price range\n    bottom: float = 0.1  # Bottom margin as percentage of visible price range\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options.PriceScaleOptions","title":"PriceScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for price scales in financial charts.</p> <p>This class provides extensive configuration options for price scales, controlling how price values are displayed, formatted, and positioned on the chart. It supports both left and right price scales as well as overlay scales with full customization of appearance, behavior, and interaction.</p> <p>Attributes:</p> Name Type Description <code>visible</code> <code>bool</code> <p>Whether the price scale is visible. Defaults to True.</p> <code>auto_scale</code> <code>bool</code> <p>Whether to automatically scale the price range based on data. Defaults to True. Set to False for manual scale control.</p> <code>mode</code> <code>PriceScaleMode</code> <p>Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE). Defaults to PriceScaleMode.NORMAL for linear scaling.</p> <code>invert_scale</code> <code>bool</code> <p>Whether to invert the price scale (high to low). Defaults to False for normal orientation.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the price scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the price scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>text_color</code> <code>str</code> <p>Color of price scale text and labels. Defaults to dark gray. Must be valid color format (hex or rgba).</p> <code>ticks_visible</code> <code>bool</code> <p>Whether to show tick marks on the price scale. Defaults to True.</p> <code>ensure_edge_tick_marks_visible</code> <code>bool</code> <p>Whether to ensure edge tick marks are always visible. Defaults to False.</p> <code>align_labels</code> <code>bool</code> <p>Whether to align price labels. Defaults to True.</p> <code>entire_text_only</code> <code>bool</code> <p>Whether to show only complete text labels. Defaults to False.</p> <code>minimum_width</code> <code>int</code> <p>Minimum width of the price scale in pixels. Defaults to 72 pixels.</p> <code>scale_margins</code> <code>PriceScaleMargins</code> <p>Margin configuration for the price scale. Defaults to 10% margins on top and bottom.</p> <code>price_scale_id</code> <code>str</code> <p>Unique identifier for the price scale. Defaults to \"\".</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n# Create left price scale with custom styling\nleft_scale = PriceScaleOptions(\n    visible=True,\n    auto_scale=True,\n    mode=PriceScaleMode.NORMAL,\n    border_color=\"#e0e0e0\",\n    text_color=\"#333333\",\n    minimum_width=100,\n)\n\n# Create right price scale for overlay series\nright_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n</code></pre> See also <p>PriceScaleMargins: Configuration class for price scale margins. PriceScaleMode: Enum for different price scale modes.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"auto_scale\", bool)\n@chainable_field(\"mode\", PriceScaleMode)\n@chainable_field(\"invert_scale\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"ticks_visible\", bool)\n@chainable_field(\"ensure_edge_tick_marks_visible\", bool)\n@chainable_field(\"align_labels\", bool)\n@chainable_field(\"entire_text_only\", bool)\n@chainable_field(\"minimum_width\", int)\n@chainable_field(\"scale_margins\", PriceScaleMargins)\n@chainable_field(\"price_scale_id\", str)\nclass PriceScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for price scales in financial charts.\n\n    This class provides extensive configuration options for price scales, controlling\n    how price values are displayed, formatted, and positioned on the chart. It supports\n    both left and right price scales as well as overlay scales with full customization\n    of appearance, behavior, and interaction.\n\n    Attributes:\n        visible (bool): Whether the price scale is visible. Defaults to True.\n        auto_scale (bool): Whether to automatically scale the price range based on data.\n            Defaults to True. Set to False for manual scale control.\n        mode (PriceScaleMode): Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE).\n            Defaults to PriceScaleMode.NORMAL for linear scaling.\n        invert_scale (bool): Whether to invert the price scale (high to low).\n            Defaults to False for normal orientation.\n        border_visible (bool): Whether to show the price scale border. Defaults to True.\n        border_color (str): Color of the price scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        text_color (str): Color of price scale text and labels. Defaults to dark gray.\n            Must be valid color format (hex or rgba).\n        ticks_visible (bool): Whether to show tick marks on the price scale.\n            Defaults to True.\n        ensure_edge_tick_marks_visible (bool): Whether to ensure edge tick marks\n            are always visible. Defaults to False.\n        align_labels (bool): Whether to align price labels. Defaults to True.\n        entire_text_only (bool): Whether to show only complete text labels.\n            Defaults to False.\n        minimum_width (int): Minimum width of the price scale in pixels.\n            Defaults to 72 pixels.\n        scale_margins (PriceScaleMargins): Margin configuration for the price scale.\n            Defaults to 10% margins on top and bottom.\n        price_scale_id (str): Unique identifier for the price scale. Defaults to \"\".\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n        # Create left price scale with custom styling\n        left_scale = PriceScaleOptions(\n            visible=True,\n            auto_scale=True,\n            mode=PriceScaleMode.NORMAL,\n            border_color=\"#e0e0e0\",\n            text_color=\"#333333\",\n            minimum_width=100,\n        )\n\n        # Create right price scale for overlay series\n        right_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n        ```\n\n    See also:\n        PriceScaleMargins: Configuration class for price scale margins.\n        PriceScaleMode: Enum for different price scale modes.\n    \"\"\"\n\n    # Core visibility and behavior settings\n    visible: bool = True  # Whether the price scale is visible\n    auto_scale: bool = True  # Whether to automatically scale based on data\n    mode: PriceScaleMode = PriceScaleMode.NORMAL  # Price scale mode (linear/log/percentage)\n    invert_scale: bool = False  # Whether to invert the scale orientation\n\n    # Visual appearance configuration\n    border_visible: bool = True  # Whether to show the price scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n    text_color: str = \"#131722\"  # Text color (TradingView dark gray)\n\n    # Tick marks and label configuration\n    ticks_visible: bool = True  # Whether to show tick marks\n    ensure_edge_tick_marks_visible: bool = False  # Force edge tick marks to be visible\n    align_labels: bool = True  # Whether to align price labels\n    entire_text_only: bool = False  # Whether to show only complete text labels\n\n    # Size and positioning settings\n    minimum_width: int = 72  # Minimum width in pixels\n    scale_margins: PriceScaleMargins = field(\n        default_factory=PriceScaleMargins,\n    )  # Margin configuration\n\n    # Price scale identification\n    price_scale_id: str = \"\"  # Unique identifier for the price scale\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html","title":"streamlit_lightweight_charts_pro.charts.options.sync_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options","title":"sync_options","text":"<p>Synchronization options for linked charts.</p> <p>This module provides synchronization configuration options for managing multiple linked charts. These options control how charts interact with each other when they are part of a linked chart system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions","title":"SyncOptions  <code>dataclass</code>","text":"<p>Synchronization options for linked charts.</p> <p>This class provides configuration options for synchronizing multiple charts in a linked chart system. It controls crosshair and time range synchronization behavior across linked charts, including support for chart groups to enable selective synchronization.</p> <p>When synchronization is enabled, user interactions (crosshair movements and zoom/scroll operations) on one chart are propagated to all other charts in the same synchronization group. This creates a coordinated viewing experience across multiple charts.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether synchronization is enabled. When True, enables synchronization features based on crosshair and time_range settings. When False, disables all synchronization. Defaults to False.</p> <code>crosshair</code> <code>bool</code> <p>Whether to synchronize crosshair position across linked charts. When enabled, moving the crosshair on one chart will update the crosshair position on all linked charts. Defaults to False.</p> <code>time_range</code> <code>bool</code> <p>Whether to synchronize time range (zoom/scroll) across linked charts. When enabled, zooming or panning the time range on one chart will update the visible time range on all linked charts. Defaults to False.</p> <code>group_id</code> <code>Optional[str]</code> <p>Optional group identifier for chart synchronization. Charts with the same group_id will be synchronized with each other. If None, all charts in the same ChartManager will be synchronized. Defaults to None.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n# Enable all synchronization\nsync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n# Enable only crosshair synchronization\nsync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n# Use with group synchronization\nsync_options = SyncOptions(\n    enabled=True,\n    crosshair=True,\n    time_range=True,\n    group_id=\"price_charts\"\n)\n</code></pre> Note <p>The synchronization system prevents race conditions and feedback loops through debouncing and flag-based protection mechanisms. This ensures smooth performance even with rapid user interactions.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"crosshair\", bool)\n@chainable_field(\"time_range\", bool)\n@chainable_field(\"group_id\", str)\nclass SyncOptions(Options):\n    \"\"\"Synchronization options for linked charts.\n\n    This class provides configuration options for synchronizing multiple\n    charts in a linked chart system. It controls crosshair and time range\n    synchronization behavior across linked charts, including support for\n    chart groups to enable selective synchronization.\n\n    When synchronization is enabled, user interactions (crosshair movements\n    and zoom/scroll operations) on one chart are propagated to all other\n    charts in the same synchronization group. This creates a coordinated\n    viewing experience across multiple charts.\n\n    Attributes:\n        enabled (bool): Whether synchronization is enabled. When True,\n            enables synchronization features based on crosshair and time_range\n            settings. When False, disables all synchronization. Defaults to False.\n        crosshair (bool): Whether to synchronize crosshair position across\n            linked charts. When enabled, moving the crosshair on one chart\n            will update the crosshair position on all linked charts.\n            Defaults to False.\n        time_range (bool): Whether to synchronize time range (zoom/scroll)\n            across linked charts. When enabled, zooming or panning the time\n            range on one chart will update the visible time range on all\n            linked charts. Defaults to False.\n        group_id (Optional[str]): Optional group identifier for chart\n            synchronization. Charts with the same group_id will be\n            synchronized with each other. If None, all charts in the\n            same ChartManager will be synchronized. Defaults to None.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n        # Enable all synchronization\n        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n        # Enable only crosshair synchronization\n        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n        # Use with group synchronization\n        sync_options = SyncOptions(\n            enabled=True,\n            crosshair=True,\n            time_range=True,\n            group_id=\"price_charts\"\n        )\n        ```\n\n    Note:\n        The synchronization system prevents race conditions and feedback loops\n        through debouncing and flag-based protection mechanisms. This ensures\n        smooth performance even with rapid user interactions.\n    \"\"\"\n\n    enabled: bool = False\n    crosshair: bool = False\n    time_range: bool = False\n    group_id: Optional[str] = None\n\n    def enable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = True\n        self.crosshair = True\n        self.time_range = True\n        return self\n\n    def disable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = False\n        self.crosshair = False\n        self.time_range = False\n        return self\n\n    def enable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = True\n        self.enabled = True\n        return self\n\n    def disable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = False\n        if not self.time_range:\n            self.enabled = False\n        return self\n\n    def enable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = True\n        self.enabled = True\n        return self\n\n    def disable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = False\n        if not self.crosshair:\n            self.enabled = False\n        return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_all","title":"enable_all","text":"<pre><code>enable_all() -&gt; SyncOptions\n</code></pre> <p>Enable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = True\n    self.crosshair = True\n    self.time_range = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_all","title":"disable_all","text":"<pre><code>disable_all() -&gt; SyncOptions\n</code></pre> <p>Disable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = False\n    self.crosshair = False\n    self.time_range = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_crosshair","title":"enable_crosshair","text":"<pre><code>enable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Enable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_crosshair","title":"disable_crosshair","text":"<pre><code>disable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Disable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = False\n    if not self.time_range:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_time_range","title":"enable_time_range","text":"<pre><code>enable_time_range() -&gt; SyncOptions\n</code></pre> <p>Enable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_time_range","title":"disable_time_range","text":"<pre><code>disable_time_range() -&gt; SyncOptions\n</code></pre> <p>Disable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = False\n    if not self.crosshair:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html","title":"streamlit_lightweight_charts_pro.charts.options.time_scale_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options","title":"time_scale_options","text":"<p>Time scale option classes for streamlit-lightweight-charts.</p> <p>This module provides comprehensive configuration options for time scales in financial charts. Time scales control how time values are displayed, formatted, and positioned on the horizontal axis of the chart, including spacing, visibility, and interaction settings.</p> Key Features <ul> <li>Time axis spacing and positioning configuration</li> <li>Time visibility and formatting options</li> <li>Border and visual appearance customization</li> <li>Interactive behavior and scrolling controls</li> <li>Bar spacing and offset settings</li> <li>Time range locking and edge fixing options</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n# Create time scale options\ntime_scale = TimeScaleOptions(\n    visible=True, time_visible=True, border_visible=True, bar_spacing=6, right_offset=10\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options.TimeScaleOptions","title":"TimeScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for time scales in financial charts.</p> <p>This class provides extensive configuration options for time scales, controlling how time values are displayed, formatted, and positioned on the horizontal axis of the chart. It includes spacing, visibility, interaction, and formatting settings for professional time-based chart visualization.</p> <p>Attributes:</p> Name Type Description <code>right_offset</code> <code>int</code> <p>Right offset in pixels from the chart edge. Defaults to 0.</p> <code>left_offset</code> <code>int</code> <p>Left offset in pixels from the chart edge. Defaults to 0.</p> <code>bar_spacing</code> <code>int</code> <p>Spacing between bars in pixels. Defaults to 6.</p> <code>min_bar_spacing</code> <code>float</code> <p>Minimum spacing between bars in pixels. Defaults to 0.001.</p> <code>visible</code> <code>bool</code> <p>Whether the time scale is visible. Defaults to True.</p> <code>time_visible</code> <code>bool</code> <p>Whether to show time labels on the scale. Defaults to True.</p> <code>seconds_visible</code> <code>bool</code> <p>Whether to show seconds in time labels. Defaults to False.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the time scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the time scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>fix_left_edge</code> <code>bool</code> <p>Whether to fix the left edge of the time range. Defaults to False.</p> <code>fix_right_edge</code> <code>bool</code> <p>Whether to fix the right edge of the time range. Defaults to False.</p> <code>lock_visible_time_range_on_resize</code> <code>bool</code> <p>Whether to lock the visible time range when resizing the chart. Defaults to False.</p> <code>right_bar_stays_on_scroll</code> <code>bool</code> <p>Whether the rightmost bar stays visible during scroll. Defaults to False.</p> <code>shift_visible_range_on_new_bar</code> <code>bool</code> <p>Whether to shift the visible range when a new bar is added. Defaults to False.</p> <code>allow_shift_visible_range_on_whitespace_access</code> <code>bool</code> <p>Whether to allow shifting the visible range when accessing whitespace. Defaults to False.</p> <code>tick_mark_formatter</code> <code>Optional[Callable]</code> <p>Custom formatter function for tick marks. Defaults to None (uses default formatting).</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to handle double-click interactions. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to handle scale interactions. Defaults to True.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to handle scroll interactions. Defaults to True.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n# Create time scale with custom spacing and visibility\ntime_scale = TimeScaleOptions(\n    visible=True,\n    time_visible=True,\n    seconds_visible=False,\n    border_visible=True,\n    bar_spacing=8,\n    right_offset=20,\n    left_offset=10,\n)\n\n# Create time scale with locked edges\nlocked_time_scale = TimeScaleOptions(\n    fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n)\n</code></pre> See also <p>Options: Base class providing common option functionality.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/time_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"right_offset\", int)\n@chainable_field(\"left_offset\", int)\n@chainable_field(\"bar_spacing\", int)\n@chainable_field(\"min_bar_spacing\", float)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"time_visible\", bool)\n@chainable_field(\"seconds_visible\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"fix_left_edge\", bool)\n@chainable_field(\"fix_right_edge\", bool)\n@chainable_field(\"lock_visible_time_range_on_resize\", bool)\n@chainable_field(\"right_bar_stays_on_scroll\", bool)\n@chainable_field(\"shift_visible_range_on_new_bar\", bool)\n@chainable_field(\"allow_shift_visible_range_on_whitespace_access\", bool)\n@chainable_field(\"tick_mark_formatter\", allow_none=True)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_scroll\", bool)\nclass TimeScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for time scales in financial charts.\n\n    This class provides extensive configuration options for time scales, controlling\n    how time values are displayed, formatted, and positioned on the horizontal axis\n    of the chart. It includes spacing, visibility, interaction, and formatting\n    settings for professional time-based chart visualization.\n\n    Attributes:\n        right_offset (int): Right offset in pixels from the chart edge. Defaults to 0.\n        left_offset (int): Left offset in pixels from the chart edge. Defaults to 0.\n        bar_spacing (int): Spacing between bars in pixels. Defaults to 6.\n        min_bar_spacing (float): Minimum spacing between bars in pixels. Defaults to 0.001.\n        visible (bool): Whether the time scale is visible. Defaults to True.\n        time_visible (bool): Whether to show time labels on the scale. Defaults to True.\n        seconds_visible (bool): Whether to show seconds in time labels. Defaults to False.\n        border_visible (bool): Whether to show the time scale border. Defaults to True.\n        border_color (str): Color of the time scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        fix_left_edge (bool): Whether to fix the left edge of the time range. Defaults to False.\n        fix_right_edge (bool): Whether to fix the right edge of the time range. Defaults to False.\n        lock_visible_time_range_on_resize (bool): Whether to lock the visible time range\n            when resizing the chart. Defaults to False.\n        right_bar_stays_on_scroll (bool): Whether the rightmost bar stays visible during scroll.\n            Defaults to False.\n        shift_visible_range_on_new_bar (bool): Whether to shift the visible range when\n            a new bar is added. Defaults to False.\n        allow_shift_visible_range_on_whitespace_access (bool): Whether to allow shifting\n            the visible range when accessing whitespace. Defaults to False.\n        tick_mark_formatter (Optional[Callable]): Custom formatter function for tick marks.\n            Defaults to None (uses default formatting).\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to True.\n        handle_double_click (bool): Whether to handle double-click interactions.\n            Defaults to True.\n        handle_scale (bool): Whether to handle scale interactions. Defaults to True.\n        handle_scroll (bool): Whether to handle scroll interactions. Defaults to True.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n        # Create time scale with custom spacing and visibility\n        time_scale = TimeScaleOptions(\n            visible=True,\n            time_visible=True,\n            seconds_visible=False,\n            border_visible=True,\n            bar_spacing=8,\n            right_offset=20,\n            left_offset=10,\n        )\n\n        # Create time scale with locked edges\n        locked_time_scale = TimeScaleOptions(\n            fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n        )\n        ```\n\n    See also:\n        Options: Base class providing common option functionality.\n    \"\"\"\n\n    # Offset and spacing configuration\n    right_offset: int = 0  # Right offset in pixels from chart edge\n    left_offset: int = 0  # Left offset in pixels from chart edge\n    bar_spacing: int = 6  # Spacing between bars in pixels\n    min_bar_spacing: float = 0.001  # Minimum spacing between bars in pixels\n\n    # Visibility and appearance settings\n    visible: bool = True  # Whether the time scale is visible\n    time_visible: bool = True  # Whether to show time labels\n    seconds_visible: bool = False  # Whether to show seconds in time labels\n    border_visible: bool = True  # Whether to show the time scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n\n    # Time range and scrolling behavior\n    fix_left_edge: bool = False  # Whether to fix the left edge of the time range\n    fix_right_edge: bool = False  # Whether to fix the right edge of the time range\n    lock_visible_time_range_on_resize: bool = False  # Lock visible range on resize\n    right_bar_stays_on_scroll: bool = False  # Keep rightmost bar visible during scroll\n    shift_visible_range_on_new_bar: bool = False  # Shift range when new bar is added\n    allow_shift_visible_range_on_whitespace_access: bool = False  # Allow shifting on whitespace\n\n    # Formatting and interaction settings\n    tick_mark_formatter: Optional[Callable] = None  # Custom formatter for tick marks\n    fit_content_on_load: bool = True  # Fit content to visible area on load\n    handle_double_click: bool = True  # Handle double-click interactions\n    handle_scale: bool = True  # Handle scale interactions\n    handle_scroll: bool = True  # Handle scroll interactions\n\n    def __getitem__(self, key):\n        \"\"\"Get option value by key for dictionary-like access.\n\n        Allows accessing option values using dictionary-style syntax, which\n        is useful for dynamic configuration and testing.\n\n        Args:\n            key (str): The option key to retrieve.\n\n        Returns:\n            Any: The value of the specified option key.\n\n        Example:\n            ```python\n            time_scale = TimeScaleOptions()\n            spacing = time_scale[\"bar_spacing\"]  # Returns 6\n            visible = time_scale[\"visible\"]  # Returns True\n            ```\n        \"\"\"\n        return self.asdict()[key]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html","title":"streamlit_lightweight_charts_pro.charts.options.trade_visualization_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options","title":"trade_visualization_options","text":"<p>Trade visualization options for streamlit-lightweight-charts.</p> <p>This module provides the TradeVisualizationOptions class for configuring how trades are visualized on charts, including markers, rectangles, lines, arrows, and zones.</p> The module supports multiple visualization styles <ul> <li>Markers: Entry/exit markers at trade points</li> <li>Rectangles: Filled rectangles spanning trade duration</li> <li>Lines: Connecting lines between entry and exit</li> <li>Arrows: Directional arrows indicating trade flow</li> <li>Zones: Highlighted zones around trade areas</li> </ul> Key Features <ul> <li>Template-based tooltips and markers with HTML/placeholders</li> <li>Flexible color customization for profit/loss visualization</li> <li>Chainable API for fluent configuration</li> <li>Automatic validation of shapes, positions, and styles</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TradeVisualizationOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import TradeVisualization\n\n# Create options with method chaining\noptions = (\n    TradeVisualizationOptions()\n    .set_style(TradeVisualization.BOTH)\n    .set_rectangle_color_profit(\"#00FF00\")\n    .set_marker_size(1)\n    .set_tooltip_template(\"&lt;div&gt;$$trade_type$$: $$pnl$$&lt;/div&gt;\")\n)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options.TradeVisualizationOptions","title":"TradeVisualizationOptions  <code>dataclass</code>","text":"<p>Options for trade visualization.</p> <p>This class provides comprehensive configuration options for how trades are displayed on charts, including various visual styles and customization options for markers, rectangles, lines, arrows, and zones.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>TradeVisualization</code> <p>The visualization style to use (markers, rectangles, both, etc.)</p> <code>entry_marker_color_long</code> <code>str</code> <p>Color for long entry markers</p> <code>entry_marker_color_short</code> <code>str</code> <p>Color for short entry markers</p> <code>exit_marker_color_profit</code> <code>str</code> <p>Color for profitable exit markers</p> <code>exit_marker_color_loss</code> <code>str</code> <p>Color for loss exit markers</p> <code>marker_size</code> <code>int</code> <p>Size of markers in pixels</p> <code>show_pnl_in_markers</code> <code>bool</code> <p>Whether to show P&amp;L in marker text</p> <code>rectangle_fill_opacity</code> <code>float</code> <p>Opacity for rectangle fill (0.0 to 1.0)</p> <code>rectangle_border_width</code> <code>int</code> <p>Width of rectangle borders</p> <code>rectangle_color_profit</code> <code>str</code> <p>Color for profitable trade rectangles</p> <code>rectangle_color_loss</code> <code>str</code> <p>Color for loss trade rectangles</p> <code>rectangle_fill_color_profit</code> <code>str</code> <p>Fill color for profitable trade rectangles</p> <code>rectangle_border_color_profit</code> <code>str</code> <p>Border color for profitable trade rectangles</p> <code>rectangle_border_color_loss</code> <code>str</code> <p>Border color for loss trade rectangles</p> <code>line_width</code> <code>int</code> <p>Width of connecting lines</p> <code>line_style</code> <code>str</code> <p>Style of connecting lines (solid, dashed, etc.)</p> <code>line_color_profit</code> <code>str</code> <p>Color for profitable trade lines</p> <code>line_color_loss</code> <code>str</code> <p>Color for loss trade lines</p> <code>arrow_size</code> <code>int</code> <p>Size of arrows in pixels</p> <code>arrow_color_profit</code> <code>str</code> <p>Color for profitable trade arrows</p> <code>arrow_color_loss</code> <code>str</code> <p>Color for loss trade arrows</p> <code>zone_opacity</code> <code>float</code> <p>Opacity for zone fills (0.0 to 1.0)</p> <code>zone_color_long</code> <code>str</code> <p>Color for long trade zones</p> <code>zone_color_short</code> <code>str</code> <p>Color for short trade zones</p> <code>zone_extend_bars</code> <code>int</code> <p>Number of bars to extend zones</p> <code>show_trade_id</code> <code>bool</code> <p>Whether to show trade ID in annotations</p> <code>show_quantity</code> <code>bool</code> <p>Whether to show quantity in annotations</p> <code>show_trade_type</code> <code>bool</code> <p>Whether to show trade type in annotations</p> <code>annotation_font_size</code> <code>int</code> <p>Font size for annotations</p> <code>annotation_background</code> <code>str</code> <p>Background color for annotations</p> <code>rectangle_show_text</code> <code>bool</code> <p>Whether to show text on rectangles</p> <code>rectangle_text_position</code> <code>str</code> <p>Position of text on rectangles (inside, above, below)</p> <code>rectangle_text_font_size</code> <code>int</code> <p>Font size for rectangle text</p> <code>rectangle_text_color</code> <code>str</code> <p>Color for rectangle text</p> <code>rectangle_text_background</code> <code>str</code> <p>Background color for rectangle text</p> <code>tooltip_template</code> <code>str</code> <p>Custom HTML template for tooltips with placeholders</p> <code>marker_template</code> <code>str</code> <p>Deprecated - use entry_marker_template and exit_marker_template</p> <code>entry_marker_template</code> <code>str</code> <p>Custom HTML template for entry marker text</p> <code>exit_marker_template</code> <code>str</code> <p>Custom HTML template for exit marker text</p> <code>entry_marker_shape</code> <code>str</code> <p>Shape for entry markers (arrow_up, arrow_down, circle, square)</p> <code>exit_marker_shape</code> <code>str</code> <p>Shape for exit markers (arrow_up, arrow_down, circle, square)</p> <code>entry_marker_position</code> <code>str</code> <p>Position for entry markers (above, below)</p> <code>exit_marker_position</code> <code>str</code> <p>Position for exit markers (above, below)</p> <code>show_marker_text</code> <code>bool</code> <p>Whether to show text on markers</p> Template Placeholders <p>For tooltips and markers, you can use these placeholders in your HTML templates. All fields from TradeData.additional_data are also available: - \\(\\(id\\)\\): Trade ID - \\(\\(entry_price\\)\\): Entry price value - \\(\\(exit_price\\)\\): Exit price value - \\(\\(is_profitable\\)\\): Boolean profitability flag - \\(\\(pnl\\)\\): Profit/Loss amount - \\(\\(pnl_percentage\\)\\): Profit/Loss percentage - \\(\\(trade_type\\)\\): LONG or SHORT (from additional_data) - \\(\\(quantity\\)\\): Trade quantity (from additional_data) - \\(\\(notes\\)\\): Trade notes (from additional_data) - Any custom field from additional_data: \\(\\(strategy\\)\\), \\(\\(risk_level\\)\\), etc.</p> Example templates <p>tooltip_template: \"\\(\\(trade_type\\)\\)Entry: \\(\\(entry_price\\)\\)Exit: \\(\\(exit_price\\)\\)P&amp;L: \\(\\(pnl\\)\\) (\\(\\(pnl_percentage\\)\\)%)\" entry_marker_template: \"\u2191 \\(\\(trade_type\\)\\)\\((\\(entry_price\\)\\)\" exit_marker_template: \"\u2193 ((\\(exit_price\\)\\)&lt;br/&gt;(\\)\\)pnl_percentage$$%)\"</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", TradeVisualization)\n@chainable_field(\"entry_marker_color_long\", str, validator=\"color\")\n@chainable_field(\"entry_marker_color_short\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_profit\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_loss\", str, validator=\"color\")\n@chainable_field(\"marker_size\", int)\n@chainable_field(\"show_pnl_in_markers\", bool)\n@chainable_field(\"rectangle_fill_opacity\", float)\n@chainable_field(\"rectangle_border_width\", int)\n@chainable_field(\"rectangle_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_color_loss\", str, validator=\"color\")\n@chainable_field(\"rectangle_fill_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_loss\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"line_color_profit\", str, validator=\"color\")\n@chainable_field(\"line_color_loss\", str, validator=\"color\")\n@chainable_field(\"arrow_size\", int)\n@chainable_field(\"arrow_color_profit\", str, validator=\"color\")\n@chainable_field(\"arrow_color_loss\", str, validator=\"color\")\n@chainable_field(\"zone_opacity\", float)\n@chainable_field(\"zone_color_long\", str, validator=\"color\")\n@chainable_field(\"zone_color_short\", str, validator=\"color\")\n@chainable_field(\"zone_extend_bars\", int)\n@chainable_field(\"show_trade_id\", bool)\n@chainable_field(\"show_quantity\", bool)\n@chainable_field(\"show_trade_type\", bool)\n@chainable_field(\"annotation_font_size\", int)\n@chainable_field(\"annotation_background\", str, validator=\"color\")\n@chainable_field(\"rectangle_show_text\", bool)\n@chainable_field(\"rectangle_text_position\", str)\n@chainable_field(\"rectangle_text_font_size\", int)\n@chainable_field(\"rectangle_text_color\", str, validator=\"color\")\n@chainable_field(\"rectangle_text_background\", str, validator=\"color\")\n@chainable_field(\"tooltip_template\", str)\n@chainable_field(\"marker_template\", str)\n@chainable_field(\"entry_marker_template\", str)\n@chainable_field(\"exit_marker_template\", str)\n@chainable_field(\"entry_marker_shape\", str)\n@chainable_field(\"exit_marker_shape\", str)\n@chainable_field(\"entry_marker_position\", str)\n@chainable_field(\"exit_marker_position\", str)\n@chainable_field(\"show_marker_text\", bool)\nclass TradeVisualizationOptions(Options):\n    \"\"\"Options for trade visualization.\n\n    This class provides comprehensive configuration options for how trades\n    are displayed on charts, including various visual styles and customization\n    options for markers, rectangles, lines, arrows, and zones.\n\n    Attributes:\n        style: The visualization style to use (markers, rectangles, both, etc.)\n        entry_marker_color_long: Color for long entry markers\n        entry_marker_color_short: Color for short entry markers\n        exit_marker_color_profit: Color for profitable exit markers\n        exit_marker_color_loss: Color for loss exit markers\n        marker_size: Size of markers in pixels\n        show_pnl_in_markers: Whether to show P&amp;L in marker text\n        rectangle_fill_opacity: Opacity for rectangle fill (0.0 to 1.0)\n        rectangle_border_width: Width of rectangle borders\n        rectangle_color_profit: Color for profitable trade rectangles\n        rectangle_color_loss: Color for loss trade rectangles\n        rectangle_fill_color_profit: Fill color for profitable trade rectangles\n        rectangle_border_color_profit: Border color for profitable trade rectangles\n        rectangle_border_color_loss: Border color for loss trade rectangles\n        line_width: Width of connecting lines\n        line_style: Style of connecting lines (solid, dashed, etc.)\n        line_color_profit: Color for profitable trade lines\n        line_color_loss: Color for loss trade lines\n        arrow_size: Size of arrows in pixels\n        arrow_color_profit: Color for profitable trade arrows\n        arrow_color_loss: Color for loss trade arrows\n        zone_opacity: Opacity for zone fills (0.0 to 1.0)\n        zone_color_long: Color for long trade zones\n        zone_color_short: Color for short trade zones\n        zone_extend_bars: Number of bars to extend zones\n        show_trade_id: Whether to show trade ID in annotations\n        show_quantity: Whether to show quantity in annotations\n        show_trade_type: Whether to show trade type in annotations\n        annotation_font_size: Font size for annotations\n        annotation_background: Background color for annotations\n        rectangle_show_text: Whether to show text on rectangles\n        rectangle_text_position: Position of text on rectangles (inside, above, below)\n        rectangle_text_font_size: Font size for rectangle text\n        rectangle_text_color: Color for rectangle text\n        rectangle_text_background: Background color for rectangle text\n        tooltip_template: Custom HTML template for tooltips with placeholders\n        marker_template: Deprecated - use entry_marker_template and exit_marker_template\n        entry_marker_template: Custom HTML template for entry marker text\n        exit_marker_template: Custom HTML template for exit marker text\n        entry_marker_shape: Shape for entry markers (arrow_up, arrow_down, circle, square)\n        exit_marker_shape: Shape for exit markers (arrow_up, arrow_down, circle, square)\n        entry_marker_position: Position for entry markers (above, below)\n        exit_marker_position: Position for exit markers (above, below)\n        show_marker_text: Whether to show text on markers\n\n    Template Placeholders:\n        For tooltips and markers, you can use these placeholders in your HTML templates.\n        All fields from TradeData.additional_data are also available:\n        - $$id$$: Trade ID\n        - $$entry_price$$: Entry price value\n        - $$exit_price$$: Exit price value\n        - $$is_profitable$$: Boolean profitability flag\n        - $$pnl$$: Profit/Loss amount\n        - $$pnl_percentage$$: Profit/Loss percentage\n        - $$trade_type$$: LONG or SHORT (from additional_data)\n        - $$quantity$$: Trade quantity (from additional_data)\n        - $$notes$$: Trade notes (from additional_data)\n        - Any custom field from additional_data: $$strategy$$, $$risk_level$$, etc.\n\n    Example templates:\n        tooltip_template: \"&lt;div&gt;&lt;strong&gt;$$trade_type$$&lt;/strong&gt;&lt;br/&gt;Entry: $$entry_price$$&lt;br/&gt;Exit: $$exit_price$$&lt;br/&gt;P&amp;L: $$pnl$$ ($$pnl_percentage$$%)&lt;/div&gt;\"\n        entry_marker_template: \"\u2191 $$trade_type$$&lt;br/&gt;$$$entry_price$$\"\n        exit_marker_template: \"\u2193 $$$exit_price$$&lt;br/&gt;($$pnl_percentage$$%)\"\n    \"\"\"\n\n    style: TradeVisualization = TradeVisualization.RECTANGLES\n\n    # Marker options\n    entry_marker_color_long: str = \"#2196F3\"\n    entry_marker_color_short: str = \"#FF9800\"\n    exit_marker_color_profit: str = \"#4CAF50\"\n    exit_marker_color_loss: str = \"#F44336\"\n    marker_size: int = 5\n    show_pnl_in_markers: bool = False\n\n    # Rectangle options\n    rectangle_fill_opacity: float = 0.1\n    rectangle_border_width: int = 1\n    rectangle_color_profit: str = \"#4CAF50\"\n    rectangle_color_loss: str = \"#F44336\"\n    rectangle_fill_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_loss: str = \"#F44336\"\n\n    # Line options\n    line_width: int = 2\n    line_style: str = \"dashed\"\n    line_color_profit: str = \"#4CAF50\"\n    line_color_loss: str = \"#F44336\"\n\n    # Arrow options\n    arrow_size: int = 10\n    arrow_color_profit: str = \"#4CAF50\"\n    arrow_color_loss: str = \"#F44336\"\n\n    # Zone options\n    zone_opacity: float = 0.1\n    zone_color_long: str = \"#2196F3\"\n    zone_color_short: str = \"#FF9800\"\n    zone_extend_bars: int = 2  # Extend zone by this many bars\n\n    # Annotation options\n    show_trade_id: bool = False\n    show_quantity: bool = True\n    show_trade_type: bool = True\n    annotation_font_size: int = 12\n    annotation_background: str = \"rgba(255, 255, 255, 0.8)\"\n\n    # Rectangle text options\n    rectangle_show_text: bool = False\n    rectangle_text_position: str = \"inside\"  # inside, above, below\n    rectangle_text_font_size: int = 10\n    rectangle_text_color: str = \"#FFFFFF\"\n    rectangle_text_background: str = \"rgba(0, 0, 0, 0.7)\"\n\n    # Template options\n    tooltip_template: str = \"\"  # Custom HTML template for tooltips\n    marker_template: str = \"\"  # Deprecated - use entry/exit templates\n    entry_marker_template: str = \"\"  # Custom HTML template for entry markers\n    exit_marker_template: str = \"\"  # Custom HTML template for exit markers\n\n    # Marker shape and position options\n    entry_marker_shape: str = \"arrowUp\"  # arrowUp, arrowDown, circle, square\n    exit_marker_shape: str = \"arrowDown\"  # arrowUp, arrowDown, circle, square\n    entry_marker_position: str = \"belowBar\"  # belowBar, aboveBar\n    exit_marker_position: str = \"aboveBar\"  # belowBar, aboveBar\n    show_marker_text: bool = True  # Whether to show text on markers\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize options.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates all configuration values and sets defaults for invalid values.\n\n        Raises:\n            ValueError: If the style string cannot be converted to TradeVisualization enum.\n        \"\"\"\n        # Step 1: Convert style to enum if it's a string\n        # Allows users to pass \"rectangles\" instead of TradeVisualization.RECTANGLES\n        if isinstance(self.style, str):\n            self.style = TradeVisualization(self.style.lower())\n\n        # Step 2: Validate rectangle text position\n        # Ensures only valid positions are used (inside, above, below)\n        valid_positions = [\"inside\", \"above\", \"below\"]\n        if self.rectangle_text_position.lower() not in valid_positions:\n            # Default to \"inside\" if invalid position provided\n            self.rectangle_text_position = \"inside\"\n\n        # Step 3: Validate marker shapes\n        # Ensures only TradingView-supported shapes are used\n        valid_shapes = [\"arrowUp\", \"arrowDown\", \"circle\", \"square\"]\n        if self.entry_marker_shape not in valid_shapes:\n            # Default to arrowUp for entry if invalid shape provided\n            self.entry_marker_shape = \"arrowUp\"\n        if self.exit_marker_shape not in valid_shapes:\n            # Default to arrowDown for exit if invalid shape provided\n            self.exit_marker_shape = \"arrowDown\"\n\n        # Step 4: Validate marker positions\n        # Ensures only valid positions are used (belowBar, aboveBar)\n        valid_marker_positions = [\"belowBar\", \"aboveBar\"]\n        if self.entry_marker_position not in valid_marker_positions:\n            # Default to belowBar for entry (typical for long trades)\n            self.entry_marker_position = \"belowBar\"\n        if self.exit_marker_position not in valid_marker_positions:\n            # Default to aboveBar for exit (typical for long trades)\n            self.exit_marker_position = \"aboveBar\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html","title":"streamlit_lightweight_charts_pro.charts.options.ui_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options","title":"ui_options","text":"<p>UI option classes for streamlit-lightweight-charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.TimeRange","title":"TimeRange","text":"<p>Time range constants in seconds for range switcher.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>class TimeRange(Enum):\n    \"\"\"Time range constants in seconds for range switcher.\"\"\"\n\n    FIVE_MINUTES = 300\n    FIFTEEN_MINUTES = 900\n    ONE_HOUR = 3600\n    FOUR_HOURS = 14400\n    ONE_DAY = 86400\n    ONE_WEEK = 604800\n    ONE_MONTH = 2592000\n    THREE_MONTHS = 7776000\n    SIX_MONTHS = 15552000\n    ONE_YEAR = 31536000\n    FIVE_YEARS = 157680000\n    ALL = None  # Special value for \"all data\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig","title":"RangeConfig  <code>dataclass</code>","text":"<p>Range configuration for range switcher.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"text\", str)\n@chainable_field(\"tooltip\", str)\n@chainable_field(\"range\", TimeRange)\nclass RangeConfig(Options):\n    \"\"\"Range configuration for range switcher.\"\"\"\n\n    text: str = \"\"\n    tooltip: str = \"\"\n    range: TimeRange = TimeRange.ONE_DAY\n\n    @property\n    def seconds(self) -&gt; int | None:\n        \"\"\"Get the time range in seconds.\"\"\"\n        return self.range.value if self.range else None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: int | None\n</code></pre> <p>Get the time range in seconds.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeSwitcherOptions","title":"RangeSwitcherOptions  <code>dataclass</code>","text":"<p>Range switcher configuration.</p> <p>Range switcher supports only corner positions: top-left, top-right, bottom-left, bottom-right. Center positions are not supported.</p> <p>Range buttons are automatically hidden when they exceed the available data timespan, providing a better user experience.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"ranges\", list)\n@chainable_field(\"position\", str)\nclass RangeSwitcherOptions(Options):\n    \"\"\"Range switcher configuration.\n\n    Range switcher supports only corner positions: top-left, top-right,\n    bottom-left, bottom-right. Center positions are not supported.\n\n    Range buttons are automatically hidden when they exceed the available\n    data timespan, providing a better user experience.\n    \"\"\"\n\n    visible: bool = True\n    ranges: List[RangeConfig] = field(default_factory=list)\n    position: Literal[\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"] = \"bottom-right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.LegendOptions","title":"LegendOptions  <code>dataclass</code>","text":"<p>Legend configuration with support for custom HTML templates and dynamic value display.</p> <p>The text supports a single placeholder that will be replaced by the frontend: - \\(\\(value\\)\\): Current value of the series at crosshair position</p> <p>Note: Title and color should be handled directly in your HTML template using the series title and color from your series configuration. This avoids conflicts with Python's f-string syntax and other templating systems.</p> <p>Dynamic Value Display: When show_values=True, the legend will automatically display current values at the crosshair position without needing to specify a custom template.</p> <p>Example templates: - \"MA20: \\(\\(value\\)\\)\" - \"PriceValue: \\(\\(value\\)\\)\" - \"RSI: \\(\\(value\\)\\)\"</p> <p>Example with dynamic values: LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"position\", str)\n@chainable_field(\"symbol_name\", str)\n@chainable_field(\"background_color\", str)\n@chainable_field(\"border_color\", str)\n@chainable_field(\"border_width\", int)\n@chainable_field(\"border_radius\", int)\n@chainable_field(\"padding\", int)\n@chainable_field(\"margin\", int)\n@chainable_field(\"z_index\", int)\n@chainable_field(\"price_format\", str)\n@chainable_field(\"text\", str)\n@chainable_field(\"show_values\", bool)\n@chainable_field(\"value_format\", str)\n@chainable_field(\"update_on_crosshair\", bool)\nclass LegendOptions(Options):\n    \"\"\"Legend configuration with support for custom HTML templates and dynamic value display.\n\n    The text supports a single placeholder that will be replaced by the frontend:\n    - $$value$$: Current value of the series at crosshair position\n\n    Note: Title and color should be handled directly in your HTML template using\n    the series title and color from your series configuration. This avoids\n    conflicts with Python's f-string syntax and other templating systems.\n\n    Dynamic Value Display:\n    When show_values=True, the legend will automatically display current values\n    at the crosshair position without needing to specify a custom template.\n\n    Example templates:\n    - \"&lt;span style='color: #2196f3'&gt;MA20: $$value$$&lt;/span&gt;\"\n    - \"&lt;div&gt;&lt;strong&gt;Price&lt;/strong&gt;&lt;br/&gt;Value: $$value$$&lt;/div&gt;\"\n    - \"&lt;span class='legend-item'&gt;RSI: $$value$$&lt;/span&gt;\"\n\n    Example with dynamic values:\n    LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)\n    \"\"\"\n\n    visible: bool = True\n    position: str = \"top-left\"\n    symbol_name: str = \"\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    margin: int = 0  # No margin - spacing handled by layout manager\n    z_index: int = 1000\n    price_format: str = \".2f\"\n    text: str = \"\"\n    show_values: bool = True\n    value_format: str = \".2f\"\n    update_on_crosshair: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html","title":"streamlit_lightweight_charts_pro.charts.series","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series","title":"series","text":"<p>Series module for Streamlit Lightweight Charts Pro.</p> <p>This module provides all series classes for creating different types of chart visualizations. Each series type represents a specific way of displaying data on charts, with its own styling options and data requirements.</p> The module includes <ul> <li>Series: Base abstract class for all series types</li> <li>LineSeries: Simple line charts connecting data points</li> <li>AreaSeries: Filled area charts below lines</li> <li>CandlestickSeries: Japanese candlestick charts for OHLC data</li> <li>BarSeries: OHLC bar charts for price data</li> <li>HistogramSeries: Bar charts for volume or distribution data</li> <li>BaselineSeries: Charts relative to a baseline value</li> <li>BandSeries: Multiple lines with fill areas (e.g., Bollinger Bands)</li> <li>SignalSeries: Background coloring based on signal values</li> </ul> Each series type supports <ul> <li>Custom styling (colors, line styles, markers)</li> <li>Data validation and type safety</li> <li>Method chaining for fluent API</li> <li>Integration with chart options</li> <li>Automatic data serialization</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries,\n    AreaSeries,\n    CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData, CandlestickData\n\n# Create line series\nline_data = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\nline_series = LineSeries(line_data, color=\"#ff0000\", line_width=2)\n\n# Create candlestick series\ncandlestick_data = [CandlestickData(\"2024-01-01\", 100, 105, 98, 102, 1000)]\ncandlestick_series = CandlestickSeries(candlestick_data)\n\n# Add to chart\nchart = Chart().add_series(line_series).add_series(candlestick_series)\n</code></pre> Available Series Types <ul> <li>LineSeries: Simple line charts for continuous data</li> <li>AreaSeries: Filled area charts for trend visualization</li> <li>CandlestickSeries: Traditional Japanese candlesticks for price data</li> <li>BarSeries: OHLC bars for price data with volume</li> <li>HistogramSeries: Volume or distribution visualization</li> <li>BaselineSeries: Values relative to a baseline reference</li> <li>BandSeries: Multiple lines with fill areas for technical analysis</li> <li>RibbonSeries: Upper and lower bands with fill areas</li> <li>SignalSeries: Background coloring for signal-based analysis</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.AreaSeries","title":"AreaSeries","text":"<p>Area series for creating filled area charts in financial visualization.</p> <p>This class represents an area series that displays continuous data points with filled areas under the line. It's commonly used for price charts, technical indicators, and trend analysis where the area under the curve provides visual emphasis and context.</p> <p>The AreaSeries supports various styling options including area colors, line styling via LineOptions, and gradient effects for enhanced visual appeal and data interpretation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[AreaData], DataFrame, Series]</code> <p>Data points for the area series. Can be a list of AreaData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <code>LineOptions</code> <p>LineOptions instance for line styling. Provides comprehensive line customization including color, width, style, and animation effects.</p> <code>top_color</code> <code>str</code> <p>Color of the top part of the area fill. Defaults to \"#2196F3\" (blue). Can be hex or rgba format.</p> <code>bottom_color</code> <code>str</code> <p>Color of the bottom part of the area fill. Defaults to \"rgba(33, 150, 243, 0.0)\" (transparent blue).</p> <code>relative_gradient</code> <code>bool</code> <p>Whether gradient is relative to base value. Defaults to False for absolute gradient positioning.</p> <code>invert_filled_area</code> <code>bool</code> <p>Whether to invert the filled area direction. Defaults to False for normal area filling.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (AreaData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data with line colors\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with gradient styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n\n# Configure line options\nseries.line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre> See also <p>Series: Base class providing common series functionality. LineOptions: Configuration class for line styling options. AreaData: Data class for area chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/area.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"top_color\", str, validator=\"color\")\n@chainable_property(\"bottom_color\", str, validator=\"color\")\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"invert_filled_area\", bool)\nclass AreaSeries(Series):\n    \"\"\"Area series for creating filled area charts in financial visualization.\n\n    This class represents an area series that displays continuous data points\n    with filled areas under the line. It's commonly used for price charts,\n    technical indicators, and trend analysis where the area under the curve\n    provides visual emphasis and context.\n\n    The AreaSeries supports various styling options including area colors,\n    line styling via LineOptions, and gradient effects for enhanced\n    visual appeal and data interpretation.\n\n    Attributes:\n        data (Union[List[AreaData], pd.DataFrame, pd.Series]): Data points for\n            the area series. Can be a list of AreaData objects, a pandas\n            DataFrame, or a pandas Series.\n        line_options (LineOptions): LineOptions instance for line styling.\n            Provides comprehensive line customization including color, width,\n            style, and animation effects.\n        top_color (str): Color of the top part of the area fill. Defaults to\n            \"#2196F3\" (blue). Can be hex or rgba format.\n        bottom_color (str): Color of the bottom part of the area fill. Defaults\n            to \"rgba(33, 150, 243, 0.0)\" (transparent blue).\n        relative_gradient (bool): Whether gradient is relative to base value.\n            Defaults to False for absolute gradient positioning.\n        invert_filled_area (bool): Whether to invert the filled area direction.\n            Defaults to False for normal area filling.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (AreaData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import AreaSeries\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data with line colors\n        data = [\n            AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n        ]\n\n        # Create area series with gradient styling\n        series = AreaSeries(\n            data=data,\n            top_color=\"rgba(33, 150, 243, 0.4)\",\n            bottom_color=\"rgba(33, 150, 243, 0.0)\",\n            relative_gradient=False,\n            invert_filled_area=False,\n        )\n\n        # Configure line options\n        series.line_options.set_color(\"#2196F3\").set_width(2)\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        LineOptions: Configuration class for line styling options.\n        AreaData: Data class for area chart data points.\n    \"\"\"\n\n    DATA_CLASS = AreaData\n\n    def __init__(\n        self,\n        data: Union[List[AreaData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize AreaSeries with data and configuration options.\n\n        Creates a new area series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes area-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[AreaData], pd.DataFrame, pd.Series]): Area data as a list\n                of AreaData objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of AreaData objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of AreaData or its subclasses.\n\n        Example:\n            ```python\n            # Basic area series with list of data objects\n            data = [AreaData(\"2024-01-01\", 100)]\n            series = AreaSeries(data=data)\n\n            # Area series with DataFrame\n            series = AreaSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Area series with custom configuration\n            series = AreaSeries(data=data, visible=True, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize area-specific properties with default values\n        self._line_options = LineOptions()  # Line styling configuration\n        self._top_color = COLOR_BLUE_MATERIAL  # Top area color (blue)\n        self._bottom_color = AREA_BOTTOM_COLOR_DEFAULT  # Bottom area color (transparent)\n        self._relative_gradient = False  # Absolute gradient positioning\n        self._invert_filled_area = False  # Normal area filling direction\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as an area chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The area chart type identifier.\n\n        Example:\n            ```python\n            series = AreaSeries(data=data)\n            chart_type = series.chart_type  # ChartType.AREA\n            ```\n        \"\"\"\n        return ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.AreaSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.AreaSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as an area chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The area chart type identifier.</p> Example <pre><code>series = AreaSeries(data=data)\nchart_type = series.chart_type  # ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BandSeries","title":"BandSeries","text":"<p>Band series for lightweight charts (e.g., Bollinger Bands).</p> <p>This class represents a band series that displays upper, middle, and lower bands. It's commonly used for technical indicators like Bollinger Bands, Keltner Channels, and other envelope indicators.</p> <p>The BandSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>middle_line</code> <p>LineOptions instance for middle band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>upper_fill_color</code> <p>Fill color for upper band area.</p> <code>lower_fill_color</code> <p>Fill color for lower band area.</p> <code>upper_fill</code> <p>Whether to display the upper fill area.</p> <code>lower_fill</code> <p>Whether to display the lower fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/band.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"middle_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"upper_fill_color\", str, validator=\"color\")\n@chainable_property(\"lower_fill_color\", str, validator=\"color\")\n@chainable_property(\"upper_fill\", bool)\n@chainable_property(\"lower_fill\", bool)\nclass BandSeries(Series):\n    \"\"\"Band series for lightweight charts (e.g., Bollinger Bands).\n\n    This class represents a band series that displays upper, middle, and lower bands.\n    It's commonly used for technical indicators like Bollinger Bands, Keltner Channels,\n    and other envelope indicators.\n\n    The BandSeries supports various styling options including separate line styling\n    for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        middle_line: LineOptions instance for middle band styling.\n        lower_line: LineOptions instance for lower band styling.\n        upper_fill_color: Fill color for upper band area.\n        lower_fill_color: Fill color for lower band area.\n        upper_fill: Whether to display the upper fill area.\n        lower_fill: Whether to display the lower fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BandData\n\n    def __init__(\n        self,\n        data: Union[List[BandData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize BandSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._middle_line = create_middle_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill colors\n        self._upper_fill_color = BAND_UPPER_FILL_COLOR\n        self._lower_fill_color = BAND_LOWER_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._upper_fill = True\n        self._lower_fill = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAND\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BandSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BandSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BarSeries","title":"BarSeries","text":"<p>Bar series for lightweight charts.</p> <p>This class represents a bar series that displays data as bars. It's commonly used for price charts, volume overlays, and other bar-based visualizations.</p> <p>The BarSeries supports various styling options including bar colors, base value, and animation effects.</p> <p>Attributes:</p> Name Type Description <code>color</code> <p>Color of the bars (set via property).</p> <code>base</code> <p>Base value for the bars (set via property).</p> <code>up_color</code> <p>Color for up bars (set via property).</p> <code>down_color</code> <p>Color for down bars (set via property).</p> <code>open_visible</code> <p>Whether open values are visible (set via property).</p> <code>thin_bars</code> <p>Whether to use thin bars (set via property).</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/bar_series.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"open_visible\", bool)\n@chainable_property(\"thin_bars\", bool)\nclass BarSeries(Series):\n    \"\"\"Bar series for lightweight charts.\n\n    This class represents a bar series that displays data as bars.\n    It's commonly used for price charts, volume overlays, and other\n    bar-based visualizations.\n\n    The BarSeries supports various styling options including bar colors,\n    base value, and animation effects.\n\n    Attributes:\n        color: Color of the bars (set via property).\n        base: Base value for the bars (set via property).\n        up_color: Color for up bars (set via property).\n        down_color: Color for down bars (set via property).\n        open_visible: Whether open values are visible (set via property).\n        thin_bars: Whether to use thin bars (set via property).\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BarData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAR\n\n    def __init__(\n        self,\n        data: Union[List[BarData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize properties with default values\n        self._up_color = \"#26a69a\"\n        self._down_color = \"#ef5350\"\n        self._open_visible = True\n        self._thin_bars = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BarSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BarSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series","title":"Series","text":"<p>Abstract base class for all series types in financial chart visualization.</p> <p>This class defines the common interface and functionality that all series classes must implement. It provides core data handling, configuration methods, and frontend integration capabilities with comprehensive support for pandas DataFrame integration, markers, price lines, and formatting.</p> <p>All series classes should inherit from this base class and implement the required abstract methods. The class supports method chaining for fluent API usage and provides extensive customization options.</p> Key Features <ul> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line management for annotations</li> <li>Price scale and pane configuration for multi-pane charts</li> <li>Visibility and formatting controls for UI customization</li> <li>Comprehensive data validation and error handling</li> <li>Method chaining support for fluent API design</li> <li>Frontend serialization for React component integration</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for this series. Can be a list of Data objects, pandas DataFrame, or pandas Series.</p> <code>title</code> <code>Optional[str]</code> <p>Technical title displayed on axis/legend. Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").</p> <code>display_name</code> <code>Optional[str]</code> <p>User-friendly name for UI elements. Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").</p> <code>visible</code> <code>bool</code> <p>Whether the series is currently visible on the chart.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Common values are \"left\", \"right\", or custom scale IDs.</p> <code>price_format</code> <code>PriceFormatOptions</code> <p>Price formatting configuration for display.</p> <code>price_lines</code> <code>List[PriceLineOptions]</code> <p>List of price lines for horizontal markers.</p> <code>markers</code> <code>List[MarkerBase]</code> <p>List of markers to display on this series.</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to for multi-pane charts.</p> <code>z_index</code> <code>int</code> <p>Z-index for controlling series rendering order.</p> Class Attributes <p>DATA_CLASS (Type[Data]): The data class type used for this series.     Must be defined by subclasses for DataFrame conversion to work.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create series with list of data objects\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = LineSeries(data=data)\n\n# Add markers and price lines\nseries.add_marker(bar_marker).add_price_line(price_line)\n\n# Configure series properties\nseries.set_visible(True).set_price_scale_id(\"right\")\n</code></pre> Note <p>Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work. The data_class property will always pick the most-derived DATA_CLASS in the MRO.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@chainable_property(\"title\", top_level=True)\n@chainable_property(\"display_name\", top_level=True)\n@chainable_property(\"visible\", top_level=True)\n@chainable_property(\"z_index\", allow_none=True, top_level=True)\n@chainable_property(\"price_scale_id\", top_level=True)\n@chainable_property(\"price_scale\", allow_none=True, top_level=True)\n@chainable_property(\"price_format\")\n@chainable_property(\"price_lines\", top_level=True)\n@chainable_property(\"markers\", List[MarkerBase], allow_none=True, top_level=True)\n@chainable_property(\"pane_id\", top_level=True)\n@chainable_property(\"last_value_visible\", top_level=True)\n@chainable_property(\"price_line_visible\", top_level=True)\n@chainable_property(\"price_line_source\", top_level=True)\n@chainable_property(\"price_line_width\", top_level=True)\n@chainable_property(\"price_line_color\", top_level=True)\n@chainable_property(\"price_line_style\", top_level=True)\n@chainable_property(\"tooltip\", allow_none=True, top_level=True)\n@chainable_property(\"legend\", allow_none=True, top_level=True)\nclass Series(ABC):  # noqa: B024\n    \"\"\"Abstract base class for all series types in financial chart visualization.\n\n    This class defines the common interface and functionality that all series\n    classes must implement. It provides core data handling, configuration\n    methods, and frontend integration capabilities with comprehensive support\n    for pandas DataFrame integration, markers, price lines, and formatting.\n\n    All series classes should inherit from this base class and implement\n    the required abstract methods. The class supports method chaining for\n    fluent API usage and provides extensive customization options.\n\n    Key Features:\n        - DataFrame integration with automatic column mapping\n        - Marker and price line management for annotations\n        - Price scale and pane configuration for multi-pane charts\n        - Visibility and formatting controls for UI customization\n        - Comprehensive data validation and error handling\n        - Method chaining support for fluent API design\n        - Frontend serialization for React component integration\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for this series.\n            Can be a list of Data objects, pandas DataFrame, or pandas Series.\n        title (Optional[str]): Technical title displayed on axis/legend.\n            Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").\n        display_name (Optional[str]): User-friendly name for UI elements.\n            Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").\n        visible (bool): Whether the series is currently visible on the chart.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Common values are \"left\", \"right\", or custom scale IDs.\n        price_format (PriceFormatOptions): Price formatting configuration for display.\n        price_lines (List[PriceLineOptions]): List of price lines for horizontal markers.\n        markers (List[MarkerBase]): List of markers to display on this series.\n        pane_id (Optional[int]): The pane index this series belongs to for multi-pane charts.\n        z_index (int): Z-index for controlling series rendering order.\n\n    Class Attributes:\n        DATA_CLASS (Type[Data]): The data class type used for this series.\n            Must be defined by subclasses for DataFrame conversion to work.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create series with list of data objects\n        data = [SingleValueData(\"2024-01-01\", 100)]\n        series = LineSeries(data=data)\n\n        # Add markers and price lines\n        series.add_marker(bar_marker).add_price_line(price_line)\n\n        # Configure series properties\n        series.set_visible(True).set_price_scale_id(\"right\")\n        ```\n\n    Note:\n        Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work.\n        The data_class property will always pick the most-derived DATA_CLASS in the MRO.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a series with data and configuration.\n\n        Creates a new series instance with the provided data and configuration options.\n        The constructor supports multiple data input types including lists of Data\n        objects, pandas DataFrames, and pandas Series with automatic validation\n        and conversion.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Series data as a list\n                of data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic series with list of data objects\n            series = LineSeries(data=line_data)\n\n            # Series with DataFrame\n            series = LineSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Series with Series\n             series = LineSeries(\n                 data=series_data,\n                 column_mapping={\"time\": \"index\", \"value\": \"values\"}\n             )\n\n            # Series with custom configuration\n            series = LineSeries(data=line_data, visible=False, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Validate and process data input based on type\n        if data is None:\n            # Handle None input by creating empty data list\n            self.data = []\n        elif isinstance(data, (pd.DataFrame, pd.Series)):\n            # DataFrame/Series input requires column mapping for conversion\n            if column_mapping is None:\n                raise ColumnMappingRequiredError()\n            # Process DataFrame/Series using from_dataframe logic\n            self.data = self._process_dataframe_input(data, column_mapping)\n        elif isinstance(data, list):\n            # Validate that all items in list are Data instances\n            if data and not all(isinstance(item, Data) for item in data):\n                raise DataItemsTypeError()\n            self.data = data\n        else:\n            # Raise error for unsupported data types\n            raise DataFrameValidationError.invalid_data_type(type(data))\n\n        # Initialize series configuration properties with default values\n        self._title = None  # Optional series title for legends and tooltips\n        self._display_name = None  # User-friendly name for UI elements\n        self._visible = visible  # Series visibility flag\n        self._price_scale_id = price_scale_id  # Price scale attachment ID\n        self._price_scale = None  # Price scale configuration object\n        self._price_format = None  # Price formatting options\n        self._price_lines: List[PriceLineOptions] = []  # List of price line markers\n        self._markers: List[MarkerBase] = []  # List of chart markers for annotations\n        self._pane_id = pane_id  # Pane index for multi-pane charts\n        self._column_mapping = column_mapping  # DataFrame column mapping\n\n        # Initialize price line display properties\n        self._last_value_visible = True  # Show last value on price scale\n        self._price_line_visible = True  # Show price line by default\n        self._price_line_source = PriceLineSource.LAST_BAR  # Price line data source\n        self._price_line_width = 1  # Price line width in pixels\n        self._price_line_color = \"\"  # Price line color (empty for default)\n        self._price_line_style = LineStyle.DASHED  # Price line style\n\n        # Initialize optional UI components\n        self._tooltip = None  # Custom tooltip configuration\n        self._z_index = 100  # Z-index for rendering order\n        self._legend = None  # Legend configuration\n\n    @staticmethod\n    def prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n        \"\"\"Prepare index for column mapping.\n\n        Handles all index-related column mapping cases:\n        - Time column mapping with DatetimeIndex\n        - Level position mapping (e.g., \"0\", \"1\")\n        - \"index\" mapping (first unnamed level or level 0)\n        - Named level mapping (e.g., \"date\", \"symbol\")\n        - Single index reset for non-time columns\n\n        Args:\n            data_frame: DataFrame to prepare\n            column_mapping: Mapping of required fields to column names\n\n        Returns:\n            DataFrame with prepared index\n\n        Raises:\n            ValueError: If time column is not found and no DatetimeIndex is available\n        \"\"\"\n        # Handle time column mapping first (special case for DatetimeIndex)\n        if \"time\" in column_mapping:\n            time_col = column_mapping[\"time\"]\n            if time_col not in data_frame.columns:\n                # Handle single DatetimeIndex\n                if isinstance(data_frame.index, pd.DatetimeIndex):\n                    if data_frame.index.name is None:\n                        # Set name and reset index to make it a regular column\n                        data_frame.index.name = time_col\n                        data_frame = data_frame.reset_index()\n                    elif data_frame.index.name == time_col:\n                        # Index name already matches, just reset to make it a regular column\n                        data_frame = data_frame.reset_index()\n\n                # Handle MultiIndex with DatetimeIndex level\n                elif isinstance(data_frame.index, pd.MultiIndex):\n                    for i, level in enumerate(data_frame.index.levels):\n                        if isinstance(level, pd.DatetimeIndex):\n                            if data_frame.index.names[i] is None:\n                                # Set name for this level and reset it\n                                new_names = list(data_frame.index.names)\n                                new_names[i] = time_col\n                                data_frame.index.names = new_names\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                            if data_frame.index.names[i] == time_col:\n                                # Level name already matches, reset this level\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                    else:\n                        # No DatetimeIndex level found, check if any level name matches\n                        if time_col in data_frame.index.names or time_col == \"index\":\n                            # Reset the entire MultiIndex to get all levels as columns\n                            data_frame = data_frame.reset_index()\n                        else:\n                            # Check if time_col is an integer level position\n                            try:\n                                level_idx = int(time_col)\n                                if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                    # Reset the entire MultiIndex to get all levels as columns\n                                    data_frame = data_frame.reset_index()\n                                else:\n                                    # Invalid level position, just pass through\n                                    pass\n                            except ValueError:\n                                # Not an integer, just pass through\n                                pass\n                # No DatetimeIndex found\n                # Check if time_col is \"index\" and we have a regular index to reset\n                elif time_col == \"index\":\n                    # Reset the index to make it a regular column\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[\"time\"] = new_col_name\n                elif time_col == data_frame.index.name:\n                    # Time column matches index name, reset the index\n                    data_frame = data_frame.reset_index()\n                else:\n                    raise NotFoundError(\"Time Column\", time_col)\n\n        # Handle other index columns\n        for field, col_name in column_mapping.items():\n            if field == \"time\":\n                continue  # Already handled above\n\n            if col_name not in data_frame.columns:\n                if isinstance(data_frame.index, pd.MultiIndex):\n                    level_names = list(data_frame.index.names)\n\n                    # Integer string or int: treat as level position\n                    try:\n                        level_idx = int(col_name)\n                        if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                            data_frame = data_frame.reset_index(level=level_idx)\n                            level_name = level_names[level_idx]\n                            # Update column mapping to use actual column name\n                            new_col_name = (\n                                level_name if level_name is not None else f\"level_{level_idx}\"\n                            )\n                            column_mapping[field] = new_col_name\n                            continue\n                    except (ValueError, IndexError):\n                        pass\n\n                    # 'index': use first unnamed level if any, else first level\n                    if col_name == \"index\":\n                        unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                        level_idx = unnamed_levels[0] if unnamed_levels else 0\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n\n                    # Named level\n                    if col_name in level_names:\n                        level_idx = level_names.index(col_name)\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        continue\n\n                # Single index\n                elif col_name in (\"index\", data_frame.index.name):\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[field] = new_col_name\n                    continue\n\n        return data_frame\n\n    def _process_dataframe_input(\n        self,\n        data: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n    ) -&gt; List[Data]:\n        \"\"\"Process DataFrame or Series input into a list of Data objects.\n\n        This method duplicates the logic from from_dataframe to handle\n        DataFrame/Series input in the constructor. It validates the input\n        data structure and converts it to the appropriate Data objects\n        based on the series type.\n\n        Args:\n            data (Union[pd.DataFrame, pd.Series]): DataFrame or Series to process.\n            column_mapping (Dict[str, str]): Mapping of required fields to column names.\n\n        Returns:\n            List[Data]: List of processed data objects suitable for the series type.\n\n        Raises:\n            ValueError: If required columns are missing from the DataFrame/Series.\n            ValueError: If the data structure is invalid for the series type.\n            ValueError: If time column is not found and no DatetimeIndex is available.\n\n        Note:\n            This method uses the data_class property to determine the appropriate\n            Data class for conversion.\n        \"\"\"\n        # Convert Series to DataFrame if needed (do this first)\n        if isinstance(data, pd.Series):\n            data = data.to_frame()\n\n        data_class = self.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check if all required columns are mapped\n        # Normalize keys to handle both snake_case and camelCase\n        def normalize_key(key):\n            \"\"\"Convert snake_case to camelCase for comparison.\"\"\"\n            if \"_\" in key:\n                parts = key.split(\"_\")\n                return parts[0] + \"\".join(part.capitalize() for part in parts[1:])\n            return key\n\n        # Create normalized versions of both sets for comparison\n        normalized_required = {normalize_key(key) for key in required}\n        normalized_mapping_keys = {normalize_key(key) for key in column_mapping}\n\n        missing_required = normalized_required - normalized_mapping_keys\n        if missing_required:\n            # Convert back to original format for error message\n            missing_original = {key for key in required if normalize_key(key) in missing_required}\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column mapping: {missing_original}\",\n            )\n\n        # Prepare index for all column mappings\n        data_frame = self.prepare_index(data, column_mapping)\n\n        # Check if all required columns are present in the DataFrame\n        mapped_columns = set(column_mapping.values())\n        available_columns = set(data_frame.columns.tolist())\n        missing_columns = mapped_columns - available_columns\n\n        if missing_columns:\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column: {missing_columns}\",\n            )\n\n        # Create data objects\n        result = []\n        for _, row in data_frame.iterrows():\n            kwargs = {}\n            # Process both required and optional columns\n            for key in required.union(optional):\n                # Find the corresponding column mapping key (handle both snake_case and camelCase)\n                mapped_key = None\n                for mapping_key in column_mapping:\n                    if normalize_key(mapping_key) == normalize_key(key):\n                        mapped_key = mapping_key\n                        break\n\n                if mapped_key:\n                    col_name = column_mapping[mapped_key]\n                    if col_name in data_frame.columns:\n                        value = row[col_name]\n                        kwargs[key] = value\n            data_obj = data_class(**kwargs)\n            result.append(data_obj)\n\n        return result\n\n    @property\n    def data_dict(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the data in dictionary format.\n\n        Converts the series data to a list of dictionaries suitable for\n        frontend serialization. Handles various data formats including\n        dictionaries, lists of dictionaries, or lists of objects with\n        asdict() methods.\n\n        Returns:\n            List[Dict[str, Any]]: List of data dictionaries ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            # Get data as dictionaries\n            data_dicts = series.data_dict\n\n            # Access individual data points\n            for data_point in data_dicts:\n                # Data point contains time and value information\n                pass\n            ```\n        \"\"\"\n        if isinstance(self.data, dict):\n            return self.data  # type: ignore[return-value]\n        if isinstance(self.data, list):\n            if len(self.data) == 0:\n                return []\n            # If already list of dicts\n            if isinstance(self.data[0], dict):\n                return self.data  # type: ignore[return-value]\n                # If list of objects with asdict\n        if hasattr(self.data[0], \"asdict\"):\n            return [item.asdict() for item in self.data]\n        # Fallback: return as-is\n        return self.data  # type: ignore[return-value]\n\n    def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n        \"\"\"Add a marker to this series.\n\n        Adds a marker object to the series for highlighting specific data points\n        or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n        Args:\n            marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If the marker position is not valid for its type.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n             from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                 MarkerPosition, MarkerShape\n             )\n\n            # Add a bar marker\n            bar_marker = BarMarker(\n                time=\"2024-01-01 10:00:00\",\n                position=MarkerPosition.ABOVE_BAR,\n                color=\"red\",\n                shape=MarkerShape.CIRCLE,\n                text=\"Buy Signal\",\n            )\n            series.add_marker(bar_marker)\n\n            # Add a price marker\n            price_marker = PriceMarker(\n                time=1640995200,\n                position=MarkerPosition.AT_PRICE_TOP,\n                color=\"#00ff00\",\n                shape=MarkerShape.ARROW_UP,\n                price=100.50,\n                text=\"Resistance Level\",\n            )\n            series.add_marker(price_marker)\n\n            # Method chaining\n            series.add_marker(marker1).add_marker(marker2)\n            ```\n        \"\"\"\n        # Validate the marker position\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.append(marker)\n        return self\n\n    def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n        \"\"\"Add multiple markers to this series.\n\n        Adds a list of markers to the series. Returns self for method chaining.\n\n        Args:\n            markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If any marker position is not valid for its type.\n        \"\"\"\n        # Validate all markers before adding\n        for marker in markers:\n            if not marker.validate_position():\n                raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.extend(markers)\n        return self\n\n    def clear_markers(self) -&gt; \"Series\":\n        \"\"\"Clear all markers from this series.\n\n        Removes all markers from the series. Returns self for method chaining.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._markers.clear()\n        return self\n\n    def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n        \"\"\"Add a price line option to this series.\n\n        Args:\n            price_line (PriceLineOptions): The price line option to add.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.append(price_line)\n        return self\n\n    def clear_price_lines(self) -&gt; \"Series\":\n        \"\"\"Remove all price line options from this series.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.clear()\n        return self\n\n    def _validate_pane_config(self) -&gt; None:\n        \"\"\"Validate pane configuration for the series.\n\n        This method ensures that pane_id is properly set.\n        It should be called by subclasses in their asdict() method.\n\n        Raises:\n            ValueError: If pane_id is negative.\n        \"\"\"\n        if self._pane_id is not None and self._pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n        if self._pane_id is None:\n            self._pane_id = 0\n\n    def _get_attr_name(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get the attribute name for a given key.\"\"\"\n        # Convert camelCase to snake_case for attribute lookup\n        attr_name: Optional[str] = self._camel_to_snake(key)\n\n        # Check if attribute exists (try multiple variations)\n        # Need to check attr_name is not None before using hasattr\n        if attr_name is not None and not hasattr(self, attr_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                attr_name = key\n            # Try with _ prefix (for private attributes)\n            elif hasattr(self, f\"_{attr_name}\"):\n                attr_name = f\"_{attr_name}\"\n            # Try original key with _ prefix\n            elif hasattr(self, f\"_{key}\"):\n                attr_name = f\"_{key}\"\n            else:\n                # Ignore invalid attributes instead of raising an error\n\n                attr_name = None\n\n        return attr_name\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n        \"\"\"Update series configuration with a dictionary of values.\n\n        This method updates series properties using a configuration dictionary. It supports\n        updating simple attributes, nested options objects, and lists of options. Keys may be\n        in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n        Args:\n            updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n                or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            AttributeError: If an attribute cannot be set due to type or value errors.\n\n        Example:\n            ```python\n            series = LineSeries(data=data)\n            series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n            series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n            series.update(\n                {\n                    \"price_lines\": [\n                        {\"price\": 105, \"color\": \"#00ff00\"},\n                        {\"price\": 110, \"color\": \"#ff0000\"},\n                    ]\n                }\n            )\n            series.update({\"visible\": True}).update({\"pane_id\": 1})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            attr_name = self._get_attr_name(key)\n\n            if attr_name is None:\n                continue\n\n            try:\n                if isinstance(value, dict):\n                    self._update_dict_value(attr_name, value)\n                elif isinstance(value, list):\n                    self._update_list_value(attr_name, value)\n                else:\n                    setattr(self, attr_name, value)\n            except Exception:\n                logger.exception(\"Failed to update attribute '%s'\", attr_name)\n                raise\n\n        return self\n\n    def _update_dict_value(self, attr_name: str, value: dict) -&gt; None:\n        \"\"\"Update a nested options object attribute with a dictionary.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (dict): Dictionary of values to update the nested object.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        if current_value is not None and hasattr(current_value, \"update\"):\n            current_value.update(value)\n            return\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            return\n\n        # Handle Union types (e.g., Optional[T])\n        if getattr(attr_type, \"__origin__\", None) is Union:\n            for arg in attr_type.__args__:\n                if arg is not type(None):\n                    attr_type = arg\n                    break\n\n        if hasattr(attr_type, \"update\"):\n            try:\n                instance = attr_type()\n                setattr(self, attr_name, instance)\n                instance.update(value)\n            except Exception:\n                logger.exception(\"Failed to instantiate or update %s\", attr_name)\n                raise\n        else:\n            # No update method for this attribute\n            pass\n\n    def _update_list_value(self, attr_name: str, value: list) -&gt; None:\n        \"\"\"Update a list attribute, instantiating and updating items as needed.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (list): List of values or dicts to update the list attribute.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            setattr(self, attr_name, value)\n            return\n\n        if getattr(attr_type, \"__origin__\", None) is list:\n            item_type = attr_type.__args__[0]\n\n            if not hasattr(item_type, \"update\"):\n                setattr(self, attr_name, value)\n                return\n\n            if current_value is None:\n                current_value = []\n                setattr(self, attr_name, current_value)\n\n            for _i, item in enumerate(value):\n                if isinstance(item, dict):\n                    try:\n                        instance = item_type()\n                        instance.update(item)\n                        current_value.append(instance)\n                    except Exception:\n                        logger.exception(\n                            \"Failed to instantiate or update list item for %s\",\n                            attr_name,\n                        )\n                        raise\n                else:\n                    current_value.append(item)\n        else:\n            setattr(self, attr_name, value)\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n        \"\"\"\n        import re  # pylint: disable=import-outside-toplevel\n\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert series to dictionary representation.\n\n        This method creates a dictionary representation of the series\n        that can be consumed by the frontend React component.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing series configuration for the frontend.\n        \"\"\"\n        # Validate pane configuration\n        self._validate_pane_config()\n\n        # Get base configuration\n        config = {\n            \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n            \"data\": self.data_dict,\n        }\n\n        # Add options from chainable properties only\n        options = {}\n        for attr_name in dir(self):\n            if attr_name.startswith(\"_\"):\n                continue\n            # Skip data attribute as it's handled separately\n            if attr_name == \"data\":\n                continue\n            # Skip class attributes (like DATA_CLASS)\n            if attr_name.isupper():\n                continue\n            # Skip class properties (like data_class)\n            if attr_name == \"data_class\":\n                continue\n\n            # Rule 1: Only include attributes decorated with chainable_property\n            if not self._is_chainable_property(attr_name):\n                continue\n\n            attr_value = getattr(self, attr_name)\n\n            # Rule 2: Skip if None and allow_none is True\n            if attr_value is None and self._is_allow_none(attr_name):\n                continue\n\n            # Determine if this should go to top level or options\n            is_top_level = self._is_top_level(attr_name)\n\n            # Handle objects with asdict() method\n            if (\n                hasattr(attr_value, \"asdict\")\n                and callable(attr_value.asdict)\n                and not isinstance(attr_value, type)\n            ):\n                # Rule 3: Flatten LineOptions with property name prefix for consistency\n                # This ensures all LineOptions are serialized the same way:\n                # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n                # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n                from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n                if isinstance(attr_value, LineOptions):\n                    line_dict = attr_value.asdict()\n                    # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                    if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                        # Send lineOptions nested - let frontend handle flattening via descriptors\n                        # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                        # based on the series type's descriptor apiMapping\n                        options[\"lineOptions\"] = line_dict\n                    else:\n                        # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                        # Convert the property name to camelCase for the prefix\n                        prefix = snake_to_camel(attr_name)\n                        for line_key, line_value in line_dict.items():\n                            # Capitalize first letter of line property and append to prefix\n                            # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                            # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                            if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                                # Remove 'line' prefix from the key before appending\n                                # lineWidth -&gt; Width, lineStyle -&gt; Style\n                                key_without_line_prefix = line_key[4:]  # Remove 'line'\n                                flattened_key = prefix + key_without_line_prefix\n                            else:\n                                # Normal case: capitalize first letter and append\n                                # e.g., upperLine + color -&gt; upperLineColor\n                                flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                            if is_top_level:\n                                config[flattened_key] = line_value\n                            else:\n                                options[flattened_key] = line_value\n                elif attr_name.endswith(\"_options\"):\n                    # Other options objects (not LineOptions) - flatten without prefix\n                    options.update(attr_value.asdict())\n                else:\n                    # Other objects with asdict() - keep nested\n                    key = snake_to_camel(attr_name)\n                    if is_top_level:\n                        config[key] = attr_value.asdict()\n                    else:\n                        options[key] = attr_value.asdict()\n\n            # Handle lists of objects with asdict() method\n            elif (\n                isinstance(attr_value, list)\n                and attr_value\n                and hasattr(attr_value[0], \"asdict\")\n                and callable(attr_value[0].asdict)\n            ):\n                # Convert list of objects to list of dictionaries\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = [item.asdict() for item in attr_value]\n                else:\n                    options[key] = [item.asdict() for item in attr_value]\n\n            # Also include individual option attributes that are not None\n            elif (\n                not callable(attr_value)\n                and not isinstance(attr_value, type)\n                and attr_value is not None\n            ):\n                # Skip empty lists (they should not be included in configuration)\n                if isinstance(attr_value, list) and not attr_value:\n                    continue\n\n                # Convert snake_case to camelCase for the key\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    # Include empty strings for top-level properties (they are valid)\n                    config[key] = attr_value\n                # Skip empty strings for options (they are not meaningful)\n                elif attr_value != \"\":\n                    options[key] = attr_value\n\n        # Only include options field if it's not empty\n        if options:\n            config[\"options\"] = options\n\n        return config\n\n    def _is_chainable_property(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if an attribute is decorated with chainable_property.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute is a chainable property\n        \"\"\"\n        return (\n            hasattr(self.__class__, \"_chainable_properties\")\n            and attr_name in self.__class__._chainable_properties  # pylint: disable=protected-access\n        )\n\n    def _is_allow_none(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property allows None values.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the property allows None values\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"allow_none\"]  # type: ignore[attr-defined]\n        return False\n\n    def _is_top_level(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property should be output at the top level.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute should be at the top level\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"top_level\"]  # type: ignore[attr-defined]\n        return False\n\n    @classproperty\n    def data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n        \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n        for base in self.__mro__:  # type: ignore[attr-defined]\n            if hasattr(base, \"DATA_CLASS\"):\n                return base.DATA_CLASS\n        raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n\n    @classmethod\n    def from_dataframe(\n        cls,\n        df: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n        price_scale_id: str = \"\",\n        **kwargs,\n    ) -&gt; \"Series\":\n        \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n        Args:\n            df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n            column_mapping (dict): Mapping of required fields\n                (e.g., {'time': 'datetime', 'value': 'close', ...}).\n            price_scale_id (str): Price scale ID (default '').\n            **kwargs: Additional arguments for the Series constructor.\n\n        Returns:\n            Series: An instance of the Series (or subclass) with normalized data.\n\n        Raises:\n            NotImplementedError: If the subclass does not define DATA_CLASS.\n            ValueError: If required columns are missing in column_mapping or DataFrame.\n            AttributeError: If the data class does not define REQUIRED_COLUMNS.\n        \"\"\"\n        # Convert Series to DataFrame if needed\n        dataframe = df\n        if isinstance(dataframe, pd.Series):\n            dataframe = dataframe.to_frame()\n\n        data_class = cls.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check required columns in column_mapping\n        missing_mapping = [col for col in required if col not in column_mapping]\n        if missing_mapping:\n            raise ValueValidationError(\n                \"column_mapping\",\n                f\"missing required columns: {missing_mapping}\",\n            )\n        # Removed print\n\n        # Prepare index for all column mappings\n        data_frame = cls.prepare_index(dataframe, column_mapping)\n\n        # Check required columns in DataFrame (including index) - after processing\n        for key in required:\n            col = column_mapping[key]\n            if col not in data_frame.columns:\n                raise NotFoundError(\"Column\", col)\n            # Removed print\n\n        # Build data objects\n        data = []\n        for i in range(len(dataframe)):\n            kwargs_data = {}\n            for key in required.union(optional):\n                if key in column_mapping:\n                    col = column_mapping[key]\n                    if col in data_frame.columns:\n                        value = data_frame.iloc[i][col]\n                        kwargs_data[key] = value\n                    else:\n                        raise NotFoundError(\"Column\", col)\n                else:\n                    # Skip optional columns that are not in column_mapping\n                    continue\n\n            data.append(data_class(**kwargs_data))\n\n        return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.data_dict","title":"data_dict  <code>property</code>","text":"<pre><code>data_dict: List[Dict[str, Any]]\n</code></pre> <p>Get the data in dictionary format.</p> <p>Converts the series data to a list of dictionaries suitable for frontend serialization. Handles various data formats including dictionaries, lists of dictionaries, or lists of objects with asdict() methods.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of data dictionaries ready for frontend consumption.</p> Example <pre><code># Get data as dictionaries\ndata_dicts = series.data_dict\n\n# Access individual data points\nfor data_point in data_dicts:\n    # Data point contains time and value information\n    pass\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.prepare_index","title":"prepare_index  <code>staticmethod</code>","text":"<pre><code>prepare_index(data_frame: DataFrame, column_mapping: Dict[str, str]) -&gt; DataFrame\n</code></pre> <p>Prepare index for column mapping.</p> <p>Handles all index-related column mapping cases: - Time column mapping with DatetimeIndex - Level position mapping (e.g., \"0\", \"1\") - \"index\" mapping (first unnamed level or level 0) - Named level mapping (e.g., \"date\", \"symbol\") - Single index reset for non-time columns</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>DataFrame to prepare</p> required <code>column_mapping</code> <code>Dict[str, str]</code> <p>Mapping of required fields to column names</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with prepared index</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time column is not found and no DatetimeIndex is available</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@staticmethod\ndef prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n    \"\"\"Prepare index for column mapping.\n\n    Handles all index-related column mapping cases:\n    - Time column mapping with DatetimeIndex\n    - Level position mapping (e.g., \"0\", \"1\")\n    - \"index\" mapping (first unnamed level or level 0)\n    - Named level mapping (e.g., \"date\", \"symbol\")\n    - Single index reset for non-time columns\n\n    Args:\n        data_frame: DataFrame to prepare\n        column_mapping: Mapping of required fields to column names\n\n    Returns:\n        DataFrame with prepared index\n\n    Raises:\n        ValueError: If time column is not found and no DatetimeIndex is available\n    \"\"\"\n    # Handle time column mapping first (special case for DatetimeIndex)\n    if \"time\" in column_mapping:\n        time_col = column_mapping[\"time\"]\n        if time_col not in data_frame.columns:\n            # Handle single DatetimeIndex\n            if isinstance(data_frame.index, pd.DatetimeIndex):\n                if data_frame.index.name is None:\n                    # Set name and reset index to make it a regular column\n                    data_frame.index.name = time_col\n                    data_frame = data_frame.reset_index()\n                elif data_frame.index.name == time_col:\n                    # Index name already matches, just reset to make it a regular column\n                    data_frame = data_frame.reset_index()\n\n            # Handle MultiIndex with DatetimeIndex level\n            elif isinstance(data_frame.index, pd.MultiIndex):\n                for i, level in enumerate(data_frame.index.levels):\n                    if isinstance(level, pd.DatetimeIndex):\n                        if data_frame.index.names[i] is None:\n                            # Set name for this level and reset it\n                            new_names = list(data_frame.index.names)\n                            new_names[i] = time_col\n                            data_frame.index.names = new_names\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                        if data_frame.index.names[i] == time_col:\n                            # Level name already matches, reset this level\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                else:\n                    # No DatetimeIndex level found, check if any level name matches\n                    if time_col in data_frame.index.names or time_col == \"index\":\n                        # Reset the entire MultiIndex to get all levels as columns\n                        data_frame = data_frame.reset_index()\n                    else:\n                        # Check if time_col is an integer level position\n                        try:\n                            level_idx = int(time_col)\n                            if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                # Reset the entire MultiIndex to get all levels as columns\n                                data_frame = data_frame.reset_index()\n                            else:\n                                # Invalid level position, just pass through\n                                pass\n                        except ValueError:\n                            # Not an integer, just pass through\n                            pass\n            # No DatetimeIndex found\n            # Check if time_col is \"index\" and we have a regular index to reset\n            elif time_col == \"index\":\n                # Reset the index to make it a regular column\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[\"time\"] = new_col_name\n            elif time_col == data_frame.index.name:\n                # Time column matches index name, reset the index\n                data_frame = data_frame.reset_index()\n            else:\n                raise NotFoundError(\"Time Column\", time_col)\n\n    # Handle other index columns\n    for field, col_name in column_mapping.items():\n        if field == \"time\":\n            continue  # Already handled above\n\n        if col_name not in data_frame.columns:\n            if isinstance(data_frame.index, pd.MultiIndex):\n                level_names = list(data_frame.index.names)\n\n                # Integer string or int: treat as level position\n                try:\n                    level_idx = int(col_name)\n                    if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        # Update column mapping to use actual column name\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n                except (ValueError, IndexError):\n                    pass\n\n                # 'index': use first unnamed level if any, else first level\n                if col_name == \"index\":\n                    unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                    level_idx = unnamed_levels[0] if unnamed_levels else 0\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    level_name = level_names[level_idx]\n                    new_col_name = (\n                        level_name if level_name is not None else f\"level_{level_idx}\"\n                    )\n                    column_mapping[field] = new_col_name\n                    continue\n\n                # Named level\n                if col_name in level_names:\n                    level_idx = level_names.index(col_name)\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    continue\n\n            # Single index\n            elif col_name in (\"index\", data_frame.index.name):\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[field] = new_col_name\n                continue\n\n    return data_frame\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.add_marker","title":"add_marker","text":"<pre><code>add_marker(marker: MarkerBase) -&gt; Series\n</code></pre> <p>Add a marker to this series.</p> <p>Adds a marker object to the series for highlighting specific data points or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>MarkerBase</code> <p>The marker object to add. Must be a BarMarker or PriceMarker.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker position is not valid for its type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n from streamlit_lightweight_charts_pro.type_definitions.enums import (\n     MarkerPosition, MarkerShape\n )\n\n# Add a bar marker\nbar_marker = BarMarker(\n    time=\"2024-01-01 10:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    color=\"red\",\n    shape=MarkerShape.CIRCLE,\n    text=\"Buy Signal\",\n)\nseries.add_marker(bar_marker)\n\n# Add a price marker\nprice_marker = PriceMarker(\n    time=1640995200,\n    position=MarkerPosition.AT_PRICE_TOP,\n    color=\"#00ff00\",\n    shape=MarkerShape.ARROW_UP,\n    price=100.50,\n    text=\"Resistance Level\",\n)\nseries.add_marker(price_marker)\n\n# Method chaining\nseries.add_marker(marker1).add_marker(marker2)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n    \"\"\"Add a marker to this series.\n\n    Adds a marker object to the series for highlighting specific data points\n    or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n    Args:\n        marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If the marker position is not valid for its type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n         from streamlit_lightweight_charts_pro.type_definitions.enums import (\n             MarkerPosition, MarkerShape\n         )\n\n        # Add a bar marker\n        bar_marker = BarMarker(\n            time=\"2024-01-01 10:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            color=\"red\",\n            shape=MarkerShape.CIRCLE,\n            text=\"Buy Signal\",\n        )\n        series.add_marker(bar_marker)\n\n        # Add a price marker\n        price_marker = PriceMarker(\n            time=1640995200,\n            position=MarkerPosition.AT_PRICE_TOP,\n            color=\"#00ff00\",\n            shape=MarkerShape.ARROW_UP,\n            price=100.50,\n            text=\"Resistance Level\",\n        )\n        series.add_marker(price_marker)\n\n        # Method chaining\n        series.add_marker(marker1).add_marker(marker2)\n        ```\n    \"\"\"\n    # Validate the marker position\n    if not marker.validate_position():\n        raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.append(marker)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.add_markers","title":"add_markers","text":"<pre><code>add_markers(markers: List[MarkerBase]) -&gt; Series\n</code></pre> <p>Add multiple markers to this series.</p> <p>Adds a list of markers to the series. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>List[MarkerBase]</code> <p>List of marker objects to add. Must be MarkerBase subclasses.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any marker position is not valid for its type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n    \"\"\"Add multiple markers to this series.\n\n    Adds a list of markers to the series. Returns self for method chaining.\n\n    Args:\n        markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If any marker position is not valid for its type.\n    \"\"\"\n    # Validate all markers before adding\n    for marker in markers:\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.extend(markers)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.clear_markers","title":"clear_markers","text":"<pre><code>clear_markers() -&gt; Series\n</code></pre> <p>Clear all markers from this series.</p> <p>Removes all markers from the series. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_markers(self) -&gt; \"Series\":\n    \"\"\"Clear all markers from this series.\n\n    Removes all markers from the series. Returns self for method chaining.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._markers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.add_price_line","title":"add_price_line","text":"<pre><code>add_price_line(price_line: PriceLineOptions) -&gt; Series\n</code></pre> <p>Add a price line option to this series.</p> <p>Parameters:</p> Name Type Description Default <code>price_line</code> <code>PriceLineOptions</code> <p>The price line option to add.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n    \"\"\"Add a price line option to this series.\n\n    Args:\n        price_line (PriceLineOptions): The price line option to add.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.append(price_line)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.clear_price_lines","title":"clear_price_lines","text":"<pre><code>clear_price_lines() -&gt; Series\n</code></pre> <p>Remove all price line options from this series.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_price_lines(self) -&gt; \"Series\":\n    \"\"\"Remove all price line options from this series.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Series\n</code></pre> <p>Update series configuration with a dictionary of values.</p> <p>This method updates series properties using a configuration dictionary. It supports updating simple attributes, nested options objects, and lists of options. Keys may be in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types, dictionaries for nested objects, or lists.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute cannot be set due to type or value errors.</p> Example <pre><code>series = LineSeries(data=data)\nseries.update({\"visible\": False, \"price_scale_id\": \"left\"})\nseries.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\nseries.update(\n    {\n        \"price_lines\": [\n            {\"price\": 105, \"color\": \"#00ff00\"},\n            {\"price\": 110, \"color\": \"#ff0000\"},\n        ]\n    }\n)\nseries.update({\"visible\": True}).update({\"pane_id\": 1})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n    \"\"\"Update series configuration with a dictionary of values.\n\n    This method updates series properties using a configuration dictionary. It supports\n    updating simple attributes, nested options objects, and lists of options. Keys may be\n    in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n    Args:\n        updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n            or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        AttributeError: If an attribute cannot be set due to type or value errors.\n\n    Example:\n        ```python\n        series = LineSeries(data=data)\n        series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n        series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n        series.update(\n            {\n                \"price_lines\": [\n                    {\"price\": 105, \"color\": \"#00ff00\"},\n                    {\"price\": 110, \"color\": \"#ff0000\"},\n                ]\n            }\n        )\n        series.update({\"visible\": True}).update({\"pane_id\": 1})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        attr_name = self._get_attr_name(key)\n\n        if attr_name is None:\n            continue\n\n        try:\n            if isinstance(value, dict):\n                self._update_dict_value(attr_name, value)\n            elif isinstance(value, list):\n                self._update_list_value(attr_name, value)\n            else:\n                setattr(self, attr_name, value)\n        except Exception:\n            logger.exception(\"Failed to update attribute '%s'\", attr_name)\n            raise\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert series to dictionary representation.</p> <p>This method creates a dictionary representation of the series that can be consumed by the frontend React component.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing series configuration for the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert series to dictionary representation.\n\n    This method creates a dictionary representation of the series\n    that can be consumed by the frontend React component.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing series configuration for the frontend.\n    \"\"\"\n    # Validate pane configuration\n    self._validate_pane_config()\n\n    # Get base configuration\n    config = {\n        \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n        \"data\": self.data_dict,\n    }\n\n    # Add options from chainable properties only\n    options = {}\n    for attr_name in dir(self):\n        if attr_name.startswith(\"_\"):\n            continue\n        # Skip data attribute as it's handled separately\n        if attr_name == \"data\":\n            continue\n        # Skip class attributes (like DATA_CLASS)\n        if attr_name.isupper():\n            continue\n        # Skip class properties (like data_class)\n        if attr_name == \"data_class\":\n            continue\n\n        # Rule 1: Only include attributes decorated with chainable_property\n        if not self._is_chainable_property(attr_name):\n            continue\n\n        attr_value = getattr(self, attr_name)\n\n        # Rule 2: Skip if None and allow_none is True\n        if attr_value is None and self._is_allow_none(attr_name):\n            continue\n\n        # Determine if this should go to top level or options\n        is_top_level = self._is_top_level(attr_name)\n\n        # Handle objects with asdict() method\n        if (\n            hasattr(attr_value, \"asdict\")\n            and callable(attr_value.asdict)\n            and not isinstance(attr_value, type)\n        ):\n            # Rule 3: Flatten LineOptions with property name prefix for consistency\n            # This ensures all LineOptions are serialized the same way:\n            # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n            # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n            from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n            if isinstance(attr_value, LineOptions):\n                line_dict = attr_value.asdict()\n                # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                    # Send lineOptions nested - let frontend handle flattening via descriptors\n                    # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                    # based on the series type's descriptor apiMapping\n                    options[\"lineOptions\"] = line_dict\n                else:\n                    # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                    # Convert the property name to camelCase for the prefix\n                    prefix = snake_to_camel(attr_name)\n                    for line_key, line_value in line_dict.items():\n                        # Capitalize first letter of line property and append to prefix\n                        # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                        # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                        if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                            # Remove 'line' prefix from the key before appending\n                            # lineWidth -&gt; Width, lineStyle -&gt; Style\n                            key_without_line_prefix = line_key[4:]  # Remove 'line'\n                            flattened_key = prefix + key_without_line_prefix\n                        else:\n                            # Normal case: capitalize first letter and append\n                            # e.g., upperLine + color -&gt; upperLineColor\n                            flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                        if is_top_level:\n                            config[flattened_key] = line_value\n                        else:\n                            options[flattened_key] = line_value\n            elif attr_name.endswith(\"_options\"):\n                # Other options objects (not LineOptions) - flatten without prefix\n                options.update(attr_value.asdict())\n            else:\n                # Other objects with asdict() - keep nested\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = attr_value.asdict()\n                else:\n                    options[key] = attr_value.asdict()\n\n        # Handle lists of objects with asdict() method\n        elif (\n            isinstance(attr_value, list)\n            and attr_value\n            and hasattr(attr_value[0], \"asdict\")\n            and callable(attr_value[0].asdict)\n        ):\n            # Convert list of objects to list of dictionaries\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                config[key] = [item.asdict() for item in attr_value]\n            else:\n                options[key] = [item.asdict() for item in attr_value]\n\n        # Also include individual option attributes that are not None\n        elif (\n            not callable(attr_value)\n            and not isinstance(attr_value, type)\n            and attr_value is not None\n        ):\n            # Skip empty lists (they should not be included in configuration)\n            if isinstance(attr_value, list) and not attr_value:\n                continue\n\n            # Convert snake_case to camelCase for the key\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                # Include empty strings for top-level properties (they are valid)\n                config[key] = attr_value\n            # Skip empty strings for options (they are not meaningful)\n            elif attr_value != \"\":\n                options[key] = attr_value\n\n    # Only include options field if it's not empty\n    if options:\n        config[\"options\"] = options\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.data_class","title":"data_class","text":"<pre><code>data_class() -&gt; Type[Data]\n</code></pre> <p>Return the first DATA_CLASS found in the MRO (most-derived class wins).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classproperty\ndef data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n    \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n    for base in self.__mro__:  # type: ignore[attr-defined]\n        if hasattr(base, \"DATA_CLASS\"):\n            return base.DATA_CLASS\n    raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.Series.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: Union[DataFrame, Series], column_mapping: Dict[str, str], price_scale_id: str = '', **kwargs) -&gt; Series\n</code></pre> <p>Create a Series instance from a pandas DataFrame or Series.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Union[DataFrame, Series]</code> <p>The input DataFrame or Series.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields (e.g., {'time': 'datetime', 'value': 'close', ...}).</p> required <code>price_scale_id</code> <code>str</code> <p>Price scale ID (default '').</p> <code>''</code> <code>**kwargs</code> <p>Additional arguments for the Series constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>An instance of the Series (or subclass) with normalized data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the subclass does not define DATA_CLASS.</p> <code>ValueError</code> <p>If required columns are missing in column_mapping or DataFrame.</p> <code>AttributeError</code> <p>If the data class does not define REQUIRED_COLUMNS.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classmethod\ndef from_dataframe(\n    cls,\n    df: Union[pd.DataFrame, pd.Series],\n    column_mapping: Dict[str, str],\n    price_scale_id: str = \"\",\n    **kwargs,\n) -&gt; \"Series\":\n    \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n    Args:\n        df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n        column_mapping (dict): Mapping of required fields\n            (e.g., {'time': 'datetime', 'value': 'close', ...}).\n        price_scale_id (str): Price scale ID (default '').\n        **kwargs: Additional arguments for the Series constructor.\n\n    Returns:\n        Series: An instance of the Series (or subclass) with normalized data.\n\n    Raises:\n        NotImplementedError: If the subclass does not define DATA_CLASS.\n        ValueError: If required columns are missing in column_mapping or DataFrame.\n        AttributeError: If the data class does not define REQUIRED_COLUMNS.\n    \"\"\"\n    # Convert Series to DataFrame if needed\n    dataframe = df\n    if isinstance(dataframe, pd.Series):\n        dataframe = dataframe.to_frame()\n\n    data_class = cls.data_class\n    required = data_class.required_columns\n    optional = data_class.optional_columns\n\n    # Check required columns in column_mapping\n    missing_mapping = [col for col in required if col not in column_mapping]\n    if missing_mapping:\n        raise ValueValidationError(\n            \"column_mapping\",\n            f\"missing required columns: {missing_mapping}\",\n        )\n    # Removed print\n\n    # Prepare index for all column mappings\n    data_frame = cls.prepare_index(dataframe, column_mapping)\n\n    # Check required columns in DataFrame (including index) - after processing\n    for key in required:\n        col = column_mapping[key]\n        if col not in data_frame.columns:\n            raise NotFoundError(\"Column\", col)\n        # Removed print\n\n    # Build data objects\n    data = []\n    for i in range(len(dataframe)):\n        kwargs_data = {}\n        for key in required.union(optional):\n            if key in column_mapping:\n                col = column_mapping[key]\n                if col in data_frame.columns:\n                    value = data_frame.iloc[i][col]\n                    kwargs_data[key] = value\n                else:\n                    raise NotFoundError(\"Column\", col)\n            else:\n                # Skip optional columns that are not in column_mapping\n                continue\n\n        data.append(data_class(**kwargs_data))\n\n    return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BaselineSeries","title":"BaselineSeries","text":"<p>Baseline series for lightweight charts.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/baseline.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=_validate_base_value_static)\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"top_fill_color1\", str, validator=\"color\")\n@chainable_property(\"top_fill_color2\", str, validator=\"color\")\n@chainable_property(\"top_line_color\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color1\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color2\", str, validator=\"color\")\n@chainable_property(\"bottom_line_color\", str, validator=\"color\")\nclass BaselineSeries(Series):\n    \"\"\"Baseline series for lightweight charts.\"\"\"\n\n    DATA_CLASS = BaselineData\n\n    def __init__(\n        self,\n        data: Union[List[BaselineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize LineOptions for common line properties\n        self._line_options = LineOptions()\n\n        # Baseline-specific properties (not in LineOptions) - set default values internally\n        self._base_value = self._validate_base_value({\"type\": \"price\", \"price\": 0})\n        self._relative_gradient = False\n        self._top_fill_color1 = BASELINE_TOP_FILL_COLOR1\n        self._top_fill_color2 = BASELINE_TOP_FILL_COLOR2\n        self._top_line_color = BASELINE_TOP_LINE_COLOR\n        self._bottom_fill_color1 = BASELINE_BOTTOM_FILL_COLOR1\n        self._bottom_fill_color2 = BASELINE_BOTTOM_FILL_COLOR2\n        self._bottom_line_color = BASELINE_BOTTOM_LINE_COLOR\n\n    def _validate_base_value(self, base_value: Union[int, float, Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate and normalize base_value.\"\"\"\n        if isinstance(base_value, (int, float)):\n            return {\"type\": \"price\", \"price\": float(base_value)}\n        if isinstance(base_value, dict):\n            if \"type\" not in base_value or \"price\" not in base_value:\n                raise BaseValueFormatError()\n            return {\"type\": str(base_value[\"type\"]), \"price\": float(base_value[\"price\"])}\n        raise BaseValueFormatError()\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BASELINE\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BaselineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.BaselineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.CandlestickSeries","title":"CandlestickSeries","text":"<p>Candlestick series for creating OHLC candlestick charts in financial visualization.</p> <p>This class represents a candlestick series that displays OHLC (Open, High, Low, Close) data as candlestick bars. It's commonly used for price charts, technical analysis, and comprehensive price action visualization in financial applications.</p> <p>The CandlestickSeries extends the base Series class with candlestick-specific functionality and supports extensive styling options through chainable properties. It provides comprehensive color customization for bullish/bearish candles, wicks, borders, and other visual elements.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[CandlestickData], DataFrame, Series]</code> <p>Data points for the candlestick series. Can be a list of CandlestickData objects, a pandas DataFrame, or a pandas Series.</p> <code>up_color</code> <code>str</code> <p>Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).</p> <code>down_color</code> <code>str</code> <p>Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).</p> <code>wick_visible</code> <code>bool</code> <p>Whether wicks are visible. Defaults to True.</p> <code>border_visible</code> <code>bool</code> <p>Whether borders are visible. Defaults to False.</p> <code>border_color</code> <code>str</code> <p>General border color. Defaults to \"#378658\" (green).</p> <code>border_up_color</code> <code>str</code> <p>Border color for bullish candles. Defaults to \"#26a69a\".</p> <code>border_down_color</code> <code>str</code> <p>Border color for bearish candles. Defaults to \"#ef5350\".</p> <code>wick_color</code> <code>str</code> <p>General wick color. Defaults to \"#737375\" (gray).</p> <code>wick_up_color</code> <code>str</code> <p>Wick color for bullish candles. Defaults to \"#26a69a\".</p> <code>wick_down_color</code> <code>str</code> <p>Wick color for bearish candles. Defaults to \"#ef5350\".</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (CandlestickData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. CandlestickData: Data class for candlestick chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/candlestick.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"wick_visible\", bool)\n@chainable_property(\"border_visible\", bool)\n@chainable_property(\"border_color\", str, validator=\"color\")\n@chainable_property(\"border_up_color\", str, validator=\"color\")\n@chainable_property(\"border_down_color\", str, validator=\"color\")\n@chainable_property(\"wick_color\", str, validator=\"color\")\n@chainable_property(\"wick_up_color\", str, validator=\"color\")\n@chainable_property(\"wick_down_color\", str, validator=\"color\")\nclass CandlestickSeries(Series):\n    \"\"\"Candlestick series for creating OHLC candlestick charts in financial visualization.\n\n    This class represents a candlestick series that displays OHLC (Open, High, Low, Close)\n    data as candlestick bars. It's commonly used for price charts, technical analysis,\n    and comprehensive price action visualization in financial applications.\n\n    The CandlestickSeries extends the base Series class with candlestick-specific\n    functionality and supports extensive styling options through chainable properties.\n    It provides comprehensive color customization for bullish/bearish candles,\n    wicks, borders, and other visual elements.\n\n    Attributes:\n        data (Union[List[CandlestickData], pd.DataFrame, pd.Series]): Data points for\n            the candlestick series. Can be a list of CandlestickData objects,\n            a pandas DataFrame, or a pandas Series.\n        up_color (str): Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).\n        down_color (str): Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).\n        wick_visible (bool): Whether wicks are visible. Defaults to True.\n        border_visible (bool): Whether borders are visible. Defaults to False.\n        border_color (str): General border color. Defaults to \"#378658\" (green).\n        border_up_color (str): Border color for bullish candles. Defaults to \"#26a69a\".\n        border_down_color (str): Border color for bearish candles. Defaults to \"#ef5350\".\n        wick_color (str): General wick color. Defaults to \"#737375\" (gray).\n        wick_up_color (str): Wick color for bullish candles. Defaults to \"#26a69a\".\n        wick_down_color (str): Wick color for bearish candles. Defaults to \"#ef5350\".\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (CandlestickData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data\n        data = [\n            CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n            CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n        ]\n\n        # Create candlestick series with styling\n        series = (\n            CandlestickSeries(data=data)\n            .set_up_color(\"#4CAF50\")\n            .set_down_color(\"#F44336\")\n            .set_border_visible(True)\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        CandlestickData: Data class for candlestick chart data points.\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = CandlestickData\n\n    def __init__(\n        self,\n        data: Union[List[CandlestickData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a CandlestickSeries instance with data and configuration options.\n\n        This constructor initializes a candlestick series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes candlestick-specific styling properties with default values.\n\n        Args:\n            data: Data points for the candlestick series. Can be a list of\n                CandlestickData objects, a pandas DataFrame, or a pandas Series.\n                If DataFrame is provided, column_mapping can be used to specify\n                field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize candlestick-specific properties with default values\n        # Up color for bullish candles - defaults to teal\n        self._up_color = \"#26a69a\"\n        # Down color for bearish candles - defaults to red\n        self._down_color = \"#ef5350\"\n        # Wick visibility - defaults to True (wicks visible)\n        self._wick_visible = True\n        # Border visibility - defaults to False (borders hidden)\n        self._border_visible = False\n        # General border color - defaults to green\n        self._border_color = \"#378658\"\n        # Border color for bullish candles - defaults to teal\n        self._border_up_color = \"#26a69a\"\n        # Border color for bearish candles - defaults to red\n        self._border_down_color = \"#ef5350\"\n        # General wick color - defaults to gray\n        self._wick_color = \"#737375\"\n        # Wick color for bullish candles - defaults to teal\n        self._wick_up_color = \"#26a69a\"\n        # Wick color for bearish candles - defaults to red\n        self._wick_down_color = \"#ef5350\"\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format for candlestick styling properties.\n\n        This method validates that the provided color string is in a valid\n        format (hex or rgba) for use in candlestick styling. It's used\n        internally by the chainable property validators.\n\n        Args:\n            color: The color string to validate in hex or rgba format.\n            property_name: The name of the property being validated (for error messages).\n\n        Returns:\n            str: The validated color string.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for candlestick charts.\n        \"\"\"\n        return ChartType.CANDLESTICK\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.CandlestickSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.CandlestickSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for candlestick charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries","title":"GradientRibbonSeries","text":"<p>Gradient ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with gradient fill areas based on gradient values. It extends RibbonSeries with gradient fill capabilities, allowing for dynamic color transitions based on data values.</p> <p>The GradientRibbonSeries supports various styling options including separate line styling for each band via LineOptions, and gradient color effects based on data values.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>gradient_start_color</code> <p>Starting color for gradient fills (minimum value).</p> <code>gradient_end_color</code> <p>Ending color for gradient fills (maximum value).</p> <code>normalize_gradients</code> <p>Whether to normalize gradient values to 0-1 range.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>@chainable_property(\"gradient_start_color\", str, validator=\"color\")\n@chainable_property(\"gradient_end_color\", str, validator=\"color\")\n@chainable_property(\"normalize_gradients\", bool)\nclass GradientRibbonSeries(RibbonSeries):\n    \"\"\"Gradient ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with gradient fill areas based on gradient values. It extends RibbonSeries\n    with gradient fill capabilities, allowing for dynamic color transitions\n    based on data values.\n\n    The GradientRibbonSeries supports various styling options including separate\n    line styling for each band via LineOptions, and gradient color effects based\n    on data values.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_visible: Whether to display the fill area.\n        gradient_start_color: Starting color for gradient fills (minimum value).\n        gradient_end_color: Ending color for gradient fills (maximum value).\n        normalize_gradients: Whether to normalize gradient values to 0-1 range.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = GradientRibbonData\n\n    def __init__(\n        self,\n        data: Union[List[GradientRibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        gradient_start_color: str = \"#4CAF50\",\n        gradient_end_color: str = \"#F44336\",\n        normalize_gradients: bool = False,\n    ):\n        \"\"\"Initialize GradientRibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            gradient_start_color: Starting color for gradient fills\n            gradient_end_color: Ending color for gradient fills\n            normalize_gradients: Whether to normalize gradient values to 0-1 range\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize gradient-specific properties\n        self._gradient_start_color = gradient_start_color\n        self._gradient_end_color = gradient_end_color\n        self._normalize_gradients = normalize_gradients\n        self._gradient_bounds: Optional[tuple[float, float]] = None\n\n        # Performance optimization: cache normalized results\n        self._normalized_cache: Optional[dict] = None\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.GRADIENT_RIBBON\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate the normalized data cache.\n\n        This method should be called whenever the data changes to ensure\n        the cached normalized results are recalculated on the next asdict() call.\n        \"\"\"\n        self._normalized_cache = None\n        self._gradient_bounds = None\n\n    def update(self, updates: dict):\n        \"\"\"Override update to invalidate cache when data changes.\n\n        Args:\n            updates: Dictionary of updates to apply.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        # Invalidate cache before updating\n        self._invalidate_cache()\n        # Call parent update\n        return super().update(updates)\n\n    @property\n    def data(self):\n        \"\"\"Get the series data.\"\"\"\n        return self._data if hasattr(self, \"_data\") else []\n\n    @data.setter\n    def data(self, value):\n        \"\"\"Set the series data and invalidate cache.\n\n        Args:\n            value: New data to set.\n        \"\"\"\n        self._data = value\n        self._invalidate_cache()\n\n    def _calculate_gradient_bounds(self) -&gt; None:\n        \"\"\"Calculate min/max gradient values for normalization with optimized performance.\"\"\"\n        if not self.data:\n            self._gradient_bounds = None\n            return\n\n        # Ultra-optimized single-pass min/max tracking\n        min_grad = float(\"inf\")\n        max_grad = float(\"-inf\")\n        valid_count = 0\n\n        # Single pass with inline min/max tracking - no list building\n        for data_point in self.data:\n            # Type check: ensure data point has gradient attribute\n            if not hasattr(data_point, \"gradient\"):\n                continue\n            gradient = data_point.gradient  # type: ignore[attr-defined]\n            if (\n                gradient is not None\n                and isinstance(gradient, (int, float))\n                and not math.isnan(gradient)  # Not NaN\n                and gradient != float(\"inf\")\n                and gradient != float(\"-inf\")\n            ):\n                # Update min/max inline - no list operations\n                min_grad = min(min_grad, gradient)\n                max_grad = max(max_grad, gradient)\n                valid_count += 1\n                continue\n\n        # Set bounds efficiently - only if we found valid values\n        if valid_count &gt; 0:\n            self._gradient_bounds = (min_grad, max_grad)\n        else:\n            self._gradient_bounds = None\n\n    def _compute_normalized_dict(self) -&gt; dict:\n        \"\"\"Compute the normalized dictionary (expensive operation).\n\n        This method performs the actual gradient normalization computation.\n        It's called only when the cache is invalid.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        data_dict = super().asdict()\n\n        # Remove inherited fill_color property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n        data_dict.get(\"options\", {}).pop(\"fillColor\", None)\n\n        if self._normalize_gradients:\n            # Calculate bounds if not already calculated\n            if self._gradient_bounds is None:\n                self._calculate_gradient_bounds()\n\n            if self._gradient_bounds:\n                min_grad, max_grad = self._gradient_bounds\n                range_grad = max_grad - min_grad\n\n                if range_grad &gt; 0:  # Avoid division by zero\n                    # Ultra-optimized normalization with minimal function calls\n                    data_items = data_dict[\"data\"]\n                    range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                    for item in data_items:  # Remove enumerate for speed\n                        gradient = item.get(\"gradient\")\n                        if gradient is not None:\n                            # Since we already validated in _calculate_gradient_bounds,\n                            # we can trust the gradient values here\n                            try:\n                                # Use pre-calculated inverse for faster division\n                                normalized = (gradient - min_grad) * range_grad_inv\n                                # Fast clamping using conditional expression\n                                item[\"gradient\"] = (\n                                    0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                                )\n                            except (TypeError, ValueError):\n                                item.pop(\"gradient\", None)\n\n        return data_dict\n\n    def asdict(self):\n        \"\"\"Override to include normalized gradients with caching for performance.\n\n        Returns cached normalized results if available, otherwise computes and caches them.\n        This optimization prevents O(2n) iterations on every serialization call.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        # Return cached result if available\n        if self._normalized_cache is not None:\n            return self._normalized_cache\n\n        # Compute and cache the result\n        self._normalized_cache = self._compute_normalized_dict()\n        return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data\n</code></pre> <p>Get the series data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries.update","title":"update","text":"<pre><code>update(updates: dict)\n</code></pre> <p>Override update to invalidate cache when data changes.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict</code> <p>Dictionary of updates to apply.</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def update(self, updates: dict):\n    \"\"\"Override update to invalidate cache when data changes.\n\n    Args:\n        updates: Dictionary of updates to apply.\n\n    Returns:\n        Self for method chaining.\n    \"\"\"\n    # Invalidate cache before updating\n    self._invalidate_cache()\n    # Call parent update\n    return super().update(updates)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.GradientRibbonSeries.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Override to include normalized gradients with caching for performance.</p> <p>Returns cached normalized results if available, otherwise computes and caches them. This optimization prevents O(2n) iterations on every serialization call.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The serialized dictionary with normalized gradients.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def asdict(self):\n    \"\"\"Override to include normalized gradients with caching for performance.\n\n    Returns cached normalized results if available, otherwise computes and caches them.\n    This optimization prevents O(2n) iterations on every serialization call.\n\n    Returns:\n        dict: The serialized dictionary with normalized gradients.\n    \"\"\"\n    # Return cached result if available\n    if self._normalized_cache is not None:\n        return self._normalized_cache\n\n    # Compute and cache the result\n    self._normalized_cache = self._compute_normalized_dict()\n    return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.HistogramSeries","title":"HistogramSeries","text":"<p>Histogram series for creating bar-based charts in financial visualization.</p> <p>This class represents a histogram series that displays data as bars. It's commonly used for volume overlays, technical indicators, and other bar-based visualizations where individual data points are represented as vertical bars.</p> <p>The HistogramSeries supports various styling options including bar color, base value, and animation effects. It also provides a factory method for creating volume series with automatic bullish/bearish color coding.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for the histogram series. Can be a list of Data objects, a pandas DataFrame, or a pandas Series.</p> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to \"#26a69a\" (teal). Can be hex or rgba format.</p> <code>base</code> <code>Union[int, float]</code> <p>Base value for the histogram bars. Defaults to 0. This determines the baseline from which bars extend.</p> <code>scale_margins</code> <code>dict</code> <p>Scale margins for the histogram series. Controls the top and bottom margins of the price scale. Defaults to {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (HistogramData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. HistogramData: Data class for histogram chart data points. create_volume_series: Factory method for volume series with color coding.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"base\", (int, float))\n@chainable_property(\"scale_margins\", dict)\nclass HistogramSeries(Series):\n    \"\"\"Histogram series for creating bar-based charts in financial visualization.\n\n    This class represents a histogram series that displays data as bars.\n    It's commonly used for volume overlays, technical indicators, and other\n    bar-based visualizations where individual data points are represented\n    as vertical bars.\n\n    The HistogramSeries supports various styling options including bar color,\n    base value, and animation effects. It also provides a factory method\n    for creating volume series with automatic bullish/bearish color coding.\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for\n            the histogram series. Can be a list of Data objects, a pandas\n            DataFrame, or a pandas Series.\n        color (str): Color of the histogram bars. Defaults to \"#26a69a\" (teal).\n            Can be hex or rgba format.\n        base (Union[int, float]): Base value for the histogram bars. Defaults to 0.\n            This determines the baseline from which bars extend.\n        scale_margins (dict): Scale margins for the histogram series. Controls\n            the top and bottom margins of the price scale. Defaults to\n            {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (HistogramData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data\n        data = [\n            HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n            HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n        ]\n\n        # Create histogram series with styling\n        series = HistogramSeries(data=data)\n        series.set_color(\"#2196F3\").set_base(0)\n\n        # Create volume series with color coding\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n            up_color=\"rgba(38,166,154,0.5)\",\n            down_color=\"rgba(239,83,80,0.5)\",\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        HistogramData: Data class for histogram chart data points.\n        create_volume_series: Factory method for volume series with color coding.\n    \"\"\"\n\n    DATA_CLASS = HistogramData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as a histogram chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The histogram chart type identifier.\n\n        Example:\n            ```python\n            series = HistogramSeries(data=data)\n            chart_type = series.chart_type  # ChartType.HISTOGRAM\n            ```\n        \"\"\"\n        return ChartType.HISTOGRAM\n\n    @classmethod\n    def create_volume_series(\n        cls,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: dict,\n        up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n        down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n        **kwargs,\n    ) -&gt; \"HistogramSeries\":\n        \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n        This factory method processes OHLCV data and creates a HistogramSeries\n        with volume bars colored based on whether the candle is bullish (close &gt;= open)\n        or bearish (close &lt; open). This provides visual context for volume analysis\n        by showing whether volume occurred during price increases or decreases.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n                or sequence of OhlcvData objects containing price and volume information.\n            column_mapping (dict): Mapping of required fields to column names.\n                Must include \"open\", \"close\", and \"volume\" mappings.\n            up_color (str, optional): Color for bullish candles (close &gt;= open).\n                Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n            down_color (str, optional): Color for bearish candles (close &lt; open).\n                Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n            **kwargs: Additional arguments for HistogramSeries constructor.\n\n        Returns:\n            HistogramSeries: Configured histogram series for volume visualization\n                with color-coded bars based on price movement.\n\n        Raises:\n            ValueError: If required columns are missing from the data or column mapping.\n            KeyError: If column mapping doesn't include required fields.\n\n        Example:\n            ```python\n            # Create volume series with default colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping={\n                    \"time\": \"datetime\",\n                    \"open\": \"open_price\",\n                    \"close\": \"close_price\",\n                    \"volume\": \"trading_volume\",\n                },\n            )\n\n            # Create volume series with custom colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping=column_mapping,\n                up_color=\"#4CAF50\",  # Green for bullish\n                down_color=\"#F44336\",  # Red for bearish\n            )\n            ```\n\n        Note:\n            The method automatically sets _last_value_visible to False for volume series\n            as it's typically used as an overlay rather than a main price series.\n        \"\"\"\n        if isinstance(data, pd.DataFrame):\n            # Use vectorized operations for efficient color assignment on large datasets\n            volume_dataframe = data.copy()\n\n            # Extract column names for open and close prices from mapping\n            open_col = column_mapping.get(\"open\", \"open\")\n            close_col = column_mapping.get(\"close\", \"close\")\n\n            # Use NumPy vectorized operations to assign colors based on price movement\n            # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n            colors = np.where(\n                volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n                up_color,\n                down_color,\n            )\n\n            # Add color column to DataFrame for histogram visualization\n            volume_dataframe[\"color\"] = colors\n\n            # Update column mapping to include color field and map volume to value\n            volume_col = column_mapping.get(\"volume\", \"volume\")\n            updated_mapping = column_mapping.copy()\n            updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n            updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n            # Use from_dataframe factory method to create the series\n            return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n        # Handle sequence of OhlcvData objects (non-DataFrame input)\n        if data is None:\n            # Return empty series for None data input\n            return cls(data=[])\n\n        # Process each item in the sequence individually\n        processed_data = []\n        for item in data:\n            if isinstance(item, dict):\n                # Determine color based on price movement for dictionary input\n                color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n                processed_item = item.copy()\n                processed_item[\"color\"] = color  # Add color information\n                processed_data.append(processed_item)\n            else:\n                # For OhlcvData objects, convert to dict and add color\n                item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n                color = (\n                    up_color\n                    if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                    else down_color\n                )\n                item_dict[\"color\"] = color  # Add color information\n                processed_data.append(item_dict)\n\n        # Convert processed data to DataFrame and use from_dataframe factory method\n        processed_dataframe = pd.DataFrame(processed_data)\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n        # Map volume to value for HistogramSeries compatibility\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping[\"value\"] = volume_col\n\n        # Create the volume series using the factory method\n        volume_series = cls.from_dataframe(\n            processed_dataframe,\n            column_mapping=updated_mapping,\n            **kwargs,\n        )\n\n        # Disable last value visibility for volume series (typically used as overlay)\n        volume_series._last_value_visible = False\n\n        return volume_series  # type: ignore[return-value]\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize HistogramSeries with data and configuration options.\n\n        Creates a new histogram series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes histogram-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Histogram data as a list\n                of Data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"right\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic histogram series with list of data objects\n            data = [HistogramData(\"2024-01-01\", 1000)]\n            series = HistogramSeries(data=data)\n\n            # Histogram series with DataFrame\n            series = HistogramSeries(data=dataframe, column_mapping={\"time\": \"datetime\", \"value\": \"volume\"})\n\n            # Histogram series with Series\n            series = HistogramSeries(data=series_data, column_mapping={\"time\": \"index\", \"value\": \"values\"})\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize histogram-specific properties with default values\n        self._color = \"#26a69a\"  # Default teal color for histogram bars\n        self._base = 0  # Default base value (baseline for bars)\n        self._scale_margins = {\"top\": 0.75, \"bottom\": 0}  # Default scale margins\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.HistogramSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.HistogramSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as a histogram chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The histogram chart type identifier.</p> Example <pre><code>series = HistogramSeries(data=data)\nchart_type = series.chart_type  # ChartType.HISTOGRAM\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.HistogramSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.HistogramSeries.create_volume_series","title":"create_volume_series  <code>classmethod</code>","text":"<pre><code>create_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: dict, up_color: str = HISTOGRAM_UP_COLOR_DEFAULT, down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT, **kwargs) -&gt; HistogramSeries\n</code></pre> <p>Create a histogram series for volume data with colors based on price movement.</p> <p>This factory method processes OHLCV data and creates a HistogramSeries with volume bars colored based on whether the candle is bullish (close &gt;= open) or bearish (close &lt; open). This provides visual context for volume analysis by showing whether volume occurred during price increases or decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data as DataFrame or sequence of OhlcvData objects containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields to column names. Must include \"open\", \"close\", and \"volume\" mappings.</p> required <code>up_color</code> <code>str</code> <p>Color for bullish candles (close &gt;= open). Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).</p> <code>HISTOGRAM_UP_COLOR_DEFAULT</code> <code>down_color</code> <code>str</code> <p>Color for bearish candles (close &lt; open). Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).</p> <code>HISTOGRAM_DOWN_COLOR_DEFAULT</code> <code>**kwargs</code> <p>Additional arguments for HistogramSeries constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HistogramSeries</code> <code>HistogramSeries</code> <p>Configured histogram series for volume visualization with color-coded bars based on price movement.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing from the data or column mapping.</p> <code>KeyError</code> <p>If column mapping doesn't include required fields.</p> Example <pre><code># Create volume series with default colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\n        \"time\": \"datetime\",\n        \"open\": \"open_price\",\n        \"close\": \"close_price\",\n        \"volume\": \"trading_volume\",\n    },\n)\n\n# Create volume series with custom colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping=column_mapping,\n    up_color=\"#4CAF50\",  # Green for bullish\n    down_color=\"#F44336\",  # Red for bearish\n)\n</code></pre> Note <p>The method automatically sets _last_value_visible to False for volume series as it's typically used as an overlay rather than a main price series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@classmethod\ndef create_volume_series(\n    cls,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: dict,\n    up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n    down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n    **kwargs,\n) -&gt; \"HistogramSeries\":\n    \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n    This factory method processes OHLCV data and creates a HistogramSeries\n    with volume bars colored based on whether the candle is bullish (close &gt;= open)\n    or bearish (close &lt; open). This provides visual context for volume analysis\n    by showing whether volume occurred during price increases or decreases.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n            or sequence of OhlcvData objects containing price and volume information.\n        column_mapping (dict): Mapping of required fields to column names.\n            Must include \"open\", \"close\", and \"volume\" mappings.\n        up_color (str, optional): Color for bullish candles (close &gt;= open).\n            Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n        down_color (str, optional): Color for bearish candles (close &lt; open).\n            Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n        **kwargs: Additional arguments for HistogramSeries constructor.\n\n    Returns:\n        HistogramSeries: Configured histogram series for volume visualization\n            with color-coded bars based on price movement.\n\n    Raises:\n        ValueError: If required columns are missing from the data or column mapping.\n        KeyError: If column mapping doesn't include required fields.\n\n    Example:\n        ```python\n        # Create volume series with default colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\n                \"time\": \"datetime\",\n                \"open\": \"open_price\",\n                \"close\": \"close_price\",\n                \"volume\": \"trading_volume\",\n            },\n        )\n\n        # Create volume series with custom colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping=column_mapping,\n            up_color=\"#4CAF50\",  # Green for bullish\n            down_color=\"#F44336\",  # Red for bearish\n        )\n        ```\n\n    Note:\n        The method automatically sets _last_value_visible to False for volume series\n        as it's typically used as an overlay rather than a main price series.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # Use vectorized operations for efficient color assignment on large datasets\n        volume_dataframe = data.copy()\n\n        # Extract column names for open and close prices from mapping\n        open_col = column_mapping.get(\"open\", \"open\")\n        close_col = column_mapping.get(\"close\", \"close\")\n\n        # Use NumPy vectorized operations to assign colors based on price movement\n        # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n        colors = np.where(\n            volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n            up_color,\n            down_color,\n        )\n\n        # Add color column to DataFrame for histogram visualization\n        volume_dataframe[\"color\"] = colors\n\n        # Update column mapping to include color field and map volume to value\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n        updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n        # Use from_dataframe factory method to create the series\n        return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n    # Handle sequence of OhlcvData objects (non-DataFrame input)\n    if data is None:\n        # Return empty series for None data input\n        return cls(data=[])\n\n    # Process each item in the sequence individually\n    processed_data = []\n    for item in data:\n        if isinstance(item, dict):\n            # Determine color based on price movement for dictionary input\n            color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n            processed_item = item.copy()\n            processed_item[\"color\"] = color  # Add color information\n            processed_data.append(processed_item)\n        else:\n            # For OhlcvData objects, convert to dict and add color\n            item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n            color = (\n                up_color\n                if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                else down_color\n            )\n            item_dict[\"color\"] = color  # Add color information\n            processed_data.append(item_dict)\n\n    # Convert processed data to DataFrame and use from_dataframe factory method\n    processed_dataframe = pd.DataFrame(processed_data)\n    updated_mapping = column_mapping.copy()\n    updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n    # Map volume to value for HistogramSeries compatibility\n    volume_col = column_mapping.get(\"volume\", \"volume\")\n    updated_mapping[\"value\"] = volume_col\n\n    # Create the volume series using the factory method\n    volume_series = cls.from_dataframe(\n        processed_dataframe,\n        column_mapping=updated_mapping,\n        **kwargs,\n    )\n\n    # Disable last value visibility for volume series (typically used as overlay)\n    volume_series._last_value_visible = False\n\n    return volume_series  # type: ignore[return-value]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.LineSeries","title":"LineSeries","text":"<p>Line series for creating continuous line charts in financial visualization.</p> <p>This class represents a line series that displays continuous data points connected by lines. It's commonly used for price charts, technical indicators, trend analysis, and other time-series data visualization in financial applications.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Data points for the line series. Can be a list of LineData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <p>LineOptions instance for all line style options including color, width, style, and animation effects.</p> <code>column_mapping</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <p>The pane index this series belongs to. Defaults to 0.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data\ndata = [\n    LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n    LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n    LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n# Add to chart\nchart = Chart(series=series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/line.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\nclass LineSeries(Series):\n    \"\"\"Line series for creating continuous line charts in financial visualization.\n\n    This class represents a line series that displays continuous data points\n    connected by lines. It's commonly used for price charts, technical\n    indicators, trend analysis, and other time-series data visualization\n    in financial applications.\n\n    Attributes:\n        data: Data points for the line series. Can be a list of LineData\n            objects, a pandas DataFrame, or a pandas Series.\n        line_options: LineOptions instance for all line style options\n            including color, width, style, and animation effects.\n        column_mapping: Optional mapping for DataFrame columns to data fields.\n            Used when data is provided as a DataFrame.\n        visible: Whether the series is visible on the chart. Defaults to True.\n        price_scale_id: ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id: The pane index this series belongs to.\n            Defaults to 0.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data\n        data = [\n            LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n            LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n            LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n        ]\n\n        # Create line series with styling\n        series = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n        # Add to chart\n        chart = Chart(series=series)\n        ```\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = LineData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for line charts.\n        \"\"\"\n        return ChartType.LINE\n\n    def __init__(\n        self,\n        data: Union[List[LineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a LineSeries instance with data and configuration options.\n\n        This constructor initializes a line series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes line-specific styling options with default values.\n\n        Args:\n            data: Data points for the line series. Can be a list of LineData\n                objects, a pandas DataFrame, or a pandas Series. If DataFrame\n                is provided, column_mapping can be used to specify field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        # This sets up data validation, column mapping processing, and basic properties\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n        # Initialize line_options with default styling configuration\n        # This creates an empty LineOptions instance for future customization\n        self._line_options = LineOptions()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.LineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.LineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for line charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.RibbonSeries","title":"RibbonSeries","text":"<p>Ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with a fill area between them. It's commonly used for technical indicators like Bollinger Bands without the middle line, or other envelope indicators.</p> <p>The RibbonSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_color</code> <p>Fill color for the area between upper and lower bands.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/ribbon.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass RibbonSeries(Series):\n    \"\"\"Ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with a fill area between them. It's commonly used for technical indicators\n    like Bollinger Bands without the middle line, or other envelope indicators.\n\n    The RibbonSeries supports various styling options including separate line\n    styling for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_color: Fill color for the area between upper and lower bands.\n        fill_visible: Whether to display the fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = RibbonData\n\n    def __init__(\n        self,\n        data: Union[List[RibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize RibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill color\n        self._fill_color = RIBBON_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.RIBBON\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.RibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.RibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.SignalSeries","title":"SignalSeries","text":"<p>Signal series for background coloring in charts.</p> <p>SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>The series takes signal data with binary or ternary values and maps them to background colors for specific time periods. The background bands appear across all chart panes and provide visual context for the data.</p> <p>Signal data can be: - Binary (0, 1): Only uses neutral_color and signal_color - Ternary (0, 1, negative): Uses all three colors including alert_color</p> <p>Attributes:</p> Name Type Description <code>neutral_color</code> <p>Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")</p> <code>signal_color</code> <p>Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")</p> <code>alert_color</code> <p>Background color for signal value&lt;0 (negative, optional, default: None) Frontend intelligently uses this only when data contains non-boolean values</p> Example <pre><code># Create signal data\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n    SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n]\n\n# Create signal series\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n\n# Add to chart\nchart.add_series(signal_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/signal_series.py</code> <pre><code>@chainable_property(\"neutral_color\", str, validator=\"color\")\n@chainable_property(\"signal_color\", str, validator=\"color\")\n@chainable_property(\"alert_color\", str, validator=\"color\", allow_none=True)\nclass SignalSeries(Series):\n    \"\"\"Signal series for background coloring in charts.\n\n    SignalSeries creates vertical background bands that span the entire chart\n    height, colored based on signal values at specific time points. This is\n    commonly used in financial charts to highlight specific market conditions,\n    trading signals, or events.\n\n    The series takes signal data with binary or ternary values and maps them\n    to background colors for specific time periods. The background bands\n    appear across all chart panes and provide visual context for the data.\n\n    Signal data can be:\n    - Binary (0, 1): Only uses neutral_color and signal_color\n    - Ternary (0, 1, negative): Uses all three colors including alert_color\n\n    Attributes:\n        neutral_color: Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")\n        signal_color: Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")\n        alert_color: Background color for signal value&lt;0 (negative, optional, default: None)\n            Frontend intelligently uses this only when data contains non-boolean values\n\n    Example:\n        ```python\n        # Create signal data\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n            SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n        ]\n\n        # Create signal series\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n\n        # Add to chart\n        chart.add_series(signal_series)\n        ```\n    \"\"\"\n\n    DATA_CLASS = SignalData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: ChartType.SIGNAL indicating this is a signal series.\n        \"\"\"\n        return ChartType.SIGNAL\n\n    def __init__(\n        self,\n        data: Union[List[SignalData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        neutral_color: str = \"rgba(128, 128, 128, 0.1)\",\n        signal_color: str = \"rgba(76, 175, 80, 0.2)\",\n        alert_color: Optional[str] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize SignalSeries.\n\n        Args:\n            data: List of SignalData objects, DataFrame, or Series.\n            column_mapping: Optional column mapping for DataFrame input.\n            neutral_color: Background color for value=0. Defaults to \"rgba(128, 128, 128, 0.1)\".\n            signal_color: Background color for value&gt;0 (positive). Defaults to \"rgba(76, 175, 80, 0.2)\".\n            alert_color: Background color for value&lt;0 (negative). Defaults to None.\n                Frontend intelligently uses this only when needed based on data values.\n            visible: Whether the signal series should be visible. Defaults to True.\n            price_scale_id: Price scale ID. Defaults to \"right\".\n            pane_id: Pane ID for multi-pane charts. Defaults to 0.\n\n        Raises:\n            ValueError: If data is empty or invalid.\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize signal-specific properties with default values\n        self._neutral_color = neutral_color\n        self._signal_color = signal_color\n        self._alert_color = alert_color\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the signal series.\"\"\"\n        return (\n            f\"SignalSeries(data_points={len(self.data)}, neutral_color='{self._neutral_color}',\"\n            f\" signal_color='{self._signal_color}')\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.SignalSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.SignalSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>ChartType.SIGNAL indicating this is a signal series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.TrendFillSeries","title":"TrendFillSeries","text":"<p>Trend fill series for lightweight charts.</p> <p>This class represents a trend fill series that displays fills between trend lines and base lines. It's commonly used for technical indicators like Supertrend, where the fill area changes color based on trend direction.</p> <p>The series properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p> <p>Attributes:</p> Name Type Description <code>uptrend_line</code> <code>LineOptions</code> <p>Line options for the uptrend line.</p> <code>downtrend_line</code> <code>LineOptions</code> <p>Line options for the downtrend line.</p> <code>base_line</code> <code>LineOptions</code> <p>Line options for the base line.</p> <code>uptrend_fill_color</code> <code>str</code> <p>Color for uptrend fills (default: green).</p> <code>downtrend_fill_color</code> <code>str</code> <p>Color for downtrend fills (default: red).</p> <code>fill_visible</code> <code>bool</code> <p>Whether fills are visible.</p> Example <pre><code>from streamlit_lightweight_charts_pro import TrendFillSeries\nfrom streamlit_lightweight_charts_pro.data import TrendFillData\n\n# Create trend fill data\ndata = [\n    TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n    TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n]\n\n# Create series with custom colors\nseries = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/trend_fill.py</code> <pre><code>@chainable_property(\"uptrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"downtrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"base_line\", LineOptions, allow_none=True)\n@chainable_property(\"uptrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"downtrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass TrendFillSeries(Series):\n    \"\"\"Trend fill series for lightweight charts.\n\n    This class represents a trend fill series that displays fills between\n    trend lines and base lines. It's commonly used for technical\n    indicators like Supertrend, where the fill area changes color based on\n    trend direction.\n\n    The series properly handles separate trend lines based on trend direction:\n    - Uptrend (+1): Uses uptrend_line options for trend line above price\n    - Downtrend (-1): Uses downtrend_line options for trend line below price\n\n    Attributes:\n        uptrend_line (LineOptions): Line options for the uptrend line.\n        downtrend_line (LineOptions): Line options for the downtrend line.\n        base_line (LineOptions): Line options for the base line.\n        uptrend_fill_color (str): Color for uptrend fills (default: green).\n        downtrend_fill_color (str): Color for downtrend fills (default: red).\n        fill_visible (bool): Whether fills are visible.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import TrendFillSeries\n        from streamlit_lightweight_charts_pro.data import TrendFillData\n\n        # Create trend fill data\n        data = [\n            TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n            TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n        ]\n\n        # Create series with custom colors\n        series = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n        ```\n    \"\"\"\n\n    DATA_CLASS = TrendFillData\n\n    def __init__(\n        self,\n        data: Union[List[TrendFillData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        uptrend_fill_color: str = \"#4CAF50\",\n        downtrend_fill_color: str = \"#F44336\",\n    ):\n        \"\"\"Initialize TrendFillSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            uptrend_fill_color: Color for uptrend fills (green)\n            downtrend_fill_color: Color for downtrend fills (red)\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Convert colors to rgba with default opacity\n        self._uptrend_fill_color = add_opacity(uptrend_fill_color)\n        self._downtrend_fill_color = add_opacity(downtrend_fill_color)\n\n        # Initialize line options for uptrend line, downtrend line, and base line\n        self._uptrend_line = create_uptrend_line()\n        self._downtrend_line = create_downtrend_line()\n        self._base_line = create_base_line()\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Return the chart type for this series.\"\"\"\n        return ChartType.TREND_FILL\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.TrendFillSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/index.html#streamlit_lightweight_charts_pro.charts.series.TrendFillSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Return the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html","title":"streamlit_lightweight_charts_pro.charts.series.area","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area","title":"area","text":"<p>Area series for streamlit-lightweight-charts.</p> <p>This module provides the AreaSeries class for creating area charts that display continuous data points with filled areas under the line. Area series are commonly used for price charts, indicators, and trend analysis in financial visualization.</p> <p>The AreaSeries class supports various styling options including area color, line color, width, style, and animation effects. It also supports markers and price line configurations for comprehensive chart customization.</p> Key Features <ul> <li>Filled area visualization with customizable colors</li> <li>Line styling through LineOptions integration</li> <li>Gradient effects and area inversion options</li> <li>Marker and price line support for annotations</li> <li>DataFrame integration with automatic column mapping</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries","title":"AreaSeries","text":"<p>Area series for creating filled area charts in financial visualization.</p> <p>This class represents an area series that displays continuous data points with filled areas under the line. It's commonly used for price charts, technical indicators, and trend analysis where the area under the curve provides visual emphasis and context.</p> <p>The AreaSeries supports various styling options including area colors, line styling via LineOptions, and gradient effects for enhanced visual appeal and data interpretation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[AreaData], DataFrame, Series]</code> <p>Data points for the area series. Can be a list of AreaData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <code>LineOptions</code> <p>LineOptions instance for line styling. Provides comprehensive line customization including color, width, style, and animation effects.</p> <code>top_color</code> <code>str</code> <p>Color of the top part of the area fill. Defaults to \"#2196F3\" (blue). Can be hex or rgba format.</p> <code>bottom_color</code> <code>str</code> <p>Color of the bottom part of the area fill. Defaults to \"rgba(33, 150, 243, 0.0)\" (transparent blue).</p> <code>relative_gradient</code> <code>bool</code> <p>Whether gradient is relative to base value. Defaults to False for absolute gradient positioning.</p> <code>invert_filled_area</code> <code>bool</code> <p>Whether to invert the filled area direction. Defaults to False for normal area filling.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (AreaData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data with line colors\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with gradient styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n\n# Configure line options\nseries.line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre> See also <p>Series: Base class providing common series functionality. LineOptions: Configuration class for line styling options. AreaData: Data class for area chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/area.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"top_color\", str, validator=\"color\")\n@chainable_property(\"bottom_color\", str, validator=\"color\")\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"invert_filled_area\", bool)\nclass AreaSeries(Series):\n    \"\"\"Area series for creating filled area charts in financial visualization.\n\n    This class represents an area series that displays continuous data points\n    with filled areas under the line. It's commonly used for price charts,\n    technical indicators, and trend analysis where the area under the curve\n    provides visual emphasis and context.\n\n    The AreaSeries supports various styling options including area colors,\n    line styling via LineOptions, and gradient effects for enhanced\n    visual appeal and data interpretation.\n\n    Attributes:\n        data (Union[List[AreaData], pd.DataFrame, pd.Series]): Data points for\n            the area series. Can be a list of AreaData objects, a pandas\n            DataFrame, or a pandas Series.\n        line_options (LineOptions): LineOptions instance for line styling.\n            Provides comprehensive line customization including color, width,\n            style, and animation effects.\n        top_color (str): Color of the top part of the area fill. Defaults to\n            \"#2196F3\" (blue). Can be hex or rgba format.\n        bottom_color (str): Color of the bottom part of the area fill. Defaults\n            to \"rgba(33, 150, 243, 0.0)\" (transparent blue).\n        relative_gradient (bool): Whether gradient is relative to base value.\n            Defaults to False for absolute gradient positioning.\n        invert_filled_area (bool): Whether to invert the filled area direction.\n            Defaults to False for normal area filling.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (AreaData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import AreaSeries\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data with line colors\n        data = [\n            AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n        ]\n\n        # Create area series with gradient styling\n        series = AreaSeries(\n            data=data,\n            top_color=\"rgba(33, 150, 243, 0.4)\",\n            bottom_color=\"rgba(33, 150, 243, 0.0)\",\n            relative_gradient=False,\n            invert_filled_area=False,\n        )\n\n        # Configure line options\n        series.line_options.set_color(\"#2196F3\").set_width(2)\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        LineOptions: Configuration class for line styling options.\n        AreaData: Data class for area chart data points.\n    \"\"\"\n\n    DATA_CLASS = AreaData\n\n    def __init__(\n        self,\n        data: Union[List[AreaData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize AreaSeries with data and configuration options.\n\n        Creates a new area series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes area-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[AreaData], pd.DataFrame, pd.Series]): Area data as a list\n                of AreaData objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of AreaData objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of AreaData or its subclasses.\n\n        Example:\n            ```python\n            # Basic area series with list of data objects\n            data = [AreaData(\"2024-01-01\", 100)]\n            series = AreaSeries(data=data)\n\n            # Area series with DataFrame\n            series = AreaSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Area series with custom configuration\n            series = AreaSeries(data=data, visible=True, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize area-specific properties with default values\n        self._line_options = LineOptions()  # Line styling configuration\n        self._top_color = COLOR_BLUE_MATERIAL  # Top area color (blue)\n        self._bottom_color = AREA_BOTTOM_COLOR_DEFAULT  # Bottom area color (transparent)\n        self._relative_gradient = False  # Absolute gradient positioning\n        self._invert_filled_area = False  # Normal area filling direction\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as an area chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The area chart type identifier.\n\n        Example:\n            ```python\n            series = AreaSeries(data=data)\n            chart_type = series.chart_type  # ChartType.AREA\n            ```\n        \"\"\"\n        return ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as an area chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The area chart type identifier.</p> Example <pre><code>series = AreaSeries(data=data)\nchart_type = series.chart_type  # ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html","title":"streamlit_lightweight_charts_pro.charts.series.band","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band","title":"band","text":"<p>Band series for streamlit-lightweight-charts.</p> <p>This module provides the BandSeries class for creating band charts (e.g., Bollinger Bands) that display upper, middle, and lower bands. Band series are commonly used for technical indicators and volatility analysis.</p> <p>The BandSeries class supports various styling options for each band, fill colors, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BandSeries from streamlit_lightweight_charts_pro.data import BandData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band--create-band-data","title":"Create band data","text":"<p>data = [     BandData(\"2024-01-01\", upper=110, middle=105, lower=100),     BandData(\"2024-01-02\", upper=112, middle=107, lower=102) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band--create-band-series-with-styling","title":"Create band series with styling","text":"<p>series = BandSeries(data=data) series.upper_line.color = \"#4CAF50\" series.lower_line.color = \"#F44336\" series.upper_fill_color = \"rgba(76, 175, 80, 0.1)\" series.lower_fill_color = \"rgba(244, 67, 54, 0.1)\"</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries","title":"BandSeries","text":"<p>Band series for lightweight charts (e.g., Bollinger Bands).</p> <p>This class represents a band series that displays upper, middle, and lower bands. It's commonly used for technical indicators like Bollinger Bands, Keltner Channels, and other envelope indicators.</p> <p>The BandSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>middle_line</code> <p>LineOptions instance for middle band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>upper_fill_color</code> <p>Fill color for upper band area.</p> <code>lower_fill_color</code> <p>Fill color for lower band area.</p> <code>upper_fill</code> <p>Whether to display the upper fill area.</p> <code>lower_fill</code> <p>Whether to display the lower fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/band.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"middle_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"upper_fill_color\", str, validator=\"color\")\n@chainable_property(\"lower_fill_color\", str, validator=\"color\")\n@chainable_property(\"upper_fill\", bool)\n@chainable_property(\"lower_fill\", bool)\nclass BandSeries(Series):\n    \"\"\"Band series for lightweight charts (e.g., Bollinger Bands).\n\n    This class represents a band series that displays upper, middle, and lower bands.\n    It's commonly used for technical indicators like Bollinger Bands, Keltner Channels,\n    and other envelope indicators.\n\n    The BandSeries supports various styling options including separate line styling\n    for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        middle_line: LineOptions instance for middle band styling.\n        lower_line: LineOptions instance for lower band styling.\n        upper_fill_color: Fill color for upper band area.\n        lower_fill_color: Fill color for lower band area.\n        upper_fill: Whether to display the upper fill area.\n        lower_fill: Whether to display the lower fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BandData\n\n    def __init__(\n        self,\n        data: Union[List[BandData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize BandSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._middle_line = create_middle_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill colors\n        self._upper_fill_color = BAND_UPPER_FILL_COLOR\n        self._lower_fill_color = BAND_LOWER_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._upper_fill = True\n        self._lower_fill = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAND\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html","title":"streamlit_lightweight_charts_pro.charts.series.bar_series","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series","title":"bar_series","text":"<p>Bar series for streamlit-lightweight-charts.</p> <p>This module provides the BarSeries class for creating bar charts that display OHLC data as bars. Bar series are commonly used for price charts and volume overlays.</p> <p>The BarSeries class supports various styling options including bar color, base value, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BarSeries from streamlit_lightweight_charts_pro.data import SingleValueData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series--create-bar-data","title":"Create bar data","text":"<p>data = [     SingleValueData(\"2024-01-01\", 100),     SingleValueData(\"2024-01-02\", 105) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series--create-bar-series-with-styling","title":"Create bar series with styling","text":"<p>series = BarSeries(data=data) series.color = \"#26a69a\" series.base = 0</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries","title":"BarSeries","text":"<p>Bar series for lightweight charts.</p> <p>This class represents a bar series that displays data as bars. It's commonly used for price charts, volume overlays, and other bar-based visualizations.</p> <p>The BarSeries supports various styling options including bar colors, base value, and animation effects.</p> <p>Attributes:</p> Name Type Description <code>color</code> <p>Color of the bars (set via property).</p> <code>base</code> <p>Base value for the bars (set via property).</p> <code>up_color</code> <p>Color for up bars (set via property).</p> <code>down_color</code> <p>Color for down bars (set via property).</p> <code>open_visible</code> <p>Whether open values are visible (set via property).</p> <code>thin_bars</code> <p>Whether to use thin bars (set via property).</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/bar_series.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"open_visible\", bool)\n@chainable_property(\"thin_bars\", bool)\nclass BarSeries(Series):\n    \"\"\"Bar series for lightweight charts.\n\n    This class represents a bar series that displays data as bars.\n    It's commonly used for price charts, volume overlays, and other\n    bar-based visualizations.\n\n    The BarSeries supports various styling options including bar colors,\n    base value, and animation effects.\n\n    Attributes:\n        color: Color of the bars (set via property).\n        base: Base value for the bars (set via property).\n        up_color: Color for up bars (set via property).\n        down_color: Color for down bars (set via property).\n        open_visible: Whether open values are visible (set via property).\n        thin_bars: Whether to use thin bars (set via property).\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BarData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAR\n\n    def __init__(\n        self,\n        data: Union[List[BarData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize properties with default values\n        self._up_color = \"#26a69a\"\n        self._down_color = \"#ef5350\"\n        self._open_visible = True\n        self._thin_bars = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html","title":"streamlit_lightweight_charts_pro.charts.series.base","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base","title":"base","text":"<p>Base series class for streamlit-lightweight-charts.</p> <p>This module provides the base Series class that defines the common interface for all series types in the library. It includes core functionality for data handling, configuration, and frontend integration.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series.base import Series\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n\nclass MyCustomSeries(Series):\n    DATA_CLASS = SingleValueData\n\n    @property\n    def chart_type(self):\n        return ChartType.LINE\n\n\n# Create series with data\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = MyCustomSeries(data=data)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series","title":"Series","text":"<p>Abstract base class for all series types in financial chart visualization.</p> <p>This class defines the common interface and functionality that all series classes must implement. It provides core data handling, configuration methods, and frontend integration capabilities with comprehensive support for pandas DataFrame integration, markers, price lines, and formatting.</p> <p>All series classes should inherit from this base class and implement the required abstract methods. The class supports method chaining for fluent API usage and provides extensive customization options.</p> Key Features <ul> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line management for annotations</li> <li>Price scale and pane configuration for multi-pane charts</li> <li>Visibility and formatting controls for UI customization</li> <li>Comprehensive data validation and error handling</li> <li>Method chaining support for fluent API design</li> <li>Frontend serialization for React component integration</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for this series. Can be a list of Data objects, pandas DataFrame, or pandas Series.</p> <code>title</code> <code>Optional[str]</code> <p>Technical title displayed on axis/legend. Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").</p> <code>display_name</code> <code>Optional[str]</code> <p>User-friendly name for UI elements. Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").</p> <code>visible</code> <code>bool</code> <p>Whether the series is currently visible on the chart.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Common values are \"left\", \"right\", or custom scale IDs.</p> <code>price_format</code> <code>PriceFormatOptions</code> <p>Price formatting configuration for display.</p> <code>price_lines</code> <code>List[PriceLineOptions]</code> <p>List of price lines for horizontal markers.</p> <code>markers</code> <code>List[MarkerBase]</code> <p>List of markers to display on this series.</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to for multi-pane charts.</p> <code>z_index</code> <code>int</code> <p>Z-index for controlling series rendering order.</p> Class Attributes <p>DATA_CLASS (Type[Data]): The data class type used for this series.     Must be defined by subclasses for DataFrame conversion to work.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create series with list of data objects\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = LineSeries(data=data)\n\n# Add markers and price lines\nseries.add_marker(bar_marker).add_price_line(price_line)\n\n# Configure series properties\nseries.set_visible(True).set_price_scale_id(\"right\")\n</code></pre> Note <p>Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work. The data_class property will always pick the most-derived DATA_CLASS in the MRO.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@chainable_property(\"title\", top_level=True)\n@chainable_property(\"display_name\", top_level=True)\n@chainable_property(\"visible\", top_level=True)\n@chainable_property(\"z_index\", allow_none=True, top_level=True)\n@chainable_property(\"price_scale_id\", top_level=True)\n@chainable_property(\"price_scale\", allow_none=True, top_level=True)\n@chainable_property(\"price_format\")\n@chainable_property(\"price_lines\", top_level=True)\n@chainable_property(\"markers\", List[MarkerBase], allow_none=True, top_level=True)\n@chainable_property(\"pane_id\", top_level=True)\n@chainable_property(\"last_value_visible\", top_level=True)\n@chainable_property(\"price_line_visible\", top_level=True)\n@chainable_property(\"price_line_source\", top_level=True)\n@chainable_property(\"price_line_width\", top_level=True)\n@chainable_property(\"price_line_color\", top_level=True)\n@chainable_property(\"price_line_style\", top_level=True)\n@chainable_property(\"tooltip\", allow_none=True, top_level=True)\n@chainable_property(\"legend\", allow_none=True, top_level=True)\nclass Series(ABC):  # noqa: B024\n    \"\"\"Abstract base class for all series types in financial chart visualization.\n\n    This class defines the common interface and functionality that all series\n    classes must implement. It provides core data handling, configuration\n    methods, and frontend integration capabilities with comprehensive support\n    for pandas DataFrame integration, markers, price lines, and formatting.\n\n    All series classes should inherit from this base class and implement\n    the required abstract methods. The class supports method chaining for\n    fluent API usage and provides extensive customization options.\n\n    Key Features:\n        - DataFrame integration with automatic column mapping\n        - Marker and price line management for annotations\n        - Price scale and pane configuration for multi-pane charts\n        - Visibility and formatting controls for UI customization\n        - Comprehensive data validation and error handling\n        - Method chaining support for fluent API design\n        - Frontend serialization for React component integration\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for this series.\n            Can be a list of Data objects, pandas DataFrame, or pandas Series.\n        title (Optional[str]): Technical title displayed on axis/legend.\n            Used for chart identification (e.g., \"SMA(20)\", \"RSI(14)\").\n        display_name (Optional[str]): User-friendly name for UI elements.\n            Used in dialog tabs and tooltips (e.g., \"Moving Average\", \"Momentum\").\n        visible (bool): Whether the series is currently visible on the chart.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Common values are \"left\", \"right\", or custom scale IDs.\n        price_format (PriceFormatOptions): Price formatting configuration for display.\n        price_lines (List[PriceLineOptions]): List of price lines for horizontal markers.\n        markers (List[MarkerBase]): List of markers to display on this series.\n        pane_id (Optional[int]): The pane index this series belongs to for multi-pane charts.\n        z_index (int): Z-index for controlling series rendering order.\n\n    Class Attributes:\n        DATA_CLASS (Type[Data]): The data class type used for this series.\n            Must be defined by subclasses for DataFrame conversion to work.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create series with list of data objects\n        data = [SingleValueData(\"2024-01-01\", 100)]\n        series = LineSeries(data=data)\n\n        # Add markers and price lines\n        series.add_marker(bar_marker).add_price_line(price_line)\n\n        # Configure series properties\n        series.set_visible(True).set_price_scale_id(\"right\")\n        ```\n\n    Note:\n        Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work.\n        The data_class property will always pick the most-derived DATA_CLASS in the MRO.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a series with data and configuration.\n\n        Creates a new series instance with the provided data and configuration options.\n        The constructor supports multiple data input types including lists of Data\n        objects, pandas DataFrames, and pandas Series with automatic validation\n        and conversion.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Series data as a list\n                of data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic series with list of data objects\n            series = LineSeries(data=line_data)\n\n            # Series with DataFrame\n            series = LineSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Series with Series\n             series = LineSeries(\n                 data=series_data,\n                 column_mapping={\"time\": \"index\", \"value\": \"values\"}\n             )\n\n            # Series with custom configuration\n            series = LineSeries(data=line_data, visible=False, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Validate and process data input based on type\n        if data is None:\n            # Handle None input by creating empty data list\n            self.data = []\n        elif isinstance(data, (pd.DataFrame, pd.Series)):\n            # DataFrame/Series input requires column mapping for conversion\n            if column_mapping is None:\n                raise ColumnMappingRequiredError()\n            # Process DataFrame/Series using from_dataframe logic\n            self.data = self._process_dataframe_input(data, column_mapping)\n        elif isinstance(data, list):\n            # Validate that all items in list are Data instances\n            if data and not all(isinstance(item, Data) for item in data):\n                raise DataItemsTypeError()\n            self.data = data\n        else:\n            # Raise error for unsupported data types\n            raise DataFrameValidationError.invalid_data_type(type(data))\n\n        # Initialize series configuration properties with default values\n        self._title = None  # Optional series title for legends and tooltips\n        self._display_name = None  # User-friendly name for UI elements\n        self._visible = visible  # Series visibility flag\n        self._price_scale_id = price_scale_id  # Price scale attachment ID\n        self._price_scale = None  # Price scale configuration object\n        self._price_format = None  # Price formatting options\n        self._price_lines: List[PriceLineOptions] = []  # List of price line markers\n        self._markers: List[MarkerBase] = []  # List of chart markers for annotations\n        self._pane_id = pane_id  # Pane index for multi-pane charts\n        self._column_mapping = column_mapping  # DataFrame column mapping\n\n        # Initialize price line display properties\n        self._last_value_visible = True  # Show last value on price scale\n        self._price_line_visible = True  # Show price line by default\n        self._price_line_source = PriceLineSource.LAST_BAR  # Price line data source\n        self._price_line_width = 1  # Price line width in pixels\n        self._price_line_color = \"\"  # Price line color (empty for default)\n        self._price_line_style = LineStyle.DASHED  # Price line style\n\n        # Initialize optional UI components\n        self._tooltip = None  # Custom tooltip configuration\n        self._z_index = 100  # Z-index for rendering order\n        self._legend = None  # Legend configuration\n\n    @staticmethod\n    def prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n        \"\"\"Prepare index for column mapping.\n\n        Handles all index-related column mapping cases:\n        - Time column mapping with DatetimeIndex\n        - Level position mapping (e.g., \"0\", \"1\")\n        - \"index\" mapping (first unnamed level or level 0)\n        - Named level mapping (e.g., \"date\", \"symbol\")\n        - Single index reset for non-time columns\n\n        Args:\n            data_frame: DataFrame to prepare\n            column_mapping: Mapping of required fields to column names\n\n        Returns:\n            DataFrame with prepared index\n\n        Raises:\n            ValueError: If time column is not found and no DatetimeIndex is available\n        \"\"\"\n        # Handle time column mapping first (special case for DatetimeIndex)\n        if \"time\" in column_mapping:\n            time_col = column_mapping[\"time\"]\n            if time_col not in data_frame.columns:\n                # Handle single DatetimeIndex\n                if isinstance(data_frame.index, pd.DatetimeIndex):\n                    if data_frame.index.name is None:\n                        # Set name and reset index to make it a regular column\n                        data_frame.index.name = time_col\n                        data_frame = data_frame.reset_index()\n                    elif data_frame.index.name == time_col:\n                        # Index name already matches, just reset to make it a regular column\n                        data_frame = data_frame.reset_index()\n\n                # Handle MultiIndex with DatetimeIndex level\n                elif isinstance(data_frame.index, pd.MultiIndex):\n                    for i, level in enumerate(data_frame.index.levels):\n                        if isinstance(level, pd.DatetimeIndex):\n                            if data_frame.index.names[i] is None:\n                                # Set name for this level and reset it\n                                new_names = list(data_frame.index.names)\n                                new_names[i] = time_col\n                                data_frame.index.names = new_names\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                            if data_frame.index.names[i] == time_col:\n                                # Level name already matches, reset this level\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                    else:\n                        # No DatetimeIndex level found, check if any level name matches\n                        if time_col in data_frame.index.names or time_col == \"index\":\n                            # Reset the entire MultiIndex to get all levels as columns\n                            data_frame = data_frame.reset_index()\n                        else:\n                            # Check if time_col is an integer level position\n                            try:\n                                level_idx = int(time_col)\n                                if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                    # Reset the entire MultiIndex to get all levels as columns\n                                    data_frame = data_frame.reset_index()\n                                else:\n                                    # Invalid level position, just pass through\n                                    pass\n                            except ValueError:\n                                # Not an integer, just pass through\n                                pass\n                # No DatetimeIndex found\n                # Check if time_col is \"index\" and we have a regular index to reset\n                elif time_col == \"index\":\n                    # Reset the index to make it a regular column\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[\"time\"] = new_col_name\n                elif time_col == data_frame.index.name:\n                    # Time column matches index name, reset the index\n                    data_frame = data_frame.reset_index()\n                else:\n                    raise NotFoundError(\"Time Column\", time_col)\n\n        # Handle other index columns\n        for field, col_name in column_mapping.items():\n            if field == \"time\":\n                continue  # Already handled above\n\n            if col_name not in data_frame.columns:\n                if isinstance(data_frame.index, pd.MultiIndex):\n                    level_names = list(data_frame.index.names)\n\n                    # Integer string or int: treat as level position\n                    try:\n                        level_idx = int(col_name)\n                        if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                            data_frame = data_frame.reset_index(level=level_idx)\n                            level_name = level_names[level_idx]\n                            # Update column mapping to use actual column name\n                            new_col_name = (\n                                level_name if level_name is not None else f\"level_{level_idx}\"\n                            )\n                            column_mapping[field] = new_col_name\n                            continue\n                    except (ValueError, IndexError):\n                        pass\n\n                    # 'index': use first unnamed level if any, else first level\n                    if col_name == \"index\":\n                        unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                        level_idx = unnamed_levels[0] if unnamed_levels else 0\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n\n                    # Named level\n                    if col_name in level_names:\n                        level_idx = level_names.index(col_name)\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        continue\n\n                # Single index\n                elif col_name in (\"index\", data_frame.index.name):\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[field] = new_col_name\n                    continue\n\n        return data_frame\n\n    def _process_dataframe_input(\n        self,\n        data: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n    ) -&gt; List[Data]:\n        \"\"\"Process DataFrame or Series input into a list of Data objects.\n\n        This method duplicates the logic from from_dataframe to handle\n        DataFrame/Series input in the constructor. It validates the input\n        data structure and converts it to the appropriate Data objects\n        based on the series type.\n\n        Args:\n            data (Union[pd.DataFrame, pd.Series]): DataFrame or Series to process.\n            column_mapping (Dict[str, str]): Mapping of required fields to column names.\n\n        Returns:\n            List[Data]: List of processed data objects suitable for the series type.\n\n        Raises:\n            ValueError: If required columns are missing from the DataFrame/Series.\n            ValueError: If the data structure is invalid for the series type.\n            ValueError: If time column is not found and no DatetimeIndex is available.\n\n        Note:\n            This method uses the data_class property to determine the appropriate\n            Data class for conversion.\n        \"\"\"\n        # Convert Series to DataFrame if needed (do this first)\n        if isinstance(data, pd.Series):\n            data = data.to_frame()\n\n        data_class = self.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check if all required columns are mapped\n        # Normalize keys to handle both snake_case and camelCase\n        def normalize_key(key):\n            \"\"\"Convert snake_case to camelCase for comparison.\"\"\"\n            if \"_\" in key:\n                parts = key.split(\"_\")\n                return parts[0] + \"\".join(part.capitalize() for part in parts[1:])\n            return key\n\n        # Create normalized versions of both sets for comparison\n        normalized_required = {normalize_key(key) for key in required}\n        normalized_mapping_keys = {normalize_key(key) for key in column_mapping}\n\n        missing_required = normalized_required - normalized_mapping_keys\n        if missing_required:\n            # Convert back to original format for error message\n            missing_original = {key for key in required if normalize_key(key) in missing_required}\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column mapping: {missing_original}\",\n            )\n\n        # Prepare index for all column mappings\n        data_frame = self.prepare_index(data, column_mapping)\n\n        # Check if all required columns are present in the DataFrame\n        mapped_columns = set(column_mapping.values())\n        available_columns = set(data_frame.columns.tolist())\n        missing_columns = mapped_columns - available_columns\n\n        if missing_columns:\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column: {missing_columns}\",\n            )\n\n        # Create data objects\n        result = []\n        for _, row in data_frame.iterrows():\n            kwargs = {}\n            # Process both required and optional columns\n            for key in required.union(optional):\n                # Find the corresponding column mapping key (handle both snake_case and camelCase)\n                mapped_key = None\n                for mapping_key in column_mapping:\n                    if normalize_key(mapping_key) == normalize_key(key):\n                        mapped_key = mapping_key\n                        break\n\n                if mapped_key:\n                    col_name = column_mapping[mapped_key]\n                    if col_name in data_frame.columns:\n                        value = row[col_name]\n                        kwargs[key] = value\n            data_obj = data_class(**kwargs)\n            result.append(data_obj)\n\n        return result\n\n    @property\n    def data_dict(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the data in dictionary format.\n\n        Converts the series data to a list of dictionaries suitable for\n        frontend serialization. Handles various data formats including\n        dictionaries, lists of dictionaries, or lists of objects with\n        asdict() methods.\n\n        Returns:\n            List[Dict[str, Any]]: List of data dictionaries ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            # Get data as dictionaries\n            data_dicts = series.data_dict\n\n            # Access individual data points\n            for data_point in data_dicts:\n                # Data point contains time and value information\n                pass\n            ```\n        \"\"\"\n        if isinstance(self.data, dict):\n            return self.data  # type: ignore[return-value]\n        if isinstance(self.data, list):\n            if len(self.data) == 0:\n                return []\n            # If already list of dicts\n            if isinstance(self.data[0], dict):\n                return self.data  # type: ignore[return-value]\n                # If list of objects with asdict\n        if hasattr(self.data[0], \"asdict\"):\n            return [item.asdict() for item in self.data]\n        # Fallback: return as-is\n        return self.data  # type: ignore[return-value]\n\n    def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n        \"\"\"Add a marker to this series.\n\n        Adds a marker object to the series for highlighting specific data points\n        or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n        Args:\n            marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If the marker position is not valid for its type.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n             from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                 MarkerPosition, MarkerShape\n             )\n\n            # Add a bar marker\n            bar_marker = BarMarker(\n                time=\"2024-01-01 10:00:00\",\n                position=MarkerPosition.ABOVE_BAR,\n                color=\"red\",\n                shape=MarkerShape.CIRCLE,\n                text=\"Buy Signal\",\n            )\n            series.add_marker(bar_marker)\n\n            # Add a price marker\n            price_marker = PriceMarker(\n                time=1640995200,\n                position=MarkerPosition.AT_PRICE_TOP,\n                color=\"#00ff00\",\n                shape=MarkerShape.ARROW_UP,\n                price=100.50,\n                text=\"Resistance Level\",\n            )\n            series.add_marker(price_marker)\n\n            # Method chaining\n            series.add_marker(marker1).add_marker(marker2)\n            ```\n        \"\"\"\n        # Validate the marker position\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.append(marker)\n        return self\n\n    def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n        \"\"\"Add multiple markers to this series.\n\n        Adds a list of markers to the series. Returns self for method chaining.\n\n        Args:\n            markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If any marker position is not valid for its type.\n        \"\"\"\n        # Validate all markers before adding\n        for marker in markers:\n            if not marker.validate_position():\n                raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.extend(markers)\n        return self\n\n    def clear_markers(self) -&gt; \"Series\":\n        \"\"\"Clear all markers from this series.\n\n        Removes all markers from the series. Returns self for method chaining.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._markers.clear()\n        return self\n\n    def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n        \"\"\"Add a price line option to this series.\n\n        Args:\n            price_line (PriceLineOptions): The price line option to add.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.append(price_line)\n        return self\n\n    def clear_price_lines(self) -&gt; \"Series\":\n        \"\"\"Remove all price line options from this series.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.clear()\n        return self\n\n    def _validate_pane_config(self) -&gt; None:\n        \"\"\"Validate pane configuration for the series.\n\n        This method ensures that pane_id is properly set.\n        It should be called by subclasses in their asdict() method.\n\n        Raises:\n            ValueError: If pane_id is negative.\n        \"\"\"\n        if self._pane_id is not None and self._pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n        if self._pane_id is None:\n            self._pane_id = 0\n\n    def _get_attr_name(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get the attribute name for a given key.\"\"\"\n        # Convert camelCase to snake_case for attribute lookup\n        attr_name: Optional[str] = self._camel_to_snake(key)\n\n        # Check if attribute exists (try multiple variations)\n        # Need to check attr_name is not None before using hasattr\n        if attr_name is not None and not hasattr(self, attr_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                attr_name = key\n            # Try with _ prefix (for private attributes)\n            elif hasattr(self, f\"_{attr_name}\"):\n                attr_name = f\"_{attr_name}\"\n            # Try original key with _ prefix\n            elif hasattr(self, f\"_{key}\"):\n                attr_name = f\"_{key}\"\n            else:\n                # Ignore invalid attributes instead of raising an error\n\n                attr_name = None\n\n        return attr_name\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n        \"\"\"Update series configuration with a dictionary of values.\n\n        This method updates series properties using a configuration dictionary. It supports\n        updating simple attributes, nested options objects, and lists of options. Keys may be\n        in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n        Args:\n            updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n                or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            AttributeError: If an attribute cannot be set due to type or value errors.\n\n        Example:\n            ```python\n            series = LineSeries(data=data)\n            series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n            series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n            series.update(\n                {\n                    \"price_lines\": [\n                        {\"price\": 105, \"color\": \"#00ff00\"},\n                        {\"price\": 110, \"color\": \"#ff0000\"},\n                    ]\n                }\n            )\n            series.update({\"visible\": True}).update({\"pane_id\": 1})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            attr_name = self._get_attr_name(key)\n\n            if attr_name is None:\n                continue\n\n            try:\n                if isinstance(value, dict):\n                    self._update_dict_value(attr_name, value)\n                elif isinstance(value, list):\n                    self._update_list_value(attr_name, value)\n                else:\n                    setattr(self, attr_name, value)\n            except Exception:\n                logger.exception(\"Failed to update attribute '%s'\", attr_name)\n                raise\n\n        return self\n\n    def _update_dict_value(self, attr_name: str, value: dict) -&gt; None:\n        \"\"\"Update a nested options object attribute with a dictionary.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (dict): Dictionary of values to update the nested object.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        if current_value is not None and hasattr(current_value, \"update\"):\n            current_value.update(value)\n            return\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            return\n\n        # Handle Union types (e.g., Optional[T])\n        if getattr(attr_type, \"__origin__\", None) is Union:\n            for arg in attr_type.__args__:\n                if arg is not type(None):\n                    attr_type = arg\n                    break\n\n        if hasattr(attr_type, \"update\"):\n            try:\n                instance = attr_type()\n                setattr(self, attr_name, instance)\n                instance.update(value)\n            except Exception:\n                logger.exception(\"Failed to instantiate or update %s\", attr_name)\n                raise\n        else:\n            # No update method for this attribute\n            pass\n\n    def _update_list_value(self, attr_name: str, value: list) -&gt; None:\n        \"\"\"Update a list attribute, instantiating and updating items as needed.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (list): List of values or dicts to update the list attribute.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            setattr(self, attr_name, value)\n            return\n\n        if getattr(attr_type, \"__origin__\", None) is list:\n            item_type = attr_type.__args__[0]\n\n            if not hasattr(item_type, \"update\"):\n                setattr(self, attr_name, value)\n                return\n\n            if current_value is None:\n                current_value = []\n                setattr(self, attr_name, current_value)\n\n            for _i, item in enumerate(value):\n                if isinstance(item, dict):\n                    try:\n                        instance = item_type()\n                        instance.update(item)\n                        current_value.append(instance)\n                    except Exception:\n                        logger.exception(\n                            \"Failed to instantiate or update list item for %s\",\n                            attr_name,\n                        )\n                        raise\n                else:\n                    current_value.append(item)\n        else:\n            setattr(self, attr_name, value)\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n        \"\"\"\n        import re  # pylint: disable=import-outside-toplevel\n\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert series to dictionary representation.\n\n        This method creates a dictionary representation of the series\n        that can be consumed by the frontend React component.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing series configuration for the frontend.\n        \"\"\"\n        # Validate pane configuration\n        self._validate_pane_config()\n\n        # Get base configuration\n        config = {\n            \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n            \"data\": self.data_dict,\n        }\n\n        # Add options from chainable properties only\n        options = {}\n        for attr_name in dir(self):\n            if attr_name.startswith(\"_\"):\n                continue\n            # Skip data attribute as it's handled separately\n            if attr_name == \"data\":\n                continue\n            # Skip class attributes (like DATA_CLASS)\n            if attr_name.isupper():\n                continue\n            # Skip class properties (like data_class)\n            if attr_name == \"data_class\":\n                continue\n\n            # Rule 1: Only include attributes decorated with chainable_property\n            if not self._is_chainable_property(attr_name):\n                continue\n\n            attr_value = getattr(self, attr_name)\n\n            # Rule 2: Skip if None and allow_none is True\n            if attr_value is None and self._is_allow_none(attr_name):\n                continue\n\n            # Determine if this should go to top level or options\n            is_top_level = self._is_top_level(attr_name)\n\n            # Handle objects with asdict() method\n            if (\n                hasattr(attr_value, \"asdict\")\n                and callable(attr_value.asdict)\n                and not isinstance(attr_value, type)\n            ):\n                # Rule 3: Flatten LineOptions with property name prefix for consistency\n                # This ensures all LineOptions are serialized the same way:\n                # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n                # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n                from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n                if isinstance(attr_value, LineOptions):\n                    line_dict = attr_value.asdict()\n                    # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                    if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                        # Send lineOptions nested - let frontend handle flattening via descriptors\n                        # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                        # based on the series type's descriptor apiMapping\n                        options[\"lineOptions\"] = line_dict\n                    else:\n                        # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                        # Convert the property name to camelCase for the prefix\n                        prefix = snake_to_camel(attr_name)\n                        for line_key, line_value in line_dict.items():\n                            # Capitalize first letter of line property and append to prefix\n                            # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                            # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                            if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                                # Remove 'line' prefix from the key before appending\n                                # lineWidth -&gt; Width, lineStyle -&gt; Style\n                                key_without_line_prefix = line_key[4:]  # Remove 'line'\n                                flattened_key = prefix + key_without_line_prefix\n                            else:\n                                # Normal case: capitalize first letter and append\n                                # e.g., upperLine + color -&gt; upperLineColor\n                                flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                            if is_top_level:\n                                config[flattened_key] = line_value\n                            else:\n                                options[flattened_key] = line_value\n                elif attr_name.endswith(\"_options\"):\n                    # Other options objects (not LineOptions) - flatten without prefix\n                    options.update(attr_value.asdict())\n                else:\n                    # Other objects with asdict() - keep nested\n                    key = snake_to_camel(attr_name)\n                    if is_top_level:\n                        config[key] = attr_value.asdict()\n                    else:\n                        options[key] = attr_value.asdict()\n\n            # Handle lists of objects with asdict() method\n            elif (\n                isinstance(attr_value, list)\n                and attr_value\n                and hasattr(attr_value[0], \"asdict\")\n                and callable(attr_value[0].asdict)\n            ):\n                # Convert list of objects to list of dictionaries\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = [item.asdict() for item in attr_value]\n                else:\n                    options[key] = [item.asdict() for item in attr_value]\n\n            # Also include individual option attributes that are not None\n            elif (\n                not callable(attr_value)\n                and not isinstance(attr_value, type)\n                and attr_value is not None\n            ):\n                # Skip empty lists (they should not be included in configuration)\n                if isinstance(attr_value, list) and not attr_value:\n                    continue\n\n                # Convert snake_case to camelCase for the key\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    # Include empty strings for top-level properties (they are valid)\n                    config[key] = attr_value\n                # Skip empty strings for options (they are not meaningful)\n                elif attr_value != \"\":\n                    options[key] = attr_value\n\n        # Only include options field if it's not empty\n        if options:\n            config[\"options\"] = options\n\n        return config\n\n    def _is_chainable_property(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if an attribute is decorated with chainable_property.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute is a chainable property\n        \"\"\"\n        return (\n            hasattr(self.__class__, \"_chainable_properties\")\n            and attr_name in self.__class__._chainable_properties  # pylint: disable=protected-access\n        )\n\n    def _is_allow_none(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property allows None values.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the property allows None values\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"allow_none\"]  # type: ignore[attr-defined]\n        return False\n\n    def _is_top_level(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property should be output at the top level.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute should be at the top level\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"top_level\"]  # type: ignore[attr-defined]\n        return False\n\n    @classproperty\n    def data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n        \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n        for base in self.__mro__:  # type: ignore[attr-defined]\n            if hasattr(base, \"DATA_CLASS\"):\n                return base.DATA_CLASS\n        raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n\n    @classmethod\n    def from_dataframe(\n        cls,\n        df: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n        price_scale_id: str = \"\",\n        **kwargs,\n    ) -&gt; \"Series\":\n        \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n        Args:\n            df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n            column_mapping (dict): Mapping of required fields\n                (e.g., {'time': 'datetime', 'value': 'close', ...}).\n            price_scale_id (str): Price scale ID (default '').\n            **kwargs: Additional arguments for the Series constructor.\n\n        Returns:\n            Series: An instance of the Series (or subclass) with normalized data.\n\n        Raises:\n            NotImplementedError: If the subclass does not define DATA_CLASS.\n            ValueError: If required columns are missing in column_mapping or DataFrame.\n            AttributeError: If the data class does not define REQUIRED_COLUMNS.\n        \"\"\"\n        # Convert Series to DataFrame if needed\n        dataframe = df\n        if isinstance(dataframe, pd.Series):\n            dataframe = dataframe.to_frame()\n\n        data_class = cls.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check required columns in column_mapping\n        missing_mapping = [col for col in required if col not in column_mapping]\n        if missing_mapping:\n            raise ValueValidationError(\n                \"column_mapping\",\n                f\"missing required columns: {missing_mapping}\",\n            )\n        # Removed print\n\n        # Prepare index for all column mappings\n        data_frame = cls.prepare_index(dataframe, column_mapping)\n\n        # Check required columns in DataFrame (including index) - after processing\n        for key in required:\n            col = column_mapping[key]\n            if col not in data_frame.columns:\n                raise NotFoundError(\"Column\", col)\n            # Removed print\n\n        # Build data objects\n        data = []\n        for i in range(len(dataframe)):\n            kwargs_data = {}\n            for key in required.union(optional):\n                if key in column_mapping:\n                    col = column_mapping[key]\n                    if col in data_frame.columns:\n                        value = data_frame.iloc[i][col]\n                        kwargs_data[key] = value\n                    else:\n                        raise NotFoundError(\"Column\", col)\n                else:\n                    # Skip optional columns that are not in column_mapping\n                    continue\n\n            data.append(data_class(**kwargs_data))\n\n        return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.data_dict","title":"data_dict  <code>property</code>","text":"<pre><code>data_dict: List[Dict[str, Any]]\n</code></pre> <p>Get the data in dictionary format.</p> <p>Converts the series data to a list of dictionaries suitable for frontend serialization. Handles various data formats including dictionaries, lists of dictionaries, or lists of objects with asdict() methods.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of data dictionaries ready for frontend consumption.</p> Example <pre><code># Get data as dictionaries\ndata_dicts = series.data_dict\n\n# Access individual data points\nfor data_point in data_dicts:\n    # Data point contains time and value information\n    pass\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.prepare_index","title":"prepare_index  <code>staticmethod</code>","text":"<pre><code>prepare_index(data_frame: DataFrame, column_mapping: Dict[str, str]) -&gt; DataFrame\n</code></pre> <p>Prepare index for column mapping.</p> <p>Handles all index-related column mapping cases: - Time column mapping with DatetimeIndex - Level position mapping (e.g., \"0\", \"1\") - \"index\" mapping (first unnamed level or level 0) - Named level mapping (e.g., \"date\", \"symbol\") - Single index reset for non-time columns</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>DataFrame to prepare</p> required <code>column_mapping</code> <code>Dict[str, str]</code> <p>Mapping of required fields to column names</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with prepared index</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time column is not found and no DatetimeIndex is available</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@staticmethod\ndef prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n    \"\"\"Prepare index for column mapping.\n\n    Handles all index-related column mapping cases:\n    - Time column mapping with DatetimeIndex\n    - Level position mapping (e.g., \"0\", \"1\")\n    - \"index\" mapping (first unnamed level or level 0)\n    - Named level mapping (e.g., \"date\", \"symbol\")\n    - Single index reset for non-time columns\n\n    Args:\n        data_frame: DataFrame to prepare\n        column_mapping: Mapping of required fields to column names\n\n    Returns:\n        DataFrame with prepared index\n\n    Raises:\n        ValueError: If time column is not found and no DatetimeIndex is available\n    \"\"\"\n    # Handle time column mapping first (special case for DatetimeIndex)\n    if \"time\" in column_mapping:\n        time_col = column_mapping[\"time\"]\n        if time_col not in data_frame.columns:\n            # Handle single DatetimeIndex\n            if isinstance(data_frame.index, pd.DatetimeIndex):\n                if data_frame.index.name is None:\n                    # Set name and reset index to make it a regular column\n                    data_frame.index.name = time_col\n                    data_frame = data_frame.reset_index()\n                elif data_frame.index.name == time_col:\n                    # Index name already matches, just reset to make it a regular column\n                    data_frame = data_frame.reset_index()\n\n            # Handle MultiIndex with DatetimeIndex level\n            elif isinstance(data_frame.index, pd.MultiIndex):\n                for i, level in enumerate(data_frame.index.levels):\n                    if isinstance(level, pd.DatetimeIndex):\n                        if data_frame.index.names[i] is None:\n                            # Set name for this level and reset it\n                            new_names = list(data_frame.index.names)\n                            new_names[i] = time_col\n                            data_frame.index.names = new_names\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                        if data_frame.index.names[i] == time_col:\n                            # Level name already matches, reset this level\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                else:\n                    # No DatetimeIndex level found, check if any level name matches\n                    if time_col in data_frame.index.names or time_col == \"index\":\n                        # Reset the entire MultiIndex to get all levels as columns\n                        data_frame = data_frame.reset_index()\n                    else:\n                        # Check if time_col is an integer level position\n                        try:\n                            level_idx = int(time_col)\n                            if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                # Reset the entire MultiIndex to get all levels as columns\n                                data_frame = data_frame.reset_index()\n                            else:\n                                # Invalid level position, just pass through\n                                pass\n                        except ValueError:\n                            # Not an integer, just pass through\n                            pass\n            # No DatetimeIndex found\n            # Check if time_col is \"index\" and we have a regular index to reset\n            elif time_col == \"index\":\n                # Reset the index to make it a regular column\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[\"time\"] = new_col_name\n            elif time_col == data_frame.index.name:\n                # Time column matches index name, reset the index\n                data_frame = data_frame.reset_index()\n            else:\n                raise NotFoundError(\"Time Column\", time_col)\n\n    # Handle other index columns\n    for field, col_name in column_mapping.items():\n        if field == \"time\":\n            continue  # Already handled above\n\n        if col_name not in data_frame.columns:\n            if isinstance(data_frame.index, pd.MultiIndex):\n                level_names = list(data_frame.index.names)\n\n                # Integer string or int: treat as level position\n                try:\n                    level_idx = int(col_name)\n                    if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        # Update column mapping to use actual column name\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n                except (ValueError, IndexError):\n                    pass\n\n                # 'index': use first unnamed level if any, else first level\n                if col_name == \"index\":\n                    unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                    level_idx = unnamed_levels[0] if unnamed_levels else 0\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    level_name = level_names[level_idx]\n                    new_col_name = (\n                        level_name if level_name is not None else f\"level_{level_idx}\"\n                    )\n                    column_mapping[field] = new_col_name\n                    continue\n\n                # Named level\n                if col_name in level_names:\n                    level_idx = level_names.index(col_name)\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    continue\n\n            # Single index\n            elif col_name in (\"index\", data_frame.index.name):\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[field] = new_col_name\n                continue\n\n    return data_frame\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_marker","title":"add_marker","text":"<pre><code>add_marker(marker: MarkerBase) -&gt; Series\n</code></pre> <p>Add a marker to this series.</p> <p>Adds a marker object to the series for highlighting specific data points or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>MarkerBase</code> <p>The marker object to add. Must be a BarMarker or PriceMarker.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker position is not valid for its type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n from streamlit_lightweight_charts_pro.type_definitions.enums import (\n     MarkerPosition, MarkerShape\n )\n\n# Add a bar marker\nbar_marker = BarMarker(\n    time=\"2024-01-01 10:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    color=\"red\",\n    shape=MarkerShape.CIRCLE,\n    text=\"Buy Signal\",\n)\nseries.add_marker(bar_marker)\n\n# Add a price marker\nprice_marker = PriceMarker(\n    time=1640995200,\n    position=MarkerPosition.AT_PRICE_TOP,\n    color=\"#00ff00\",\n    shape=MarkerShape.ARROW_UP,\n    price=100.50,\n    text=\"Resistance Level\",\n)\nseries.add_marker(price_marker)\n\n# Method chaining\nseries.add_marker(marker1).add_marker(marker2)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n    \"\"\"Add a marker to this series.\n\n    Adds a marker object to the series for highlighting specific data points\n    or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n    Args:\n        marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If the marker position is not valid for its type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n         from streamlit_lightweight_charts_pro.type_definitions.enums import (\n             MarkerPosition, MarkerShape\n         )\n\n        # Add a bar marker\n        bar_marker = BarMarker(\n            time=\"2024-01-01 10:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            color=\"red\",\n            shape=MarkerShape.CIRCLE,\n            text=\"Buy Signal\",\n        )\n        series.add_marker(bar_marker)\n\n        # Add a price marker\n        price_marker = PriceMarker(\n            time=1640995200,\n            position=MarkerPosition.AT_PRICE_TOP,\n            color=\"#00ff00\",\n            shape=MarkerShape.ARROW_UP,\n            price=100.50,\n            text=\"Resistance Level\",\n        )\n        series.add_marker(price_marker)\n\n        # Method chaining\n        series.add_marker(marker1).add_marker(marker2)\n        ```\n    \"\"\"\n    # Validate the marker position\n    if not marker.validate_position():\n        raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.append(marker)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_markers","title":"add_markers","text":"<pre><code>add_markers(markers: List[MarkerBase]) -&gt; Series\n</code></pre> <p>Add multiple markers to this series.</p> <p>Adds a list of markers to the series. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>List[MarkerBase]</code> <p>List of marker objects to add. Must be MarkerBase subclasses.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any marker position is not valid for its type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n    \"\"\"Add multiple markers to this series.\n\n    Adds a list of markers to the series. Returns self for method chaining.\n\n    Args:\n        markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If any marker position is not valid for its type.\n    \"\"\"\n    # Validate all markers before adding\n    for marker in markers:\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.extend(markers)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.clear_markers","title":"clear_markers","text":"<pre><code>clear_markers() -&gt; Series\n</code></pre> <p>Clear all markers from this series.</p> <p>Removes all markers from the series. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_markers(self) -&gt; \"Series\":\n    \"\"\"Clear all markers from this series.\n\n    Removes all markers from the series. Returns self for method chaining.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._markers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_price_line","title":"add_price_line","text":"<pre><code>add_price_line(price_line: PriceLineOptions) -&gt; Series\n</code></pre> <p>Add a price line option to this series.</p> <p>Parameters:</p> Name Type Description Default <code>price_line</code> <code>PriceLineOptions</code> <p>The price line option to add.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n    \"\"\"Add a price line option to this series.\n\n    Args:\n        price_line (PriceLineOptions): The price line option to add.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.append(price_line)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.clear_price_lines","title":"clear_price_lines","text":"<pre><code>clear_price_lines() -&gt; Series\n</code></pre> <p>Remove all price line options from this series.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_price_lines(self) -&gt; \"Series\":\n    \"\"\"Remove all price line options from this series.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Series\n</code></pre> <p>Update series configuration with a dictionary of values.</p> <p>This method updates series properties using a configuration dictionary. It supports updating simple attributes, nested options objects, and lists of options. Keys may be in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types, dictionaries for nested objects, or lists.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute cannot be set due to type or value errors.</p> Example <pre><code>series = LineSeries(data=data)\nseries.update({\"visible\": False, \"price_scale_id\": \"left\"})\nseries.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\nseries.update(\n    {\n        \"price_lines\": [\n            {\"price\": 105, \"color\": \"#00ff00\"},\n            {\"price\": 110, \"color\": \"#ff0000\"},\n        ]\n    }\n)\nseries.update({\"visible\": True}).update({\"pane_id\": 1})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n    \"\"\"Update series configuration with a dictionary of values.\n\n    This method updates series properties using a configuration dictionary. It supports\n    updating simple attributes, nested options objects, and lists of options. Keys may be\n    in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n    Args:\n        updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n            or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        AttributeError: If an attribute cannot be set due to type or value errors.\n\n    Example:\n        ```python\n        series = LineSeries(data=data)\n        series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n        series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n        series.update(\n            {\n                \"price_lines\": [\n                    {\"price\": 105, \"color\": \"#00ff00\"},\n                    {\"price\": 110, \"color\": \"#ff0000\"},\n                ]\n            }\n        )\n        series.update({\"visible\": True}).update({\"pane_id\": 1})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        attr_name = self._get_attr_name(key)\n\n        if attr_name is None:\n            continue\n\n        try:\n            if isinstance(value, dict):\n                self._update_dict_value(attr_name, value)\n            elif isinstance(value, list):\n                self._update_list_value(attr_name, value)\n            else:\n                setattr(self, attr_name, value)\n        except Exception:\n            logger.exception(\"Failed to update attribute '%s'\", attr_name)\n            raise\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert series to dictionary representation.</p> <p>This method creates a dictionary representation of the series that can be consumed by the frontend React component.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing series configuration for the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert series to dictionary representation.\n\n    This method creates a dictionary representation of the series\n    that can be consumed by the frontend React component.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing series configuration for the frontend.\n    \"\"\"\n    # Validate pane configuration\n    self._validate_pane_config()\n\n    # Get base configuration\n    config = {\n        \"type\": self.chart_type.value,  # type: ignore[attr-defined]\n        \"data\": self.data_dict,\n    }\n\n    # Add options from chainable properties only\n    options = {}\n    for attr_name in dir(self):\n        if attr_name.startswith(\"_\"):\n            continue\n        # Skip data attribute as it's handled separately\n        if attr_name == \"data\":\n            continue\n        # Skip class attributes (like DATA_CLASS)\n        if attr_name.isupper():\n            continue\n        # Skip class properties (like data_class)\n        if attr_name == \"data_class\":\n            continue\n\n        # Rule 1: Only include attributes decorated with chainable_property\n        if not self._is_chainable_property(attr_name):\n            continue\n\n        attr_value = getattr(self, attr_name)\n\n        # Rule 2: Skip if None and allow_none is True\n        if attr_value is None and self._is_allow_none(attr_name):\n            continue\n\n        # Determine if this should go to top level or options\n        is_top_level = self._is_top_level(attr_name)\n\n        # Handle objects with asdict() method\n        if (\n            hasattr(attr_value, \"asdict\")\n            and callable(attr_value.asdict)\n            and not isinstance(attr_value, type)\n        ):\n            # Rule 3: Flatten LineOptions with property name prefix for consistency\n            # This ensures all LineOptions are serialized the same way:\n            # upper_line -&gt; upperLineColor, upperLineWidth, upperLineStyle\n            # line_options -&gt; color, lineWidth, lineStyle (backward compatible)\n            from streamlit_lightweight_charts_pro.charts.options.line_options import LineOptions\n\n            if isinstance(attr_value, LineOptions):\n                line_dict = attr_value.asdict()\n                # If property ends with _options or is named line_options, send nested as 'lineOptions'\n                if attr_name.endswith(\"_options\") or attr_name == \"line_options\":\n                    # Send lineOptions nested - let frontend handle flattening via descriptors\n                    # This is cleaner: frontend knows the correct property names (color vs lineColor)\n                    # based on the series type's descriptor apiMapping\n                    options[\"lineOptions\"] = line_dict\n                else:\n                    # Flatten with property name as prefix (e.g., upper_line -&gt; upperLine*)\n                    # Convert the property name to camelCase for the prefix\n                    prefix = snake_to_camel(attr_name)\n                    for line_key, line_value in line_dict.items():\n                        # Capitalize first letter of line property and append to prefix\n                        # Special handling: if line_key starts with 'line' and prefix ends with 'Line',\n                        # don't duplicate 'Line' (e.g., upperLine + lineWidth -&gt; upperLineWidth, not upperLineLineWidth)\n                        if line_key.startswith(\"line\") and prefix.endswith(\"Line\"):\n                            # Remove 'line' prefix from the key before appending\n                            # lineWidth -&gt; Width, lineStyle -&gt; Style\n                            key_without_line_prefix = line_key[4:]  # Remove 'line'\n                            flattened_key = prefix + key_without_line_prefix\n                        else:\n                            # Normal case: capitalize first letter and append\n                            # e.g., upperLine + color -&gt; upperLineColor\n                            flattened_key = prefix + line_key[0].upper() + line_key[1:]\n\n                        if is_top_level:\n                            config[flattened_key] = line_value\n                        else:\n                            options[flattened_key] = line_value\n            elif attr_name.endswith(\"_options\"):\n                # Other options objects (not LineOptions) - flatten without prefix\n                options.update(attr_value.asdict())\n            else:\n                # Other objects with asdict() - keep nested\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = attr_value.asdict()\n                else:\n                    options[key] = attr_value.asdict()\n\n        # Handle lists of objects with asdict() method\n        elif (\n            isinstance(attr_value, list)\n            and attr_value\n            and hasattr(attr_value[0], \"asdict\")\n            and callable(attr_value[0].asdict)\n        ):\n            # Convert list of objects to list of dictionaries\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                config[key] = [item.asdict() for item in attr_value]\n            else:\n                options[key] = [item.asdict() for item in attr_value]\n\n        # Also include individual option attributes that are not None\n        elif (\n            not callable(attr_value)\n            and not isinstance(attr_value, type)\n            and attr_value is not None\n        ):\n            # Skip empty lists (they should not be included in configuration)\n            if isinstance(attr_value, list) and not attr_value:\n                continue\n\n            # Convert snake_case to camelCase for the key\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                # Include empty strings for top-level properties (they are valid)\n                config[key] = attr_value\n            # Skip empty strings for options (they are not meaningful)\n            elif attr_value != \"\":\n                options[key] = attr_value\n\n    # Only include options field if it's not empty\n    if options:\n        config[\"options\"] = options\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.data_class","title":"data_class","text":"<pre><code>data_class() -&gt; Type[Data]\n</code></pre> <p>Return the first DATA_CLASS found in the MRO (most-derived class wins).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classproperty\ndef data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n    \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n    for base in self.__mro__:  # type: ignore[attr-defined]\n        if hasattr(base, \"DATA_CLASS\"):\n            return base.DATA_CLASS\n    raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: Union[DataFrame, Series], column_mapping: Dict[str, str], price_scale_id: str = '', **kwargs) -&gt; Series\n</code></pre> <p>Create a Series instance from a pandas DataFrame or Series.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Union[DataFrame, Series]</code> <p>The input DataFrame or Series.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields (e.g., {'time': 'datetime', 'value': 'close', ...}).</p> required <code>price_scale_id</code> <code>str</code> <p>Price scale ID (default '').</p> <code>''</code> <code>**kwargs</code> <p>Additional arguments for the Series constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>An instance of the Series (or subclass) with normalized data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the subclass does not define DATA_CLASS.</p> <code>ValueError</code> <p>If required columns are missing in column_mapping or DataFrame.</p> <code>AttributeError</code> <p>If the data class does not define REQUIRED_COLUMNS.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classmethod\ndef from_dataframe(\n    cls,\n    df: Union[pd.DataFrame, pd.Series],\n    column_mapping: Dict[str, str],\n    price_scale_id: str = \"\",\n    **kwargs,\n) -&gt; \"Series\":\n    \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n    Args:\n        df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n        column_mapping (dict): Mapping of required fields\n            (e.g., {'time': 'datetime', 'value': 'close', ...}).\n        price_scale_id (str): Price scale ID (default '').\n        **kwargs: Additional arguments for the Series constructor.\n\n    Returns:\n        Series: An instance of the Series (or subclass) with normalized data.\n\n    Raises:\n        NotImplementedError: If the subclass does not define DATA_CLASS.\n        ValueError: If required columns are missing in column_mapping or DataFrame.\n        AttributeError: If the data class does not define REQUIRED_COLUMNS.\n    \"\"\"\n    # Convert Series to DataFrame if needed\n    dataframe = df\n    if isinstance(dataframe, pd.Series):\n        dataframe = dataframe.to_frame()\n\n    data_class = cls.data_class\n    required = data_class.required_columns\n    optional = data_class.optional_columns\n\n    # Check required columns in column_mapping\n    missing_mapping = [col for col in required if col not in column_mapping]\n    if missing_mapping:\n        raise ValueValidationError(\n            \"column_mapping\",\n            f\"missing required columns: {missing_mapping}\",\n        )\n    # Removed print\n\n    # Prepare index for all column mappings\n    data_frame = cls.prepare_index(dataframe, column_mapping)\n\n    # Check required columns in DataFrame (including index) - after processing\n    for key in required:\n        col = column_mapping[key]\n        if col not in data_frame.columns:\n            raise NotFoundError(\"Column\", col)\n        # Removed print\n\n    # Build data objects\n    data = []\n    for i in range(len(dataframe)):\n        kwargs_data = {}\n        for key in required.union(optional):\n            if key in column_mapping:\n                col = column_mapping[key]\n                if col in data_frame.columns:\n                    value = data_frame.iloc[i][col]\n                    kwargs_data[key] = value\n                else:\n                    raise NotFoundError(\"Column\", col)\n            else:\n                # Skip optional columns that are not in column_mapping\n                continue\n\n        data.append(data_class(**kwargs_data))\n\n    return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html","title":"streamlit_lightweight_charts_pro.charts.series.baseline","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline","title":"baseline","text":"<p>Baseline series for streamlit-lightweight-charts.</p> <p>This module provides the BaselineSeries class for creating baseline charts that display areas above and below a baseline value with different colors. Baseline series are commonly used for highlighting positive/negative trends and threshold analysis.</p> <p>The BaselineSeries class supports various styling options for the baseline, fill colors, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BaselineSeries from streamlit_lightweight_charts_pro.data.baseline_data import BaselineData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline--create-baseline-data","title":"Create baseline data","text":"<p>data = [     BaselineData(time=1640995200, value=100.5),     BaselineData(time=1641081600, value=105.2) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline--create-baseline-series-with-styling","title":"Create baseline series with styling","text":"<p>series = BaselineSeries(data=data) series.base_value = {\"type\": \"price\", \"price\": 100} series.top_line_color = \"#26a69a\" series.bottom_line_color = \"#ef5350\"</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries","title":"BaselineSeries","text":"<p>Baseline series for lightweight charts.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/baseline.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=_validate_base_value_static)\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"top_fill_color1\", str, validator=\"color\")\n@chainable_property(\"top_fill_color2\", str, validator=\"color\")\n@chainable_property(\"top_line_color\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color1\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color2\", str, validator=\"color\")\n@chainable_property(\"bottom_line_color\", str, validator=\"color\")\nclass BaselineSeries(Series):\n    \"\"\"Baseline series for lightweight charts.\"\"\"\n\n    DATA_CLASS = BaselineData\n\n    def __init__(\n        self,\n        data: Union[List[BaselineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize LineOptions for common line properties\n        self._line_options = LineOptions()\n\n        # Baseline-specific properties (not in LineOptions) - set default values internally\n        self._base_value = self._validate_base_value({\"type\": \"price\", \"price\": 0})\n        self._relative_gradient = False\n        self._top_fill_color1 = BASELINE_TOP_FILL_COLOR1\n        self._top_fill_color2 = BASELINE_TOP_FILL_COLOR2\n        self._top_line_color = BASELINE_TOP_LINE_COLOR\n        self._bottom_fill_color1 = BASELINE_BOTTOM_FILL_COLOR1\n        self._bottom_fill_color2 = BASELINE_BOTTOM_FILL_COLOR2\n        self._bottom_line_color = BASELINE_BOTTOM_LINE_COLOR\n\n    def _validate_base_value(self, base_value: Union[int, float, Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate and normalize base_value.\"\"\"\n        if isinstance(base_value, (int, float)):\n            return {\"type\": \"price\", \"price\": float(base_value)}\n        if isinstance(base_value, dict):\n            if \"type\" not in base_value or \"price\" not in base_value:\n                raise BaseValueFormatError()\n            return {\"type\": str(base_value[\"type\"]), \"price\": float(base_value[\"price\"])}\n        raise BaseValueFormatError()\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BASELINE\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html","title":"streamlit_lightweight_charts_pro.charts.series.candlestick","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick","title":"candlestick","text":"<p>Candlestick series for Streamlit Lightweight Charts Pro.</p> <p>This module provides the CandlestickSeries class for creating candlestick charts that display OHLC or OHLCV data. Candlestick series are commonly used for price charts and technical analysis in financial visualization, providing a comprehensive view of price action.</p> <p>The CandlestickSeries class supports extensive styling options for up/down colors, wicks, borders, and animation effects. It also supports markers, price line configurations, trade visualizations, and various customization options through chainable properties.</p> The module includes <ul> <li>CandlestickSeries: Main class for creating candlestick chart series</li> <li>Color validation and styling options</li> <li>DataFrame support with column mapping</li> <li>Method chaining for fluent API usage</li> </ul> Key Features <ul> <li>Support for CandlestickData and OHLC data types</li> <li>Comprehensive color customization (up/down, border, wick colors)</li> <li>Visibility controls for wicks and borders</li> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line support</li> <li>Method chaining for fluent configuration</li> <li>Color format validation</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries","title":"CandlestickSeries","text":"<p>Candlestick series for creating OHLC candlestick charts in financial visualization.</p> <p>This class represents a candlestick series that displays OHLC (Open, High, Low, Close) data as candlestick bars. It's commonly used for price charts, technical analysis, and comprehensive price action visualization in financial applications.</p> <p>The CandlestickSeries extends the base Series class with candlestick-specific functionality and supports extensive styling options through chainable properties. It provides comprehensive color customization for bullish/bearish candles, wicks, borders, and other visual elements.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[CandlestickData], DataFrame, Series]</code> <p>Data points for the candlestick series. Can be a list of CandlestickData objects, a pandas DataFrame, or a pandas Series.</p> <code>up_color</code> <code>str</code> <p>Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).</p> <code>down_color</code> <code>str</code> <p>Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).</p> <code>wick_visible</code> <code>bool</code> <p>Whether wicks are visible. Defaults to True.</p> <code>border_visible</code> <code>bool</code> <p>Whether borders are visible. Defaults to False.</p> <code>border_color</code> <code>str</code> <p>General border color. Defaults to \"#378658\" (green).</p> <code>border_up_color</code> <code>str</code> <p>Border color for bullish candles. Defaults to \"#26a69a\".</p> <code>border_down_color</code> <code>str</code> <p>Border color for bearish candles. Defaults to \"#ef5350\".</p> <code>wick_color</code> <code>str</code> <p>General wick color. Defaults to \"#737375\" (gray).</p> <code>wick_up_color</code> <code>str</code> <p>Wick color for bullish candles. Defaults to \"#26a69a\".</p> <code>wick_down_color</code> <code>str</code> <p>Wick color for bearish candles. Defaults to \"#ef5350\".</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (CandlestickData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. CandlestickData: Data class for candlestick chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/candlestick.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"wick_visible\", bool)\n@chainable_property(\"border_visible\", bool)\n@chainable_property(\"border_color\", str, validator=\"color\")\n@chainable_property(\"border_up_color\", str, validator=\"color\")\n@chainable_property(\"border_down_color\", str, validator=\"color\")\n@chainable_property(\"wick_color\", str, validator=\"color\")\n@chainable_property(\"wick_up_color\", str, validator=\"color\")\n@chainable_property(\"wick_down_color\", str, validator=\"color\")\nclass CandlestickSeries(Series):\n    \"\"\"Candlestick series for creating OHLC candlestick charts in financial visualization.\n\n    This class represents a candlestick series that displays OHLC (Open, High, Low, Close)\n    data as candlestick bars. It's commonly used for price charts, technical analysis,\n    and comprehensive price action visualization in financial applications.\n\n    The CandlestickSeries extends the base Series class with candlestick-specific\n    functionality and supports extensive styling options through chainable properties.\n    It provides comprehensive color customization for bullish/bearish candles,\n    wicks, borders, and other visual elements.\n\n    Attributes:\n        data (Union[List[CandlestickData], pd.DataFrame, pd.Series]): Data points for\n            the candlestick series. Can be a list of CandlestickData objects,\n            a pandas DataFrame, or a pandas Series.\n        up_color (str): Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).\n        down_color (str): Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).\n        wick_visible (bool): Whether wicks are visible. Defaults to True.\n        border_visible (bool): Whether borders are visible. Defaults to False.\n        border_color (str): General border color. Defaults to \"#378658\" (green).\n        border_up_color (str): Border color for bullish candles. Defaults to \"#26a69a\".\n        border_down_color (str): Border color for bearish candles. Defaults to \"#ef5350\".\n        wick_color (str): General wick color. Defaults to \"#737375\" (gray).\n        wick_up_color (str): Wick color for bullish candles. Defaults to \"#26a69a\".\n        wick_down_color (str): Wick color for bearish candles. Defaults to \"#ef5350\".\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (CandlestickData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data\n        data = [\n            CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n            CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n        ]\n\n        # Create candlestick series with styling\n        series = (\n            CandlestickSeries(data=data)\n            .set_up_color(\"#4CAF50\")\n            .set_down_color(\"#F44336\")\n            .set_border_visible(True)\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        CandlestickData: Data class for candlestick chart data points.\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = CandlestickData\n\n    def __init__(\n        self,\n        data: Union[List[CandlestickData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a CandlestickSeries instance with data and configuration options.\n\n        This constructor initializes a candlestick series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes candlestick-specific styling properties with default values.\n\n        Args:\n            data: Data points for the candlestick series. Can be a list of\n                CandlestickData objects, a pandas DataFrame, or a pandas Series.\n                If DataFrame is provided, column_mapping can be used to specify\n                field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize candlestick-specific properties with default values\n        # Up color for bullish candles - defaults to teal\n        self._up_color = \"#26a69a\"\n        # Down color for bearish candles - defaults to red\n        self._down_color = \"#ef5350\"\n        # Wick visibility - defaults to True (wicks visible)\n        self._wick_visible = True\n        # Border visibility - defaults to False (borders hidden)\n        self._border_visible = False\n        # General border color - defaults to green\n        self._border_color = \"#378658\"\n        # Border color for bullish candles - defaults to teal\n        self._border_up_color = \"#26a69a\"\n        # Border color for bearish candles - defaults to red\n        self._border_down_color = \"#ef5350\"\n        # General wick color - defaults to gray\n        self._wick_color = \"#737375\"\n        # Wick color for bullish candles - defaults to teal\n        self._wick_up_color = \"#26a69a\"\n        # Wick color for bearish candles - defaults to red\n        self._wick_down_color = \"#ef5350\"\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format for candlestick styling properties.\n\n        This method validates that the provided color string is in a valid\n        format (hex or rgba) for use in candlestick styling. It's used\n        internally by the chainable property validators.\n\n        Args:\n            color: The color string to validate in hex or rgba format.\n            property_name: The name of the property being validated (for error messages).\n\n        Returns:\n            str: The validated color string.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for candlestick charts.\n        \"\"\"\n        return ChartType.CANDLESTICK\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for candlestick charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html","title":"streamlit_lightweight_charts_pro.charts.series.defaults","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults","title":"defaults","text":"<p>Default configurations for series line options.</p> <p>This module provides default line option configurations used across multiple series types. Using centralized defaults ensures consistency and makes it easier to maintain the visual style across the charting library.</p> <p>These defaults follow a color-coded semantic scheme: - Green (#4CAF50): Upper lines, uptrends, positive movement - Blue (#2196F3): Middle lines, neutral reference - Red (#F44336): Lower lines, downtrends, negative movement - Gray (#666666): Base lines, hidden reference lines</p> <p>Google-style docstrings are used throughout.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_upper_line","title":"create_upper_line","text":"<pre><code>create_upper_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for upper lines.</p> <p>Used for: - Band series upper line - Ribbon series upper line - Trend fill uptrend line</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured with green color, standard width, solid style.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_upper_line() -&gt; LineOptions:\n    \"\"\"Create default line options for upper lines.\n\n    Used for:\n    - Band series upper line\n    - Ribbon series upper line\n    - Trend fill uptrend line\n\n    Returns:\n        LineOptions configured with green color, standard width, solid style.\n    \"\"\"\n    return LineOptions(\n        color=COLOR_UPPER_GREEN, line_width=LINE_WIDTH_STANDARD, line_style=LineStyle.SOLID\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_middle_line","title":"create_middle_line","text":"<pre><code>create_middle_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for middle lines.</p> <p>Used for: - Band series middle line</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured with blue color, standard width, solid style.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_middle_line() -&gt; LineOptions:\n    \"\"\"Create default line options for middle lines.\n\n    Used for:\n    - Band series middle line\n\n    Returns:\n        LineOptions configured with blue color, standard width, solid style.\n    \"\"\"\n    return LineOptions(\n        color=COLOR_MIDDLE_BLUE, line_width=LINE_WIDTH_STANDARD, line_style=LineStyle.SOLID\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_lower_line","title":"create_lower_line","text":"<pre><code>create_lower_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for lower lines.</p> <p>Used for: - Band series lower line - Ribbon series lower line - Trend fill downtrend line</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured with red color, standard width, solid style.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_lower_line() -&gt; LineOptions:\n    \"\"\"Create default line options for lower lines.\n\n    Used for:\n    - Band series lower line\n    - Ribbon series lower line\n    - Trend fill downtrend line\n\n    Returns:\n        LineOptions configured with red color, standard width, solid style.\n    \"\"\"\n    return LineOptions(\n        color=COLOR_LOWER_RED, line_width=LINE_WIDTH_STANDARD, line_style=LineStyle.SOLID\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_base_line","title":"create_base_line","text":"<pre><code>create_base_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for hidden base/reference lines.</p> <p>Used for: - Trend fill base line (reference line for fill area)</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured with gray color, thin width, dotted style, hidden.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_base_line() -&gt; LineOptions:\n    \"\"\"Create default line options for hidden base/reference lines.\n\n    Used for:\n    - Trend fill base line (reference line for fill area)\n\n    Returns:\n        LineOptions configured with gray color, thin width, dotted style, hidden.\n    \"\"\"\n    return LineOptions(\n        color=COLOR_BASE_GRAY,\n        line_width=LINE_WIDTH_THIN,\n        line_style=LineStyle.DOTTED,\n        line_visible=False,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_uptrend_line","title":"create_uptrend_line","text":"<pre><code>create_uptrend_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for uptrend lines.</p> <p>Alias for create_upper_line() with more descriptive name for trend-based series.</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured for uptrend visualization (green, solid).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_uptrend_line() -&gt; LineOptions:\n    \"\"\"Create default line options for uptrend lines.\n\n    Alias for create_upper_line() with more descriptive name for trend-based series.\n\n    Returns:\n        LineOptions configured for uptrend visualization (green, solid).\n    \"\"\"\n    return create_upper_line()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/defaults.html#streamlit_lightweight_charts_pro.charts.series.defaults.create_downtrend_line","title":"create_downtrend_line","text":"<pre><code>create_downtrend_line() -&gt; LineOptions\n</code></pre> <p>Create default line options for downtrend lines.</p> <p>Alias for create_lower_line() with more descriptive name for trend-based series.</p> <p>Returns:</p> Type Description <code>LineOptions</code> <p>LineOptions configured for downtrend visualization (red, solid).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/defaults.py</code> <pre><code>def create_downtrend_line() -&gt; LineOptions:\n    \"\"\"Create default line options for downtrend lines.\n\n    Alias for create_lower_line() with more descriptive name for trend-based series.\n\n    Returns:\n        LineOptions configured for downtrend visualization (red, solid).\n    \"\"\"\n    return create_lower_line()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html","title":"streamlit_lightweight_charts_pro.charts.series.gradient_ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon","title":"gradient_ribbon","text":"<p>Gradient ribbon series for streamlit-lightweight-charts.</p> <p>This module provides the GradientRibbonSeries class for creating ribbon charts that display upper and lower bands with gradient fill areas based on gradient values.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries","title":"GradientRibbonSeries","text":"<p>Gradient ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with gradient fill areas based on gradient values. It extends RibbonSeries with gradient fill capabilities, allowing for dynamic color transitions based on data values.</p> <p>The GradientRibbonSeries supports various styling options including separate line styling for each band via LineOptions, and gradient color effects based on data values.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>gradient_start_color</code> <p>Starting color for gradient fills (minimum value).</p> <code>gradient_end_color</code> <p>Ending color for gradient fills (maximum value).</p> <code>normalize_gradients</code> <p>Whether to normalize gradient values to 0-1 range.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>@chainable_property(\"gradient_start_color\", str, validator=\"color\")\n@chainable_property(\"gradient_end_color\", str, validator=\"color\")\n@chainable_property(\"normalize_gradients\", bool)\nclass GradientRibbonSeries(RibbonSeries):\n    \"\"\"Gradient ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with gradient fill areas based on gradient values. It extends RibbonSeries\n    with gradient fill capabilities, allowing for dynamic color transitions\n    based on data values.\n\n    The GradientRibbonSeries supports various styling options including separate\n    line styling for each band via LineOptions, and gradient color effects based\n    on data values.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_visible: Whether to display the fill area.\n        gradient_start_color: Starting color for gradient fills (minimum value).\n        gradient_end_color: Ending color for gradient fills (maximum value).\n        normalize_gradients: Whether to normalize gradient values to 0-1 range.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = GradientRibbonData\n\n    def __init__(\n        self,\n        data: Union[List[GradientRibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        gradient_start_color: str = \"#4CAF50\",\n        gradient_end_color: str = \"#F44336\",\n        normalize_gradients: bool = False,\n    ):\n        \"\"\"Initialize GradientRibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            gradient_start_color: Starting color for gradient fills\n            gradient_end_color: Ending color for gradient fills\n            normalize_gradients: Whether to normalize gradient values to 0-1 range\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize gradient-specific properties\n        self._gradient_start_color = gradient_start_color\n        self._gradient_end_color = gradient_end_color\n        self._normalize_gradients = normalize_gradients\n        self._gradient_bounds: Optional[tuple[float, float]] = None\n\n        # Performance optimization: cache normalized results\n        self._normalized_cache: Optional[dict] = None\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.GRADIENT_RIBBON\n\n    def _invalidate_cache(self) -&gt; None:\n        \"\"\"Invalidate the normalized data cache.\n\n        This method should be called whenever the data changes to ensure\n        the cached normalized results are recalculated on the next asdict() call.\n        \"\"\"\n        self._normalized_cache = None\n        self._gradient_bounds = None\n\n    def update(self, updates: dict):\n        \"\"\"Override update to invalidate cache when data changes.\n\n        Args:\n            updates: Dictionary of updates to apply.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        # Invalidate cache before updating\n        self._invalidate_cache()\n        # Call parent update\n        return super().update(updates)\n\n    @property\n    def data(self):\n        \"\"\"Get the series data.\"\"\"\n        return self._data if hasattr(self, \"_data\") else []\n\n    @data.setter\n    def data(self, value):\n        \"\"\"Set the series data and invalidate cache.\n\n        Args:\n            value: New data to set.\n        \"\"\"\n        self._data = value\n        self._invalidate_cache()\n\n    def _calculate_gradient_bounds(self) -&gt; None:\n        \"\"\"Calculate min/max gradient values for normalization with optimized performance.\"\"\"\n        if not self.data:\n            self._gradient_bounds = None\n            return\n\n        # Ultra-optimized single-pass min/max tracking\n        min_grad = float(\"inf\")\n        max_grad = float(\"-inf\")\n        valid_count = 0\n\n        # Single pass with inline min/max tracking - no list building\n        for data_point in self.data:\n            # Type check: ensure data point has gradient attribute\n            if not hasattr(data_point, \"gradient\"):\n                continue\n            gradient = data_point.gradient  # type: ignore[attr-defined]\n            if (\n                gradient is not None\n                and isinstance(gradient, (int, float))\n                and not math.isnan(gradient)  # Not NaN\n                and gradient != float(\"inf\")\n                and gradient != float(\"-inf\")\n            ):\n                # Update min/max inline - no list operations\n                min_grad = min(min_grad, gradient)\n                max_grad = max(max_grad, gradient)\n                valid_count += 1\n                continue\n\n        # Set bounds efficiently - only if we found valid values\n        if valid_count &gt; 0:\n            self._gradient_bounds = (min_grad, max_grad)\n        else:\n            self._gradient_bounds = None\n\n    def _compute_normalized_dict(self) -&gt; dict:\n        \"\"\"Compute the normalized dictionary (expensive operation).\n\n        This method performs the actual gradient normalization computation.\n        It's called only when the cache is invalid.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        data_dict = super().asdict()\n\n        # Remove inherited fill_color property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n        data_dict.get(\"options\", {}).pop(\"fillColor\", None)\n\n        if self._normalize_gradients:\n            # Calculate bounds if not already calculated\n            if self._gradient_bounds is None:\n                self._calculate_gradient_bounds()\n\n            if self._gradient_bounds:\n                min_grad, max_grad = self._gradient_bounds\n                range_grad = max_grad - min_grad\n\n                if range_grad &gt; 0:  # Avoid division by zero\n                    # Ultra-optimized normalization with minimal function calls\n                    data_items = data_dict[\"data\"]\n                    range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                    for item in data_items:  # Remove enumerate for speed\n                        gradient = item.get(\"gradient\")\n                        if gradient is not None:\n                            # Since we already validated in _calculate_gradient_bounds,\n                            # we can trust the gradient values here\n                            try:\n                                # Use pre-calculated inverse for faster division\n                                normalized = (gradient - min_grad) * range_grad_inv\n                                # Fast clamping using conditional expression\n                                item[\"gradient\"] = (\n                                    0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                                )\n                            except (TypeError, ValueError):\n                                item.pop(\"gradient\", None)\n\n        return data_dict\n\n    def asdict(self):\n        \"\"\"Override to include normalized gradients with caching for performance.\n\n        Returns cached normalized results if available, otherwise computes and caches them.\n        This optimization prevents O(2n) iterations on every serialization call.\n\n        Returns:\n            dict: The serialized dictionary with normalized gradients.\n        \"\"\"\n        # Return cached result if available\n        if self._normalized_cache is not None:\n            return self._normalized_cache\n\n        # Compute and cache the result\n        self._normalized_cache = self._compute_normalized_dict()\n        return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data\n</code></pre> <p>Get the series data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.update","title":"update","text":"<pre><code>update(updates: dict)\n</code></pre> <p>Override update to invalidate cache when data changes.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict</code> <p>Dictionary of updates to apply.</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def update(self, updates: dict):\n    \"\"\"Override update to invalidate cache when data changes.\n\n    Args:\n        updates: Dictionary of updates to apply.\n\n    Returns:\n        Self for method chaining.\n    \"\"\"\n    # Invalidate cache before updating\n    self._invalidate_cache()\n    # Call parent update\n    return super().update(updates)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Override to include normalized gradients with caching for performance.</p> <p>Returns cached normalized results if available, otherwise computes and caches them. This optimization prevents O(2n) iterations on every serialization call.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The serialized dictionary with normalized gradients.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def asdict(self):\n    \"\"\"Override to include normalized gradients with caching for performance.\n\n    Returns cached normalized results if available, otherwise computes and caches them.\n    This optimization prevents O(2n) iterations on every serialization call.\n\n    Returns:\n        dict: The serialized dictionary with normalized gradients.\n    \"\"\"\n    # Return cached result if available\n    if self._normalized_cache is not None:\n        return self._normalized_cache\n\n    # Compute and cache the result\n    self._normalized_cache = self._compute_normalized_dict()\n    return self._normalized_cache\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html","title":"streamlit_lightweight_charts_pro.charts.series.histogram","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram","title":"histogram","text":"<p>Histogram series for streamlit-lightweight-charts.</p> <p>This module provides the HistogramSeries class for creating histogram charts that display volume or other single-value data as bars. Histogram series are commonly used for volume overlays and technical indicators in financial visualization.</p> <p>The HistogramSeries class supports various styling options including bar color, base value, and animation effects. It also supports markers and price line configurations for comprehensive chart customization.</p> Key Features <ul> <li>Bar-based visualization for volume and single-value data</li> <li>Customizable bar colors and base values</li> <li>Volume series factory with bullish/bearish color coding</li> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line support for annotations</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries","title":"HistogramSeries","text":"<p>Histogram series for creating bar-based charts in financial visualization.</p> <p>This class represents a histogram series that displays data as bars. It's commonly used for volume overlays, technical indicators, and other bar-based visualizations where individual data points are represented as vertical bars.</p> <p>The HistogramSeries supports various styling options including bar color, base value, and animation effects. It also provides a factory method for creating volume series with automatic bullish/bearish color coding.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for the histogram series. Can be a list of Data objects, a pandas DataFrame, or a pandas Series.</p> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to \"#26a69a\" (teal). Can be hex or rgba format.</p> <code>base</code> <code>Union[int, float]</code> <p>Base value for the histogram bars. Defaults to 0. This determines the baseline from which bars extend.</p> <code>scale_margins</code> <code>dict</code> <p>Scale margins for the histogram series. Controls the top and bottom margins of the price scale. Defaults to {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (HistogramData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. HistogramData: Data class for histogram chart data points. create_volume_series: Factory method for volume series with color coding.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"base\", (int, float))\n@chainable_property(\"scale_margins\", dict)\nclass HistogramSeries(Series):\n    \"\"\"Histogram series for creating bar-based charts in financial visualization.\n\n    This class represents a histogram series that displays data as bars.\n    It's commonly used for volume overlays, technical indicators, and other\n    bar-based visualizations where individual data points are represented\n    as vertical bars.\n\n    The HistogramSeries supports various styling options including bar color,\n    base value, and animation effects. It also provides a factory method\n    for creating volume series with automatic bullish/bearish color coding.\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for\n            the histogram series. Can be a list of Data objects, a pandas\n            DataFrame, or a pandas Series.\n        color (str): Color of the histogram bars. Defaults to \"#26a69a\" (teal).\n            Can be hex or rgba format.\n        base (Union[int, float]): Base value for the histogram bars. Defaults to 0.\n            This determines the baseline from which bars extend.\n        scale_margins (dict): Scale margins for the histogram series. Controls\n            the top and bottom margins of the price scale. Defaults to\n            {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (HistogramData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data\n        data = [\n            HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n            HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n        ]\n\n        # Create histogram series with styling\n        series = HistogramSeries(data=data)\n        series.set_color(\"#2196F3\").set_base(0)\n\n        # Create volume series with color coding\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n            up_color=\"rgba(38,166,154,0.5)\",\n            down_color=\"rgba(239,83,80,0.5)\",\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        HistogramData: Data class for histogram chart data points.\n        create_volume_series: Factory method for volume series with color coding.\n    \"\"\"\n\n    DATA_CLASS = HistogramData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as a histogram chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The histogram chart type identifier.\n\n        Example:\n            ```python\n            series = HistogramSeries(data=data)\n            chart_type = series.chart_type  # ChartType.HISTOGRAM\n            ```\n        \"\"\"\n        return ChartType.HISTOGRAM\n\n    @classmethod\n    def create_volume_series(\n        cls,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: dict,\n        up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n        down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n        **kwargs,\n    ) -&gt; \"HistogramSeries\":\n        \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n        This factory method processes OHLCV data and creates a HistogramSeries\n        with volume bars colored based on whether the candle is bullish (close &gt;= open)\n        or bearish (close &lt; open). This provides visual context for volume analysis\n        by showing whether volume occurred during price increases or decreases.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n                or sequence of OhlcvData objects containing price and volume information.\n            column_mapping (dict): Mapping of required fields to column names.\n                Must include \"open\", \"close\", and \"volume\" mappings.\n            up_color (str, optional): Color for bullish candles (close &gt;= open).\n                Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n            down_color (str, optional): Color for bearish candles (close &lt; open).\n                Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n            **kwargs: Additional arguments for HistogramSeries constructor.\n\n        Returns:\n            HistogramSeries: Configured histogram series for volume visualization\n                with color-coded bars based on price movement.\n\n        Raises:\n            ValueError: If required columns are missing from the data or column mapping.\n            KeyError: If column mapping doesn't include required fields.\n\n        Example:\n            ```python\n            # Create volume series with default colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping={\n                    \"time\": \"datetime\",\n                    \"open\": \"open_price\",\n                    \"close\": \"close_price\",\n                    \"volume\": \"trading_volume\",\n                },\n            )\n\n            # Create volume series with custom colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping=column_mapping,\n                up_color=\"#4CAF50\",  # Green for bullish\n                down_color=\"#F44336\",  # Red for bearish\n            )\n            ```\n\n        Note:\n            The method automatically sets _last_value_visible to False for volume series\n            as it's typically used as an overlay rather than a main price series.\n        \"\"\"\n        if isinstance(data, pd.DataFrame):\n            # Use vectorized operations for efficient color assignment on large datasets\n            volume_dataframe = data.copy()\n\n            # Extract column names for open and close prices from mapping\n            open_col = column_mapping.get(\"open\", \"open\")\n            close_col = column_mapping.get(\"close\", \"close\")\n\n            # Use NumPy vectorized operations to assign colors based on price movement\n            # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n            colors = np.where(\n                volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n                up_color,\n                down_color,\n            )\n\n            # Add color column to DataFrame for histogram visualization\n            volume_dataframe[\"color\"] = colors\n\n            # Update column mapping to include color field and map volume to value\n            volume_col = column_mapping.get(\"volume\", \"volume\")\n            updated_mapping = column_mapping.copy()\n            updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n            updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n            # Use from_dataframe factory method to create the series\n            return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n        # Handle sequence of OhlcvData objects (non-DataFrame input)\n        if data is None:\n            # Return empty series for None data input\n            return cls(data=[])\n\n        # Process each item in the sequence individually\n        processed_data = []\n        for item in data:\n            if isinstance(item, dict):\n                # Determine color based on price movement for dictionary input\n                color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n                processed_item = item.copy()\n                processed_item[\"color\"] = color  # Add color information\n                processed_data.append(processed_item)\n            else:\n                # For OhlcvData objects, convert to dict and add color\n                item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n                color = (\n                    up_color\n                    if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                    else down_color\n                )\n                item_dict[\"color\"] = color  # Add color information\n                processed_data.append(item_dict)\n\n        # Convert processed data to DataFrame and use from_dataframe factory method\n        processed_dataframe = pd.DataFrame(processed_data)\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n        # Map volume to value for HistogramSeries compatibility\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping[\"value\"] = volume_col\n\n        # Create the volume series using the factory method\n        volume_series = cls.from_dataframe(\n            processed_dataframe,\n            column_mapping=updated_mapping,\n            **kwargs,\n        )\n\n        # Disable last value visibility for volume series (typically used as overlay)\n        volume_series._last_value_visible = False\n\n        return volume_series  # type: ignore[return-value]\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize HistogramSeries with data and configuration options.\n\n        Creates a new histogram series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes histogram-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Histogram data as a list\n                of Data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"right\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic histogram series with list of data objects\n            data = [HistogramData(\"2024-01-01\", 1000)]\n            series = HistogramSeries(data=data)\n\n            # Histogram series with DataFrame\n            series = HistogramSeries(data=dataframe, column_mapping={\"time\": \"datetime\", \"value\": \"volume\"})\n\n            # Histogram series with Series\n            series = HistogramSeries(data=series_data, column_mapping={\"time\": \"index\", \"value\": \"values\"})\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize histogram-specific properties with default values\n        self._color = \"#26a69a\"  # Default teal color for histogram bars\n        self._base = 0  # Default base value (baseline for bars)\n        self._scale_margins = {\"top\": 0.75, \"bottom\": 0}  # Default scale margins\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as a histogram chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The histogram chart type identifier.</p> Example <pre><code>series = HistogramSeries(data=data)\nchart_type = series.chart_type  # ChartType.HISTOGRAM\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries.create_volume_series","title":"create_volume_series  <code>classmethod</code>","text":"<pre><code>create_volume_series(data: Union[Sequence[OhlcvData], DataFrame], column_mapping: dict, up_color: str = HISTOGRAM_UP_COLOR_DEFAULT, down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT, **kwargs) -&gt; HistogramSeries\n</code></pre> <p>Create a histogram series for volume data with colors based on price movement.</p> <p>This factory method processes OHLCV data and creates a HistogramSeries with volume bars colored based on whether the candle is bullish (close &gt;= open) or bearish (close &lt; open). This provides visual context for volume analysis by showing whether volume occurred during price increases or decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data as DataFrame or sequence of OhlcvData objects containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields to column names. Must include \"open\", \"close\", and \"volume\" mappings.</p> required <code>up_color</code> <code>str</code> <p>Color for bullish candles (close &gt;= open). Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).</p> <code>HISTOGRAM_UP_COLOR_DEFAULT</code> <code>down_color</code> <code>str</code> <p>Color for bearish candles (close &lt; open). Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).</p> <code>HISTOGRAM_DOWN_COLOR_DEFAULT</code> <code>**kwargs</code> <p>Additional arguments for HistogramSeries constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HistogramSeries</code> <code>HistogramSeries</code> <p>Configured histogram series for volume visualization with color-coded bars based on price movement.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing from the data or column mapping.</p> <code>KeyError</code> <p>If column mapping doesn't include required fields.</p> Example <pre><code># Create volume series with default colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\n        \"time\": \"datetime\",\n        \"open\": \"open_price\",\n        \"close\": \"close_price\",\n        \"volume\": \"trading_volume\",\n    },\n)\n\n# Create volume series with custom colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping=column_mapping,\n    up_color=\"#4CAF50\",  # Green for bullish\n    down_color=\"#F44336\",  # Red for bearish\n)\n</code></pre> Note <p>The method automatically sets _last_value_visible to False for volume series as it's typically used as an overlay rather than a main price series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@classmethod\ndef create_volume_series(\n    cls,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: dict,\n    up_color: str = HISTOGRAM_UP_COLOR_DEFAULT,\n    down_color: str = HISTOGRAM_DOWN_COLOR_DEFAULT,\n    **kwargs,\n) -&gt; \"HistogramSeries\":\n    \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n    This factory method processes OHLCV data and creates a HistogramSeries\n    with volume bars colored based on whether the candle is bullish (close &gt;= open)\n    or bearish (close &lt; open). This provides visual context for volume analysis\n    by showing whether volume occurred during price increases or decreases.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n            or sequence of OhlcvData objects containing price and volume information.\n        column_mapping (dict): Mapping of required fields to column names.\n            Must include \"open\", \"close\", and \"volume\" mappings.\n        up_color (str, optional): Color for bullish candles (close &gt;= open).\n            Defaults to HISTOGRAM_UP_COLOR_DEFAULT (teal with transparency).\n        down_color (str, optional): Color for bearish candles (close &lt; open).\n            Defaults to HISTOGRAM_DOWN_COLOR_DEFAULT (red with transparency).\n        **kwargs: Additional arguments for HistogramSeries constructor.\n\n    Returns:\n        HistogramSeries: Configured histogram series for volume visualization\n            with color-coded bars based on price movement.\n\n    Raises:\n        ValueError: If required columns are missing from the data or column mapping.\n        KeyError: If column mapping doesn't include required fields.\n\n    Example:\n        ```python\n        # Create volume series with default colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\n                \"time\": \"datetime\",\n                \"open\": \"open_price\",\n                \"close\": \"close_price\",\n                \"volume\": \"trading_volume\",\n            },\n        )\n\n        # Create volume series with custom colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping=column_mapping,\n            up_color=\"#4CAF50\",  # Green for bullish\n            down_color=\"#F44336\",  # Red for bearish\n        )\n        ```\n\n    Note:\n        The method automatically sets _last_value_visible to False for volume series\n        as it's typically used as an overlay rather than a main price series.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # Use vectorized operations for efficient color assignment on large datasets\n        volume_dataframe = data.copy()\n\n        # Extract column names for open and close prices from mapping\n        open_col = column_mapping.get(\"open\", \"open\")\n        close_col = column_mapping.get(\"close\", \"close\")\n\n        # Use NumPy vectorized operations to assign colors based on price movement\n        # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n        colors = np.where(\n            volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n            up_color,\n            down_color,\n        )\n\n        # Add color column to DataFrame for histogram visualization\n        volume_dataframe[\"color\"] = colors\n\n        # Update column mapping to include color field and map volume to value\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n        updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n        # Use from_dataframe factory method to create the series\n        return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)  # type: ignore[return-value]\n\n    # Handle sequence of OhlcvData objects (non-DataFrame input)\n    if data is None:\n        # Return empty series for None data input\n        return cls(data=[])\n\n    # Process each item in the sequence individually\n    processed_data = []\n    for item in data:\n        if isinstance(item, dict):\n            # Determine color based on price movement for dictionary input\n            color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n            processed_item = item.copy()\n            processed_item[\"color\"] = color  # Add color information\n            processed_data.append(processed_item)\n        else:\n            # For OhlcvData objects, convert to dict and add color\n            item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n            color = (\n                up_color\n                if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                else down_color\n            )\n            item_dict[\"color\"] = color  # Add color information\n            processed_data.append(item_dict)\n\n    # Convert processed data to DataFrame and use from_dataframe factory method\n    processed_dataframe = pd.DataFrame(processed_data)\n    updated_mapping = column_mapping.copy()\n    updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n    # Map volume to value for HistogramSeries compatibility\n    volume_col = column_mapping.get(\"volume\", \"volume\")\n    updated_mapping[\"value\"] = volume_col\n\n    # Create the volume series using the factory method\n    volume_series = cls.from_dataframe(\n        processed_dataframe,\n        column_mapping=updated_mapping,\n        **kwargs,\n    )\n\n    # Disable last value visibility for volume series (typically used as overlay)\n    volume_series._last_value_visible = False\n\n    return volume_series  # type: ignore[return-value]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html","title":"streamlit_lightweight_charts_pro.charts.series.line","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line","title":"line","text":"<p>Line series for Streamlit Lightweight Charts Pro.</p> <p>This module provides the LineSeries class for creating line charts that display continuous data points connected by lines. Line series are commonly used for price charts, technical indicators, and trend analysis in financial visualization.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create line data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 102),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries","title":"LineSeries","text":"<p>Line series for creating continuous line charts in financial visualization.</p> <p>This class represents a line series that displays continuous data points connected by lines. It's commonly used for price charts, technical indicators, trend analysis, and other time-series data visualization in financial applications.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Data points for the line series. Can be a list of LineData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <p>LineOptions instance for all line style options including color, width, style, and animation effects.</p> <code>column_mapping</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <p>The pane index this series belongs to. Defaults to 0.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data\ndata = [\n    LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n    LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n    LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n# Add to chart\nchart = Chart(series=series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/line.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\nclass LineSeries(Series):\n    \"\"\"Line series for creating continuous line charts in financial visualization.\n\n    This class represents a line series that displays continuous data points\n    connected by lines. It's commonly used for price charts, technical\n    indicators, trend analysis, and other time-series data visualization\n    in financial applications.\n\n    Attributes:\n        data: Data points for the line series. Can be a list of LineData\n            objects, a pandas DataFrame, or a pandas Series.\n        line_options: LineOptions instance for all line style options\n            including color, width, style, and animation effects.\n        column_mapping: Optional mapping for DataFrame columns to data fields.\n            Used when data is provided as a DataFrame.\n        visible: Whether the series is visible on the chart. Defaults to True.\n        price_scale_id: ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id: The pane index this series belongs to.\n            Defaults to 0.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data\n        data = [\n            LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n            LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n            LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n        ]\n\n        # Create line series with styling\n        series = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n        # Add to chart\n        chart = Chart(series=series)\n        ```\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = LineData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for line charts.\n        \"\"\"\n        return ChartType.LINE\n\n    def __init__(\n        self,\n        data: Union[List[LineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a LineSeries instance with data and configuration options.\n\n        This constructor initializes a line series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes line-specific styling options with default values.\n\n        Args:\n            data: Data points for the line series. Can be a list of LineData\n                objects, a pandas DataFrame, or a pandas Series. If DataFrame\n                is provided, column_mapping can be used to specify field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        # This sets up data validation, column mapping processing, and basic properties\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n        # Initialize line_options with default styling configuration\n        # This creates an empty LineOptions instance for future customization\n        self._line_options = LineOptions()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for line charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html","title":"streamlit_lightweight_charts_pro.charts.series.ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon","title":"ribbon","text":"<p>Ribbon series for streamlit-lightweight-charts.</p> <p>This module provides the RibbonSeries class for creating ribbon charts that display upper and lower bands with fill areas between them.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries","title":"RibbonSeries","text":"<p>Ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with a fill area between them. It's commonly used for technical indicators like Bollinger Bands without the middle line, or other envelope indicators.</p> <p>The RibbonSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_color</code> <p>Fill color for the area between upper and lower bands.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/ribbon.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass RibbonSeries(Series):\n    \"\"\"Ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with a fill area between them. It's commonly used for technical indicators\n    like Bollinger Bands without the middle line, or other envelope indicators.\n\n    The RibbonSeries supports various styling options including separate line\n    styling for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_color: Fill color for the area between upper and lower bands.\n        fill_visible: Whether to display the fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = RibbonData\n\n    def __init__(\n        self,\n        data: Union[List[RibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize RibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = create_upper_line()\n        self._lower_line = create_lower_line()\n\n        # Initialize fill color\n        self._fill_color = RIBBON_FILL_COLOR\n\n        # Initialize fill visibility (default to True)\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.RIBBON\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html","title":"streamlit_lightweight_charts_pro.charts.series.signal_series","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series","title":"signal_series","text":"<p>Signal series for background coloring in charts.</p> <p>This module provides the SignalSeries class for creating signal-based background coloring in financial charts. SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries","title":"SignalSeries","text":"<p>Signal series for background coloring in charts.</p> <p>SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>The series takes signal data with binary or ternary values and maps them to background colors for specific time periods. The background bands appear across all chart panes and provide visual context for the data.</p> <p>Signal data can be: - Binary (0, 1): Only uses neutral_color and signal_color - Ternary (0, 1, negative): Uses all three colors including alert_color</p> <p>Attributes:</p> Name Type Description <code>neutral_color</code> <p>Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")</p> <code>signal_color</code> <p>Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")</p> <code>alert_color</code> <p>Background color for signal value&lt;0 (negative, optional, default: None) Frontend intelligently uses this only when data contains non-boolean values</p> Example <pre><code># Create signal data\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n    SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n]\n\n# Create signal series\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n\n# Add to chart\nchart.add_series(signal_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/signal_series.py</code> <pre><code>@chainable_property(\"neutral_color\", str, validator=\"color\")\n@chainable_property(\"signal_color\", str, validator=\"color\")\n@chainable_property(\"alert_color\", str, validator=\"color\", allow_none=True)\nclass SignalSeries(Series):\n    \"\"\"Signal series for background coloring in charts.\n\n    SignalSeries creates vertical background bands that span the entire chart\n    height, colored based on signal values at specific time points. This is\n    commonly used in financial charts to highlight specific market conditions,\n    trading signals, or events.\n\n    The series takes signal data with binary or ternary values and maps them\n    to background colors for specific time periods. The background bands\n    appear across all chart panes and provide visual context for the data.\n\n    Signal data can be:\n    - Binary (0, 1): Only uses neutral_color and signal_color\n    - Ternary (0, 1, negative): Uses all three colors including alert_color\n\n    Attributes:\n        neutral_color: Background color for signal value=0 (default: \"rgba(128, 128, 128, 0.1)\")\n        signal_color: Background color for signal value&gt;0 (positive, default: \"rgba(76, 175, 80, 0.2)\")\n        alert_color: Background color for signal value&lt;0 (negative, optional, default: None)\n            Frontend intelligently uses this only when data contains non-boolean values\n\n    Example:\n        ```python\n        # Create signal data\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n            SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n        ]\n\n        # Create signal series\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n\n        # Add to chart\n        chart.add_series(signal_series)\n        ```\n    \"\"\"\n\n    DATA_CLASS = SignalData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: ChartType.SIGNAL indicating this is a signal series.\n        \"\"\"\n        return ChartType.SIGNAL\n\n    def __init__(\n        self,\n        data: Union[List[SignalData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        neutral_color: str = \"rgba(128, 128, 128, 0.1)\",\n        signal_color: str = \"rgba(76, 175, 80, 0.2)\",\n        alert_color: Optional[str] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize SignalSeries.\n\n        Args:\n            data: List of SignalData objects, DataFrame, or Series.\n            column_mapping: Optional column mapping for DataFrame input.\n            neutral_color: Background color for value=0. Defaults to \"rgba(128, 128, 128, 0.1)\".\n            signal_color: Background color for value&gt;0 (positive). Defaults to \"rgba(76, 175, 80, 0.2)\".\n            alert_color: Background color for value&lt;0 (negative). Defaults to None.\n                Frontend intelligently uses this only when needed based on data values.\n            visible: Whether the signal series should be visible. Defaults to True.\n            price_scale_id: Price scale ID. Defaults to \"right\".\n            pane_id: Pane ID for multi-pane charts. Defaults to 0.\n\n        Raises:\n            ValueError: If data is empty or invalid.\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize signal-specific properties with default values\n        self._neutral_color = neutral_color\n        self._signal_color = signal_color\n        self._alert_color = alert_color\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the signal series.\"\"\"\n        return (\n            f\"SignalSeries(data_points={len(self.data)}, neutral_color='{self._neutral_color}',\"\n            f\" signal_color='{self._signal_color}')\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>ChartType.SIGNAL indicating this is a signal series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html","title":"streamlit_lightweight_charts_pro.charts.series.trend_fill","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill","title":"trend_fill","text":"<p>Trend fill series for streamlit-lightweight-charts.</p> <p>This module provides the TrendFillSeries class for creating trend-based fill charts that display fills between trend lines and base lines, similar to Supertrend indicators with dynamic trend-colored backgrounds.</p> <p>The series now properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries","title":"TrendFillSeries","text":"<p>Trend fill series for lightweight charts.</p> <p>This class represents a trend fill series that displays fills between trend lines and base lines. It's commonly used for technical indicators like Supertrend, where the fill area changes color based on trend direction.</p> <p>The series properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p> <p>Attributes:</p> Name Type Description <code>uptrend_line</code> <code>LineOptions</code> <p>Line options for the uptrend line.</p> <code>downtrend_line</code> <code>LineOptions</code> <p>Line options for the downtrend line.</p> <code>base_line</code> <code>LineOptions</code> <p>Line options for the base line.</p> <code>uptrend_fill_color</code> <code>str</code> <p>Color for uptrend fills (default: green).</p> <code>downtrend_fill_color</code> <code>str</code> <p>Color for downtrend fills (default: red).</p> <code>fill_visible</code> <code>bool</code> <p>Whether fills are visible.</p> Example <pre><code>from streamlit_lightweight_charts_pro import TrendFillSeries\nfrom streamlit_lightweight_charts_pro.data import TrendFillData\n\n# Create trend fill data\ndata = [\n    TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n    TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n]\n\n# Create series with custom colors\nseries = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/trend_fill.py</code> <pre><code>@chainable_property(\"uptrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"downtrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"base_line\", LineOptions, allow_none=True)\n@chainable_property(\"uptrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"downtrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass TrendFillSeries(Series):\n    \"\"\"Trend fill series for lightweight charts.\n\n    This class represents a trend fill series that displays fills between\n    trend lines and base lines. It's commonly used for technical\n    indicators like Supertrend, where the fill area changes color based on\n    trend direction.\n\n    The series properly handles separate trend lines based on trend direction:\n    - Uptrend (+1): Uses uptrend_line options for trend line above price\n    - Downtrend (-1): Uses downtrend_line options for trend line below price\n\n    Attributes:\n        uptrend_line (LineOptions): Line options for the uptrend line.\n        downtrend_line (LineOptions): Line options for the downtrend line.\n        base_line (LineOptions): Line options for the base line.\n        uptrend_fill_color (str): Color for uptrend fills (default: green).\n        downtrend_fill_color (str): Color for downtrend fills (default: red).\n        fill_visible (bool): Whether fills are visible.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import TrendFillSeries\n        from streamlit_lightweight_charts_pro.data import TrendFillData\n\n        # Create trend fill data\n        data = [\n            TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n            TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n        ]\n\n        # Create series with custom colors\n        series = TrendFillSeries(data).set_uptrend_fill_color(\"#00FF00\").set_downtrend_fill_color(\"#FF0000\")\n        ```\n    \"\"\"\n\n    DATA_CLASS = TrendFillData\n\n    def __init__(\n        self,\n        data: Union[List[TrendFillData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        uptrend_fill_color: str = \"#4CAF50\",\n        downtrend_fill_color: str = \"#F44336\",\n    ):\n        \"\"\"Initialize TrendFillSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            uptrend_fill_color: Color for uptrend fills (green)\n            downtrend_fill_color: Color for downtrend fills (red)\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Convert colors to rgba with default opacity\n        self._uptrend_fill_color = add_opacity(uptrend_fill_color)\n        self._downtrend_fill_color = add_opacity(downtrend_fill_color)\n\n        # Initialize line options for uptrend line, downtrend line, and base line\n        self._uptrend_line = create_uptrend_line()\n        self._downtrend_line = create_downtrend_line()\n        self._base_line = create_base_line()\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Return the chart type for this series.\"\"\"\n        return ChartType.TREND_FILL\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Return the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html","title":"streamlit_lightweight_charts_pro.charts.utils","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils","title":"utils","text":"<p>Chart utilities package.</p> <p>This package provides utility classes and functions for chart operations.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig","title":"PriceScaleConfig","text":"<p>Builder for common price scale configurations.</p> <p>This class provides static factory methods for creating properly configured PriceScaleOptions for common use cases like overlays, separate panes, and specific indicator types.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>class PriceScaleConfig:\n    \"\"\"Builder for common price scale configurations.\n\n    This class provides static factory methods for creating properly configured\n    PriceScaleOptions for common use cases like overlays, separate panes, and\n    specific indicator types.\n    \"\"\"\n\n    @staticmethod\n    def for_overlay(\n        scale_id: str,\n        top_margin: float = 0.8,\n        bottom_margin: float = 0.0,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for overlay series (hidden axis).\n\n        Overlays are series displayed in the same pane as the main series but\n        with a different value scale. The axis labels are hidden by default.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.0).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for overlay use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,  # Hide axis labels for overlays\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        # Merge with provided kwargs (kwargs take precedence)\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_separate_pane(\n        scale_id: str,\n        top_margin: float = 0.1,\n        bottom_margin: float = 0.1,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for separate pane (visible axis).\n\n        Separate pane series are displayed in their own vertical pane with\n        visible axis labels and balanced margins.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for separate pane use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,  # Show axis labels for separate panes\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_volume(\n        scale_id: str = \"volume\",\n        as_overlay: bool = True,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config optimized for volume series.\n\n        Volume series typically use large top margins to appear at the bottom\n        of the chart without interfering with price series.\n\n        Args:\n            scale_id: Unique identifier for the price scale (default: \"volume\").\n            as_overlay: Whether volume is overlay (True) or separate pane (False).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for volume visualization.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        if as_overlay:\n            # Volume as overlay: large top margin, hidden axis\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": False,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n            }\n        else:\n            # Volume as separate pane: visible axis, balanced margins\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": True,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n            }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_indicator(\n        scale_id: str,\n        min_value: Optional[float] = None,  # noqa: ARG004\n        max_value: Optional[float] = None,  # noqa: ARG004\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n        Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n        This method creates a config suitable for these bounded indicators.\n\n        Note: min_value and max_value are accepted for API compatibility but\n        are not used in PriceScaleOptions. Use chart-level options to set\n        value ranges if needed.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            min_value: Optional minimum value hint (not used by PriceScaleOptions).\n            max_value: Optional maximum value hint (not used by PriceScaleOptions).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for bounded indicators.\n\n        Example:\n            &gt;&gt;&gt; # RSI indicator (0-100 range)\n            &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,  # Always auto-scale for now\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n        }\n\n        # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n        # They would be used at the chart/series level if implemented in the future\n\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_percentage(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for percentage-based series.\n\n        Percentage-based series show changes as percentages rather than\n        absolute values, useful for comparing relative performance.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for percentage mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.PERCENTAGE,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_logarithmic(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for logarithmic scale.\n\n        Logarithmic scales are useful for displaying data that spans several\n        orders of magnitude or for emphasizing percentage changes.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for logarithmic mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.LOGARITHMIC,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_overlay","title":"for_overlay  <code>staticmethod</code>","text":"<pre><code>for_overlay(scale_id: str, top_margin: float = 0.8, bottom_margin: float = 0.0, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for overlay series (hidden axis).</p> <p>Overlays are series displayed in the same pane as the main series but with a different value scale. The axis labels are hidden by default.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.8 = 80% space at top).</p> <code>0.8</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.0).</p> <code>0.0</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for overlay use.</p> Example <p>config = PriceScaleConfig.for_overlay(\"volume\") chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_overlay(\n    scale_id: str,\n    top_margin: float = 0.8,\n    bottom_margin: float = 0.0,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for overlay series (hidden axis).\n\n    Overlays are series displayed in the same pane as the main series but\n    with a different value scale. The axis labels are hidden by default.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.0).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for overlay use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": False,  # Hide axis labels for overlays\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    # Merge with provided kwargs (kwargs take precedence)\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_separate_pane","title":"for_separate_pane  <code>staticmethod</code>","text":"<pre><code>for_separate_pane(scale_id: str, top_margin: float = 0.1, bottom_margin: float = 0.1, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for separate pane (visible axis).</p> <p>Separate pane series are displayed in their own vertical pane with visible axis labels and balanced margins.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.1 = 10% space at top).</p> <code>0.1</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.1 = 10% space at bottom).</p> <code>0.1</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for separate pane use.</p> Example <p>config = PriceScaleConfig.for_separate_pane(\"rsi\") chart.add_overlay_price_scale(\"rsi\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_separate_pane(\n    scale_id: str,\n    top_margin: float = 0.1,\n    bottom_margin: float = 0.1,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for separate pane (visible axis).\n\n    Separate pane series are displayed in their own vertical pane with\n    visible axis labels and balanced margins.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for separate pane use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,  # Show axis labels for separate panes\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_volume","title":"for_volume  <code>staticmethod</code>","text":"<pre><code>for_volume(scale_id: str = 'volume', as_overlay: bool = True, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config optimized for volume series.</p> <p>Volume series typically use large top margins to appear at the bottom of the chart without interfering with price series.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale (default: \"volume\").</p> <code>'volume'</code> <code>as_overlay</code> <code>bool</code> <p>Whether volume is overlay (True) or separate pane (False).</p> <code>True</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for volume visualization.</p> Example <p>config = PriceScaleConfig.for_volume(as_overlay=True) chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_volume(\n    scale_id: str = \"volume\",\n    as_overlay: bool = True,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config optimized for volume series.\n\n    Volume series typically use large top margins to appear at the bottom\n    of the chart without interfering with price series.\n\n    Args:\n        scale_id: Unique identifier for the price scale (default: \"volume\").\n        as_overlay: Whether volume is overlay (True) or separate pane (False).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for volume visualization.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    if as_overlay:\n        # Volume as overlay: large top margin, hidden axis\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n        }\n    else:\n        # Volume as separate pane: visible axis, balanced margins\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_indicator","title":"for_indicator  <code>staticmethod</code>","text":"<pre><code>for_indicator(scale_id: str, min_value: Optional[float] = None, max_value: Optional[float] = None, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for bounded indicators (RSI, Stochastic, etc).</p> <p>Many technical indicators have fixed value ranges (e.g., RSI: 0-100). This method creates a config suitable for these bounded indicators.</p> <p>Note: min_value and max_value are accepted for API compatibility but are not used in PriceScaleOptions. Use chart-level options to set value ranges if needed.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>min_value</code> <code>Optional[float]</code> <p>Optional minimum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>Optional maximum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for bounded indicators.</p> Example Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_indicator(\n    scale_id: str,\n    min_value: Optional[float] = None,  # noqa: ARG004\n    max_value: Optional[float] = None,  # noqa: ARG004\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n    Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n    This method creates a config suitable for these bounded indicators.\n\n    Note: min_value and max_value are accepted for API compatibility but\n    are not used in PriceScaleOptions. Use chart-level options to set\n    value ranges if needed.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        min_value: Optional minimum value hint (not used by PriceScaleOptions).\n        max_value: Optional maximum value hint (not used by PriceScaleOptions).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for bounded indicators.\n\n    Example:\n        &gt;&gt;&gt; # RSI indicator (0-100 range)\n        &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,  # Always auto-scale for now\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n    }\n\n    # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n    # They would be used at the chart/series level if implemented in the future\n\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_indicator--rsi-indicator-0-100-range","title":"RSI indicator (0-100 range)","text":"<p>config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100) chart.add_overlay_price_scale(\"rsi\", config)</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_percentage","title":"for_percentage  <code>staticmethod</code>","text":"<pre><code>for_percentage(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for percentage-based series.</p> <p>Percentage-based series show changes as percentages rather than absolute values, useful for comparing relative performance.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for percentage mode.</p> Example <p>config = PriceScaleConfig.for_percentage(\"pct_change\") chart.add_overlay_price_scale(\"pct_change\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_percentage(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for percentage-based series.\n\n    Percentage-based series show changes as percentages rather than\n    absolute values, useful for comparing relative performance.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for percentage mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.PERCENTAGE,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/index.html#streamlit_lightweight_charts_pro.charts.utils.PriceScaleConfig.for_logarithmic","title":"for_logarithmic  <code>staticmethod</code>","text":"<pre><code>for_logarithmic(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for logarithmic scale.</p> <p>Logarithmic scales are useful for displaying data that spans several orders of magnitude or for emphasizing percentage changes.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for logarithmic mode.</p> Example <p>config = PriceScaleConfig.for_logarithmic(\"price_log\") chart.add_overlay_price_scale(\"price_log\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_logarithmic(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for logarithmic scale.\n\n    Logarithmic scales are useful for displaying data that spans several\n    orders of magnitude or for emphasizing percentage changes.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for logarithmic mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.LOGARITHMIC,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html","title":"streamlit_lightweight_charts_pro.charts.utils.price_scale_config","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config","title":"price_scale_config","text":"<p>Price scale configuration builder utilities.</p> <p>This module provides fluent builder patterns for common price scale configurations, making it easier to create properly configured price scales for various use cases.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig","title":"PriceScaleConfig","text":"<p>Builder for common price scale configurations.</p> <p>This class provides static factory methods for creating properly configured PriceScaleOptions for common use cases like overlays, separate panes, and specific indicator types.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>class PriceScaleConfig:\n    \"\"\"Builder for common price scale configurations.\n\n    This class provides static factory methods for creating properly configured\n    PriceScaleOptions for common use cases like overlays, separate panes, and\n    specific indicator types.\n    \"\"\"\n\n    @staticmethod\n    def for_overlay(\n        scale_id: str,\n        top_margin: float = 0.8,\n        bottom_margin: float = 0.0,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for overlay series (hidden axis).\n\n        Overlays are series displayed in the same pane as the main series but\n        with a different value scale. The axis labels are hidden by default.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.0).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for overlay use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,  # Hide axis labels for overlays\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        # Merge with provided kwargs (kwargs take precedence)\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_separate_pane(\n        scale_id: str,\n        top_margin: float = 0.1,\n        bottom_margin: float = 0.1,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for separate pane (visible axis).\n\n        Separate pane series are displayed in their own vertical pane with\n        visible axis labels and balanced margins.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n            bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for separate pane use.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,  # Show axis labels for separate panes\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_volume(\n        scale_id: str = \"volume\",\n        as_overlay: bool = True,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config optimized for volume series.\n\n        Volume series typically use large top margins to appear at the bottom\n        of the chart without interfering with price series.\n\n        Args:\n            scale_id: Unique identifier for the price scale (default: \"volume\").\n            as_overlay: Whether volume is overlay (True) or separate pane (False).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for volume visualization.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n        \"\"\"\n        if as_overlay:\n            # Volume as overlay: large top margin, hidden axis\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": False,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n            }\n        else:\n            # Volume as separate pane: visible axis, balanced margins\n            defaults = {\n                \"price_scale_id\": scale_id,\n                \"visible\": True,\n                \"auto_scale\": True,\n                \"mode\": PriceScaleMode.NORMAL,\n                \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n            }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_indicator(\n        scale_id: str,\n        min_value: Optional[float] = None,  # noqa: ARG004\n        max_value: Optional[float] = None,  # noqa: ARG004\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n        Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n        This method creates a config suitable for these bounded indicators.\n\n        Note: min_value and max_value are accepted for API compatibility but\n        are not used in PriceScaleOptions. Use chart-level options to set\n        value ranges if needed.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            min_value: Optional minimum value hint (not used by PriceScaleOptions).\n            max_value: Optional maximum value hint (not used by PriceScaleOptions).\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for bounded indicators.\n\n        Example:\n            &gt;&gt;&gt; # RSI indicator (0-100 range)\n            &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,  # Always auto-scale for now\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n        }\n\n        # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n        # They would be used at the chart/series level if implemented in the future\n\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_percentage(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for percentage-based series.\n\n        Percentage-based series show changes as percentages rather than\n        absolute values, useful for comparing relative performance.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for percentage mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.PERCENTAGE,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n\n    @staticmethod\n    def for_logarithmic(\n        scale_id: str,\n        **kwargs,\n    ) -&gt; PriceScaleOptions:\n        \"\"\"Create price scale config for logarithmic scale.\n\n        Logarithmic scales are useful for displaying data that spans several\n        orders of magnitude or for emphasizing percentage changes.\n\n        Args:\n            scale_id: Unique identifier for the price scale.\n            **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n        Returns:\n            PriceScaleOptions configured for logarithmic mode.\n\n        Example:\n            &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n            &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n        \"\"\"\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.LOGARITHMIC,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n        defaults.update(kwargs)\n        return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_overlay","title":"for_overlay  <code>staticmethod</code>","text":"<pre><code>for_overlay(scale_id: str, top_margin: float = 0.8, bottom_margin: float = 0.0, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for overlay series (hidden axis).</p> <p>Overlays are series displayed in the same pane as the main series but with a different value scale. The axis labels are hidden by default.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.8 = 80% space at top).</p> <code>0.8</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.0).</p> <code>0.0</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for overlay use.</p> Example <p>config = PriceScaleConfig.for_overlay(\"volume\") chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_overlay(\n    scale_id: str,\n    top_margin: float = 0.8,\n    bottom_margin: float = 0.0,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for overlay series (hidden axis).\n\n    Overlays are series displayed in the same pane as the main series but\n    with a different value scale. The axis labels are hidden by default.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.8 = 80% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.0).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for overlay use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_overlay(\"volume\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": False,  # Hide axis labels for overlays\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    # Merge with provided kwargs (kwargs take precedence)\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_separate_pane","title":"for_separate_pane  <code>staticmethod</code>","text":"<pre><code>for_separate_pane(scale_id: str, top_margin: float = 0.1, bottom_margin: float = 0.1, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for separate pane (visible axis).</p> <p>Separate pane series are displayed in their own vertical pane with visible axis labels and balanced margins.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>top_margin</code> <code>float</code> <p>Top margin as proportion (default: 0.1 = 10% space at top).</p> <code>0.1</code> <code>bottom_margin</code> <code>float</code> <p>Bottom margin as proportion (default: 0.1 = 10% space at bottom).</p> <code>0.1</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for separate pane use.</p> Example <p>config = PriceScaleConfig.for_separate_pane(\"rsi\") chart.add_overlay_price_scale(\"rsi\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_separate_pane(\n    scale_id: str,\n    top_margin: float = 0.1,\n    bottom_margin: float = 0.1,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for separate pane (visible axis).\n\n    Separate pane series are displayed in their own vertical pane with\n    visible axis labels and balanced margins.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        top_margin: Top margin as proportion (default: 0.1 = 10% space at top).\n        bottom_margin: Bottom margin as proportion (default: 0.1 = 10% space at bottom).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for separate pane use.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_separate_pane(\"rsi\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,  # Show axis labels for separate panes\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=top_margin, bottom=bottom_margin),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_volume","title":"for_volume  <code>staticmethod</code>","text":"<pre><code>for_volume(scale_id: str = 'volume', as_overlay: bool = True, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config optimized for volume series.</p> <p>Volume series typically use large top margins to appear at the bottom of the chart without interfering with price series.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale (default: \"volume\").</p> <code>'volume'</code> <code>as_overlay</code> <code>bool</code> <p>Whether volume is overlay (True) or separate pane (False).</p> <code>True</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for volume visualization.</p> Example <p>config = PriceScaleConfig.for_volume(as_overlay=True) chart.add_overlay_price_scale(\"volume\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_volume(\n    scale_id: str = \"volume\",\n    as_overlay: bool = True,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config optimized for volume series.\n\n    Volume series typically use large top margins to appear at the bottom\n    of the chart without interfering with price series.\n\n    Args:\n        scale_id: Unique identifier for the price scale (default: \"volume\").\n        as_overlay: Whether volume is overlay (True) or separate pane (False).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for volume visualization.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_volume(as_overlay=True)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"volume\", config)\n    \"\"\"\n    if as_overlay:\n        # Volume as overlay: large top margin, hidden axis\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": False,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.8, bottom=0.0),\n        }\n    else:\n        # Volume as separate pane: visible axis, balanced margins\n        defaults = {\n            \"price_scale_id\": scale_id,\n            \"visible\": True,\n            \"auto_scale\": True,\n            \"mode\": PriceScaleMode.NORMAL,\n            \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n        }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_indicator","title":"for_indicator  <code>staticmethod</code>","text":"<pre><code>for_indicator(scale_id: str, min_value: Optional[float] = None, max_value: Optional[float] = None, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for bounded indicators (RSI, Stochastic, etc).</p> <p>Many technical indicators have fixed value ranges (e.g., RSI: 0-100). This method creates a config suitable for these bounded indicators.</p> <p>Note: min_value and max_value are accepted for API compatibility but are not used in PriceScaleOptions. Use chart-level options to set value ranges if needed.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>min_value</code> <code>Optional[float]</code> <p>Optional minimum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>max_value</code> <code>Optional[float]</code> <p>Optional maximum value hint (not used by PriceScaleOptions).</p> <code>None</code> <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for bounded indicators.</p> Example Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_indicator(\n    scale_id: str,\n    min_value: Optional[float] = None,  # noqa: ARG004\n    max_value: Optional[float] = None,  # noqa: ARG004\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for bounded indicators (RSI, Stochastic, etc).\n\n    Many technical indicators have fixed value ranges (e.g., RSI: 0-100).\n    This method creates a config suitable for these bounded indicators.\n\n    Note: min_value and max_value are accepted for API compatibility but\n    are not used in PriceScaleOptions. Use chart-level options to set\n    value ranges if needed.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        min_value: Optional minimum value hint (not used by PriceScaleOptions).\n        max_value: Optional maximum value hint (not used by PriceScaleOptions).\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for bounded indicators.\n\n    Example:\n        &gt;&gt;&gt; # RSI indicator (0-100 range)\n        &gt;&gt;&gt; config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100)\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"rsi\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,  # Always auto-scale for now\n        \"mode\": PriceScaleMode.NORMAL,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.2),\n    }\n\n    # Note: min_value and max_value are accepted but not used in PriceScaleOptions\n    # They would be used at the chart/series level if implemented in the future\n\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_indicator--rsi-indicator-0-100-range","title":"RSI indicator (0-100 range)","text":"<p>config = PriceScaleConfig.for_indicator(\"rsi\", min_value=0, max_value=100) chart.add_overlay_price_scale(\"rsi\", config)</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_percentage","title":"for_percentage  <code>staticmethod</code>","text":"<pre><code>for_percentage(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for percentage-based series.</p> <p>Percentage-based series show changes as percentages rather than absolute values, useful for comparing relative performance.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for percentage mode.</p> Example <p>config = PriceScaleConfig.for_percentage(\"pct_change\") chart.add_overlay_price_scale(\"pct_change\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_percentage(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for percentage-based series.\n\n    Percentage-based series show changes as percentages rather than\n    absolute values, useful for comparing relative performance.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for percentage mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_percentage(\"pct_change\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"pct_change\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.PERCENTAGE,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/utils/price_scale_config.html#streamlit_lightweight_charts_pro.charts.utils.price_scale_config.PriceScaleConfig.for_logarithmic","title":"for_logarithmic  <code>staticmethod</code>","text":"<pre><code>for_logarithmic(scale_id: str, **kwargs) -&gt; PriceScaleOptions\n</code></pre> <p>Create price scale config for logarithmic scale.</p> <p>Logarithmic scales are useful for displaying data that spans several orders of magnitude or for emphasizing percentage changes.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>Unique identifier for the price scale.</p> required <code>**kwargs</code> <p>Additional PriceScaleOptions parameters to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriceScaleOptions</code> <p>PriceScaleOptions configured for logarithmic mode.</p> Example <p>config = PriceScaleConfig.for_logarithmic(\"price_log\") chart.add_overlay_price_scale(\"price_log\", config)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/utils/price_scale_config.py</code> <pre><code>@staticmethod\ndef for_logarithmic(\n    scale_id: str,\n    **kwargs,\n) -&gt; PriceScaleOptions:\n    \"\"\"Create price scale config for logarithmic scale.\n\n    Logarithmic scales are useful for displaying data that spans several\n    orders of magnitude or for emphasizing percentage changes.\n\n    Args:\n        scale_id: Unique identifier for the price scale.\n        **kwargs: Additional PriceScaleOptions parameters to override defaults.\n\n    Returns:\n        PriceScaleOptions configured for logarithmic mode.\n\n    Example:\n        &gt;&gt;&gt; config = PriceScaleConfig.for_logarithmic(\"price_log\")\n        &gt;&gt;&gt; chart.add_overlay_price_scale(\"price_log\", config)\n    \"\"\"\n    defaults = {\n        \"price_scale_id\": scale_id,\n        \"visible\": True,\n        \"auto_scale\": True,\n        \"mode\": PriceScaleMode.LOGARITHMIC,\n        \"scale_margins\": PriceScaleMargins(top=0.1, bottom=0.1),\n    }\n    defaults.update(kwargs)\n    return PriceScaleOptions(**defaults)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html","title":"streamlit_lightweight_charts_pro.charts.validators","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators","title":"validators","text":"<p>Chart validators package.</p> <p>This package provides validation utilities for chart configurations.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidationError","title":"PriceScaleValidationError","text":"<p>Raised when price scale validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidationError(Exception):\n    \"\"\"Raised when price scale validation fails.\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidator","title":"PriceScaleValidator","text":"<p>Validates price scale configurations and provides helpful errors.</p> <p>This validator helps developers catch common price scale configuration mistakes early with actionable error messages.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidator:\n    \"\"\"Validates price scale configurations and provides helpful errors.\n\n    This validator helps developers catch common price scale configuration\n    mistakes early with actionable error messages.\n    \"\"\"\n\n    @staticmethod\n    def validate_series_price_scale(\n        series: Series,\n        available_scales: Dict[str, PriceScaleOptions],\n        auto_create_enabled: bool = True,\n    ) -&gt; None:\n        \"\"\"Validate that series price_scale_id references existing scale.\n\n        Args:\n            series: The series to validate.\n            available_scales: Dictionary of available overlay price scales.\n            auto_create_enabled: Whether auto-creation is enabled.\n\n        Raises:\n            PriceScaleValidationError: If validation fails and auto-create is disabled.\n        \"\"\"\n        scale_id = getattr(series, \"price_scale_id\", \"\")\n\n        # Built-in scales always valid\n        if scale_id in (\"\", \"left\", \"right\"):\n            return\n\n        # Check if custom scale exists\n        if scale_id not in available_scales:\n            if auto_create_enabled:\n                # Auto-creation will handle this - no error needed\n                return\n\n            # Auto-creation disabled - provide helpful error\n            available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n            raise PriceScaleValidationError(\n                f\"Series references non-existent price scale '{scale_id}'. \"\n                f\"Available scales: {available}. \"\n                f\"\\n\\nOptions to fix this:\"\n                f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n                f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n                f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n            )\n\n    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n\n    @staticmethod\n    def validate_pane_configuration(\n        pane_id: int,\n        existing_series: list,\n    ) -&gt; Optional[str]:\n        \"\"\"Validate pane configuration and provide warnings if needed.\n\n        Args:\n            pane_id: The pane ID to validate.\n            existing_series: List of existing series in the chart.\n\n        Returns:\n            Warning message if configuration seems inefficient, None otherwise.\n        \"\"\"\n        # Check if multiple series in same pane use different custom scales\n        pane_scales = {}\n        for series in existing_series:\n            series_pane = getattr(series, \"pane_id\", 0)\n            if series_pane == pane_id:\n                scale_id = getattr(series, \"price_scale_id\", \"\")\n                if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                    if scale_id not in pane_scales:\n                        pane_scales[scale_id] = []\n                    pane_scales[scale_id].append(series)\n\n        # If multiple different custom scales in same pane, suggest consolidation\n        if len(pane_scales) &gt; 1:\n            scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n            return (\n                f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n                f\"Consider using a single shared scale for better performance, or use \"\n                f\"built-in scales ('left', 'right') for primary series.\"\n            )\n\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidator-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidator.validate_series_price_scale","title":"validate_series_price_scale  <code>staticmethod</code>","text":"<pre><code>validate_series_price_scale(series: Series, available_scales: Dict[str, PriceScaleOptions], auto_create_enabled: bool = True) -&gt; None\n</code></pre> <p>Validate that series price_scale_id references existing scale.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series to validate.</p> required <code>available_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Dictionary of available overlay price scales.</p> required <code>auto_create_enabled</code> <code>bool</code> <p>Whether auto-creation is enabled.</p> <code>True</code> <p>Raises:</p> Type Description <code>PriceScaleValidationError</code> <p>If validation fails and auto-create is disabled.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_series_price_scale(\n    series: Series,\n    available_scales: Dict[str, PriceScaleOptions],\n    auto_create_enabled: bool = True,\n) -&gt; None:\n    \"\"\"Validate that series price_scale_id references existing scale.\n\n    Args:\n        series: The series to validate.\n        available_scales: Dictionary of available overlay price scales.\n        auto_create_enabled: Whether auto-creation is enabled.\n\n    Raises:\n        PriceScaleValidationError: If validation fails and auto-create is disabled.\n    \"\"\"\n    scale_id = getattr(series, \"price_scale_id\", \"\")\n\n    # Built-in scales always valid\n    if scale_id in (\"\", \"left\", \"right\"):\n        return\n\n    # Check if custom scale exists\n    if scale_id not in available_scales:\n        if auto_create_enabled:\n            # Auto-creation will handle this - no error needed\n            return\n\n        # Auto-creation disabled - provide helpful error\n        available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n        raise PriceScaleValidationError(\n            f\"Series references non-existent price scale '{scale_id}'. \"\n            f\"Available scales: {available}. \"\n            f\"\\n\\nOptions to fix this:\"\n            f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n            f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n            f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidator.suggest_configuration","title":"suggest_configuration  <code>staticmethod</code>","text":"<pre><code>suggest_configuration(series_type: str, pane_id: int, is_overlay: bool) -&gt; str\n</code></pre> <p>Provide configuration suggestions based on context.</p> <p>Parameters:</p> Name Type Description Default <code>series_type</code> <code>str</code> <p>The type of series (e.g., 'LineSeries').</p> required <code>pane_id</code> <code>int</code> <p>The pane ID.</p> required <code>is_overlay</code> <code>bool</code> <p>Whether this is an overlay series.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted suggestion string.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/index.html#streamlit_lightweight_charts_pro.charts.validators.PriceScaleValidator.validate_pane_configuration","title":"validate_pane_configuration  <code>staticmethod</code>","text":"<pre><code>validate_pane_configuration(pane_id: int, existing_series: list) -&gt; Optional[str]\n</code></pre> <p>Validate pane configuration and provide warnings if needed.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to validate.</p> required <code>existing_series</code> <code>list</code> <p>List of existing series in the chart.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Warning message if configuration seems inefficient, None otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_pane_configuration(\n    pane_id: int,\n    existing_series: list,\n) -&gt; Optional[str]:\n    \"\"\"Validate pane configuration and provide warnings if needed.\n\n    Args:\n        pane_id: The pane ID to validate.\n        existing_series: List of existing series in the chart.\n\n    Returns:\n        Warning message if configuration seems inefficient, None otherwise.\n    \"\"\"\n    # Check if multiple series in same pane use different custom scales\n    pane_scales = {}\n    for series in existing_series:\n        series_pane = getattr(series, \"pane_id\", 0)\n        if series_pane == pane_id:\n            scale_id = getattr(series, \"price_scale_id\", \"\")\n            if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                if scale_id not in pane_scales:\n                    pane_scales[scale_id] = []\n                pane_scales[scale_id].append(series)\n\n    # If multiple different custom scales in same pane, suggest consolidation\n    if len(pane_scales) &gt; 1:\n        scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n        return (\n            f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n            f\"Consider using a single shared scale for better performance, or use \"\n            f\"built-in scales ('left', 'right') for primary series.\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html","title":"streamlit_lightweight_charts_pro.charts.validators.price_scale_validator","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator","title":"price_scale_validator","text":"<p>Price scale validation utilities.</p> <p>This module provides validation and helpful error messages for price scale configurations, helping developers catch common mistakes early.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidationError","title":"PriceScaleValidationError","text":"<p>Raised when price scale validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidationError(Exception):\n    \"\"\"Raised when price scale validation fails.\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidator","title":"PriceScaleValidator","text":"<p>Validates price scale configurations and provides helpful errors.</p> <p>This validator helps developers catch common price scale configuration mistakes early with actionable error messages.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>class PriceScaleValidator:\n    \"\"\"Validates price scale configurations and provides helpful errors.\n\n    This validator helps developers catch common price scale configuration\n    mistakes early with actionable error messages.\n    \"\"\"\n\n    @staticmethod\n    def validate_series_price_scale(\n        series: Series,\n        available_scales: Dict[str, PriceScaleOptions],\n        auto_create_enabled: bool = True,\n    ) -&gt; None:\n        \"\"\"Validate that series price_scale_id references existing scale.\n\n        Args:\n            series: The series to validate.\n            available_scales: Dictionary of available overlay price scales.\n            auto_create_enabled: Whether auto-creation is enabled.\n\n        Raises:\n            PriceScaleValidationError: If validation fails and auto-create is disabled.\n        \"\"\"\n        scale_id = getattr(series, \"price_scale_id\", \"\")\n\n        # Built-in scales always valid\n        if scale_id in (\"\", \"left\", \"right\"):\n            return\n\n        # Check if custom scale exists\n        if scale_id not in available_scales:\n            if auto_create_enabled:\n                # Auto-creation will handle this - no error needed\n                return\n\n            # Auto-creation disabled - provide helpful error\n            available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n            raise PriceScaleValidationError(\n                f\"Series references non-existent price scale '{scale_id}'. \"\n                f\"Available scales: {available}. \"\n                f\"\\n\\nOptions to fix this:\"\n                f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n                f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n                f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n            )\n\n    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n\n    @staticmethod\n    def validate_pane_configuration(\n        pane_id: int,\n        existing_series: list,\n    ) -&gt; Optional[str]:\n        \"\"\"Validate pane configuration and provide warnings if needed.\n\n        Args:\n            pane_id: The pane ID to validate.\n            existing_series: List of existing series in the chart.\n\n        Returns:\n            Warning message if configuration seems inefficient, None otherwise.\n        \"\"\"\n        # Check if multiple series in same pane use different custom scales\n        pane_scales = {}\n        for series in existing_series:\n            series_pane = getattr(series, \"pane_id\", 0)\n            if series_pane == pane_id:\n                scale_id = getattr(series, \"price_scale_id\", \"\")\n                if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                    if scale_id not in pane_scales:\n                        pane_scales[scale_id] = []\n                    pane_scales[scale_id].append(series)\n\n        # If multiple different custom scales in same pane, suggest consolidation\n        if len(pane_scales) &gt; 1:\n            scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n            return (\n                f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n                f\"Consider using a single shared scale for better performance, or use \"\n                f\"built-in scales ('left', 'right') for primary series.\"\n            )\n\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidator-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidator.validate_series_price_scale","title":"validate_series_price_scale  <code>staticmethod</code>","text":"<pre><code>validate_series_price_scale(series: Series, available_scales: Dict[str, PriceScaleOptions], auto_create_enabled: bool = True) -&gt; None\n</code></pre> <p>Validate that series price_scale_id references existing scale.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series to validate.</p> required <code>available_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Dictionary of available overlay price scales.</p> required <code>auto_create_enabled</code> <code>bool</code> <p>Whether auto-creation is enabled.</p> <code>True</code> <p>Raises:</p> Type Description <code>PriceScaleValidationError</code> <p>If validation fails and auto-create is disabled.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_series_price_scale(\n    series: Series,\n    available_scales: Dict[str, PriceScaleOptions],\n    auto_create_enabled: bool = True,\n) -&gt; None:\n    \"\"\"Validate that series price_scale_id references existing scale.\n\n    Args:\n        series: The series to validate.\n        available_scales: Dictionary of available overlay price scales.\n        auto_create_enabled: Whether auto-creation is enabled.\n\n    Raises:\n        PriceScaleValidationError: If validation fails and auto-create is disabled.\n    \"\"\"\n    scale_id = getattr(series, \"price_scale_id\", \"\")\n\n    # Built-in scales always valid\n    if scale_id in (\"\", \"left\", \"right\"):\n        return\n\n    # Check if custom scale exists\n    if scale_id not in available_scales:\n        if auto_create_enabled:\n            # Auto-creation will handle this - no error needed\n            return\n\n        # Auto-creation disabled - provide helpful error\n        available = \", \".join([\"left\", \"right\", *list(available_scales.keys())])\n        raise PriceScaleValidationError(\n            f\"Series references non-existent price scale '{scale_id}'. \"\n            f\"Available scales: {available}. \"\n            f\"\\n\\nOptions to fix this:\"\n            f\"\\n1. Enable auto-creation (default): auto_create_price_scales=True\"\n            f\"\\n2. Manually add scale: chart.add_overlay_price_scale('{scale_id}', options)\"\n            f\"\\n3. Use a built-in scale: price_scale_id='left' or 'right'\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidator.suggest_configuration","title":"suggest_configuration  <code>staticmethod</code>","text":"<pre><code>suggest_configuration(series_type: str, pane_id: int, is_overlay: bool) -&gt; str\n</code></pre> <p>Provide configuration suggestions based on context.</p> <p>Parameters:</p> Name Type Description Default <code>series_type</code> <code>str</code> <p>The type of series (e.g., 'LineSeries').</p> required <code>pane_id</code> <code>int</code> <p>The pane ID.</p> required <code>is_overlay</code> <code>bool</code> <p>Whether this is an overlay series.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted suggestion string.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>    @staticmethod\n    def suggest_configuration(\n        series_type: str,\n        pane_id: int,\n        is_overlay: bool,\n    ) -&gt; str:\n        \"\"\"Provide configuration suggestions based on context.\n\n        Args:\n            series_type: The type of series (e.g., 'LineSeries').\n            pane_id: The pane ID.\n            is_overlay: Whether this is an overlay series.\n\n        Returns:\n            Formatted suggestion string.\n        \"\"\"\n        if is_overlay:\n            return f\"\"\"\nDetected overlay series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_overlay(\"custom_id\")\n    chart.add_overlay_price_scale(\"custom_id\", scale)\n    series.price_scale_id = \"custom_id\"\n\"\"\"\n        return f\"\"\"\nDetected separate pane series ({series_type}) in pane {pane_id}.\nRecommended configuration:\n    # Option 1: Auto-creation (simplest)\n    chart.add_series(series)  # Price scale auto-created\n\n    # Option 2: Pane-centric API\n    chart.add_pane_with_series(\n        pane_id={pane_id},\n        series=your_series,\n        price_scale_id=\"pane_{pane_id}\"  # Auto-generated if omitted\n    )\n\n    # Option 3: Manual configuration\n    from streamlit_lightweight_charts_pro import PriceScaleConfig\n    scale = PriceScaleConfig.for_separate_pane(\"pane_{pane_id}\")\n    chart.add_overlay_price_scale(\"pane_{pane_id}\", scale)\n\"\"\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.html#streamlit_lightweight_charts_pro.charts.validators.price_scale_validator.PriceScaleValidator.validate_pane_configuration","title":"validate_pane_configuration  <code>staticmethod</code>","text":"<pre><code>validate_pane_configuration(pane_id: int, existing_series: list) -&gt; Optional[str]\n</code></pre> <p>Validate pane configuration and provide warnings if needed.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to validate.</p> required <code>existing_series</code> <code>list</code> <p>List of existing series in the chart.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Warning message if configuration seems inefficient, None otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/validators/price_scale_validator.py</code> <pre><code>@staticmethod\ndef validate_pane_configuration(\n    pane_id: int,\n    existing_series: list,\n) -&gt; Optional[str]:\n    \"\"\"Validate pane configuration and provide warnings if needed.\n\n    Args:\n        pane_id: The pane ID to validate.\n        existing_series: List of existing series in the chart.\n\n    Returns:\n        Warning message if configuration seems inefficient, None otherwise.\n    \"\"\"\n    # Check if multiple series in same pane use different custom scales\n    pane_scales = {}\n    for series in existing_series:\n        series_pane = getattr(series, \"pane_id\", 0)\n        if series_pane == pane_id:\n            scale_id = getattr(series, \"price_scale_id\", \"\")\n            if scale_id and scale_id not in (\"left\", \"right\", \"\"):\n                if scale_id not in pane_scales:\n                    pane_scales[scale_id] = []\n                pane_scales[scale_id].append(series)\n\n    # If multiple different custom scales in same pane, suggest consolidation\n    if len(pane_scales) &gt; 1:\n        scale_names = \", \".join(f\"'{s}'\" for s in pane_scales)\n        return (\n            f\"Warning: Pane {pane_id} has multiple custom price scales ({scale_names}). \"\n            f\"Consider using a single shared scale for better performance, or use \"\n            f\"built-in scales ('left', 'right') for primary series.\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/constants/index.html","title":"streamlit_lightweight_charts_pro.constants","text":""},{"location":"api/streamlit_lightweight_charts_pro/constants/index.html#streamlit_lightweight_charts_pro.constants","title":"constants","text":"<p>Global constants for streamlit-lightweight-charts-pro.</p> <p>This module contains all magic numbers, colors, timeouts, and other hardcoded values used throughout the library. Centralizing these values makes it easier to maintain consistency and modify behavior across the codebase.</p> <p>Author: Nand Kapadia License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html","title":"streamlit_lightweight_charts_pro.data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data","title":"data","text":"<p>Data model classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides the core data models used throughout the library for representing financial data points, markers, annotations, and other chart elements. It serves as the foundation for all data handling and visualization in the library.</p> <p>The data models are designed to be flexible and support various input formats while maintaining consistency in the internal representation. They provide type safety and validation for financial data structures.</p> The module includes <ul> <li>Base data classes: Data, SingleValueData, LineData, etc.</li> <li>OHLC data classes: CandlestickData, OhlcvData, BarData</li> <li>Specialized data classes: AreaData, BaselineData, HistogramData, BandData</li> <li>Marker classes: MarkerBase, PriceMarker, BarMarker, Marker</li> <li>Annotation system: Annotation, AnnotationLayer, AnnotationManager</li> <li>Trade visualization: TradeData, TradeType, TradeVisualizationOptions</li> <li>Tooltip system: TooltipConfig, TooltipManager, various tooltip creators</li> <li>Signal data: SignalData for signal-based visualizations</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import (\n    SingleValueData,\n    CandlestickData,\n    Marker,\n    create_text_annotation,\n)\n\n# Create single value data\ndata = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\n\n# Create OHLC data\nohlc_data = [CandlestickData(\"2024-01-01\", 100, 105, 98, 102, 1000)]\n\n# Create markers\nmarker = Marker(\"2024-01-01\", 100, MarkerPosition.ABOVE_BAR, MarkerShape.CIRCLE)\n\n# Create annotations\nannotation = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeVisualizationOptions","title":"TradeVisualizationOptions  <code>dataclass</code>","text":"<p>Options for trade visualization.</p> <p>This class provides comprehensive configuration options for how trades are displayed on charts, including various visual styles and customization options for markers, rectangles, lines, arrows, and zones.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>TradeVisualization</code> <p>The visualization style to use (markers, rectangles, both, etc.)</p> <code>entry_marker_color_long</code> <code>str</code> <p>Color for long entry markers</p> <code>entry_marker_color_short</code> <code>str</code> <p>Color for short entry markers</p> <code>exit_marker_color_profit</code> <code>str</code> <p>Color for profitable exit markers</p> <code>exit_marker_color_loss</code> <code>str</code> <p>Color for loss exit markers</p> <code>marker_size</code> <code>int</code> <p>Size of markers in pixels</p> <code>show_pnl_in_markers</code> <code>bool</code> <p>Whether to show P&amp;L in marker text</p> <code>rectangle_fill_opacity</code> <code>float</code> <p>Opacity for rectangle fill (0.0 to 1.0)</p> <code>rectangle_border_width</code> <code>int</code> <p>Width of rectangle borders</p> <code>rectangle_color_profit</code> <code>str</code> <p>Color for profitable trade rectangles</p> <code>rectangle_color_loss</code> <code>str</code> <p>Color for loss trade rectangles</p> <code>rectangle_fill_color_profit</code> <code>str</code> <p>Fill color for profitable trade rectangles</p> <code>rectangle_border_color_profit</code> <code>str</code> <p>Border color for profitable trade rectangles</p> <code>rectangle_border_color_loss</code> <code>str</code> <p>Border color for loss trade rectangles</p> <code>line_width</code> <code>int</code> <p>Width of connecting lines</p> <code>line_style</code> <code>str</code> <p>Style of connecting lines (solid, dashed, etc.)</p> <code>line_color_profit</code> <code>str</code> <p>Color for profitable trade lines</p> <code>line_color_loss</code> <code>str</code> <p>Color for loss trade lines</p> <code>arrow_size</code> <code>int</code> <p>Size of arrows in pixels</p> <code>arrow_color_profit</code> <code>str</code> <p>Color for profitable trade arrows</p> <code>arrow_color_loss</code> <code>str</code> <p>Color for loss trade arrows</p> <code>zone_opacity</code> <code>float</code> <p>Opacity for zone fills (0.0 to 1.0)</p> <code>zone_color_long</code> <code>str</code> <p>Color for long trade zones</p> <code>zone_color_short</code> <code>str</code> <p>Color for short trade zones</p> <code>zone_extend_bars</code> <code>int</code> <p>Number of bars to extend zones</p> <code>show_trade_id</code> <code>bool</code> <p>Whether to show trade ID in annotations</p> <code>show_quantity</code> <code>bool</code> <p>Whether to show quantity in annotations</p> <code>show_trade_type</code> <code>bool</code> <p>Whether to show trade type in annotations</p> <code>annotation_font_size</code> <code>int</code> <p>Font size for annotations</p> <code>annotation_background</code> <code>str</code> <p>Background color for annotations</p> <code>rectangle_show_text</code> <code>bool</code> <p>Whether to show text on rectangles</p> <code>rectangle_text_position</code> <code>str</code> <p>Position of text on rectangles (inside, above, below)</p> <code>rectangle_text_font_size</code> <code>int</code> <p>Font size for rectangle text</p> <code>rectangle_text_color</code> <code>str</code> <p>Color for rectangle text</p> <code>rectangle_text_background</code> <code>str</code> <p>Background color for rectangle text</p> <code>tooltip_template</code> <code>str</code> <p>Custom HTML template for tooltips with placeholders</p> <code>marker_template</code> <code>str</code> <p>Deprecated - use entry_marker_template and exit_marker_template</p> <code>entry_marker_template</code> <code>str</code> <p>Custom HTML template for entry marker text</p> <code>exit_marker_template</code> <code>str</code> <p>Custom HTML template for exit marker text</p> <code>entry_marker_shape</code> <code>str</code> <p>Shape for entry markers (arrow_up, arrow_down, circle, square)</p> <code>exit_marker_shape</code> <code>str</code> <p>Shape for exit markers (arrow_up, arrow_down, circle, square)</p> <code>entry_marker_position</code> <code>str</code> <p>Position for entry markers (above, below)</p> <code>exit_marker_position</code> <code>str</code> <p>Position for exit markers (above, below)</p> <code>show_marker_text</code> <code>bool</code> <p>Whether to show text on markers</p> Template Placeholders <p>For tooltips and markers, you can use these placeholders in your HTML templates. All fields from TradeData.additional_data are also available: - \\(\\(id\\)\\): Trade ID - \\(\\(entry_price\\)\\): Entry price value - \\(\\(exit_price\\)\\): Exit price value - \\(\\(is_profitable\\)\\): Boolean profitability flag - \\(\\(pnl\\)\\): Profit/Loss amount - \\(\\(pnl_percentage\\)\\): Profit/Loss percentage - \\(\\(trade_type\\)\\): LONG or SHORT (from additional_data) - \\(\\(quantity\\)\\): Trade quantity (from additional_data) - \\(\\(notes\\)\\): Trade notes (from additional_data) - Any custom field from additional_data: \\(\\(strategy\\)\\), \\(\\(risk_level\\)\\), etc.</p> Example templates <p>tooltip_template: \"\\(\\(trade_type\\)\\)Entry: \\(\\(entry_price\\)\\)Exit: \\(\\(exit_price\\)\\)P&amp;L: \\(\\(pnl\\)\\) (\\(\\(pnl_percentage\\)\\)%)\" entry_marker_template: \"\u2191 \\(\\(trade_type\\)\\)\\((\\(entry_price\\)\\)\" exit_marker_template: \"\u2193 ((\\(exit_price\\)\\)&lt;br/&gt;(\\)\\)pnl_percentage$$%)\"</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", TradeVisualization)\n@chainable_field(\"entry_marker_color_long\", str, validator=\"color\")\n@chainable_field(\"entry_marker_color_short\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_profit\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_loss\", str, validator=\"color\")\n@chainable_field(\"marker_size\", int)\n@chainable_field(\"show_pnl_in_markers\", bool)\n@chainable_field(\"rectangle_fill_opacity\", float)\n@chainable_field(\"rectangle_border_width\", int)\n@chainable_field(\"rectangle_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_color_loss\", str, validator=\"color\")\n@chainable_field(\"rectangle_fill_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_loss\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"line_color_profit\", str, validator=\"color\")\n@chainable_field(\"line_color_loss\", str, validator=\"color\")\n@chainable_field(\"arrow_size\", int)\n@chainable_field(\"arrow_color_profit\", str, validator=\"color\")\n@chainable_field(\"arrow_color_loss\", str, validator=\"color\")\n@chainable_field(\"zone_opacity\", float)\n@chainable_field(\"zone_color_long\", str, validator=\"color\")\n@chainable_field(\"zone_color_short\", str, validator=\"color\")\n@chainable_field(\"zone_extend_bars\", int)\n@chainable_field(\"show_trade_id\", bool)\n@chainable_field(\"show_quantity\", bool)\n@chainable_field(\"show_trade_type\", bool)\n@chainable_field(\"annotation_font_size\", int)\n@chainable_field(\"annotation_background\", str, validator=\"color\")\n@chainable_field(\"rectangle_show_text\", bool)\n@chainable_field(\"rectangle_text_position\", str)\n@chainable_field(\"rectangle_text_font_size\", int)\n@chainable_field(\"rectangle_text_color\", str, validator=\"color\")\n@chainable_field(\"rectangle_text_background\", str, validator=\"color\")\n@chainable_field(\"tooltip_template\", str)\n@chainable_field(\"marker_template\", str)\n@chainable_field(\"entry_marker_template\", str)\n@chainable_field(\"exit_marker_template\", str)\n@chainable_field(\"entry_marker_shape\", str)\n@chainable_field(\"exit_marker_shape\", str)\n@chainable_field(\"entry_marker_position\", str)\n@chainable_field(\"exit_marker_position\", str)\n@chainable_field(\"show_marker_text\", bool)\nclass TradeVisualizationOptions(Options):\n    \"\"\"Options for trade visualization.\n\n    This class provides comprehensive configuration options for how trades\n    are displayed on charts, including various visual styles and customization\n    options for markers, rectangles, lines, arrows, and zones.\n\n    Attributes:\n        style: The visualization style to use (markers, rectangles, both, etc.)\n        entry_marker_color_long: Color for long entry markers\n        entry_marker_color_short: Color for short entry markers\n        exit_marker_color_profit: Color for profitable exit markers\n        exit_marker_color_loss: Color for loss exit markers\n        marker_size: Size of markers in pixels\n        show_pnl_in_markers: Whether to show P&amp;L in marker text\n        rectangle_fill_opacity: Opacity for rectangle fill (0.0 to 1.0)\n        rectangle_border_width: Width of rectangle borders\n        rectangle_color_profit: Color for profitable trade rectangles\n        rectangle_color_loss: Color for loss trade rectangles\n        rectangle_fill_color_profit: Fill color for profitable trade rectangles\n        rectangle_border_color_profit: Border color for profitable trade rectangles\n        rectangle_border_color_loss: Border color for loss trade rectangles\n        line_width: Width of connecting lines\n        line_style: Style of connecting lines (solid, dashed, etc.)\n        line_color_profit: Color for profitable trade lines\n        line_color_loss: Color for loss trade lines\n        arrow_size: Size of arrows in pixels\n        arrow_color_profit: Color for profitable trade arrows\n        arrow_color_loss: Color for loss trade arrows\n        zone_opacity: Opacity for zone fills (0.0 to 1.0)\n        zone_color_long: Color for long trade zones\n        zone_color_short: Color for short trade zones\n        zone_extend_bars: Number of bars to extend zones\n        show_trade_id: Whether to show trade ID in annotations\n        show_quantity: Whether to show quantity in annotations\n        show_trade_type: Whether to show trade type in annotations\n        annotation_font_size: Font size for annotations\n        annotation_background: Background color for annotations\n        rectangle_show_text: Whether to show text on rectangles\n        rectangle_text_position: Position of text on rectangles (inside, above, below)\n        rectangle_text_font_size: Font size for rectangle text\n        rectangle_text_color: Color for rectangle text\n        rectangle_text_background: Background color for rectangle text\n        tooltip_template: Custom HTML template for tooltips with placeholders\n        marker_template: Deprecated - use entry_marker_template and exit_marker_template\n        entry_marker_template: Custom HTML template for entry marker text\n        exit_marker_template: Custom HTML template for exit marker text\n        entry_marker_shape: Shape for entry markers (arrow_up, arrow_down, circle, square)\n        exit_marker_shape: Shape for exit markers (arrow_up, arrow_down, circle, square)\n        entry_marker_position: Position for entry markers (above, below)\n        exit_marker_position: Position for exit markers (above, below)\n        show_marker_text: Whether to show text on markers\n\n    Template Placeholders:\n        For tooltips and markers, you can use these placeholders in your HTML templates.\n        All fields from TradeData.additional_data are also available:\n        - $$id$$: Trade ID\n        - $$entry_price$$: Entry price value\n        - $$exit_price$$: Exit price value\n        - $$is_profitable$$: Boolean profitability flag\n        - $$pnl$$: Profit/Loss amount\n        - $$pnl_percentage$$: Profit/Loss percentage\n        - $$trade_type$$: LONG or SHORT (from additional_data)\n        - $$quantity$$: Trade quantity (from additional_data)\n        - $$notes$$: Trade notes (from additional_data)\n        - Any custom field from additional_data: $$strategy$$, $$risk_level$$, etc.\n\n    Example templates:\n        tooltip_template: \"&lt;div&gt;&lt;strong&gt;$$trade_type$$&lt;/strong&gt;&lt;br/&gt;Entry: $$entry_price$$&lt;br/&gt;Exit: $$exit_price$$&lt;br/&gt;P&amp;L: $$pnl$$ ($$pnl_percentage$$%)&lt;/div&gt;\"\n        entry_marker_template: \"\u2191 $$trade_type$$&lt;br/&gt;$$$entry_price$$\"\n        exit_marker_template: \"\u2193 $$$exit_price$$&lt;br/&gt;($$pnl_percentage$$%)\"\n    \"\"\"\n\n    style: TradeVisualization = TradeVisualization.RECTANGLES\n\n    # Marker options\n    entry_marker_color_long: str = \"#2196F3\"\n    entry_marker_color_short: str = \"#FF9800\"\n    exit_marker_color_profit: str = \"#4CAF50\"\n    exit_marker_color_loss: str = \"#F44336\"\n    marker_size: int = 5\n    show_pnl_in_markers: bool = False\n\n    # Rectangle options\n    rectangle_fill_opacity: float = 0.1\n    rectangle_border_width: int = 1\n    rectangle_color_profit: str = \"#4CAF50\"\n    rectangle_color_loss: str = \"#F44336\"\n    rectangle_fill_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_loss: str = \"#F44336\"\n\n    # Line options\n    line_width: int = 2\n    line_style: str = \"dashed\"\n    line_color_profit: str = \"#4CAF50\"\n    line_color_loss: str = \"#F44336\"\n\n    # Arrow options\n    arrow_size: int = 10\n    arrow_color_profit: str = \"#4CAF50\"\n    arrow_color_loss: str = \"#F44336\"\n\n    # Zone options\n    zone_opacity: float = 0.1\n    zone_color_long: str = \"#2196F3\"\n    zone_color_short: str = \"#FF9800\"\n    zone_extend_bars: int = 2  # Extend zone by this many bars\n\n    # Annotation options\n    show_trade_id: bool = False\n    show_quantity: bool = True\n    show_trade_type: bool = True\n    annotation_font_size: int = 12\n    annotation_background: str = \"rgba(255, 255, 255, 0.8)\"\n\n    # Rectangle text options\n    rectangle_show_text: bool = False\n    rectangle_text_position: str = \"inside\"  # inside, above, below\n    rectangle_text_font_size: int = 10\n    rectangle_text_color: str = \"#FFFFFF\"\n    rectangle_text_background: str = \"rgba(0, 0, 0, 0.7)\"\n\n    # Template options\n    tooltip_template: str = \"\"  # Custom HTML template for tooltips\n    marker_template: str = \"\"  # Deprecated - use entry/exit templates\n    entry_marker_template: str = \"\"  # Custom HTML template for entry markers\n    exit_marker_template: str = \"\"  # Custom HTML template for exit markers\n\n    # Marker shape and position options\n    entry_marker_shape: str = \"arrowUp\"  # arrowUp, arrowDown, circle, square\n    exit_marker_shape: str = \"arrowDown\"  # arrowUp, arrowDown, circle, square\n    entry_marker_position: str = \"belowBar\"  # belowBar, aboveBar\n    exit_marker_position: str = \"aboveBar\"  # belowBar, aboveBar\n    show_marker_text: bool = True  # Whether to show text on markers\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize options.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates all configuration values and sets defaults for invalid values.\n\n        Raises:\n            ValueError: If the style string cannot be converted to TradeVisualization enum.\n        \"\"\"\n        # Step 1: Convert style to enum if it's a string\n        # Allows users to pass \"rectangles\" instead of TradeVisualization.RECTANGLES\n        if isinstance(self.style, str):\n            self.style = TradeVisualization(self.style.lower())\n\n        # Step 2: Validate rectangle text position\n        # Ensures only valid positions are used (inside, above, below)\n        valid_positions = [\"inside\", \"above\", \"below\"]\n        if self.rectangle_text_position.lower() not in valid_positions:\n            # Default to \"inside\" if invalid position provided\n            self.rectangle_text_position = \"inside\"\n\n        # Step 3: Validate marker shapes\n        # Ensures only TradingView-supported shapes are used\n        valid_shapes = [\"arrowUp\", \"arrowDown\", \"circle\", \"square\"]\n        if self.entry_marker_shape not in valid_shapes:\n            # Default to arrowUp for entry if invalid shape provided\n            self.entry_marker_shape = \"arrowUp\"\n        if self.exit_marker_shape not in valid_shapes:\n            # Default to arrowDown for exit if invalid shape provided\n            self.exit_marker_shape = \"arrowDown\"\n\n        # Step 4: Validate marker positions\n        # Ensures only valid positions are used (belowBar, aboveBar)\n        valid_marker_positions = [\"belowBar\", \"aboveBar\"]\n        if self.entry_marker_position not in valid_marker_positions:\n            # Default to belowBar for entry (typical for long trades)\n            self.entry_marker_position = \"belowBar\"\n        if self.exit_marker_position not in valid_marker_positions:\n            # Default to aboveBar for exit (typical for long trades)\n            self.exit_marker_position = \"aboveBar\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation","title":"Annotation","text":"<p>Represents a chart annotation.</p> <p>This class defines an annotation that can be displayed on charts to provide additional context, highlight important events, or add explanatory information. Annotations support various types, positions, and styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Annotation time (accepts pd.Timestamp, datetime, or string)</p> <code>price</code> <code>float</code> <p>Price level for the annotation</p> <code>text</code> <code>str</code> <p>Annotation text content</p> <code>annotation_type</code> <code>AnnotationType</code> <p>Type of annotation (text, arrow, shape, etc.)</p> <code>position</code> <code>AnnotationPosition</code> <p>Position of the annotation relative to the price level</p> <code>color</code> <code>str</code> <p>Primary color of the annotation</p> <code>background_color</code> <code>str</code> <p>Background color for text annotations</p> <code>font_size</code> <code>int</code> <p>Font size for text annotations</p> <code>font_weight</code> <code>str</code> <p>Font weight for text annotations</p> <code>text_color</code> <code>str</code> <p>Color of the text content</p> <code>border_color</code> <code>str</code> <p>Border color for shape annotations</p> <code>border_width</code> <code>int</code> <p>Border width for shape annotations</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the annotation (0.0 to 1.0)</p> <code>show_time</code> <code>bool</code> <p>Whether to show time in the annotation text</p> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip text for hover interactions</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class Annotation:\n    \"\"\"Represents a chart annotation.\n\n    This class defines an annotation that can be displayed on charts to\n    provide additional context, highlight important events, or add\n    explanatory information. Annotations support various types, positions,\n    and styling options.\n\n    Attributes:\n        time: Annotation time (accepts pd.Timestamp, datetime, or string)\n        price: Price level for the annotation\n        text: Annotation text content\n        annotation_type: Type of annotation (text, arrow, shape, etc.)\n        position: Position of the annotation relative to the price level\n        color: Primary color of the annotation\n        background_color: Background color for text annotations\n        font_size: Font size for text annotations\n        font_weight: Font weight for text annotations\n        text_color: Color of the text content\n        border_color: Border color for shape annotations\n        border_width: Border width for shape annotations\n        opacity: Overall opacity of the annotation (0.0 to 1.0)\n        show_time: Whether to show time in the annotation text\n        tooltip: Optional tooltip text for hover interactions\n    \"\"\"\n\n    time: Union[pd.Timestamp, datetime, str, int, float]\n    price: float\n    text: str\n    annotation_type: AnnotationType = AnnotationType.TEXT\n    position: AnnotationPosition = AnnotationPosition.ABOVE\n    color: str = \"#2196F3\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    font_size: int = 12\n    font_weight: str = \"normal\"\n    text_color: str = \"#000000\"\n    border_color: str = \"#CCCCCC\"\n    border_width: int = 1\n    opacity: float = 1.0\n    show_time: bool = False\n    tooltip: Optional[str] = None\n\n    def __init__(\n        self,\n        time: Union[pd.Timestamp, datetime, str, int, float],\n        price: float,\n        text: str,\n        annotation_type: Union[str, AnnotationType] = AnnotationType.TEXT,\n        position: Union[str, AnnotationPosition] = AnnotationPosition.ABOVE,\n        color: str = \"#2196F3\",\n        background_color: str = \"rgba(255, 255, 255, 0.9)\",\n        font_size: int = 12,\n        font_weight: str = \"normal\",\n        text_color: str = \"#000000\",\n        border_color: str = \"#CCCCCC\",\n        border_width: int = 1,\n        opacity: float = 1.0,\n        show_time: bool = False,\n        tooltip: Optional[str] = None,\n    ):\n        # Store time as-is, convert to UTC timestamp in asdict() for consistency\n        self.time = time\n\n        # Accept both str and Enum for annotation_type\n        if isinstance(annotation_type, str):\n            self.annotation_type = AnnotationType(annotation_type)\n        else:\n            self.annotation_type = annotation_type\n\n        # Accept both str and Enum for position\n        if isinstance(position, str):\n            self.position = AnnotationPosition(position)\n        else:\n            self.position = position\n\n        # Validate price value\n        if not isinstance(price, (int, float)):\n            raise TypeValidationError(\"price\", \"a number\")\n        self.price = price\n\n        # Validate text content\n        if not text:\n            raise ValueValidationError.required_field(\"text\")\n        self.text = text\n\n        # Validate opacity range\n        if opacity &lt; 0 or opacity &gt; 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n\n        # Validate font size\n        if font_size &lt;= 0:\n            raise ValueValidationError.positive_value(\"font_size\", font_size)\n        self.font_size = font_size\n\n        # Validate border width\n        if border_width &lt; 0:\n            raise ValueValidationError(\"border_width\", f\"must be non-negative, got {border_width}\")\n        self.border_width = border_width\n\n        self.color = color\n        self.background_color = background_color\n        self.font_weight = font_weight\n        self.text_color = text_color\n        self.border_color = border_color\n        self.show_time = show_time\n        self.tooltip = tooltip\n\n    @property\n    def timestamp(self) -&gt; int:\n        \"\"\"Get time as UTC timestamp (converted fresh).\n\n        Converts the time value to UTC timestamp each time it's accessed.\n        This allows the time to be modified after construction.\n\n        Returns:\n            int: UTC timestamp as integer (seconds).\n        \"\"\"\n        return to_utc_timestamp(self.time)\n\n    @property\n    def datetime_value(self) -&gt; pd.Timestamp:\n        \"\"\"Get time as pandas Timestamp.\n\n        Returns:\n            pd.Timestamp: Pandas Timestamp object representing the\n                annotation time.\n        \"\"\"\n        return pd.Timestamp(from_utc_timestamp(to_utc_timestamp(self.time)))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert annotation to dictionary for serialization.\n\n        This method creates a dictionary representation of the annotation\n        suitable for JSON serialization or frontend consumption.\n\n        Time conversion happens here (not cached) to allow users to modify\n        time values after construction.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing all annotation properties\n                in a format suitable for the frontend component.\n        \"\"\"\n        # Convert time fresh during serialization\n        return {\n            ColumnNames.TIME: to_utc_timestamp(self.time),\n            \"price\": self.price,\n            \"text\": self.text,\n            \"type\": self.annotation_type.value,\n            \"position\": self.position.value,\n            \"color\": self.color,\n            \"background_color\": self.background_color,\n            \"font_size\": self.font_size,\n            \"font_weight\": self.font_weight,\n            \"text_color\": self.text_color,\n            \"border_color\": self.border_color,\n            \"border_width\": self.border_width,\n            \"opacity\": self.opacity,\n            \"show_time\": self.show_time,\n            \"tooltip\": self.tooltip,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: int\n</code></pre> <p>Get time as UTC timestamp (converted fresh).</p> <p>Converts the time value to UTC timestamp each time it's accessed. This allows the time to be modified after construction.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UTC timestamp as integer (seconds).</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation.datetime_value","title":"datetime_value  <code>property</code>","text":"<pre><code>datetime_value: Timestamp\n</code></pre> <p>Get time as pandas Timestamp.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: Pandas Timestamp object representing the annotation time.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Annotation.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert annotation to dictionary for serialization.</p> <p>This method creates a dictionary representation of the annotation suitable for JSON serialization or frontend consumption.</p> <p>Time conversion happens here (not cached) to allow users to modify time values after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing all annotation properties in a format suitable for the frontend component.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert annotation to dictionary for serialization.\n\n    This method creates a dictionary representation of the annotation\n    suitable for JSON serialization or frontend consumption.\n\n    Time conversion happens here (not cached) to allow users to modify\n    time values after construction.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing all annotation properties\n            in a format suitable for the frontend component.\n    \"\"\"\n    # Convert time fresh during serialization\n    return {\n        ColumnNames.TIME: to_utc_timestamp(self.time),\n        \"price\": self.price,\n        \"text\": self.text,\n        \"type\": self.annotation_type.value,\n        \"position\": self.position.value,\n        \"color\": self.color,\n        \"background_color\": self.background_color,\n        \"font_size\": self.font_size,\n        \"font_weight\": self.font_weight,\n        \"text_color\": self.text_color,\n        \"border_color\": self.border_color,\n        \"border_width\": self.border_width,\n        \"opacity\": self.opacity,\n        \"show_time\": self.show_time,\n        \"tooltip\": self.tooltip,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer","title":"AnnotationLayer  <code>dataclass</code>","text":"<p>Manages a layer of annotations for a chart.</p> <p>This class provides functionality for grouping related annotations together and applying bulk operations to them. Layers can be shown, hidden, or have their opacity adjusted as a group.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this layer</p> <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects in this layer</p> <code>visible</code> <code>bool</code> <p>Whether this layer is currently visible</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the layer (0.0 to 1.0)</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>@dataclass\nclass AnnotationLayer:\n    \"\"\"Manages a layer of annotations for a chart.\n\n    This class provides functionality for grouping related annotations\n    together and applying bulk operations to them. Layers can be shown,\n    hidden, or have their opacity adjusted as a group.\n\n    Attributes:\n        name: Unique name identifier for this layer\n        annotations: List of annotation objects in this layer\n        visible: Whether this layer is currently visible\n        opacity: Overall opacity of the layer (0.0 to 1.0)\n    \"\"\"\n\n    name: str\n    annotations: List[Annotation]\n    visible: bool = True\n    opacity: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate annotation layer after initialization.\n\n        Raises:\n            ValueError: If layer name is empty or opacity is invalid.\n        \"\"\"\n        if not self.name:\n            raise ValueValidationError.required_field(\"layer name\")\n\n        if not 0 &lt;= self.opacity &lt;= 1:\n            raise ValueValidationError(\n                \"opacity\",\n                f\"must be between 0.0 and 1.0, got {self.opacity}\",\n            )\n\n    def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n        \"\"\"Add annotation to layer.\n\n        Adds a single annotation to this layer and returns self for\n        method chaining.\n\n        Args:\n            annotation: Annotation object to add to the layer.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.add_annotation(text_annotation)\n            ```\n        \"\"\"\n        self.annotations.append(annotation)\n        return self\n\n    def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n        \"\"\"Remove annotation by index.\n\n        Removes an annotation from the layer by its index position\n        and returns self for method chaining.\n\n        Args:\n            index: Index of the annotation to remove.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.remove_annotation(0)  # Remove first annotation\n            ```\n        \"\"\"\n        if 0 &lt;= index &lt; len(self.annotations):\n            self.annotations.pop(index)\n        return self\n\n    def clear_annotations(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Clear all annotations from layer.\n\n        Removes all annotations from this layer and returns self\n        for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.clear_annotations()\n            ```\n        \"\"\"\n        self.annotations.clear()\n        return self\n\n    def hide(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Hide the layer.\n\n        Makes this layer and all its annotations invisible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.hide()\n            ```\n        \"\"\"\n        self.visible = False\n        return self\n\n    def show(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Show the layer.\n\n        Makes this layer and all its annotations visible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.show()\n            ```\n        \"\"\"\n        self.visible = True\n        return self\n\n    def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n        \"\"\"Set layer opacity.\n\n        Sets the overall opacity of this layer and returns self\n        for method chaining.\n\n        Args:\n            opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n\n        Example:\n            ```python\n            layer.set_opacity(0.5)  # 50% opacity\n            ```\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n        return self\n\n    def filter_by_time_range(\n        self,\n        start_time: Union[pd.Timestamp, datetime, str, int, float],\n        end_time: Union[pd.Timestamp, datetime, str, int, float],\n    ) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by time range.\n\n        Returns a list of annotations that fall within the specified\n        time range.\n\n        Args:\n            start_time: Start of the time range in various formats.\n            end_time: End of the time range in various formats.\n\n        Returns:\n            List[Annotation]: List of annotations within the time range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n            ```\n        \"\"\"\n        start_ts = to_utc_timestamp(start_time)\n        end_ts = to_utc_timestamp(end_time)\n\n        return [\n            annotation\n            for annotation in self.annotations\n            if start_ts &lt;= annotation.timestamp &lt;= end_ts\n        ]\n\n    def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by price range.\n\n        Returns a list of annotations that fall within the specified\n        price range.\n\n        Args:\n            min_price: Minimum price value.\n            max_price: Maximum price value.\n\n        Returns:\n            List[Annotation]: List of annotations within the price range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_price_range(100.0, 200.0)\n            ```\n        \"\"\"\n        return [\n            annotation\n            for annotation in self.annotations\n            if min_price &lt;= annotation.price &lt;= max_price\n        ]\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert layer to dictionary for serialization.\n\n        Creates a dictionary representation of the layer including\n        its properties and all contained annotations.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the layer.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"visible\": self.visible,\n            \"opacity\": self.opacity,\n            \"annotations\": [annotation.asdict() for annotation in self.annotations],\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation) -&gt; AnnotationLayer\n</code></pre> <p>Add annotation to layer.</p> <p>Adds a single annotation to this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.add_annotation(text_annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n    \"\"\"Add annotation to layer.\n\n    Adds a single annotation to this layer and returns self for\n    method chaining.\n\n    Args:\n        annotation: Annotation object to add to the layer.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.add_annotation(text_annotation)\n        ```\n    \"\"\"\n    self.annotations.append(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(index: int) -&gt; AnnotationLayer\n</code></pre> <p>Remove annotation by index.</p> <p>Removes an annotation from the layer by its index position and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the annotation to remove.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.remove_annotation(0)  # Remove first annotation\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n    \"\"\"Remove annotation by index.\n\n    Removes an annotation from the layer by its index position\n    and returns self for method chaining.\n\n    Args:\n        index: Index of the annotation to remove.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.remove_annotation(0)  # Remove first annotation\n        ```\n    \"\"\"\n    if 0 &lt;= index &lt; len(self.annotations):\n        self.annotations.pop(index)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations() -&gt; AnnotationLayer\n</code></pre> <p>Clear all annotations from layer.</p> <p>Removes all annotations from this layer and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.clear_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_annotations(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Clear all annotations from layer.\n\n    Removes all annotations from this layer and returns self\n    for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.clear_annotations()\n        ```\n    \"\"\"\n    self.annotations.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.hide","title":"hide","text":"<pre><code>hide() -&gt; AnnotationLayer\n</code></pre> <p>Hide the layer.</p> <p>Makes this layer and all its annotations invisible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.hide()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Hide the layer.\n\n    Makes this layer and all its annotations invisible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.hide()\n        ```\n    \"\"\"\n    self.visible = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.show","title":"show","text":"<pre><code>show() -&gt; AnnotationLayer\n</code></pre> <p>Show the layer.</p> <p>Makes this layer and all its annotations visible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.show()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Show the layer.\n\n    Makes this layer and all its annotations visible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.show()\n        ```\n    \"\"\"\n    self.visible = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.set_opacity","title":"set_opacity","text":"<pre><code>set_opacity(opacity: float) -&gt; AnnotationLayer\n</code></pre> <p>Set layer opacity.</p> <p>Sets the overall opacity of this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0.0 (transparent) and 1.0 (opaque).</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opacity is not between 0 and 1.</p> Example <pre><code>layer.set_opacity(0.5)  # 50% opacity\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n    \"\"\"Set layer opacity.\n\n    Sets the overall opacity of this layer and returns self\n    for method chaining.\n\n    Args:\n        opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Raises:\n        ValueError: If opacity is not between 0 and 1.\n\n    Example:\n        ```python\n        layer.set_opacity(0.5)  # 50% opacity\n        ```\n    \"\"\"\n    if not 0 &lt;= opacity &lt;= 1:\n        raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n    self.opacity = opacity\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.filter_by_time_range","title":"filter_by_time_range","text":"<pre><code>filter_by_time_range(start_time: Union[Timestamp, datetime, str, int, float], end_time: Union[Timestamp, datetime, str, int, float]) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by time range.</p> <p>Returns a list of annotations that fall within the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Start of the time range in various formats.</p> required <code>end_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>End of the time range in various formats.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the time range.</p> Example <pre><code>annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_time_range(\n    self,\n    start_time: Union[pd.Timestamp, datetime, str, int, float],\n    end_time: Union[pd.Timestamp, datetime, str, int, float],\n) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by time range.\n\n    Returns a list of annotations that fall within the specified\n    time range.\n\n    Args:\n        start_time: Start of the time range in various formats.\n        end_time: End of the time range in various formats.\n\n    Returns:\n        List[Annotation]: List of annotations within the time range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n        ```\n    \"\"\"\n    start_ts = to_utc_timestamp(start_time)\n    end_ts = to_utc_timestamp(end_time)\n\n    return [\n        annotation\n        for annotation in self.annotations\n        if start_ts &lt;= annotation.timestamp &lt;= end_ts\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.filter_by_price_range","title":"filter_by_price_range","text":"<pre><code>filter_by_price_range(min_price: float, max_price: float) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by price range.</p> <p>Returns a list of annotations that fall within the specified price range.</p> <p>Parameters:</p> Name Type Description Default <code>min_price</code> <code>float</code> <p>Minimum price value.</p> required <code>max_price</code> <code>float</code> <p>Maximum price value.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the price range.</p> Example <pre><code>annotations = layer.filter_by_price_range(100.0, 200.0)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by price range.\n\n    Returns a list of annotations that fall within the specified\n    price range.\n\n    Args:\n        min_price: Minimum price value.\n        max_price: Maximum price value.\n\n    Returns:\n        List[Annotation]: List of annotations within the price range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_price_range(100.0, 200.0)\n        ```\n    \"\"\"\n    return [\n        annotation\n        for annotation in self.annotations\n        if min_price &lt;= annotation.price &lt;= max_price\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationLayer.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert layer to dictionary for serialization.</p> <p>Creates a dictionary representation of the layer including its properties and all contained annotations.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the layer.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert layer to dictionary for serialization.\n\n    Creates a dictionary representation of the layer including\n    its properties and all contained annotations.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the layer.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"visible\": self.visible,\n        \"opacity\": self.opacity,\n        \"annotations\": [annotation.asdict() for annotation in self.annotations],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager","title":"AnnotationManager","text":"<p>Manages multiple annotation layers for a chart.</p> <p>This class provides a centralized way to manage multiple annotation layers, allowing for organization of annotations into logical groups. It supports creating, removing, and manipulating layers, as well as bulk operations across all layers.</p> <p>The AnnotationManager supports method chaining for fluent API usage and provides comprehensive layer management capabilities.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>Dict[str, AnnotationLayer]</code> <p>Dictionary mapping layer names to AnnotationLayer objects</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class AnnotationManager:\n    \"\"\"Manages multiple annotation layers for a chart.\n\n    This class provides a centralized way to manage multiple annotation\n    layers, allowing for organization of annotations into logical groups.\n    It supports creating, removing, and manipulating layers, as well as\n    bulk operations across all layers.\n\n    The AnnotationManager supports method chaining for fluent API usage\n    and provides comprehensive layer management capabilities.\n\n    Attributes:\n        layers: Dictionary mapping layer names to AnnotationLayer objects\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the annotation manager.\n\n        Creates a new AnnotationManager with an empty layers dictionary.\n        \"\"\"\n        self.layers: Dict[str, AnnotationLayer] = {}\n\n    def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new empty annotation layer with the specified name.\n        If a layer with that name already exists, returns self for method chaining.\n\n        Args:\n            name: Name for the new layer.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.create_layer(\"technical_analysis\")\n            ```\n        \"\"\"\n        if name not in self.layers:\n            layer = AnnotationLayer(name=name, annotations=[])\n            self.layers[name] = layer\n        return self\n\n    def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n        \"\"\"Get an annotation layer by name.\n\n        Args:\n            name: Name of the layer to retrieve.\n\n        Returns:\n            Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n        Example:\n            ```python\n            layer = manager.get_layer(\"events\")\n            if layer:\n                layer.add_annotation(annotation)\n            ```\n        \"\"\"\n        return self.layers.get(name)\n\n    def remove_layer(self, name: str) -&gt; bool:\n        \"\"\"Remove an annotation layer by name.\n\n        Removes the specified layer and all its annotations. Returns\n        True if the layer was found and removed, False otherwise.\n\n        Args:\n            name: Name of the layer to remove.\n\n        Returns:\n            bool: True if layer was removed, False if layer didn't exist.\n\n        Example:\n            ```python\n            success = manager.remove_layer(\"old_layer\")\n            if success:\n                logger.info(\"Layer removed successfully\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            del self.layers[name]\n            return True\n        return False\n\n    def clear_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotation layers.\n\n        Removes all layers and their annotations. Returns self for\n        method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_all_layers()\n            ```\n        \"\"\"\n        self.layers.clear()\n        return self\n\n    def add_annotation(\n        self,\n        annotation: Annotation,\n        layer_name: str = \"default\",\n    ) -&gt; \"AnnotationManager\":\n        \"\"\"Add annotation to a specific layer.\n\n        Adds an annotation to the specified layer. If the layer doesn't exist,\n        it will be created automatically. Returns self for method chaining.\n\n        Args:\n            annotation: Annotation object to add.\n            layer_name: Name of the layer to add the annotation to.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.add_annotation(text_annotation, \"events\")\n            ```\n        \"\"\"\n        if layer_name not in self.layers:\n            self.create_layer(layer_name)\n\n        self.layers[layer_name].add_annotation(annotation)\n        return self\n\n    def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Hide a specific annotation layer.\n\n        Makes the specified layer and all its annotations invisible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to hide.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].hide()\n        return self\n\n    def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Show a specific annotation layer.\n\n        Makes the specified layer and all its annotations visible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to show.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].show()\n        return self\n\n    def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotations from a specific layer.\n\n        Removes all annotations from the specified layer while keeping\n        the layer itself. Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to clear.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].clear_annotations()\n        return self\n\n    def get_all_annotations(self) -&gt; List[Annotation]:\n        \"\"\"Get all annotations from all layers.\n\n        Returns a flat list of all annotations from all layers,\n        regardless of layer visibility.\n\n        Returns:\n            List[Annotation]: List of all annotations across all layers.\n\n        Example:\n            ```python\n            all_annotations = manager.get_all_annotations()\n            ```\n        \"\"\"\n        all_annotations = []\n        for layer in self.layers.values():\n            all_annotations.extend(layer.annotations)\n        return all_annotations\n\n    def hide_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Hide all annotation layers.\n\n        Makes all layers and their annotations invisible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.hide()\n        return self\n\n    def show_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Show all annotation layers.\n\n        Makes all layers and their annotations visible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.show()\n        return self\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert manager to dictionary for serialization.\n\n        Creates a dictionary representation of all layers and their\n        annotations suitable for serialization.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of all layers with\n                a \"layers\" wrapper containing layer names as keys.\n        \"\"\"\n        return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.create_layer","title":"create_layer","text":"<pre><code>create_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new empty annotation layer with the specified name. If a layer with that name already exists, returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.create_layer(\"technical_analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new empty annotation layer with the specified name.\n    If a layer with that name already exists, returns self for method chaining.\n\n    Args:\n        name: Name for the new layer.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.create_layer(\"technical_analysis\")\n        ```\n    \"\"\"\n    if name not in self.layers:\n        layer = AnnotationLayer(name=name, annotations=[])\n        self.layers[name] = layer\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str) -&gt; Optional[AnnotationLayer]\n</code></pre> <p>Get an annotation layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[AnnotationLayer]</code> <p>Optional[AnnotationLayer]: The layer if found, None otherwise.</p> Example <pre><code>layer = manager.get_layer(\"events\")\nif layer:\n    layer.add_annotation(annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n    \"\"\"Get an annotation layer by name.\n\n    Args:\n        name: Name of the layer to retrieve.\n\n    Returns:\n        Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n    Example:\n        ```python\n        layer = manager.get_layer(\"events\")\n        if layer:\n            layer.add_annotation(annotation)\n        ```\n    \"\"\"\n    return self.layers.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.remove_layer","title":"remove_layer","text":"<pre><code>remove_layer(name: str) -&gt; bool\n</code></pre> <p>Remove an annotation layer by name.</p> <p>Removes the specified layer and all its annotations. Returns True if the layer was found and removed, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if layer was removed, False if layer didn't exist.</p> Example <pre><code>success = manager.remove_layer(\"old_layer\")\nif success:\n    logger.info(\"Layer removed successfully\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_layer(self, name: str) -&gt; bool:\n    \"\"\"Remove an annotation layer by name.\n\n    Removes the specified layer and all its annotations. Returns\n    True if the layer was found and removed, False otherwise.\n\n    Args:\n        name: Name of the layer to remove.\n\n    Returns:\n        bool: True if layer was removed, False if layer didn't exist.\n\n    Example:\n        ```python\n        success = manager.remove_layer(\"old_layer\")\n        if success:\n            logger.info(\"Layer removed successfully\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        del self.layers[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.clear_all_layers","title":"clear_all_layers","text":"<pre><code>clear_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Clear all annotation layers.</p> <p>Removes all layers and their annotations. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotation layers.\n\n    Removes all layers and their annotations. Returns self for\n    method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_all_layers()\n        ```\n    \"\"\"\n    self.layers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; AnnotationManager\n</code></pre> <p>Add annotation to a specific layer.</p> <p>Adds an annotation to the specified layer. If the layer doesn't exist, it will be created automatically. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer to add the annotation to.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.add_annotation(text_annotation, \"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(\n    self,\n    annotation: Annotation,\n    layer_name: str = \"default\",\n) -&gt; \"AnnotationManager\":\n    \"\"\"Add annotation to a specific layer.\n\n    Adds an annotation to the specified layer. If the layer doesn't exist,\n    it will be created automatically. Returns self for method chaining.\n\n    Args:\n        annotation: Annotation object to add.\n        layer_name: Name of the layer to add the annotation to.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.add_annotation(text_annotation, \"events\")\n        ```\n    \"\"\"\n    if layer_name not in self.layers:\n        self.create_layer(layer_name)\n\n    self.layers[layer_name].add_annotation(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.hide_layer","title":"hide_layer","text":"<pre><code>hide_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Hide a specific annotation layer.</p> <p>Makes the specified layer and all its annotations invisible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to hide.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Hide a specific annotation layer.\n\n    Makes the specified layer and all its annotations invisible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to hide.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.show_layer","title":"show_layer","text":"<pre><code>show_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Show a specific annotation layer.</p> <p>Makes the specified layer and all its annotations visible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to show.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Show a specific annotation layer.\n\n    Makes the specified layer and all its annotations visible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to show.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.clear_layer","title":"clear_layer","text":"<pre><code>clear_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Clear all annotations from a specific layer.</p> <p>Removes all annotations from the specified layer while keeping the layer itself. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to clear.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotations from a specific layer.\n\n    Removes all annotations from the specified layer while keeping\n    the layer itself. Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to clear.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].clear_annotations()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.get_all_annotations","title":"get_all_annotations","text":"<pre><code>get_all_annotations() -&gt; List[Annotation]\n</code></pre> <p>Get all annotations from all layers.</p> <p>Returns a flat list of all annotations from all layers, regardless of layer visibility.</p> <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of all annotations across all layers.</p> Example <pre><code>all_annotations = manager.get_all_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_all_annotations(self) -&gt; List[Annotation]:\n    \"\"\"Get all annotations from all layers.\n\n    Returns a flat list of all annotations from all layers,\n    regardless of layer visibility.\n\n    Returns:\n        List[Annotation]: List of all annotations across all layers.\n\n    Example:\n        ```python\n        all_annotations = manager.get_all_annotations()\n        ```\n    \"\"\"\n    all_annotations = []\n    for layer in self.layers.values():\n        all_annotations.extend(layer.annotations)\n    return all_annotations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.hide_all_layers","title":"hide_all_layers","text":"<pre><code>hide_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Hide all annotation layers.</p> <p>Makes all layers and their annotations invisible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Hide all annotation layers.\n\n    Makes all layers and their annotations invisible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.show_all_layers","title":"show_all_layers","text":"<pre><code>show_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Show all annotation layers.</p> <p>Makes all layers and their annotations visible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Show all annotation layers.\n\n    Makes all layers and their annotations visible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationManager.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert manager to dictionary for serialization.</p> <p>Creates a dictionary representation of all layers and their annotations suitable for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of all layers with a \"layers\" wrapper containing layer names as keys.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert manager to dictionary for serialization.\n\n    Creates a dictionary representation of all layers and their\n    annotations suitable for serialization.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of all layers with\n            a \"layers\" wrapper containing layer names as keys.\n    \"\"\"\n    return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationPosition","title":"AnnotationPosition","text":"<p>Annotation position enumeration.</p> <p>Defines where annotations should be positioned relative to the data point or price level on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE</code> <p>Position annotation above the data point.</p> <code>BELOW</code> <p>Position annotation below the data point.</p> <code>INLINE</code> <p>Position annotation inline with the data point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationPosition(str, Enum):\n    \"\"\"Annotation position enumeration.\n\n    Defines where annotations should be positioned relative to the data point\n    or price level on the chart.\n\n    Attributes:\n        ABOVE: Position annotation above the data point.\n        BELOW: Position annotation below the data point.\n        INLINE: Position annotation inline with the data point.\n    \"\"\"\n\n    ABOVE = \"above\"\n    BELOW = \"below\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AnnotationType","title":"AnnotationType","text":"<p>Annotation type enumeration.</p> <p>Defines the available types of annotations that can be placed on charts to mark important points, draw shapes, or add visual indicators.</p> <p>Attributes:</p> Name Type Description <code>TEXT</code> <p>Text annotation - displays text at a specific location.</p> <code>ARROW</code> <p>Arrow annotation - points to a specific location with an arrow.</p> <code>SHAPE</code> <p>Shape annotation - draws geometric shapes (circles, squares, etc.).</p> <code>LINE</code> <p>Line annotation - draws horizontal or vertical lines.</p> <code>RECTANGLE</code> <p>Rectangle annotation - draws rectangular shapes.</p> <code>CIRCLE</code> <p>Circle annotation - draws circular shapes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationType(str, Enum):\n    \"\"\"Annotation type enumeration.\n\n    Defines the available types of annotations that can be placed on charts\n    to mark important points, draw shapes, or add visual indicators.\n\n    Attributes:\n        TEXT: Text annotation - displays text at a specific location.\n        ARROW: Arrow annotation - points to a specific location with an arrow.\n        SHAPE: Shape annotation - draws geometric shapes (circles, squares, etc.).\n        LINE: Line annotation - draws horizontal or vertical lines.\n        RECTANGLE: Rectangle annotation - draws rectangular shapes.\n        CIRCLE: Circle annotation - draws circular shapes.\n    \"\"\"\n\n    TEXT = \"text\"\n    ARROW = \"arrow\"\n    SHAPE = \"shape\"\n    LINE = \"line\"\n    RECTANGLE = \"rectangle\"\n    CIRCLE = \"circle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.AreaData","title":"AreaData  <code>dataclass</code>","text":"<p>Data class for area chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color fields for area chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding area-specific color features for enhanced visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>line_color</code> <code>Optional[str]</code> <p>Color for the area line in hex or rgba format. If not provided, the line_color field is not serialized.</p> <code>top_color</code> <code>Optional[str]</code> <p>Color for the top of the area fill in hex or rgba format. If not provided, the top_color field is not serialized.</p> <code>bottom_color</code> <code>Optional[str]</code> <p>Color for the bottom of the area fill in hex or rgba format. If not provided, the bottom_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/area_data.py</code> <pre><code>@dataclass\n@validated_field(\"line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_color\", str, validator=\"color\", allow_none=True)\nclass AreaData(SingleValueData):\n    \"\"\"Data class for area chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color fields for area chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding area-specific color features\n    for enhanced visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        line_color (Optional[str]): Color for the area line in hex or rgba format.\n            If not provided, the line_color field is not serialized.\n        top_color (Optional[str]): Color for the top of the area fill in hex or rgba format.\n            If not provided, the top_color field is not serialized.\n        bottom_color (Optional[str]): Color for the bottom of the area fill in hex or rgba format.\n            If not provided, the bottom_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data point with colors\n        data = AreaData(\n            time=\"2024-01-01T00:00:00\",\n            value=100.0,\n            line_color=\"#2196F3\",\n            top_color=\"rgba(33,150,243,0.3)\",\n            bottom_color=\"rgba(33,150,243,0.1)\",\n        )\n\n        # Create area data point without colors\n        data = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - area-specific color fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"line_color\", \"top_color\", \"bottom_color\"}\n\n    # Optional color field for the area line\n    line_color: Optional[str] = None\n    # Optional color field for the top of the area fill\n    top_color: Optional[str] = None\n    # Optional color field for the bottom of the area fill\n    bottom_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to strip whitespace from color values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Strips whitespace from color strings if provided\n        3. Sets empty/whitespace-only values to None to avoid serialization\n\n        Color validation is handled by @validated_field decorators.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Strip whitespace from color strings and clean up empty values\n        for color_attr in [\"line_color\", \"top_color\", \"bottom_color\"]:\n            color_value = getattr(self, color_attr)\n            if color_value is not None:\n                # Strip whitespace\n                stripped_value = color_value.strip()\n                # Set to None if empty after stripping to avoid serialization\n                setattr(self, color_attr, stripped_value if stripped_value else None)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BandData","title":"BandData  <code>dataclass</code>","text":"<p>Data point for band charts (e.g., Bollinger Bands).</p> <p>This class represents a band data point with upper, middle, and lower values, along with optional per-point color overrides. It's used for band charts that show multiple lines simultaneously, such as Bollinger Bands, Keltner Channels, or other envelope indicators.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>float</code> <p>The upper band value.</p> <code>middle</code> <code>float</code> <p>The middle band value (usually the main line).</p> <code>lower</code> <code>float</code> <p>The lower band value.</p> <code>upper_line_color</code> <code>Optional[str]</code> <p>Optional color override for upper line (hex or rgba format).</p> <code>middle_line_color</code> <code>Optional[str]</code> <p>Optional color override for middle line (hex or rgba format).</p> <code>lower_line_color</code> <code>Optional[str]</code> <p>Optional color override for lower line (hex or rgba format).</p> <code>upper_fill_color</code> <code>Optional[str]</code> <p>Optional color override for upper fill area (hex or rgba format).</p> <code>lower_fill_color</code> <code>Optional[str]</code> <p>Optional color override for lower fill area (hex or rgba format).</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BandData\n\n# Basic data point\ndata = BandData(time=\"2024-01-01\", upper=110, middle=105, lower=100)\n\n# Data point with custom per-point colors\ndata = BandData(\n    time=\"2024-01-01\",\n    upper=110,\n    middle=105,\n    lower=100,\n    upper_line_color=\"#ff0000\",\n    middle_line_color=\"#0000ff\",\n    lower_line_color=\"#00ff00\",\n    upper_fill_color=\"rgba(255,0,0,0.2)\",\n    lower_fill_color=\"rgba(0,255,0,0.2)\",\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/band.py</code> <pre><code>@dataclass\n@validated_field(\"upper_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"middle_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"upper_fill_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_fill_color\", str, validator=\"color\", allow_none=True)\nclass BandData(Data):\n    \"\"\"Data point for band charts (e.g., Bollinger Bands).\n\n    This class represents a band data point with upper, middle, and lower values,\n    along with optional per-point color overrides. It's used for band charts\n    that show multiple lines simultaneously, such as Bollinger Bands, Keltner\n    Channels, or other envelope indicators.\n\n    Attributes:\n        upper: The upper band value.\n        middle: The middle band value (usually the main line).\n        lower: The lower band value.\n        upper_line_color: Optional color override for upper line (hex or rgba format).\n        middle_line_color: Optional color override for middle line (hex or rgba format).\n        lower_line_color: Optional color override for lower line (hex or rgba format).\n        upper_fill_color: Optional color override for upper fill area (hex or rgba format).\n        lower_fill_color: Optional color override for lower fill area (hex or rgba format).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import BandData\n\n        # Basic data point\n        data = BandData(time=\"2024-01-01\", upper=110, middle=105, lower=100)\n\n        # Data point with custom per-point colors\n        data = BandData(\n            time=\"2024-01-01\",\n            upper=110,\n            middle=105,\n            lower=100,\n            upper_line_color=\"#ff0000\",\n            middle_line_color=\"#0000ff\",\n            lower_line_color=\"#00ff00\",\n            upper_fill_color=\"rgba(255,0,0,0.2)\",\n            lower_fill_color=\"rgba(0,255,0,0.2)\",\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"middle\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"upper_line_color\",\n        \"middle_line_color\",\n        \"lower_line_color\",\n        \"upper_fill_color\",\n        \"lower_fill_color\",\n    }\n\n    upper: float\n    middle: float\n    lower: float\n    upper_line_color: Optional[str] = None\n    middle_line_color: Optional[str] = None\n    lower_line_color: Optional[str] = None\n    upper_fill_color: Optional[str] = None\n    lower_fill_color: Optional[str] = None\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n        # Handle NaN in value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = 0.0\n        elif self.upper is None:\n            raise ValueValidationError(\"upper\", \"must not be None\")\n        if isinstance(self.middle, float) and math.isnan(self.middle):\n            self.middle = 0.0\n        elif self.middle is None:\n            raise ValueValidationError(\"middle\", \"must not be None\")\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = 0.0\n        elif self.lower is None:\n            raise ValueValidationError(\"lower\", \"must not be None\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BarData","title":"BarData  <code>dataclass</code>","text":"<p>Data class for a single value (line/area/histogram) chart point.</p> <p>Inherits from SingleValueData and adds an optional color field.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point (hex or rgba).                    If not provided, not serialized.</p> <p>See also: SingleValueData</p> Note <ul> <li>Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/bar_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass BarData(OhlcData):\n    \"\"\"Data class for a single value (line/area/histogram) chart point.\n\n    Inherits from SingleValueData and adds an optional color field.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        color (Optional[str]): Color for this data point (hex or rgba).\n                               If not provided, not serialized.\n\n    See also: SingleValueData\n\n    Note:\n        - Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BaselineData","title":"BaselineData  <code>dataclass</code>","text":"<p>Data class for a baseline chart point.</p> <p>Inherits from SingleValueData and adds optional color properties for baseline series. Baseline series display data with both top and bottom areas, each with their own styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>top_fill_color1</code> <code>Optional[str]</code> <p>Optional top area top fill color (hex or rgba).</p> <code>top_fill_color2</code> <code>Optional[str]</code> <p>Optional top area bottom fill color (hex or rgba).</p> <code>top_line_color</code> <code>Optional[str]</code> <p>Optional top area line color (hex or rgba).</p> <code>bottom_fill_color1</code> <code>Optional[str]</code> <p>Optional bottom area top fill color (hex or rgba).</p> <code>bottom_fill_color2</code> <code>Optional[str]</code> <p>Optional bottom area bottom fill color (hex or rgba).</p> <code>bottom_line_color</code> <code>Optional[str]</code> <p>Optional bottom area line color (hex or rgba).</p> <p>See also: SingleValueData</p> Note <ul> <li>All color properties should be valid hex (e.g., #2196F3) or rgba strings   (e.g., rgba(33,150,243,1)).</li> </ul> <pre><code>- If color properties are not provided, colors from series options will be used.\n - Baseline series display data with both positive and negative areas relative\n   to a baseline value.\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/baseline_data.py</code> <pre><code>@dataclass\n@validated_field(\"top_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_line_color\", str, validator=\"color\", allow_none=True)\nclass BaselineData(SingleValueData):\n    \"\"\"Data class for a baseline chart point.\n\n    Inherits from SingleValueData and adds optional color properties for baseline series.\n    Baseline series display data with both top and bottom areas, each with their own\n    styling options.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        top_fill_color1 (Optional[str]): Optional top area top fill color (hex or rgba).\n        top_fill_color2 (Optional[str]): Optional top area bottom fill color (hex or rgba).\n        top_line_color (Optional[str]): Optional top area line color (hex or rgba).\n        bottom_fill_color1 (Optional[str]): Optional bottom area top fill color (hex or rgba).\n        bottom_fill_color2 (Optional[str]): Optional bottom area bottom fill color\n            (hex or rgba).\n        bottom_line_color (Optional[str]): Optional bottom area line color (hex or rgba).\n\n    See also: SingleValueData\n\n    Note:\n         - All color properties should be valid hex (e.g., #2196F3) or rgba strings\n           (e.g., rgba(33,150,243,1)).\n        - If color properties are not provided, colors from series options will be used.\n         - Baseline series display data with both positive and negative areas relative\n           to a baseline value.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"top_fill_color1\",\n        \"top_fill_color2\",\n        \"top_line_color\",\n        \"bottom_fill_color1\",\n        \"bottom_fill_color2\",\n        \"bottom_line_color\",\n    }\n\n    top_fill_color1: Optional[str] = None\n    top_fill_color2: Optional[str] = None\n    top_line_color: Optional[str] = None\n    bottom_fill_color1: Optional[str] = None\n    bottom_fill_color2: Optional[str] = None\n    bottom_line_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.CandlestickData","title":"CandlestickData  <code>dataclass</code>","text":"<p>Data class for candlestick chart data points with optional color styling.</p> <p>This class extends OhlcData to add optional color fields for candlestick styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for candlestick visualization.</p> <p>The class automatically handles time normalization, OHLC validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>color</code> <code>Optional[str]</code> <p>Color for the candlestick body in hex or rgba format. If not provided, the color field is not serialized.</p> <code>border_color</code> <code>Optional[str]</code> <p>Border color for the candlestick in hex or rgba format. If not provided, the border_color field is not serialized.</p> <code>wick_color</code> <code>Optional[str]</code> <p>Wick color for the candlestick in hex or rgba format. If not provided, the wick_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Set containing color-related optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/candlestick_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"border_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"wick_color\", str, validator=\"color\", allow_none=True)\nclass CandlestickData(OhlcData):\n    \"\"\"Data class for candlestick chart data points with optional color styling.\n\n    This class extends OhlcData to add optional color fields for candlestick\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for candlestick visualization.\n\n    The class automatically handles time normalization, OHLC validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        color (Optional[str]): Color for the candlestick body in hex or rgba format.\n            If not provided, the color field is not serialized.\n        border_color (Optional[str]): Border color for the candlestick in hex or rgba format.\n            If not provided, the border_color field is not serialized.\n        wick_color (Optional[str]): Wick color for the candlestick in hex or rgba format.\n            If not provided, the wick_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Set containing color-related optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data point with colors\n        data = CandlestickData(\n            time=\"2024-01-01T00:00:00\",\n            open=100.0,\n            high=105.0,\n            low=98.0,\n            close=102.0,\n            color=\"#4CAF50\",  # Green body for bullish candle\n            border_color=\"#2E7D32\",\n            wick_color=\"#1B5E20\",\n        )\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color fields are optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\", \"border_color\", \"wick_color\"}\n\n    # Optional color field for the candlestick body\n    color: Optional[str] = None\n    # Optional color field for the candlestick border\n    border_color: Optional[str] = None\n    # Optional color field for the candlestick wick\n    wick_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Data","title":"Data  <code>dataclass</code>","text":"<p>Abstract base class for chart data points.</p> <p>All chart data classes should inherit from Data. This class provides the foundation for all data structures in the library, handling time normalization, serialization, and column management for DataFrame operations.</p> <p>Time normalization happens during serialization (asdict()) rather than at construction, allowing users to modify time values after creating data objects. This provides flexibility while ensuring all serialized data uses consistent UTC timestamps.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time value in various formats. Converted to UTC timestamp during serialization.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion. OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.</p> See also <p>LineData: Single value data points for line charts. OhlcData: OHLC data points for candlestick charts. OhlcvData: OHLCV data points with volume information.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.data import Data\n\n\n@dataclass\nclass MyData(Data):\n    value: float\n\n\n# Create data point\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Can modify time after construction\ndata.time = \"2024-01-02T00:00:00\"\n\n# Serialize for frontend (time normalized here)\nserialized = data.asdict()  # {'time': &lt;normalized_timestamp&gt;, 'value': 100.0}\n</code></pre> Note <ul> <li>All imports must be at the top of the file unless justified.</li> <li>Use specific exceptions and lazy string formatting for logging.</li> <li>Time values are normalized to UTC timestamps during serialization.</li> <li>NaN values are converted to 0.0 for frontend compatibility.</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@dataclass\nclass Data(SerializableMixin, ABC):\n    \"\"\"Abstract base class for chart data points.\n\n    All chart data classes should inherit from Data. This class provides the foundation\n    for all data structures in the library, handling time normalization, serialization,\n    and column management for DataFrame operations.\n\n    Time normalization happens during serialization (asdict()) rather than at construction,\n    allowing users to modify time values after creating data objects. This provides\n    flexibility while ensuring all serialized data uses consistent UTC timestamps.\n\n    Attributes:\n        time (Union[pd.Timestamp, datetime, str, int, float]): Time value in various\n            formats. Converted to UTC timestamp during serialization.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion.\n        OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.\n\n    See also:\n        LineData: Single value data points for line charts.\n        OhlcData: OHLC data points for candlestick charts.\n        OhlcvData: OHLCV data points with volume information.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.data import Data\n\n\n        @dataclass\n        class MyData(Data):\n            value: float\n\n\n        # Create data point\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Can modify time after construction\n        data.time = \"2024-01-02T00:00:00\"\n\n        # Serialize for frontend (time normalized here)\n        serialized = data.asdict()  # {'time': &lt;normalized_timestamp&gt;, 'value': 100.0}\n        ```\n\n    Note:\n        - All imports must be at the top of the file unless justified.\n        - Use specific exceptions and lazy string formatting for logging.\n        - Time values are normalized to UTC timestamps during serialization.\n        - NaN values are converted to 0.0 for frontend compatibility.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"time\"}  # Required columns for DataFrame conversion\n    OPTIONAL_COLUMNS: ClassVar[set] = set()  # Optional columns for DataFrame conversion\n\n    time: Any  # Accept any time format, normalize in asdict()\n\n    @classproperty\n    def required_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all required columns\n        defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All required columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n            class ChildData(ParentData):\n                REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n            # Returns {\"time\", \"value\", \"volume\"}\n            columns = ChildData.required_columns\n            ```\n        \"\"\"\n        required = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"REQUIRED_COLUMNS\"):\n                required |= base.REQUIRED_COLUMNS\n        return required\n\n    @classproperty\n    def optional_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all optional columns\n        defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All optional columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                OPTIONAL_COLUMNS = {\"color\"}\n\n\n            class ChildData(ParentData):\n                OPTIONAL_COLUMNS = {\"size\"}\n\n\n            # Returns {\"color\", \"size\"}\n            columns = ChildData.optional_columns\n            ```\n        \"\"\"\n        optional = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"OPTIONAL_COLUMNS\"):\n                optional |= base.OPTIONAL_COLUMNS\n        return optional\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing.\n\n        This method is automatically called after the dataclass is initialized.\n        Time normalization is intentionally NOT done here to allow users to\n        modify time values after construction. Normalization happens during\n        serialization in asdict().\n\n        Subclasses can override this method to add validation or processing.\n        \"\"\"\n        # Time normalization happens in asdict() to allow post-construction modification\n        # Subclasses may override this for additional processing\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n        Converts the data point to a dictionary format suitable for frontend\n        communication. This method handles various data type conversions and\n        ensures proper formatting for JavaScript consumption.\n\n        Time normalization happens here (not in __post_init__) to allow users\n        to modify time values after construction and have changes reflected\n        in serialization.\n\n        The method performs the following transformations:\n        - Normalizes time values to UNIX timestamps (fresh conversion each call)\n        - Converts field names from snake_case to camelCase\n        - Converts NaN values to 0.0 for frontend compatibility\n        - Converts NumPy scalar types to Python native types\n        - Extracts enum values using their .value property\n        - Skips None values and empty strings\n\n        Returns:\n            Dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            @dataclass\n            class MyData(Data):\n                value: float\n                color: str = \"red\"\n\n\n            data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n            result = data.asdict()\n            # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n            # Can modify time after construction\n            data.time = \"2024-01-02T00:00:00\"\n            result2 = data.asdict()\n            # Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n            ```\n\n        Note:\n            - Time is normalized fresh each call (no caching)\n            - NaN values are converted to 0.0\n            - NumPy scalar types are converted to Python native types\n            - Enum values are extracted using their .value property\n            - Time column uses standardized ColumnNames.TIME.value\n        \"\"\"\n        # Normalize time during serialization (not cached in __post_init__)\n        normalized_time = normalize_time(self.time)\n\n        # Use the inherited serialization from SerializableMixin\n        result = dict(self._serialize_to_dict())\n\n        # Override the time field with normalized value\n        result[ColumnNames.TIME.value] = normalized_time\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Data.required_columns","title":"required_columns","text":"<pre><code>required_columns()\n</code></pre> <p>Return the union of all REQUIRED_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all required columns defined in REQUIRED_COLUMNS class attributes. It ensures that all required columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All required columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\nclass ChildData(ParentData):\n    REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n# Returns {\"time\", \"value\", \"volume\"}\ncolumns = ChildData.required_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef required_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all required columns\n    defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All required columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n        class ChildData(ParentData):\n            REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n        # Returns {\"time\", \"value\", \"volume\"}\n        columns = ChildData.required_columns\n        ```\n    \"\"\"\n    required = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"REQUIRED_COLUMNS\"):\n            required |= base.REQUIRED_COLUMNS\n    return required\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Data.optional_columns","title":"optional_columns","text":"<pre><code>optional_columns()\n</code></pre> <p>Return the union of all OPTIONAL_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all optional columns defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All optional columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    OPTIONAL_COLUMNS = {\"color\"}\n\n\nclass ChildData(ParentData):\n    OPTIONAL_COLUMNS = {\"size\"}\n\n\n# Returns {\"color\", \"size\"}\ncolumns = ChildData.optional_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef optional_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all optional columns\n    defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All optional columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            OPTIONAL_COLUMNS = {\"color\"}\n\n\n        class ChildData(ParentData):\n            OPTIONAL_COLUMNS = {\"size\"}\n\n\n        # Returns {\"color\", \"size\"}\n        columns = ChildData.optional_columns\n        ```\n    \"\"\"\n    optional = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"OPTIONAL_COLUMNS\"):\n            optional |= base.OPTIONAL_COLUMNS\n    return optional\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.Data.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the data class to a dict with camelCase keys for frontend.</p> <p>Converts the data point to a dictionary format suitable for frontend communication. This method handles various data type conversions and ensures proper formatting for JavaScript consumption.</p> <p>Time normalization happens here (not in post_init) to allow users to modify time values after construction and have changes reflected in serialization.</p> <p>The method performs the following transformations: - Normalizes time values to UNIX timestamps (fresh conversion each call) - Converts field names from snake_case to camelCase - Converts NaN values to 0.0 for frontend compatibility - Converts NumPy scalar types to Python native types - Extracts enum values using their .value property - Skips None values and empty strings</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized data with camelCase keys ready for frontend consumption.</p> Example <pre><code>@dataclass\nclass MyData(Data):\n    value: float\n    color: str = \"red\"\n\n\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\nresult = data.asdict()\n# Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n# Can modify time after construction\ndata.time = \"2024-01-02T00:00:00\"\nresult2 = data.asdict()\n# Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n</code></pre> Note <ul> <li>Time is normalized fresh each call (no caching)</li> <li>NaN values are converted to 0.0</li> <li>NumPy scalar types are converted to Python native types</li> <li>Enum values are extracted using their .value property</li> <li>Time column uses standardized ColumnNames.TIME.value</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n    Converts the data point to a dictionary format suitable for frontend\n    communication. This method handles various data type conversions and\n    ensures proper formatting for JavaScript consumption.\n\n    Time normalization happens here (not in __post_init__) to allow users\n    to modify time values after construction and have changes reflected\n    in serialization.\n\n    The method performs the following transformations:\n    - Normalizes time values to UNIX timestamps (fresh conversion each call)\n    - Converts field names from snake_case to camelCase\n    - Converts NaN values to 0.0 for frontend compatibility\n    - Converts NumPy scalar types to Python native types\n    - Extracts enum values using their .value property\n    - Skips None values and empty strings\n\n    Returns:\n        Dict[str, Any]: Serialized data with camelCase keys ready for\n            frontend consumption.\n\n    Example:\n        ```python\n        @dataclass\n        class MyData(Data):\n            value: float\n            color: str = \"red\"\n\n\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n        result = data.asdict()\n        # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n        # Can modify time after construction\n        data.time = \"2024-01-02T00:00:00\"\n        result2 = data.asdict()\n        # Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n        ```\n\n    Note:\n        - Time is normalized fresh each call (no caching)\n        - NaN values are converted to 0.0\n        - NumPy scalar types are converted to Python native types\n        - Enum values are extracted using their .value property\n        - Time column uses standardized ColumnNames.TIME.value\n    \"\"\"\n    # Normalize time during serialization (not cached in __post_init__)\n    normalized_time = normalize_time(self.time)\n\n    # Use the inherited serialization from SerializableMixin\n    result = dict(self._serialize_to_dict())\n\n    # Override the time field with normalized value\n    result[ColumnNames.TIME.value] = normalized_time\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.GradientRibbonData","title":"GradientRibbonData  <code>dataclass</code>","text":"<p>Data point for gradient ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional fill color override and gradient value for color calculation. It's used for ribbon charts that show upper and lower bands with gradient fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>Optional[float]</code> <p>The upper band value.</p> <code>lower</code> <code>Optional[float]</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional fill color override (highest priority).</p> <code>gradient</code> <code>Optional[float]</code> <p>Optional gradient value for color calculation (0.0 to 1.0 or raw value).</p> Source code in <code>streamlit_lightweight_charts_pro/data/gradient_ribbon.py</code> <pre><code>@dataclass\nclass GradientRibbonData(RibbonData):\n    \"\"\"Data point for gradient ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional fill color override and gradient value for color calculation.\n    It's used for ribbon charts that show upper and lower bands with gradient\n    fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional fill color override (highest priority).\n        gradient: Optional gradient value for color calculation (0.0 to 1.0 or raw value).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\", \"gradient\"}\n\n    # upper and lower inherited from RibbonData\n    gradient: Optional[float] = None\n\n    def __post_init__(self):\n        # Call parent's __post_init__ for time normalization and NaN handling\n        super().__post_init__()\n\n        # Validate gradient if provided\n        if self.gradient is not None:\n            if not isinstance(self.gradient, (int, float)):\n                raise ValueValidationError(\"gradient\", \"must be numeric\")\n            if math.isnan(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be NaN\")\n            if math.isinf(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be infinite\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.HistogramData","title":"HistogramData  <code>dataclass</code>","text":"<p>Data class for histogram chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for histogram chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for histogram visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. AreaData: Similar data class for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/histogram_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass HistogramData(SingleValueData):\n    \"\"\"Data class for histogram chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for histogram chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for histogram visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data point with color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n        # Create histogram data point without color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        AreaData: Similar data class for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this histogram data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.LineData","title":"LineData  <code>dataclass</code>","text":"<p>Data class for line chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for line chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. AreaData: Similar data class for area charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/line_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass LineData(SingleValueData):\n    \"\"\"Data class for line chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for line chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data point with color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n        # Create line data point without color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        AreaData: Similar data class for area charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BarMarker","title":"BarMarker  <code>dataclass</code>","text":"<p>Bar marker for positioning relative to bars on charts.</p> <p>This class represents a marker that can be positioned relative to bars on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar interface, it provides flexible positioning options for markers that need to be placed relative to chart bars or candlesticks.</p> <p>The class automatically handles time normalization, position validation, and provides optional price positioning for enhanced flexibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of ABOVE_BAR, BELOW_BAR, or IN_BAR for bar markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> <code>price</code> <code>Optional[float]</code> <p>Optional price value for exact Y-axis positioning. If provided, overrides the relative bar positioning.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns including     \"price\" for enhanced positioning flexibility.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BarMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create bar marker above the bar\nbar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#00FF00\",\n    text=\"Buy Signal\",\n)\n\n# Create bar marker with exact price positioning\nprice_bar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.ARROW_UP,\n    price=105.0,\n    color=\"#FF0000\",\n)\n</code></pre> See also <p>MarkerBase: Base class providing marker functionality. PriceMarker: Marker positioned at exact price levels. Marker: Backward compatibility alias for BarMarker.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass BarMarker(MarkerBase):\n    \"\"\"Bar marker for positioning relative to bars on charts.\n\n    This class represents a marker that can be positioned relative to bars\n    on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar\n    interface, it provides flexible positioning options for markers that need\n    to be placed relative to chart bars or candlesticks.\n\n    The class automatically handles time normalization, position validation,\n    and provides optional price positioning for enhanced flexibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of ABOVE_BAR,\n            BELOW_BAR, or IN_BAR for bar markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n        price (Optional[float]): Optional price value for exact Y-axis positioning.\n            If provided, overrides the relative bar positioning.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns including\n            \"price\" for enhanced positioning flexibility.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import BarMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create bar marker above the bar\n        bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#00FF00\",\n            text=\"Buy Signal\",\n        )\n\n        # Create bar marker with exact price positioning\n        price_bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.ARROW_UP,\n            price=105.0,\n            color=\"#FF0000\",\n        )\n        ```\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        PriceMarker: Marker positioned at exact price levels.\n        Marker: Backward compatibility alias for BarMarker.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - same as base class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - includes price for flexibility\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\", \"price\"}\n\n    # Optional price value for exact Y-axis positioning - provides enhanced flexibility\n    price: Optional[float] = None\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for bar markers.\n\n        This method validates that the position is one of the valid bar-relative\n        positions that work with bar and candlestick charts.\n\n        Returns:\n            bool: True if position is valid for bar markers, False otherwise.\n        \"\"\"\n        # Define valid positions for bar markers - must be bar-relative positions\n        valid_positions = {\n            MarkerPosition.ABOVE_BAR,\n            MarkerPosition.BELOW_BAR,\n            MarkerPosition.IN_BAR,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BarMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.BarMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for bar markers.</p> <p>This method validates that the position is one of the valid bar-relative positions that work with bar and candlestick charts.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for bar markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for bar markers.\n\n    This method validates that the position is one of the valid bar-relative\n    positions that work with bar and candlestick charts.\n\n    Returns:\n        bool: True if position is valid for bar markers, False otherwise.\n    \"\"\"\n    # Define valid positions for bar markers - must be bar-relative positions\n    valid_positions = {\n        MarkerPosition.ABOVE_BAR,\n        MarkerPosition.BELOW_BAR,\n        MarkerPosition.IN_BAR,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.MarkerBase","title":"MarkerBase  <code>dataclass</code>","text":"<p>Base chart marker definition for highlighting data points.</p> <p>This class represents the base marker that can be displayed on charts to highlight specific data points, events, or annotations. Based on the TradingView Lightweight Charts SeriesMarkerBase interface, it provides the foundation for all marker types in the library.</p> <p>The class automatically handles time normalization, position and shape validation, and provides a flexible interface for marker customization.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Where to position the marker relative to the data point. Can be a string or MarkerPosition enum. Defaults to ABOVE_BAR.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker. Can be a string or MarkerShape enum. Defaults to CIRCLE.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker. If not provided, the id field is not serialized.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker. If not provided, the text field is not serialized.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import MarkerBase\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create base marker\nmarker = MarkerBase(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#FF0000\",\n    text=\"Important Event\",\n    size=2,\n)\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. PriceMarker: Marker positioned at exact price levels. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass MarkerBase(Data):\n    \"\"\"Base chart marker definition for highlighting data points.\n\n    This class represents the base marker that can be displayed on charts to\n    highlight specific data points, events, or annotations. Based on the\n    TradingView Lightweight Charts SeriesMarkerBase interface, it provides\n    the foundation for all marker types in the library.\n\n    The class automatically handles time normalization, position and shape\n    validation, and provides a flexible interface for marker customization.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Where to position the marker\n            relative to the data point. Can be a string or MarkerPosition enum.\n            Defaults to ABOVE_BAR.\n        shape (Union[str, MarkerShape]): Shape of the marker. Can be a string\n            or MarkerShape enum. Defaults to CIRCLE.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n            If not provided, the id field is not serialized.\n        text (Optional[str]): Optional text to display with the marker.\n            If not provided, the text field is not serialized.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import MarkerBase\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create base marker\n        marker = MarkerBase(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#FF0000\",\n            text=\"Important Event\",\n            size=2,\n        )\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        PriceMarker: Marker positioned at exact price levels.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - position and shape are required\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - styling and metadata fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Position of the marker relative to the data point - defaults to above bar\n    position: Union[str, MarkerPosition] = MarkerPosition.ABOVE_BAR\n    # Shape of the marker - defaults to circle\n    shape: Union[str, MarkerShape] = MarkerShape.CIRCLE\n    # Color of the marker in hex format - defaults to blue\n    color: str = \"#2196F3\"\n    # Optional unique identifier for the marker\n    id: Optional[str] = None\n    # Optional text to display with the marker\n    text: Optional[str] = None\n    # Size of the marker in pixels - defaults to 1\n    size: int = 1\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize enums and validate data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Converts string position values to MarkerPosition enum\n        3. Converts string shape values to MarkerShape enum\n\n        The method ensures that all marker data points have properly normalized\n        enum values that can be safely serialized and transmitted to the frontend.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Convert position string to enum if it's provided as a string\n        if isinstance(self.position, str):\n            self.position = MarkerPosition(self.position)\n\n        # Convert shape string to enum if it's provided as a string\n        if isinstance(self.shape, str):\n            self.shape = MarkerShape(self.shape)\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for this marker type.\n\n        This method provides a base implementation that allows all positions.\n        Subclasses should override this method to implement position-specific\n        validation logic for their marker types.\n\n        Returns:\n            bool: True if position is valid, False otherwise. Base implementation\n                always returns True.\n        \"\"\"\n        # Base class allows all positions - subclasses will override with specific validation\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.MarkerBase-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.MarkerBase.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for this marker type.</p> <p>This method provides a base implementation that allows all positions. Subclasses should override this method to implement position-specific validation logic for their marker types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid, False otherwise. Base implementation always returns True.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for this marker type.\n\n    This method provides a base implementation that allows all positions.\n    Subclasses should override this method to implement position-specific\n    validation logic for their marker types.\n\n    Returns:\n        bool: True if position is valid, False otherwise. Base implementation\n            always returns True.\n    \"\"\"\n    # Base class allows all positions - subclasses will override with specific validation\n    return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.PriceMarker","title":"PriceMarker  <code>dataclass</code>","text":"<p>Price marker for exact Y-axis positioning on charts.</p> <p>This class represents a marker that can be positioned at exact price levels on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice interface, it provides precise positioning control for markers that need to be placed at specific price values.</p> <p>The class automatically handles time normalization, price validation, and position validation for price-specific positioning scenarios.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of AT_PRICE_TOP, AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>price</code> <code>float</code> <p>Price value for exact Y-axis positioning. Required field that must be greater than 0.0.</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"     as required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import PriceMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create price marker at resistance level\nprice_marker = PriceMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.AT_PRICE_TOP,\n    shape=MarkerShape.ARROW_DOWN,\n    price=100.0,\n    color=\"#FF0000\",\n    text=\"Resistance Level\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>RequiredFieldError</code> <p>If the price field is 0.0 or missing.</p> See also <p>MarkerBase: Base class providing marker functionality. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass PriceMarker(MarkerBase):\n    \"\"\"Price marker for exact Y-axis positioning on charts.\n\n    This class represents a marker that can be positioned at exact price levels\n    on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice\n    interface, it provides precise positioning control for markers that need\n    to be placed at specific price values.\n\n    The class automatically handles time normalization, price validation, and\n    position validation for price-specific positioning scenarios.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of AT_PRICE_TOP,\n            AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        price (float): Price value for exact Y-axis positioning. Required field\n            that must be greater than 0.0.\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"\n            as required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import PriceMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create price marker at resistance level\n        price_marker = PriceMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.AT_PRICE_TOP,\n            shape=MarkerShape.ARROW_DOWN,\n            price=100.0,\n            color=\"#FF0000\",\n            text=\"Resistance Level\",\n        )\n        ```\n\n    Raises:\n        RequiredFieldError: If the price field is 0.0 or missing.\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - price is additional requirement\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\", \"price\"}\n\n    # Define optional columns for DataFrame conversion - same as base class\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Price value for exact Y-axis positioning - required for price markers\n    price: float = 0.0\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate price value.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize time and enums\n        2. Validates that the price field is provided and not 0.0\n\n        The method ensures that all price markers have valid price values\n        for proper Y-axis positioning.\n\n        Raises:\n            RequiredFieldError: If the price field is 0.0 or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize time and convert enums\n        super().__post_init__()\n\n        # Validate that price is provided and not 0.0 (required field)\n        if self.price == 0.0:\n            raise RequiredFieldError(\"Price\")\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for price markers.\n\n        This method validates that the position is one of the valid price-specific\n        positions that work with exact Y-axis positioning.\n\n        Returns:\n            bool: True if position is valid for price markers, False otherwise.\n        \"\"\"\n        # Define valid positions for price markers - must be price-specific positions\n        valid_positions = {\n            MarkerPosition.AT_PRICE_TOP,\n            MarkerPosition.AT_PRICE_BOTTOM,\n            MarkerPosition.AT_PRICE_MIDDLE,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.PriceMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.PriceMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for price markers.</p> <p>This method validates that the position is one of the valid price-specific positions that work with exact Y-axis positioning.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for price markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for price markers.\n\n    This method validates that the position is one of the valid price-specific\n    positions that work with exact Y-axis positioning.\n\n    Returns:\n        bool: True if position is valid for price markers, False otherwise.\n    \"\"\"\n    # Define valid positions for price markers - must be price-specific positions\n    valid_positions = {\n        MarkerPosition.AT_PRICE_TOP,\n        MarkerPosition.AT_PRICE_BOTTOM,\n        MarkerPosition.AT_PRICE_MIDDLE,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.OhlcvData","title":"OhlcvData  <code>dataclass</code>","text":"<p>Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.</p> <p>This class represents an OHLCV data point commonly used in candlestick and bar charts for displaying financial market data with volume information. It extends the OhlcData class with volume-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships, ensures all values are non-negative, validates volume data, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>volume</code> <code>float</code> <p>Trading volume for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column     beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship) or volume &lt; 0.</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLCV field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. CandlestickData: OHLC data with color styling capabilities. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlcv_data.py</code> <pre><code>@dataclass\nclass OhlcvData(OhlcData):\n    \"\"\"Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.\n\n    This class represents an OHLCV data point commonly used in candlestick and bar charts\n    for displaying financial market data with volume information. It extends the OhlcData\n    class with volume-specific validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships, ensures all values are non-negative,\n    validates volume data, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        volume (float): Trading volume for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column\n            beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcvData\n\n        # Create OHLCV data point with volume\n        data = OhlcvData(\n            time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n        )\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship) or volume &lt; 0.\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLCV field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        CandlestickData: OHLC data with color styling capabilities.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - volume is additional requirement\n    # beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = {\"volume\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Trading volume for the time period - must be non-negative\n    volume: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLCV data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate OHLC data and time\n        2. Validates that volume is non-negative\n        3. Handles NaN values in the volume field\n        4. Validates that volume is not None\n\n        The method ensures that all OHLCV data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If volume &lt; 0 (volume cannot be negative).\n            RequiredFieldError: If volume field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to validate OHLC data and time normalization\n        super().__post_init__()\n\n        # Validate that volume is non-negative (volume cannot be negative)\n        if self.volume &lt; 0:\n            raise ValueValidationError(\"volume\", \"must be non-negative\")\n\n        # Handle NaN values in volume field - convert to 0.0 for frontend compatibility\n        for field_name in [\"volume\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - volume is required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.RibbonData","title":"RibbonData  <code>dataclass</code>","text":"<p>Data point for ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional per-point color overrides. It's used for ribbon charts that show upper and lower bands with fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>Optional[float]</code> <p>The upper band value.</p> <code>lower</code> <code>Optional[float]</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional color for the fill area (hex or rgba format).</p> <code>upper_line_color</code> <code>Optional[str]</code> <p>Optional color override for upper line (hex or rgba format).</p> <code>lower_line_color</code> <code>Optional[str]</code> <p>Optional color override for lower line (hex or rgba format).</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import RibbonData\n\n# Basic data point\ndata = RibbonData(time=\"2024-01-01\", upper=110, lower=100)\n\n# Data point with custom per-point colors\ndata = RibbonData(\n    time=\"2024-01-01\",\n    upper=110,\n    lower=100,\n    fill=\"rgba(255,0,0,0.2)\",\n    upper_line_color=\"#ff0000\",\n    lower_line_color=\"#00ff00\",\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/ribbon.py</code> <pre><code>@dataclass\n@validated_field(\"fill\", str, validator=\"color\", allow_none=True)\n@validated_field(\"upper_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_line_color\", str, validator=\"color\", allow_none=True)\nclass RibbonData(Data):\n    \"\"\"Data point for ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional per-point color overrides. It's used for ribbon charts\n    that show upper and lower bands with fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional color for the fill area (hex or rgba format).\n        upper_line_color: Optional color override for upper line (hex or rgba format).\n        lower_line_color: Optional color override for lower line (hex or rgba format).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import RibbonData\n\n        # Basic data point\n        data = RibbonData(time=\"2024-01-01\", upper=110, lower=100)\n\n        # Data point with custom per-point colors\n        data = RibbonData(\n            time=\"2024-01-01\",\n            upper=110,\n            lower=100,\n            fill=\"rgba(255,0,0,0.2)\",\n            upper_line_color=\"#ff0000\",\n            lower_line_color=\"#00ff00\",\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\", \"upper_line_color\", \"lower_line_color\"}\n\n    upper: Optional[float]\n    lower: Optional[float]\n    fill: Optional[str] = None\n    upper_line_color: Optional[str] = None\n    lower_line_color: Optional[str] = None\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n\n        # Handle NaN in upper value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = None\n        # Allow None for missing data (no validation error)\n\n        # Handle NaN in lower value\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.SignalData","title":"SignalData  <code>dataclass</code>","text":"<p>Signal data point for background coloring.</p> <p>SignalData represents a single time point with a signal value that determines the background color for that time period. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[str, datetime]</code> <p>Time point for the signal. Can be a string in ISO format (YYYY-MM-DD) or a datetime object.</p> <code>value</code> <code>Union[int, bool]</code> <p>Signal value that determines background color. Accepts both integers and booleans (converted to int automatically): - 0 or False: First color (typically neutral/gray) - 1 or True: Second color (typically signal/blue) - 2: Third color (optional, for ternary signals/alerts)</p> Example <pre><code># Create signal data for background coloring\n# Using integers (0, 1, 2)\nsignal_data_int = [\n    SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n    SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n]\n\n# Using booleans (False, True) - more natural for binary signals\nsignal_data_bool = [\n    SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n    SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n    SignalData(\"2024-01-03\", False),  # Neutral\n    SignalData(\"2024-01-04\", True),  # Signal\n]\n\n# Use with SignalSeries\nsignal_series = SignalSeries(\n    data=signal_data_bool,  # Works with both int and bool values\n    neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n    signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/signal_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass SignalData(SingleValueData):\n    \"\"\"Signal data point for background coloring.\n\n    SignalData represents a single time point with a signal value that determines\n    the background color for that time period. This is commonly used in financial\n    charts to highlight specific market conditions, trading signals, or events.\n\n    Attributes:\n        time (Union[str, datetime]): Time point for the signal. Can be a string\n            in ISO format (YYYY-MM-DD) or a datetime object.\n        value (Union[int, bool]): Signal value that determines background color.\n            Accepts both integers and booleans (converted to int automatically):\n            - 0 or False: First color (typically neutral/gray)\n            - 1 or True: Second color (typically signal/blue)\n            - 2: Third color (optional, for ternary signals/alerts)\n\n    Example:\n        ```python\n        # Create signal data for background coloring\n        # Using integers (0, 1, 2)\n        signal_data_int = [\n            SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n            SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n        ]\n\n        # Using booleans (False, True) - more natural for binary signals\n        signal_data_bool = [\n            SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n            SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n            SignalData(\"2024-01-03\", False),  # Neutral\n            SignalData(\"2024-01-04\", True),  # Signal\n        ]\n\n        # Use with SignalSeries\n        signal_series = SignalSeries(\n            data=signal_data_bool,  # Works with both int and bool values\n            neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n            signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.SingleValueData","title":"SingleValueData  <code>dataclass</code>","text":"<p>Data class for single value data points used in line and area charts.</p> <p>This class represents a single numeric value at a specific time point, commonly used for line charts, area charts, and other chart types that display one value per time. It extends the base Data class with value-specific validation and NaN handling.</p> <p>The class automatically handles time normalization, value validation, and serialization to camelCase dictionaries suitable for frontend communication.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"value\" as the required column     for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize for frontend\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. LineData: Specialized single value data for line charts. AreaData: Specialized single value data for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/single_value_data.py</code> <pre><code>@dataclass\nclass SingleValueData(Data):\n    \"\"\"Data class for single value data points used in line and area charts.\n\n    This class represents a single numeric value at a specific time point, commonly used\n    for line charts, area charts, and other chart types that display one value per time.\n    It extends the base Data class with value-specific validation and NaN handling.\n\n    The class automatically handles time normalization, value validation, and serialization\n    to camelCase dictionaries suitable for frontend communication.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"value\" as the required column\n            for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create single value data point\n        data = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        LineData: Specialized single value data for line charts.\n        AreaData: Specialized single value data for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - only \"value\" is required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"value\"}\n\n    # Define optional columns for DataFrame conversion - none for this simple data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # The single numeric value for this data point\n    value: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates the value field for None values\n        3. Converts NaN values to 0.0 for frontend compatibility\n\n        The method ensures that all data points have valid, non-NaN values\n        that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            RequiredFieldError: If the value field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Handle NaN values in the value field - convert to 0.0 for frontend compatibility\n        if isinstance(self.value, float) and math.isnan(self.value):\n            self.value = 0.0\n        # Validate that value is not None - this is a required field\n        elif self.value is None:\n            raise RequiredFieldError(\"value\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipConfig","title":"TooltipConfig  <code>dataclass</code>","text":"<p>Configuration for tooltip functionality.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether tooltips are enabled</p> <code>type</code> <code>TooltipType</code> <p>Type of tooltip to display</p> <code>template</code> <code>Optional[str]</code> <p>Template string with placeholders</p> <code>fields</code> <code>List[TooltipField]</code> <p>List of tooltip fields</p> <code>position</code> <code>TooltipPosition</code> <p>Tooltip positioning</p> <code>offset</code> <code>Optional[Dict[str, int]]</code> <p>Offset from cursor or fixed position</p> <code>style</code> <code>TooltipStyle</code> <p>Tooltip styling</p> <code>show_date</code> <code>bool</code> <p>Whether to show date</p> <code>date_format</code> <code>str</code> <p>Date format string</p> <code>show_time</code> <code>bool</code> <p>Whether to show time</p> <code>time_format</code> <code>str</code> <p>Time format string</p> <code>custom_formatters</code> <code>Dict[str, Callable[[Any], str]]</code> <p>Custom formatter functions</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipConfig:\n    \"\"\"Configuration for tooltip functionality.\n\n    Attributes:\n        enabled: Whether tooltips are enabled\n        type: Type of tooltip to display\n        template: Template string with placeholders\n        fields: List of tooltip fields\n        position: Tooltip positioning\n        offset: Offset from cursor or fixed position\n        style: Tooltip styling\n        show_date: Whether to show date\n        date_format: Date format string\n        show_time: Whether to show time\n        time_format: Time format string\n        custom_formatters: Custom formatter functions\n    \"\"\"\n\n    enabled: bool = True\n    type: TooltipType = TooltipType.OHLC\n    template: Optional[str] = None\n    fields: List[TooltipField] = field(default_factory=list)\n    position: TooltipPosition = TooltipPosition.CURSOR\n    offset: Optional[Dict[str, int]] = None\n    style: TooltipStyle = field(default_factory=TooltipStyle)\n    show_date: bool = True\n    date_format: str = \"%Y-%m-%d\"\n    show_time: bool = True\n    time_format: str = \"%H:%M:%S\"\n    custom_formatters: Dict[str, Callable[[Any], str]] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize default fields based on tooltip type.\"\"\"\n        if not self.fields and self.type == TooltipType.OHLC:\n            self.fields = self._get_default_ohlc_fields()\n        elif not self.fields and self.type == TooltipType.SINGLE:\n            self.fields = self._get_default_single_fields()\n        elif not self.fields and self.type == TooltipType.TRADE:\n            self.fields = self._get_default_trade_fields()\n\n    def _get_default_ohlc_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for OHLC tooltip.\"\"\"\n        return [\n            TooltipField(\"Open\", \"open\", precision=2, prefix=\"$\"),\n            TooltipField(\"High\", \"high\", precision=2, prefix=\"$\"),\n            TooltipField(\"Low\", \"low\", precision=2, prefix=\"$\"),\n            TooltipField(\"Close\", \"close\", precision=2, prefix=\"$\"),\n            TooltipField(\"Volume\", \"volume\", formatter=self._format_volume),\n        ]\n\n    def _get_default_single_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for single value tooltip.\"\"\"\n        return [\n            TooltipField(\"Value\", \"value\", precision=2),\n        ]\n\n    def _get_default_trade_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for trade tooltip.\"\"\"\n        return [\n            TooltipField(\"Entry\", \"entryPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Exit\", \"exitPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Quantity\", \"quantity\"),\n            TooltipField(\"P&amp;L\", \"pnl\", precision=2, prefix=\"$\"),\n            TooltipField(\"P&amp;L %\", \"pnlPercentage\", precision=1, suffix=\"%\"),\n        ]\n\n    def _format_volume(self, value: Any) -&gt; str:\n        \"\"\"Format volume with K, M, B suffixes.\"\"\"\n        if not isinstance(value, (int, float)):\n            return str(value)\n\n        if value &gt;= 1e9:\n            return f\"{value / 1e9:.1f}B\"\n        if value &gt;= 1e6:\n            return f\"{value / 1e6:.1f}M\"\n        if value &gt;= 1e3:\n            return f\"{value / 1e3:.1f}K\"\n        return f\"{value:,.0f}\"\n\n    def format_tooltip(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip content using template or fields.\n\n        Args:\n            data: Data dictionary containing values\n            time_value: Optional time value for date/time formatting\n\n        Returns:\n            Formatted tooltip string\n        \"\"\"\n        if self.template:\n            return self._format_with_template(data, time_value)\n        return self._format_with_fields(data, time_value)\n\n    def _format_with_template(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using template string with placeholders.\"\"\"\n        if not self.template:\n            return \"\"\n\n        # Start with the template\n        result = self.template\n\n        # Replace placeholders with actual values\n        for key, value in data.items():\n            placeholder = f\"{{{key}}}\"\n            if placeholder in result:\n                # Format the value based on field configuration\n                field = next((f for f in self.fields if f.value_key == key), None)\n                formatted_value = field.format_value(value) if field else str(value)\n                result = result.replace(placeholder, formatted_value)\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                result = f\"{time_str}\\n{result}\"\n\n        return result\n\n    def _format_with_fields(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using field configuration.\"\"\"\n        lines = []\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                lines.append(time_str)\n\n        # Add field values\n        for tooltip_field in self.fields:\n            if tooltip_field.value_key in data:\n                value = data[tooltip_field.value_key]\n                formatted_value = tooltip_field.format_value(value)\n                lines.append(f\"{tooltip_field.label}: {formatted_value}\")\n\n        return \"\\n\".join(lines)\n\n    def _format_time(self, time_value: Union[int, str, pd.Timestamp]) -&gt; str:\n        \"\"\"Format time value according to configuration.\"\"\"\n        try:\n            if isinstance(time_value, (int, float)):\n                # Convert timestamp to datetime\n                dt = pd.to_datetime(time_value, unit=\"s\")\n            elif isinstance(time_value, str):\n                dt = pd.to_datetime(time_value)\n            else:\n                dt = pd.to_datetime(time_value)\n\n            parts = []\n            if self.show_date:\n                parts.append(dt.strftime(self.date_format))\n            if self.show_time:\n                parts.append(dt.strftime(self.time_format))\n\n            return \" \".join(parts)\n        except Exception:\n            return str(time_value)\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n        return {\n            \"enabled\": self.enabled,\n            \"type\": self.type.value,\n            \"template\": self.template,\n            \"fields\": [self._field_to_dict(field) for field in self.fields],\n            \"position\": self.position.value,\n            \"offset\": self.offset,\n            \"style\": self._style_to_dict(self.style),\n            \"showDate\": self.show_date,\n            \"dateFormat\": self.date_format,\n            \"showTime\": self.show_time,\n            \"timeFormat\": self.time_format,\n        }\n\n    def _field_to_dict(self, field: TooltipField) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip field to dictionary.\"\"\"\n        return {\n            \"label\": field.label,\n            \"valueKey\": field.value_key,\n            \"color\": field.color,\n            \"fontSize\": field.font_size,\n            \"fontWeight\": field.font_weight,\n            \"prefix\": field.prefix,\n            \"suffix\": field.suffix,\n            \"precision\": field.precision,\n        }\n\n    def _style_to_dict(self, style: TooltipStyle) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip style to dictionary.\"\"\"\n        return {\n            \"backgroundColor\": style.background_color,\n            \"borderColor\": style.border_color,\n            \"borderWidth\": style.border_width,\n            \"borderRadius\": style.border_radius,\n            \"padding\": style.padding,\n            \"fontSize\": style.font_size,\n            \"fontFamily\": style.font_family,\n            \"color\": style.color,\n            \"boxShadow\": style.box_shadow,\n            \"zIndex\": style.z_index,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipConfig.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(data: Dict[str, Any], time_value: Optional[Union[int, str, Timestamp]] = None) -&gt; str\n</code></pre> <p>Format tooltip content using template or fields.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Data dictionary containing values</p> required <code>time_value</code> <code>Optional[Union[int, str, Timestamp]]</code> <p>Optional time value for date/time formatting</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted tooltip string</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip content using template or fields.\n\n    Args:\n        data: Data dictionary containing values\n        time_value: Optional time value for date/time formatting\n\n    Returns:\n        Formatted tooltip string\n    \"\"\"\n    if self.template:\n        return self._format_with_template(data, time_value)\n    return self._format_with_fields(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipConfig.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert tooltip config to dictionary for serialization.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n    return {\n        \"enabled\": self.enabled,\n        \"type\": self.type.value,\n        \"template\": self.template,\n        \"fields\": [self._field_to_dict(field) for field in self.fields],\n        \"position\": self.position.value,\n        \"offset\": self.offset,\n        \"style\": self._style_to_dict(self.style),\n        \"showDate\": self.show_date,\n        \"dateFormat\": self.date_format,\n        \"showTime\": self.show_time,\n        \"timeFormat\": self.time_format,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipField","title":"TooltipField  <code>dataclass</code>","text":"<p>Represents a single field in a tooltip.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Display label for the field</p> <code>value_key</code> <code>str</code> <p>Key to access the value from data</p> <code>formatter</code> <code>Optional[Callable[[Any], str]]</code> <p>Optional function to format the value</p> <code>color</code> <code>Optional[str]</code> <p>Optional color for the field</p> <code>font_size</code> <code>Optional[int]</code> <p>Optional font size for the field</p> <code>font_weight</code> <code>Optional[str]</code> <p>Optional font weight for the field</p> <code>prefix</code> <code>Optional[str]</code> <p>Optional prefix to add before the value</p> <code>suffix</code> <code>Optional[str]</code> <p>Optional suffix to add after the value</p> <code>precision</code> <code>Optional[int]</code> <p>Optional decimal precision for numeric values</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipField:\n    \"\"\"Represents a single field in a tooltip.\n\n    Attributes:\n        label: Display label for the field\n        value_key: Key to access the value from data\n        formatter: Optional function to format the value\n        color: Optional color for the field\n        font_size: Optional font size for the field\n        font_weight: Optional font weight for the field\n        prefix: Optional prefix to add before the value\n        suffix: Optional suffix to add after the value\n        precision: Optional decimal precision for numeric values\n    \"\"\"\n\n    label: str\n    value_key: str\n    formatter: Optional[Callable[[Any], str]] = None\n    color: Optional[str] = None\n    font_size: Optional[int] = None\n    font_weight: Optional[str] = None\n    prefix: Optional[str] = None\n    suffix: Optional[str] = None\n    precision: Optional[int] = None\n\n    def format_value(self, value: Any) -&gt; str:\n        \"\"\"Format the value according to field configuration.\"\"\"\n        if self.formatter:\n            return self.formatter(value)\n\n        # Apply precision for numeric values\n        if self.precision is not None and isinstance(value, (int, float)):\n            value = f\"{value:.{self.precision}f}\"\n        else:\n            value = str(value)\n\n        # Add prefix and suffix\n        result = value\n        if self.prefix:\n            result = f\"{self.prefix}{result}\"\n        if self.suffix:\n            result = f\"{result}{self.suffix}\"\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipField-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipField.format_value","title":"format_value","text":"<pre><code>format_value(value: Any) -&gt; str\n</code></pre> <p>Format the value according to field configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_value(self, value: Any) -&gt; str:\n    \"\"\"Format the value according to field configuration.\"\"\"\n    if self.formatter:\n        return self.formatter(value)\n\n    # Apply precision for numeric values\n    if self.precision is not None and isinstance(value, (int, float)):\n        value = f\"{value:.{self.precision}f}\"\n    else:\n        value = str(value)\n\n    # Add prefix and suffix\n    result = value\n    if self.prefix:\n        result = f\"{self.prefix}{result}\"\n    if self.suffix:\n        result = f\"{result}{self.suffix}\"\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager","title":"TooltipManager","text":"<p>Manages tooltip functionality across multiple series and data types.</p> <p>This class provides centralized tooltip management with support for different data types, dynamic content, and consistent formatting.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>class TooltipManager:\n    \"\"\"Manages tooltip functionality across multiple series and data types.\n\n    This class provides centralized tooltip management with support for\n    different data types, dynamic content, and consistent formatting.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize tooltip manager.\"\"\"\n        self.configs: Dict[str, TooltipConfig] = {}\n        self.custom_formatters: Dict[str, Callable[[Any], str]] = {}\n\n    def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n        \"\"\"Add a tooltip configuration.\"\"\"\n        self.configs[name] = config\n        return self\n\n    def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n        \"\"\"Get a tooltip configuration by name.\"\"\"\n        return self.configs.get(name)\n\n    def remove_config(self, name: str) -&gt; bool:\n        \"\"\"Remove a tooltip configuration.\"\"\"\n        if name in self.configs:\n            del self.configs[name]\n            return True\n        return False\n\n    def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n        \"\"\"Add a custom formatter function.\"\"\"\n        self.custom_formatters[name] = formatter\n        return self\n\n    def format_tooltip(\n        self,\n        config_name: str,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using specified configuration.\"\"\"\n        config = self.get_config(config_name)\n        if not config:\n            return \"\"\n\n        # Add custom formatters to config\n        config.custom_formatters.update(self.custom_formatters)\n\n        return config.format_tooltip(data, time_value)\n\n    def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n        \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.OHLC)\n        self.add_config(name, config)\n        return config\n\n    def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n        \"\"\"Create a standard trade tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.TRADE)\n        self.add_config(name, config)\n        return config\n\n    def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n        \"\"\"Create a custom tooltip configuration with template.\"\"\"\n        config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n        self.add_config(name, config)\n        return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.add_config","title":"add_config","text":"<pre><code>add_config(name: str, config: TooltipConfig) -&gt; TooltipManager\n</code></pre> <p>Add a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n    \"\"\"Add a tooltip configuration.\"\"\"\n    self.configs[name] = config\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.get_config","title":"get_config","text":"<pre><code>get_config(name: str) -&gt; Optional[TooltipConfig]\n</code></pre> <p>Get a tooltip configuration by name.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n    \"\"\"Get a tooltip configuration by name.\"\"\"\n    return self.configs.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.remove_config","title":"remove_config","text":"<pre><code>remove_config(name: str) -&gt; bool\n</code></pre> <p>Remove a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def remove_config(self, name: str) -&gt; bool:\n    \"\"\"Remove a tooltip configuration.\"\"\"\n    if name in self.configs:\n        del self.configs[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.add_custom_formatter","title":"add_custom_formatter","text":"<pre><code>add_custom_formatter(name: str, formatter: Callable[[Any], str]) -&gt; TooltipManager\n</code></pre> <p>Add a custom formatter function.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n    \"\"\"Add a custom formatter function.\"\"\"\n    self.custom_formatters[name] = formatter\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(config_name: str, data: Dict[str, Any], time_value: Optional[Union[int, str, Timestamp]] = None) -&gt; str\n</code></pre> <p>Format tooltip using specified configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    config_name: str,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip using specified configuration.\"\"\"\n    config = self.get_config(config_name)\n    if not config:\n        return \"\"\n\n    # Add custom formatters to config\n    config.custom_formatters.update(self.custom_formatters)\n\n    return config.format_tooltip(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip(name: str = 'default') -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.OHLC)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip(name: str = 'trade') -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.TRADE)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipManager.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(template: str, name: str = 'custom') -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipStyle","title":"TooltipStyle  <code>dataclass</code>","text":"<p>Styling configuration for tooltips.</p> <p>Attributes:</p> Name Type Description <code>background_color</code> <code>str</code> <p>Background color of the tooltip</p> <code>border_color</code> <code>str</code> <p>Border color of the tooltip</p> <code>border_width</code> <code>int</code> <p>Border width in pixels</p> <code>border_radius</code> <code>int</code> <p>Border radius in pixels</p> <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>font_size</code> <code>int</code> <p>Font size in pixels</p> <code>font_family</code> <code>str</code> <p>Font family</p> <code>color</code> <code>str</code> <p>Text color</p> <code>box_shadow</code> <code>str</code> <p>CSS box shadow</p> <code>z_index</code> <code>int</code> <p>Z-index for layering</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipStyle:\n    \"\"\"Styling configuration for tooltips.\n\n    Attributes:\n        background_color: Background color of the tooltip\n        border_color: Border color of the tooltip\n        border_width: Border width in pixels\n        border_radius: Border radius in pixels\n        padding: Padding in pixels\n        font_size: Font size in pixels\n        font_family: Font family\n        color: Text color\n        box_shadow: CSS box shadow\n        z_index: Z-index for layering\n    \"\"\"\n\n    background_color: str = \"rgba(255, 255, 255, 0.95)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    font_size: int = 12\n    font_family: str = \"sans-serif\"\n    color: str = \"#131722\"\n    box_shadow: str = \"0 2px 4px rgba(0, 0, 0, 0.1)\"\n    z_index: int = 1000\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData","title":"TradeData  <code>dataclass</code>","text":"<p>Represents a single trade with entry and exit information.</p> <p>This class provides a comprehensive representation of a trading transaction, including entry and exit details, profit/loss calculations, and visualization capabilities. It supports both long and short trades with automatic P&amp;L calculations and marker generation for chart display.</p> <p>The class automatically validates trade data, normalizes time values, and provides computed properties for profit/loss analysis. It can convert trades to marker representations for visual display on charts.</p> <p>Attributes:</p> Name Type Description <code>entry_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Entry time in various formats (automatically normalized to UTC timestamp).</p> <code>entry_price</code> <code>Union[float, int]</code> <p>Entry price for the trade.</p> <code>exit_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Exit time in various formats (automatically normalized to UTC timestamp).</p> <code>exit_price</code> <code>Union[float, int]</code> <p>Exit price for the trade.</p> <code>is_profitable</code> <code>bool</code> <p>Whether the trade was profitable (True) or not (False).</p> <code>id</code> <code>str</code> <p>Unique identifier for the trade (required).</p> <code>additional_data</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing any additional trade data such as quantity, trade_type, notes, etc. This provides maximum flexibility for custom fields.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a profitable long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\nprint(f\"Profitable: {trade.is_profitable}\")  # True\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> Note <ul> <li>Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised</li> <li>Price values are automatically converted to appropriate numeric types</li> <li>Time values are normalized to UTC timestamps for consistent handling</li> <li>All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data</li> <li>The id field is required for trade identification</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>@dataclass\nclass TradeData(SerializableMixin):\n    \"\"\"Represents a single trade with entry and exit information.\n\n    This class provides a comprehensive representation of a trading transaction,\n    including entry and exit details, profit/loss calculations, and visualization\n    capabilities. It supports both long and short trades with automatic P&amp;L\n    calculations and marker generation for chart display.\n\n    The class automatically validates trade data, normalizes time values, and\n    provides computed properties for profit/loss analysis. It can convert trades\n    to marker representations for visual display on charts.\n\n    Attributes:\n        entry_time (Union[pd.Timestamp, datetime, str, int, float]): Entry time\n            in various formats (automatically normalized to UTC timestamp).\n        entry_price (Union[float, int]): Entry price for the trade.\n        exit_time (Union[pd.Timestamp, datetime, str, int, float]): Exit time\n            in various formats (automatically normalized to UTC timestamp).\n        exit_price (Union[float, int]): Exit price for the trade.\n        is_profitable (bool): Whether the trade was profitable (True) or not (False).\n        id (str): Unique identifier for the trade (required).\n        additional_data (Optional[Dict[str, Any]]): Optional dictionary containing\n            any additional trade data such as quantity, trade_type, notes, etc.\n            This provides maximum flexibility for custom fields.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n        # Create a profitable long trade\n        trade = TradeData(\n            entry_time=\"2024-01-01T09:00:00\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01T16:00:00\",\n            exit_price=105.0,\n            is_profitable=True,\n            id=\"trade_001\",\n            additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n        )\n\n        # Access calculated properties\n        print(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\n        print(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\n        print(f\"Profitable: {trade.is_profitable}\")  # True\n\n        # Serialize for frontend\n        trade_dict = trade.asdict()\n        ```\n\n    Note:\n        - Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised\n        - Price values are automatically converted to appropriate numeric types\n        - Time values are normalized to UTC timestamps for consistent handling\n        - All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data\n        - The id field is required for trade identification\n    \"\"\"\n\n    # Core fields required for trade visualization\n    entry_time: Union[pd.Timestamp, datetime, str, int, float]\n    entry_price: Union[float, int]\n    exit_time: Union[pd.Timestamp, datetime, str, int, float]\n    exit_price: Union[float, int]\n    is_profitable: bool\n    id: str  # Required for trade identification\n\n    # All other data moved to additional_data for maximum flexibility\n    additional_data: Optional[Dict[str, Any]] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize and validate trade data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Converts price values to appropriate numeric types\n        2. Validates that exit time is after entry time\n        3. Ensures is_profitable is a boolean\n\n        Raises:\n            ExitTimeAfterEntryTimeError: If exit time is not after entry time.\n            ValueValidationError: If time validation fails.\n        \"\"\"\n        # Step 1: Convert price values to float for consistent calculations\n        # This ensures prices are always numeric, regardless of input type\n        self.entry_price = float(self.entry_price)\n        self.exit_price = float(self.exit_price)\n\n        # Step 2: Ensure is_profitable is a boolean for consistent logic\n        # Converts any truthy/falsy value to explicit True/False\n        self.is_profitable = bool(self.is_profitable)\n\n        # Step 3: Validate that exit time is after entry time\n        # Convert times temporarily for validation only\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # This is critical for trade logic - a trade cannot exit before it enters\n        if isinstance(entry_timestamp, (int, float)) and isinstance(\n            exit_timestamp,\n            (int, float),\n        ):\n            # Case 1: Both timestamps are numeric - compare directly\n            if exit_timestamp &lt;= entry_timestamp:\n                raise ExitTimeAfterEntryTimeError()\n        elif (\n            isinstance(entry_timestamp, str)\n            and isinstance(exit_timestamp, str)\n            and exit_timestamp &lt;= entry_timestamp\n        ):\n            # Case 2: Both timestamps are strings - compare lexicographically\n            raise ValueValidationError(\"Exit time\", \"must be after entry time\")\n\n    def generate_tooltip_text(self) -&gt; str:\n        \"\"\"Generate tooltip text for the trade.\n\n        Creates a comprehensive tooltip text that displays key trade information\n        including entry/exit prices, quantity, profit/loss, and optional notes.\n        The tooltip is designed to be informative and easy to read when displayed\n        on charts.\n\n        Returns:\n            str: Formatted tooltip text with trade details and P&amp;L information.\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                quantity=100,\n                trade_type=TradeType.LONG,\n            )\n            tooltip = trade.generate_tooltip_text()\n            # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n            ```\n        \"\"\"\n        # Step 1: Calculate profit/loss metrics for tooltip display\n        # Uses the pnl and pnl_percentage properties which check additional_data first\n        pnl = self.pnl\n        pnl_pct = self.pnl_percentage\n\n        # Step 2: Determine win/loss label based on P&amp;L value\n        # Positive P&amp;L = Win, negative or zero = Loss\n        win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n        # Step 3: Build tooltip components with formatted trade information\n        # Start with core entry/exit prices (always shown)\n        tooltip_parts = [\n            f\"Entry: {self.entry_price:.2f}\",\n            f\"Exit: {self.exit_price:.2f}\",\n        ]\n\n        # Step 4: Add quantity if available in additional_data\n        # Quantity is optional and only shown if user provided it\n        if self.additional_data and \"quantity\" in self.additional_data:\n            tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n        # Step 5: Add P&amp;L information (always shown)\n        # Shows both absolute P&amp;L and percentage for complete picture\n        tooltip_parts.extend(\n            [\n                f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n                f\"{win_loss}\",\n            ],\n        )\n\n        # Step 6: Add custom notes if provided for additional context\n        # Notes are optional and only shown if user provided them\n        if self.additional_data and \"notes\" in self.additional_data:\n            tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n        # Step 7: Join all parts with newlines for multi-line tooltip display\n        return \"\\n\".join(tooltip_parts)\n\n    @property\n    def pnl(self) -&gt; float:\n        \"\"\"Get profit/loss amount from additional_data or calculate basic price difference.\n\n        First checks if P&amp;L is provided in additional_data, otherwise calculates\n        basic price difference. This allows users to provide their own P&amp;L calculation\n        logic while maintaining a fallback for basic visualization.\n\n        Returns:\n            float: Profit/loss amount. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl\n            trade = TradeData(..., additional_data={\"pnl\": 500.0})\n            trade.pnl  # Returns: 500.0\n\n            # Without additional_data, calculates basic difference\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl  # Returns: 5.0 (basic price difference)\n            ```\n        \"\"\"\n        # Check if P&amp;L is provided in additional_data dictionary\n        # User may provide custom P&amp;L calculation (e.g., accounting for fees, quantity)\n        if self.additional_data and \"pnl\" in self.additional_data:\n            return float(self.additional_data[\"pnl\"])\n\n        # Fallback: Calculate basic price difference for visualization\n        # Simple formula: exit_price - entry_price (doesn't account for quantity or fees)\n        return float(self.exit_price - self.entry_price)\n\n    @property\n    def pnl_percentage(self) -&gt; float:\n        \"\"\"Get profit/loss percentage from additional_data or calculate basic percentage.\n\n        First checks if P&amp;L percentage is provided in additional_data, otherwise\n        calculates basic percentage based on price difference relative to entry price.\n\n        Returns:\n            float: Profit/loss percentage. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl_percentage\n            trade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\n            trade.pnl_percentage  # Returns: 5.0\n\n            # Without additional_data, calculates basic percentage\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl_percentage  # Returns: 5.0 (5% gain)\n            ```\n        \"\"\"\n        # Check if P&amp;L percentage is provided in additional_data dictionary\n        # User may provide custom percentage calculation\n        if self.additional_data and \"pnl_percentage\" in self.additional_data:\n            return float(self.additional_data[\"pnl_percentage\"])\n\n        # Fallback: Calculate basic percentage from price difference\n        # Formula: ((exit - entry) / entry) * 100\n        if self.entry_price != 0:\n            return ((self.exit_price - self.entry_price) / self.entry_price) * 100\n\n        # Edge case: Return 0.0 if entry price is zero to avoid division by zero\n        return 0.0\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n        Converts the trade to a dictionary format suitable for frontend\n        communication. Converts times to UTC timestamps at serialization time\n        to handle any changes made to entry_time or exit_time after construction.\n\n        Returns:\n            Dict[str, Any]: Serialized trade with camelCase keys ready for\n                frontend consumption. Contains:\n                - entryTime: Entry timestamp (converted from entry_time)\n                - entryPrice: Entry price\n                - exitTime: Exit timestamp (converted from exit_time)\n                - exitPrice: Exit price\n                - isProfitable: Profitability status\n                - pnl: Profit/loss amount (from additional_data or calculated)\n                - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n                - All fields from additional_data (merged for template access)\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                is_profitable=True,\n                additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n            )\n\n            result = trade.asdict()\n            # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n            #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n            #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n            ```\n        \"\"\"\n        # Step 1: Convert times to UTC timestamps at serialization time\n        # This ensures we always use current entry_time/exit_time values\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # Step 2: Create base trade dictionary with core fields\n        # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n        trade_dict = {\n            \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n            \"entryPrice\": self.entry_price,  # Entry price as float\n            \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n            \"exitPrice\": self.exit_price,  # Exit price as float\n            \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n            \"id\": self.id,  # Unique trade identifier (required)\n            \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n            \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n        }\n\n        # Step 3: Merge additional data into the trade dict for template access\n        # This allows frontend templates to access custom fields like quantity, notes, etc.\n        if self.additional_data:\n            trade_dict.update(self.additional_data)\n\n        return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData.pnl","title":"pnl  <code>property</code>","text":"<pre><code>pnl: float\n</code></pre> <p>Get profit/loss amount from additional_data or calculate basic price difference.</p> <p>First checks if P&amp;L is provided in additional_data, otherwise calculates basic price difference. This allows users to provide their own P&amp;L calculation logic while maintaining a fallback for basic visualization.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss amount. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl\ntrade = TradeData(..., additional_data={\"pnl\": 500.0})\ntrade.pnl  # Returns: 500.0\n\n# Without additional_data, calculates basic difference\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl  # Returns: 5.0 (basic price difference)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData.pnl_percentage","title":"pnl_percentage  <code>property</code>","text":"<pre><code>pnl_percentage: float\n</code></pre> <p>Get profit/loss percentage from additional_data or calculate basic percentage.</p> <p>First checks if P&amp;L percentage is provided in additional_data, otherwise calculates basic percentage based on price difference relative to entry price.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss percentage. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl_percentage\ntrade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\ntrade.pnl_percentage  # Returns: 5.0\n\n# Without additional_data, calculates basic percentage\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl_percentage  # Returns: 5.0 (5% gain)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData.generate_tooltip_text","title":"generate_tooltip_text","text":"<pre><code>generate_tooltip_text() -&gt; str\n</code></pre> <p>Generate tooltip text for the trade.</p> <pre><code>    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\n</code></pre> <p>Exit: 105.00 Qty: 100.00 P&amp;L: 500.00 (5.0%) Win\"             ```</p> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def generate_tooltip_text(self) -&gt; str:\n    \"\"\"Generate tooltip text for the trade.\n\n    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n        ```\n    \"\"\"\n    # Step 1: Calculate profit/loss metrics for tooltip display\n    # Uses the pnl and pnl_percentage properties which check additional_data first\n    pnl = self.pnl\n    pnl_pct = self.pnl_percentage\n\n    # Step 2: Determine win/loss label based on P&amp;L value\n    # Positive P&amp;L = Win, negative or zero = Loss\n    win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n    # Step 3: Build tooltip components with formatted trade information\n    # Start with core entry/exit prices (always shown)\n    tooltip_parts = [\n        f\"Entry: {self.entry_price:.2f}\",\n        f\"Exit: {self.exit_price:.2f}\",\n    ]\n\n    # Step 4: Add quantity if available in additional_data\n    # Quantity is optional and only shown if user provided it\n    if self.additional_data and \"quantity\" in self.additional_data:\n        tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n    # Step 5: Add P&amp;L information (always shown)\n    # Shows both absolute P&amp;L and percentage for complete picture\n    tooltip_parts.extend(\n        [\n            f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n            f\"{win_loss}\",\n        ],\n    )\n\n    # Step 6: Add custom notes if provided for additional context\n    # Notes are optional and only shown if user provided them\n    if self.additional_data and \"notes\" in self.additional_data:\n        tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n    # Step 7: Join all parts with newlines for multi-line tooltip display\n    return \"\\n\".join(tooltip_parts)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeData.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the trade data to a dict with camelCase keys for frontend.</p> <p>Converts the trade to a dictionary format suitable for frontend communication. Converts times to UTC timestamps at serialization time to handle any changes made to entry_time or exit_time after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized trade with camelCase keys ready for frontend consumption. Contains: - entryTime: Entry timestamp (converted from entry_time) - entryPrice: Entry price - exitTime: Exit timestamp (converted from exit_time) - exitPrice: Exit price - isProfitable: Profitability status - pnl: Profit/loss amount (from additional_data or calculated) - pnlPercentage: Profit/loss percentage (from additional_data or calculated) - All fields from additional_data (merged for template access)</p> Example <pre><code>trade = TradeData(\n    entry_time=\"2024-01-01\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01\",\n    exit_price=105.0,\n    is_profitable=True,\n    additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n)\n\nresult = trade.asdict()\n# Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n#          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n#          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n    Converts the trade to a dictionary format suitable for frontend\n    communication. Converts times to UTC timestamps at serialization time\n    to handle any changes made to entry_time or exit_time after construction.\n\n    Returns:\n        Dict[str, Any]: Serialized trade with camelCase keys ready for\n            frontend consumption. Contains:\n            - entryTime: Entry timestamp (converted from entry_time)\n            - entryPrice: Entry price\n            - exitTime: Exit timestamp (converted from exit_time)\n            - exitPrice: Exit price\n            - isProfitable: Profitability status\n            - pnl: Profit/loss amount (from additional_data or calculated)\n            - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n            - All fields from additional_data (merged for template access)\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            is_profitable=True,\n            additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n        )\n\n        result = trade.asdict()\n        # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n        #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n        #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n        ```\n    \"\"\"\n    # Step 1: Convert times to UTC timestamps at serialization time\n    # This ensures we always use current entry_time/exit_time values\n    entry_timestamp = to_utc_timestamp(self.entry_time)\n    exit_timestamp = to_utc_timestamp(self.exit_time)\n\n    # Step 2: Create base trade dictionary with core fields\n    # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n    trade_dict = {\n        \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n        \"entryPrice\": self.entry_price,  # Entry price as float\n        \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n        \"exitPrice\": self.exit_price,  # Exit price as float\n        \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n        \"id\": self.id,  # Unique trade identifier (required)\n        \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n        \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n    }\n\n    # Step 3: Merge additional data into the trade dict for template access\n    # This allows frontend templates to access custom fields like quantity, notes, etc.\n    if self.additional_data:\n        trade_dict.update(self.additional_data)\n\n    return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData","title":"TrendFillData  <code>dataclass</code>","text":"<p>Trend fill data for lightweight charts.</p> <p>This data class represents a single data point for trend fill charts, with simplified trend line handling:</p> <ul> <li>Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference</li> <li>Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference</li> <li>Neutral (0): No trend line displayed</li> </ul> <p>The fill area is created between the trend line and base line, with colors automatically selected based on trend direction.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Any</code> <p>Time value for the data point</p> <code>baseLine</code> <code>Any</code> <p>Base line value (e.g., candle body midpoint, price level)</p> <code>trendLine</code> <code>Any</code> <p>Value of the trend line (used for both uptrend and downtrend)</p> <code>trendDirection</code> <code>Any</code> <p>Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)</p> <code>uptrendFillColor</code> <code>Any</code> <p>Optional custom uptrend fill color</p> <code>downtrendFillColor</code> <code>Any</code> <p>Optional custom downtrend fill color</p> Source code in <code>streamlit_lightweight_charts_pro/data/trend_fill.py</code> <pre><code>@dataclass\nclass TrendFillData(Data):\n    \"\"\"Trend fill data for lightweight charts.\n\n    This data class represents a single data point for trend fill charts,\n    with simplified trend line handling:\n\n    - Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference\n    - Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference\n    - Neutral (0): No trend line displayed\n\n    The fill area is created between the trend line and base line,\n    with colors automatically selected based on trend direction.\n\n    Attributes:\n        time: Time value for the data point\n        baseLine: Base line value (e.g., candle body midpoint, price level)\n        trendLine: Value of the trend line (used for both uptrend and downtrend)\n        trendDirection: Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)\n\n        # Fill color fields\n        uptrendFillColor: Optional custom uptrend fill color\n        downtrendFillColor: Optional custom downtrend fill color\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"base_line\", \"trend_line\", \"trend_direction\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"uptrend_fill_color\",\n        \"downtrend_fill_color\",\n    }\n\n    # Core fields\n    base_line: float = 0\n    trend_line: float = 0\n    trend_direction: int = 0\n\n    # Fill color fields\n    uptrend_fill_color: Optional[str] = None\n    downtrend_fill_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Validate and process data after initialization.\"\"\"\n        super().__post_init__()\n\n        # Handle NaN values for trend line fields\n        if isinstance(self.trend_line, float) and math.isnan(self.trend_line):\n            self.trend_line = None\n        if isinstance(self.base_line, float) and math.isnan(self.base_line):\n            self.base_line = None\n\n        # Validate trend_direction\n        if not isinstance(self.trend_direction, int):\n            raise TrendDirectionIntegerError(\n                \"trend_direction\",\n                \"integer\",\n                type(self.trend_direction).__name__,\n            )\n\n        if self.trend_direction not in [-1, 0, 1]:\n            raise ValueValidationError(\"trend_direction\", \"must be -1, 0, or 1\")\n\n        # Validate fill colors if provided\n        if self.uptrend_fill_color is not None and not isinstance(self.uptrend_fill_color, str):\n            raise TypeValidationError(\"uptrend_fill_color\", \"string\")\n        if self.downtrend_fill_color is not None and not isinstance(self.downtrend_fill_color, str):\n            raise TypeValidationError(\"downtrend_fill_color\", \"string\")\n\n    @property\n    def is_uptrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents an uptrend.\"\"\"\n        return self.trend_direction == 1\n\n    @property\n    def is_downtrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents a downtrend.\"\"\"\n        return self.trend_direction == -1\n\n    @property\n    def is_neutral(self) -&gt; bool:\n        \"\"\"Check if this data point represents a neutral trend.\"\"\"\n        return self.trend_direction == 0\n\n    @property\n    def has_valid_fill_data(self) -&gt; bool:\n        \"\"\"Check if this data point has valid data for creating fills.\n\n        Returns True if we have a valid trend line and base line,\n        with the appropriate trend line based on direction.\n        \"\"\"\n        if self.trend_direction == 0 or self.base_line is None:\n            return False\n\n        # Check if we have a valid trend line\n        return self.trend_line is not None\n\n    @property\n    def has_valid_uptrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid uptrend fill data.\"\"\"\n        return (\n            self.base_line is not None and self.trend_direction == 1 and self.trend_line is not None\n        )\n\n    @property\n    def has_valid_downtrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid downtrend fill data.\"\"\"\n        return (\n            self.base_line is not None\n            and self.trend_direction == -1\n            and self.trend_line is not None\n        )\n\n    @property\n    def active_trend_line(self) -&gt; Optional[float]:\n        \"\"\"Get the active trend line value based on trend direction.\n\n        Returns the trend line value for the current trend direction:\n        - Uptrend (+1): Returns trend_line (trend line above price)\n        - Downtrend (-1): Returns trend_line (trend line below price)\n        \"\"\"\n        if self.trend_direction in [1, -1]:  # Both uptrend and downtrend use trend_line\n            return self.trend_line\n        return None\n\n    @property\n    def active_fill_color(self) -&gt; Optional[str]:\n        \"\"\"Get the active fill color based on trend direction.\n\n        Returns the appropriate fill color for the current trend direction,\n        prioritizing direction-specific colors.\n        \"\"\"\n        if self.trend_direction == 1:  # Uptrend\n            return self.uptrend_fill_color\n        if self.trend_direction == -1:  # Downtrend\n            return self.downtrend_fill_color\n        return None\n\n    @property\n    def trend_line_type(self) -&gt; Optional[str]:\n        \"\"\"Get the type of trend line being displayed.\n\n        Returns:\n            'upper' for uptrend (trend line above price)\n            'lower' for downtrend (trend line below price)\n            None for neutral\n        \"\"\"\n        if self.trend_direction == 1:\n            return \"upper\"\n        if self.trend_direction == -1:\n            return \"lower\"\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.is_uptrend","title":"is_uptrend  <code>property</code>","text":"<pre><code>is_uptrend: bool\n</code></pre> <p>Check if this data point represents an uptrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.is_downtrend","title":"is_downtrend  <code>property</code>","text":"<pre><code>is_downtrend: bool\n</code></pre> <p>Check if this data point represents a downtrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.is_neutral","title":"is_neutral  <code>property</code>","text":"<pre><code>is_neutral: bool\n</code></pre> <p>Check if this data point represents a neutral trend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.has_valid_fill_data","title":"has_valid_fill_data  <code>property</code>","text":"<pre><code>has_valid_fill_data: bool\n</code></pre> <p>Check if this data point has valid data for creating fills.</p> <p>Returns True if we have a valid trend line and base line, with the appropriate trend line based on direction.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.has_valid_uptrend_fill","title":"has_valid_uptrend_fill  <code>property</code>","text":"<pre><code>has_valid_uptrend_fill: bool\n</code></pre> <p>Check if this data point has valid uptrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.has_valid_downtrend_fill","title":"has_valid_downtrend_fill  <code>property</code>","text":"<pre><code>has_valid_downtrend_fill: bool\n</code></pre> <p>Check if this data point has valid downtrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.active_trend_line","title":"active_trend_line  <code>property</code>","text":"<pre><code>active_trend_line: Optional[float]\n</code></pre> <p>Get the active trend line value based on trend direction.</p> <p>Returns the trend line value for the current trend direction: - Uptrend (+1): Returns trend_line (trend line above price) - Downtrend (-1): Returns trend_line (trend line below price)</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.active_fill_color","title":"active_fill_color  <code>property</code>","text":"<pre><code>active_fill_color: Optional[str]\n</code></pre> <p>Get the active fill color based on trend direction.</p> <p>Returns the appropriate fill color for the current trend direction, prioritizing direction-specific colors.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TrendFillData.trend_line_type","title":"trend_line_type  <code>property</code>","text":"<pre><code>trend_line_type: Optional[str]\n</code></pre> <p>Get the type of trend line being displayed.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>'upper' for uptrend (trend line above price)</p> <code>Optional[str]</code> <p>'lower' for downtrend (trend line below price)</p> <code>Optional[str]</code> <p>None for neutral</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipPosition","title":"TooltipPosition","text":"<p>Tooltip position enumeration.</p> <p>Defines how tooltips should be positioned relative to the cursor or chart elements.</p> <p>Attributes:</p> Name Type Description <code>CURSOR</code> <p>Cursor position - tooltip follows the mouse cursor.</p> <code>FIXED</code> <p>Fixed position - tooltip appears at a fixed location.</p> <code>AUTO</code> <p>Auto position - tooltip position is automatically determined.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipPosition(str, Enum):\n    \"\"\"Tooltip position enumeration.\n\n    Defines how tooltips should be positioned relative to the cursor\n    or chart elements.\n\n    Attributes:\n        CURSOR: Cursor position - tooltip follows the mouse cursor.\n        FIXED: Fixed position - tooltip appears at a fixed location.\n        AUTO: Auto position - tooltip position is automatically determined.\n    \"\"\"\n\n    CURSOR = \"cursor\"\n    FIXED = \"fixed\"\n    AUTO = \"auto\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TooltipType","title":"TooltipType","text":"<p>Tooltip type enumeration.</p> <p>Defines the types of tooltips supported by the system. Each type corresponds to a specific data format and display style.</p> <p>Attributes:</p> Name Type Description <code>OHLC</code> <p>OHLC tooltip - displays open, high, low, close, and volume data.</p> <code>SINGLE</code> <p>Single value tooltip - displays a single data value.</p> <code>MULTI</code> <p>Multi-series tooltip - displays data from multiple series.</p> <code>CUSTOM</code> <p>Custom tooltip - displays custom content using templates.</p> <code>TRADE</code> <p>Trade tooltip - displays trade information (entry, exit, P&amp;L).</p> <code>MARKER</code> <p>Marker tooltip - displays marker-specific information.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipType(str, Enum):\n    \"\"\"Tooltip type enumeration.\n\n    Defines the types of tooltips supported by the system.\n    Each type corresponds to a specific data format and display style.\n\n    Attributes:\n        OHLC: OHLC tooltip - displays open, high, low, close, and volume data.\n        SINGLE: Single value tooltip - displays a single data value.\n        MULTI: Multi-series tooltip - displays data from multiple series.\n        CUSTOM: Custom tooltip - displays custom content using templates.\n        TRADE: Trade tooltip - displays trade information (entry, exit, P&amp;L).\n        MARKER: Marker tooltip - displays marker-specific information.\n    \"\"\"\n\n    OHLC = \"ohlc\"\n    SINGLE = \"single\"\n    MULTI = \"multi\"\n    CUSTOM = \"custom\"\n    TRADE = \"trade\"\n    MARKER = \"marker\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeType","title":"TradeType","text":"<p>Trade type enumeration.</p> <p>Defines the direction of a trade (long or short). Used for trade visualization and profit/loss calculations.</p> <p>Attributes:</p> Name Type Description <code>LONG</code> <p>Long trade - profit when price goes up.</p> <code>SHORT</code> <p>Short trade - profit when price goes down.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeType(str, Enum):\n    \"\"\"Trade type enumeration.\n\n    Defines the direction of a trade (long or short).\n    Used for trade visualization and profit/loss calculations.\n\n    Attributes:\n        LONG: Long trade - profit when price goes up.\n        SHORT: Short trade - profit when price goes down.\n    \"\"\"\n\n    LONG = \"long\"\n    SHORT = \"short\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.TradeVisualization","title":"TradeVisualization","text":"<p>Trade visualization style enumeration.</p> <p>Defines how trades should be visualized on the chart. Multiple visualization styles can be combined to create comprehensive trade displays.</p> <p>Attributes:</p> Name Type Description <code>MARKERS</code> <p>Display entry/exit markers only.</p> <code>RECTANGLES</code> <p>Display rectangle spanning from entry to exit.</p> <code>BOTH</code> <p>Display both markers and rectangles.</p> <code>LINES</code> <p>Display connecting lines between entry and exit.</p> <code>ARROWS</code> <p>Display directional arrows from entry to exit.</p> <code>ZONES</code> <p>Display colored zones with transparency around trades.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeVisualization(str, Enum):\n    \"\"\"Trade visualization style enumeration.\n\n    Defines how trades should be visualized on the chart.\n    Multiple visualization styles can be combined to create\n    comprehensive trade displays.\n\n    Attributes:\n        MARKERS: Display entry/exit markers only.\n        RECTANGLES: Display rectangle spanning from entry to exit.\n        BOTH: Display both markers and rectangles.\n        LINES: Display connecting lines between entry and exit.\n        ARROWS: Display directional arrows from entry to exit.\n        ZONES: Display colored zones with transparency around trades.\n    \"\"\"\n\n    MARKERS = \"markers\"  # Just entry/exit markers\n    RECTANGLES = \"rectangles\"  # Rectangle from entry to exit\n    BOTH = \"both\"  # Both markers and rectangles\n    LINES = \"lines\"  # Lines connecting entry to exit\n    ARROWS = \"arrows\"  # Arrows from entry to exit\n    ZONES = \"zones\"  # Colored zones with transparency\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_arrow_annotation","title":"create_arrow_annotation","text":"<pre><code>create_arrow_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create an arrow annotation.</p> <p>Convenience function for creating arrow annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the arrow.</p> required <code>**kwargs</code> <p>Additional styling options (color, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured arrow annotation.</p> Example <pre><code># Basic arrow annotation\nann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n# With custom styling\nann = create_arrow_annotation(\n    \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_arrow_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create an arrow annotation.\n\n    Convenience function for creating arrow annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the arrow.\n        **kwargs: Additional styling options (color, position, etc.).\n\n    Returns:\n        Annotation: Configured arrow annotation.\n\n    Example:\n        ```python\n        # Basic arrow annotation\n        ann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n        # With custom styling\n        ann = create_arrow_annotation(\n            \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.ARROW,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_shape_annotation","title":"create_shape_annotation","text":"<pre><code>create_shape_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a shape annotation.</p> <p>Convenience function for creating shape annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the shape.</p> required <code>**kwargs</code> <p>Additional styling options (color, border_color, border_width, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured shape annotation.</p> Example <pre><code># Basic shape annotation\nann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n# With custom styling\nann = create_shape_annotation(\n    \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_shape_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a shape annotation.\n\n    Convenience function for creating shape annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the shape.\n        **kwargs: Additional styling options (color, border_color,\n            border_width, etc.).\n\n    Returns:\n        Annotation: Configured shape annotation.\n\n    Example:\n        ```python\n        # Basic shape annotation\n        ann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n        # With custom styling\n        ann = create_shape_annotation(\n            \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.SHAPE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_text_annotation","title":"create_text_annotation","text":"<pre><code>create_text_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a text annotation.</p> <p>Convenience function for creating text annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display.</p> required <code>**kwargs</code> <p>Additional styling options (color, background_color, font_size, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured text annotation.</p> Example <pre><code># Basic text annotation\nann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n# With custom styling\nann = create_text_annotation(\n    \"2024-01-01\",\n    100,\n    \"Buy Signal\",\n    color=\"green\",\n    background_color=\"rgba(0, 255, 0, 0.2)\",\n    font_size=14,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_text_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a text annotation.\n\n    Convenience function for creating text annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display.\n        **kwargs: Additional styling options (color, background_color,\n            font_size, position, etc.).\n\n    Returns:\n        Annotation: Configured text annotation.\n\n    Example:\n        ```python\n        # Basic text annotation\n        ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n        # With custom styling\n        ann = create_text_annotation(\n            \"2024-01-01\",\n            100,\n            \"Buy Signal\",\n            color=\"green\",\n            background_color=\"rgba(0, 255, 0, 0.2)\",\n            font_size=14,\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.TEXT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(template: str) -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(template: str) -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    return TooltipConfig(type=TooltipType.CUSTOM, template=template)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_multi_series_tooltip","title":"create_multi_series_tooltip","text":"<pre><code>create_multi_series_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a multi-series tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_multi_series_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a multi-series tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.MULTI)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.OHLC)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_single_value_tooltip","title":"create_single_value_tooltip","text":"<pre><code>create_single_value_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a single value tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_single_value_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a single value tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.SINGLE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/index.html#streamlit_lightweight_charts_pro.data.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.TRADE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html","title":"streamlit_lightweight_charts_pro.data.annotation","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation","title":"annotation","text":"<p>Annotation system for streamlit-lightweight-charts.</p> <p>This module provides a comprehensive annotation system for adding text, arrows, shapes, and other visual elements to charts. It includes classes for individual annotations, annotation layers for organization, and an annotation manager for coordinating multiple layers.</p> The annotation system supports <ul> <li>Multiple annotation types (text, arrow, shape, line, rectangle, circle)</li> <li>Annotation positioning (above, below, inline)</li> <li>Layer-based organization for grouping related annotations</li> <li>Visibility and opacity controls</li> <li>Method chaining for fluent API usage</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.data.annotation import (\n    create_text_annotation,\n    create_arrow_annotation,\n    AnnotationManager,\n)\n\n# Create annotations\ntext_ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\narrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Buy Signal\")\n\n# Use with annotation manager\nmanager = (\n    AnnotationManager()\n    .create_layer(\"events\")\n    .add_annotation(text_ann, \"events\")\n    .add_annotation(arrow_ann, \"events\")\n)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation","title":"Annotation","text":"<p>Represents a chart annotation.</p> <p>This class defines an annotation that can be displayed on charts to provide additional context, highlight important events, or add explanatory information. Annotations support various types, positions, and styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Annotation time (accepts pd.Timestamp, datetime, or string)</p> <code>price</code> <code>float</code> <p>Price level for the annotation</p> <code>text</code> <code>str</code> <p>Annotation text content</p> <code>annotation_type</code> <code>AnnotationType</code> <p>Type of annotation (text, arrow, shape, etc.)</p> <code>position</code> <code>AnnotationPosition</code> <p>Position of the annotation relative to the price level</p> <code>color</code> <code>str</code> <p>Primary color of the annotation</p> <code>background_color</code> <code>str</code> <p>Background color for text annotations</p> <code>font_size</code> <code>int</code> <p>Font size for text annotations</p> <code>font_weight</code> <code>str</code> <p>Font weight for text annotations</p> <code>text_color</code> <code>str</code> <p>Color of the text content</p> <code>border_color</code> <code>str</code> <p>Border color for shape annotations</p> <code>border_width</code> <code>int</code> <p>Border width for shape annotations</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the annotation (0.0 to 1.0)</p> <code>show_time</code> <code>bool</code> <p>Whether to show time in the annotation text</p> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip text for hover interactions</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class Annotation:\n    \"\"\"Represents a chart annotation.\n\n    This class defines an annotation that can be displayed on charts to\n    provide additional context, highlight important events, or add\n    explanatory information. Annotations support various types, positions,\n    and styling options.\n\n    Attributes:\n        time: Annotation time (accepts pd.Timestamp, datetime, or string)\n        price: Price level for the annotation\n        text: Annotation text content\n        annotation_type: Type of annotation (text, arrow, shape, etc.)\n        position: Position of the annotation relative to the price level\n        color: Primary color of the annotation\n        background_color: Background color for text annotations\n        font_size: Font size for text annotations\n        font_weight: Font weight for text annotations\n        text_color: Color of the text content\n        border_color: Border color for shape annotations\n        border_width: Border width for shape annotations\n        opacity: Overall opacity of the annotation (0.0 to 1.0)\n        show_time: Whether to show time in the annotation text\n        tooltip: Optional tooltip text for hover interactions\n    \"\"\"\n\n    time: Union[pd.Timestamp, datetime, str, int, float]\n    price: float\n    text: str\n    annotation_type: AnnotationType = AnnotationType.TEXT\n    position: AnnotationPosition = AnnotationPosition.ABOVE\n    color: str = \"#2196F3\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    font_size: int = 12\n    font_weight: str = \"normal\"\n    text_color: str = \"#000000\"\n    border_color: str = \"#CCCCCC\"\n    border_width: int = 1\n    opacity: float = 1.0\n    show_time: bool = False\n    tooltip: Optional[str] = None\n\n    def __init__(\n        self,\n        time: Union[pd.Timestamp, datetime, str, int, float],\n        price: float,\n        text: str,\n        annotation_type: Union[str, AnnotationType] = AnnotationType.TEXT,\n        position: Union[str, AnnotationPosition] = AnnotationPosition.ABOVE,\n        color: str = \"#2196F3\",\n        background_color: str = \"rgba(255, 255, 255, 0.9)\",\n        font_size: int = 12,\n        font_weight: str = \"normal\",\n        text_color: str = \"#000000\",\n        border_color: str = \"#CCCCCC\",\n        border_width: int = 1,\n        opacity: float = 1.0,\n        show_time: bool = False,\n        tooltip: Optional[str] = None,\n    ):\n        # Store time as-is, convert to UTC timestamp in asdict() for consistency\n        self.time = time\n\n        # Accept both str and Enum for annotation_type\n        if isinstance(annotation_type, str):\n            self.annotation_type = AnnotationType(annotation_type)\n        else:\n            self.annotation_type = annotation_type\n\n        # Accept both str and Enum for position\n        if isinstance(position, str):\n            self.position = AnnotationPosition(position)\n        else:\n            self.position = position\n\n        # Validate price value\n        if not isinstance(price, (int, float)):\n            raise TypeValidationError(\"price\", \"a number\")\n        self.price = price\n\n        # Validate text content\n        if not text:\n            raise ValueValidationError.required_field(\"text\")\n        self.text = text\n\n        # Validate opacity range\n        if opacity &lt; 0 or opacity &gt; 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n\n        # Validate font size\n        if font_size &lt;= 0:\n            raise ValueValidationError.positive_value(\"font_size\", font_size)\n        self.font_size = font_size\n\n        # Validate border width\n        if border_width &lt; 0:\n            raise ValueValidationError(\"border_width\", f\"must be non-negative, got {border_width}\")\n        self.border_width = border_width\n\n        self.color = color\n        self.background_color = background_color\n        self.font_weight = font_weight\n        self.text_color = text_color\n        self.border_color = border_color\n        self.show_time = show_time\n        self.tooltip = tooltip\n\n    @property\n    def timestamp(self) -&gt; int:\n        \"\"\"Get time as UTC timestamp (converted fresh).\n\n        Converts the time value to UTC timestamp each time it's accessed.\n        This allows the time to be modified after construction.\n\n        Returns:\n            int: UTC timestamp as integer (seconds).\n        \"\"\"\n        return to_utc_timestamp(self.time)\n\n    @property\n    def datetime_value(self) -&gt; pd.Timestamp:\n        \"\"\"Get time as pandas Timestamp.\n\n        Returns:\n            pd.Timestamp: Pandas Timestamp object representing the\n                annotation time.\n        \"\"\"\n        return pd.Timestamp(from_utc_timestamp(to_utc_timestamp(self.time)))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert annotation to dictionary for serialization.\n\n        This method creates a dictionary representation of the annotation\n        suitable for JSON serialization or frontend consumption.\n\n        Time conversion happens here (not cached) to allow users to modify\n        time values after construction.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing all annotation properties\n                in a format suitable for the frontend component.\n        \"\"\"\n        # Convert time fresh during serialization\n        return {\n            ColumnNames.TIME: to_utc_timestamp(self.time),\n            \"price\": self.price,\n            \"text\": self.text,\n            \"type\": self.annotation_type.value,\n            \"position\": self.position.value,\n            \"color\": self.color,\n            \"background_color\": self.background_color,\n            \"font_size\": self.font_size,\n            \"font_weight\": self.font_weight,\n            \"text_color\": self.text_color,\n            \"border_color\": self.border_color,\n            \"border_width\": self.border_width,\n            \"opacity\": self.opacity,\n            \"show_time\": self.show_time,\n            \"tooltip\": self.tooltip,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: int\n</code></pre> <p>Get time as UTC timestamp (converted fresh).</p> <p>Converts the time value to UTC timestamp each time it's accessed. This allows the time to be modified after construction.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UTC timestamp as integer (seconds).</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.datetime_value","title":"datetime_value  <code>property</code>","text":"<pre><code>datetime_value: Timestamp\n</code></pre> <p>Get time as pandas Timestamp.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: Pandas Timestamp object representing the annotation time.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert annotation to dictionary for serialization.</p> <p>This method creates a dictionary representation of the annotation suitable for JSON serialization or frontend consumption.</p> <p>Time conversion happens here (not cached) to allow users to modify time values after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing all annotation properties in a format suitable for the frontend component.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert annotation to dictionary for serialization.\n\n    This method creates a dictionary representation of the annotation\n    suitable for JSON serialization or frontend consumption.\n\n    Time conversion happens here (not cached) to allow users to modify\n    time values after construction.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing all annotation properties\n            in a format suitable for the frontend component.\n    \"\"\"\n    # Convert time fresh during serialization\n    return {\n        ColumnNames.TIME: to_utc_timestamp(self.time),\n        \"price\": self.price,\n        \"text\": self.text,\n        \"type\": self.annotation_type.value,\n        \"position\": self.position.value,\n        \"color\": self.color,\n        \"background_color\": self.background_color,\n        \"font_size\": self.font_size,\n        \"font_weight\": self.font_weight,\n        \"text_color\": self.text_color,\n        \"border_color\": self.border_color,\n        \"border_width\": self.border_width,\n        \"opacity\": self.opacity,\n        \"show_time\": self.show_time,\n        \"tooltip\": self.tooltip,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer","title":"AnnotationLayer  <code>dataclass</code>","text":"<p>Manages a layer of annotations for a chart.</p> <p>This class provides functionality for grouping related annotations together and applying bulk operations to them. Layers can be shown, hidden, or have their opacity adjusted as a group.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this layer</p> <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects in this layer</p> <code>visible</code> <code>bool</code> <p>Whether this layer is currently visible</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the layer (0.0 to 1.0)</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>@dataclass\nclass AnnotationLayer:\n    \"\"\"Manages a layer of annotations for a chart.\n\n    This class provides functionality for grouping related annotations\n    together and applying bulk operations to them. Layers can be shown,\n    hidden, or have their opacity adjusted as a group.\n\n    Attributes:\n        name: Unique name identifier for this layer\n        annotations: List of annotation objects in this layer\n        visible: Whether this layer is currently visible\n        opacity: Overall opacity of the layer (0.0 to 1.0)\n    \"\"\"\n\n    name: str\n    annotations: List[Annotation]\n    visible: bool = True\n    opacity: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate annotation layer after initialization.\n\n        Raises:\n            ValueError: If layer name is empty or opacity is invalid.\n        \"\"\"\n        if not self.name:\n            raise ValueValidationError.required_field(\"layer name\")\n\n        if not 0 &lt;= self.opacity &lt;= 1:\n            raise ValueValidationError(\n                \"opacity\",\n                f\"must be between 0.0 and 1.0, got {self.opacity}\",\n            )\n\n    def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n        \"\"\"Add annotation to layer.\n\n        Adds a single annotation to this layer and returns self for\n        method chaining.\n\n        Args:\n            annotation: Annotation object to add to the layer.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.add_annotation(text_annotation)\n            ```\n        \"\"\"\n        self.annotations.append(annotation)\n        return self\n\n    def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n        \"\"\"Remove annotation by index.\n\n        Removes an annotation from the layer by its index position\n        and returns self for method chaining.\n\n        Args:\n            index: Index of the annotation to remove.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.remove_annotation(0)  # Remove first annotation\n            ```\n        \"\"\"\n        if 0 &lt;= index &lt; len(self.annotations):\n            self.annotations.pop(index)\n        return self\n\n    def clear_annotations(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Clear all annotations from layer.\n\n        Removes all annotations from this layer and returns self\n        for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.clear_annotations()\n            ```\n        \"\"\"\n        self.annotations.clear()\n        return self\n\n    def hide(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Hide the layer.\n\n        Makes this layer and all its annotations invisible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.hide()\n            ```\n        \"\"\"\n        self.visible = False\n        return self\n\n    def show(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Show the layer.\n\n        Makes this layer and all its annotations visible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.show()\n            ```\n        \"\"\"\n        self.visible = True\n        return self\n\n    def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n        \"\"\"Set layer opacity.\n\n        Sets the overall opacity of this layer and returns self\n        for method chaining.\n\n        Args:\n            opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n\n        Example:\n            ```python\n            layer.set_opacity(0.5)  # 50% opacity\n            ```\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n        return self\n\n    def filter_by_time_range(\n        self,\n        start_time: Union[pd.Timestamp, datetime, str, int, float],\n        end_time: Union[pd.Timestamp, datetime, str, int, float],\n    ) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by time range.\n\n        Returns a list of annotations that fall within the specified\n        time range.\n\n        Args:\n            start_time: Start of the time range in various formats.\n            end_time: End of the time range in various formats.\n\n        Returns:\n            List[Annotation]: List of annotations within the time range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n            ```\n        \"\"\"\n        start_ts = to_utc_timestamp(start_time)\n        end_ts = to_utc_timestamp(end_time)\n\n        return [\n            annotation\n            for annotation in self.annotations\n            if start_ts &lt;= annotation.timestamp &lt;= end_ts\n        ]\n\n    def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by price range.\n\n        Returns a list of annotations that fall within the specified\n        price range.\n\n        Args:\n            min_price: Minimum price value.\n            max_price: Maximum price value.\n\n        Returns:\n            List[Annotation]: List of annotations within the price range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_price_range(100.0, 200.0)\n            ```\n        \"\"\"\n        return [\n            annotation\n            for annotation in self.annotations\n            if min_price &lt;= annotation.price &lt;= max_price\n        ]\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert layer to dictionary for serialization.\n\n        Creates a dictionary representation of the layer including\n        its properties and all contained annotations.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the layer.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"visible\": self.visible,\n            \"opacity\": self.opacity,\n            \"annotations\": [annotation.asdict() for annotation in self.annotations],\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation) -&gt; AnnotationLayer\n</code></pre> <p>Add annotation to layer.</p> <p>Adds a single annotation to this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.add_annotation(text_annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n    \"\"\"Add annotation to layer.\n\n    Adds a single annotation to this layer and returns self for\n    method chaining.\n\n    Args:\n        annotation: Annotation object to add to the layer.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.add_annotation(text_annotation)\n        ```\n    \"\"\"\n    self.annotations.append(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(index: int) -&gt; AnnotationLayer\n</code></pre> <p>Remove annotation by index.</p> <p>Removes an annotation from the layer by its index position and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the annotation to remove.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.remove_annotation(0)  # Remove first annotation\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n    \"\"\"Remove annotation by index.\n\n    Removes an annotation from the layer by its index position\n    and returns self for method chaining.\n\n    Args:\n        index: Index of the annotation to remove.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.remove_annotation(0)  # Remove first annotation\n        ```\n    \"\"\"\n    if 0 &lt;= index &lt; len(self.annotations):\n        self.annotations.pop(index)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations() -&gt; AnnotationLayer\n</code></pre> <p>Clear all annotations from layer.</p> <p>Removes all annotations from this layer and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.clear_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_annotations(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Clear all annotations from layer.\n\n    Removes all annotations from this layer and returns self\n    for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.clear_annotations()\n        ```\n    \"\"\"\n    self.annotations.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.hide","title":"hide","text":"<pre><code>hide() -&gt; AnnotationLayer\n</code></pre> <p>Hide the layer.</p> <p>Makes this layer and all its annotations invisible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.hide()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Hide the layer.\n\n    Makes this layer and all its annotations invisible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.hide()\n        ```\n    \"\"\"\n    self.visible = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.show","title":"show","text":"<pre><code>show() -&gt; AnnotationLayer\n</code></pre> <p>Show the layer.</p> <p>Makes this layer and all its annotations visible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.show()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Show the layer.\n\n    Makes this layer and all its annotations visible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.show()\n        ```\n    \"\"\"\n    self.visible = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.set_opacity","title":"set_opacity","text":"<pre><code>set_opacity(opacity: float) -&gt; AnnotationLayer\n</code></pre> <p>Set layer opacity.</p> <p>Sets the overall opacity of this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0.0 (transparent) and 1.0 (opaque).</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opacity is not between 0 and 1.</p> Example <pre><code>layer.set_opacity(0.5)  # 50% opacity\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n    \"\"\"Set layer opacity.\n\n    Sets the overall opacity of this layer and returns self\n    for method chaining.\n\n    Args:\n        opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Raises:\n        ValueError: If opacity is not between 0 and 1.\n\n    Example:\n        ```python\n        layer.set_opacity(0.5)  # 50% opacity\n        ```\n    \"\"\"\n    if not 0 &lt;= opacity &lt;= 1:\n        raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n    self.opacity = opacity\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.filter_by_time_range","title":"filter_by_time_range","text":"<pre><code>filter_by_time_range(start_time: Union[Timestamp, datetime, str, int, float], end_time: Union[Timestamp, datetime, str, int, float]) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by time range.</p> <p>Returns a list of annotations that fall within the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Start of the time range in various formats.</p> required <code>end_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>End of the time range in various formats.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the time range.</p> Example <pre><code>annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_time_range(\n    self,\n    start_time: Union[pd.Timestamp, datetime, str, int, float],\n    end_time: Union[pd.Timestamp, datetime, str, int, float],\n) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by time range.\n\n    Returns a list of annotations that fall within the specified\n    time range.\n\n    Args:\n        start_time: Start of the time range in various formats.\n        end_time: End of the time range in various formats.\n\n    Returns:\n        List[Annotation]: List of annotations within the time range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n        ```\n    \"\"\"\n    start_ts = to_utc_timestamp(start_time)\n    end_ts = to_utc_timestamp(end_time)\n\n    return [\n        annotation\n        for annotation in self.annotations\n        if start_ts &lt;= annotation.timestamp &lt;= end_ts\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.filter_by_price_range","title":"filter_by_price_range","text":"<pre><code>filter_by_price_range(min_price: float, max_price: float) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by price range.</p> <p>Returns a list of annotations that fall within the specified price range.</p> <p>Parameters:</p> Name Type Description Default <code>min_price</code> <code>float</code> <p>Minimum price value.</p> required <code>max_price</code> <code>float</code> <p>Maximum price value.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the price range.</p> Example <pre><code>annotations = layer.filter_by_price_range(100.0, 200.0)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by price range.\n\n    Returns a list of annotations that fall within the specified\n    price range.\n\n    Args:\n        min_price: Minimum price value.\n        max_price: Maximum price value.\n\n    Returns:\n        List[Annotation]: List of annotations within the price range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_price_range(100.0, 200.0)\n        ```\n    \"\"\"\n    return [\n        annotation\n        for annotation in self.annotations\n        if min_price &lt;= annotation.price &lt;= max_price\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert layer to dictionary for serialization.</p> <p>Creates a dictionary representation of the layer including its properties and all contained annotations.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the layer.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert layer to dictionary for serialization.\n\n    Creates a dictionary representation of the layer including\n    its properties and all contained annotations.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the layer.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"visible\": self.visible,\n        \"opacity\": self.opacity,\n        \"annotations\": [annotation.asdict() for annotation in self.annotations],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager","title":"AnnotationManager","text":"<p>Manages multiple annotation layers for a chart.</p> <p>This class provides a centralized way to manage multiple annotation layers, allowing for organization of annotations into logical groups. It supports creating, removing, and manipulating layers, as well as bulk operations across all layers.</p> <p>The AnnotationManager supports method chaining for fluent API usage and provides comprehensive layer management capabilities.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>Dict[str, AnnotationLayer]</code> <p>Dictionary mapping layer names to AnnotationLayer objects</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class AnnotationManager:\n    \"\"\"Manages multiple annotation layers for a chart.\n\n    This class provides a centralized way to manage multiple annotation\n    layers, allowing for organization of annotations into logical groups.\n    It supports creating, removing, and manipulating layers, as well as\n    bulk operations across all layers.\n\n    The AnnotationManager supports method chaining for fluent API usage\n    and provides comprehensive layer management capabilities.\n\n    Attributes:\n        layers: Dictionary mapping layer names to AnnotationLayer objects\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the annotation manager.\n\n        Creates a new AnnotationManager with an empty layers dictionary.\n        \"\"\"\n        self.layers: Dict[str, AnnotationLayer] = {}\n\n    def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new empty annotation layer with the specified name.\n        If a layer with that name already exists, returns self for method chaining.\n\n        Args:\n            name: Name for the new layer.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.create_layer(\"technical_analysis\")\n            ```\n        \"\"\"\n        if name not in self.layers:\n            layer = AnnotationLayer(name=name, annotations=[])\n            self.layers[name] = layer\n        return self\n\n    def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n        \"\"\"Get an annotation layer by name.\n\n        Args:\n            name: Name of the layer to retrieve.\n\n        Returns:\n            Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n        Example:\n            ```python\n            layer = manager.get_layer(\"events\")\n            if layer:\n                layer.add_annotation(annotation)\n            ```\n        \"\"\"\n        return self.layers.get(name)\n\n    def remove_layer(self, name: str) -&gt; bool:\n        \"\"\"Remove an annotation layer by name.\n\n        Removes the specified layer and all its annotations. Returns\n        True if the layer was found and removed, False otherwise.\n\n        Args:\n            name: Name of the layer to remove.\n\n        Returns:\n            bool: True if layer was removed, False if layer didn't exist.\n\n        Example:\n            ```python\n            success = manager.remove_layer(\"old_layer\")\n            if success:\n                logger.info(\"Layer removed successfully\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            del self.layers[name]\n            return True\n        return False\n\n    def clear_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotation layers.\n\n        Removes all layers and their annotations. Returns self for\n        method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_all_layers()\n            ```\n        \"\"\"\n        self.layers.clear()\n        return self\n\n    def add_annotation(\n        self,\n        annotation: Annotation,\n        layer_name: str = \"default\",\n    ) -&gt; \"AnnotationManager\":\n        \"\"\"Add annotation to a specific layer.\n\n        Adds an annotation to the specified layer. If the layer doesn't exist,\n        it will be created automatically. Returns self for method chaining.\n\n        Args:\n            annotation: Annotation object to add.\n            layer_name: Name of the layer to add the annotation to.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.add_annotation(text_annotation, \"events\")\n            ```\n        \"\"\"\n        if layer_name not in self.layers:\n            self.create_layer(layer_name)\n\n        self.layers[layer_name].add_annotation(annotation)\n        return self\n\n    def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Hide a specific annotation layer.\n\n        Makes the specified layer and all its annotations invisible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to hide.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].hide()\n        return self\n\n    def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Show a specific annotation layer.\n\n        Makes the specified layer and all its annotations visible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to show.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].show()\n        return self\n\n    def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotations from a specific layer.\n\n        Removes all annotations from the specified layer while keeping\n        the layer itself. Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to clear.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].clear_annotations()\n        return self\n\n    def get_all_annotations(self) -&gt; List[Annotation]:\n        \"\"\"Get all annotations from all layers.\n\n        Returns a flat list of all annotations from all layers,\n        regardless of layer visibility.\n\n        Returns:\n            List[Annotation]: List of all annotations across all layers.\n\n        Example:\n            ```python\n            all_annotations = manager.get_all_annotations()\n            ```\n        \"\"\"\n        all_annotations = []\n        for layer in self.layers.values():\n            all_annotations.extend(layer.annotations)\n        return all_annotations\n\n    def hide_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Hide all annotation layers.\n\n        Makes all layers and their annotations invisible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.hide()\n        return self\n\n    def show_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Show all annotation layers.\n\n        Makes all layers and their annotations visible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.show()\n        return self\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert manager to dictionary for serialization.\n\n        Creates a dictionary representation of all layers and their\n        annotations suitable for serialization.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of all layers with\n                a \"layers\" wrapper containing layer names as keys.\n        \"\"\"\n        return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.create_layer","title":"create_layer","text":"<pre><code>create_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new empty annotation layer with the specified name. If a layer with that name already exists, returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.create_layer(\"technical_analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new empty annotation layer with the specified name.\n    If a layer with that name already exists, returns self for method chaining.\n\n    Args:\n        name: Name for the new layer.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.create_layer(\"technical_analysis\")\n        ```\n    \"\"\"\n    if name not in self.layers:\n        layer = AnnotationLayer(name=name, annotations=[])\n        self.layers[name] = layer\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str) -&gt; Optional[AnnotationLayer]\n</code></pre> <p>Get an annotation layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[AnnotationLayer]</code> <p>Optional[AnnotationLayer]: The layer if found, None otherwise.</p> Example <pre><code>layer = manager.get_layer(\"events\")\nif layer:\n    layer.add_annotation(annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n    \"\"\"Get an annotation layer by name.\n\n    Args:\n        name: Name of the layer to retrieve.\n\n    Returns:\n        Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n    Example:\n        ```python\n        layer = manager.get_layer(\"events\")\n        if layer:\n            layer.add_annotation(annotation)\n        ```\n    \"\"\"\n    return self.layers.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.remove_layer","title":"remove_layer","text":"<pre><code>remove_layer(name: str) -&gt; bool\n</code></pre> <p>Remove an annotation layer by name.</p> <p>Removes the specified layer and all its annotations. Returns True if the layer was found and removed, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if layer was removed, False if layer didn't exist.</p> Example <pre><code>success = manager.remove_layer(\"old_layer\")\nif success:\n    logger.info(\"Layer removed successfully\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_layer(self, name: str) -&gt; bool:\n    \"\"\"Remove an annotation layer by name.\n\n    Removes the specified layer and all its annotations. Returns\n    True if the layer was found and removed, False otherwise.\n\n    Args:\n        name: Name of the layer to remove.\n\n    Returns:\n        bool: True if layer was removed, False if layer didn't exist.\n\n    Example:\n        ```python\n        success = manager.remove_layer(\"old_layer\")\n        if success:\n            logger.info(\"Layer removed successfully\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        del self.layers[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.clear_all_layers","title":"clear_all_layers","text":"<pre><code>clear_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Clear all annotation layers.</p> <p>Removes all layers and their annotations. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotation layers.\n\n    Removes all layers and their annotations. Returns self for\n    method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_all_layers()\n        ```\n    \"\"\"\n    self.layers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation, layer_name: str = 'default') -&gt; AnnotationManager\n</code></pre> <p>Add annotation to a specific layer.</p> <p>Adds an annotation to the specified layer. If the layer doesn't exist, it will be created automatically. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer to add the annotation to.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.add_annotation(text_annotation, \"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(\n    self,\n    annotation: Annotation,\n    layer_name: str = \"default\",\n) -&gt; \"AnnotationManager\":\n    \"\"\"Add annotation to a specific layer.\n\n    Adds an annotation to the specified layer. If the layer doesn't exist,\n    it will be created automatically. Returns self for method chaining.\n\n    Args:\n        annotation: Annotation object to add.\n        layer_name: Name of the layer to add the annotation to.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.add_annotation(text_annotation, \"events\")\n        ```\n    \"\"\"\n    if layer_name not in self.layers:\n        self.create_layer(layer_name)\n\n    self.layers[layer_name].add_annotation(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.hide_layer","title":"hide_layer","text":"<pre><code>hide_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Hide a specific annotation layer.</p> <p>Makes the specified layer and all its annotations invisible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to hide.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Hide a specific annotation layer.\n\n    Makes the specified layer and all its annotations invisible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to hide.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.show_layer","title":"show_layer","text":"<pre><code>show_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Show a specific annotation layer.</p> <p>Makes the specified layer and all its annotations visible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to show.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Show a specific annotation layer.\n\n    Makes the specified layer and all its annotations visible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to show.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.clear_layer","title":"clear_layer","text":"<pre><code>clear_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Clear all annotations from a specific layer.</p> <p>Removes all annotations from the specified layer while keeping the layer itself. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to clear.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotations from a specific layer.\n\n    Removes all annotations from the specified layer while keeping\n    the layer itself. Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to clear.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].clear_annotations()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.get_all_annotations","title":"get_all_annotations","text":"<pre><code>get_all_annotations() -&gt; List[Annotation]\n</code></pre> <p>Get all annotations from all layers.</p> <p>Returns a flat list of all annotations from all layers, regardless of layer visibility.</p> <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of all annotations across all layers.</p> Example <pre><code>all_annotations = manager.get_all_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_all_annotations(self) -&gt; List[Annotation]:\n    \"\"\"Get all annotations from all layers.\n\n    Returns a flat list of all annotations from all layers,\n    regardless of layer visibility.\n\n    Returns:\n        List[Annotation]: List of all annotations across all layers.\n\n    Example:\n        ```python\n        all_annotations = manager.get_all_annotations()\n        ```\n    \"\"\"\n    all_annotations = []\n    for layer in self.layers.values():\n        all_annotations.extend(layer.annotations)\n    return all_annotations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.hide_all_layers","title":"hide_all_layers","text":"<pre><code>hide_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Hide all annotation layers.</p> <p>Makes all layers and their annotations invisible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Hide all annotation layers.\n\n    Makes all layers and their annotations invisible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.show_all_layers","title":"show_all_layers","text":"<pre><code>show_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Show all annotation layers.</p> <p>Makes all layers and their annotations visible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Show all annotation layers.\n\n    Makes all layers and their annotations visible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert manager to dictionary for serialization.</p> <p>Creates a dictionary representation of all layers and their annotations suitable for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of all layers with a \"layers\" wrapper containing layer names as keys.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert manager to dictionary for serialization.\n\n    Creates a dictionary representation of all layers and their\n    annotations suitable for serialization.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of all layers with\n            a \"layers\" wrapper containing layer names as keys.\n    \"\"\"\n    return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_text_annotation","title":"create_text_annotation","text":"<pre><code>create_text_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a text annotation.</p> <p>Convenience function for creating text annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display.</p> required <code>**kwargs</code> <p>Additional styling options (color, background_color, font_size, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured text annotation.</p> Example <pre><code># Basic text annotation\nann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n# With custom styling\nann = create_text_annotation(\n    \"2024-01-01\",\n    100,\n    \"Buy Signal\",\n    color=\"green\",\n    background_color=\"rgba(0, 255, 0, 0.2)\",\n    font_size=14,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_text_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a text annotation.\n\n    Convenience function for creating text annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display.\n        **kwargs: Additional styling options (color, background_color,\n            font_size, position, etc.).\n\n    Returns:\n        Annotation: Configured text annotation.\n\n    Example:\n        ```python\n        # Basic text annotation\n        ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n        # With custom styling\n        ann = create_text_annotation(\n            \"2024-01-01\",\n            100,\n            \"Buy Signal\",\n            color=\"green\",\n            background_color=\"rgba(0, 255, 0, 0.2)\",\n            font_size=14,\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.TEXT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_arrow_annotation","title":"create_arrow_annotation","text":"<pre><code>create_arrow_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create an arrow annotation.</p> <p>Convenience function for creating arrow annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the arrow.</p> required <code>**kwargs</code> <p>Additional styling options (color, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured arrow annotation.</p> Example <pre><code># Basic arrow annotation\nann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n# With custom styling\nann = create_arrow_annotation(\n    \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_arrow_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create an arrow annotation.\n\n    Convenience function for creating arrow annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the arrow.\n        **kwargs: Additional styling options (color, position, etc.).\n\n    Returns:\n        Annotation: Configured arrow annotation.\n\n    Example:\n        ```python\n        # Basic arrow annotation\n        ann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n        # With custom styling\n        ann = create_arrow_annotation(\n            \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.ARROW,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_shape_annotation","title":"create_shape_annotation","text":"<pre><code>create_shape_annotation(time: Union[Timestamp, datetime, str, int, float], price: float, text: str, **kwargs) -&gt; Annotation\n</code></pre> <p>Create a shape annotation.</p> <p>Convenience function for creating shape annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the shape.</p> required <code>**kwargs</code> <p>Additional styling options (color, border_color, border_width, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured shape annotation.</p> Example <pre><code># Basic shape annotation\nann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n# With custom styling\nann = create_shape_annotation(\n    \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_shape_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a shape annotation.\n\n    Convenience function for creating shape annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the shape.\n        **kwargs: Additional styling options (color, border_color,\n            border_width, etc.).\n\n    Returns:\n        Annotation: Configured shape annotation.\n\n    Example:\n        ```python\n        # Basic shape annotation\n        ann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n        # With custom styling\n        ann = create_shape_annotation(\n            \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.SHAPE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html","title":"streamlit_lightweight_charts_pro.data.area_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data","title":"area_data","text":"<p>Area data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for area chart data points with optional color styling capabilities. The AreaData class extends SingleValueData with area-specific color validation and serialization features.</p> The module includes <ul> <li>AreaData: Data class for area chart data points with color styling</li> <li>Color validation for line, top, and bottom colors</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color fields with validation (line, top, bottom colors)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data.AreaData","title":"AreaData  <code>dataclass</code>","text":"<p>Data class for area chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color fields for area chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding area-specific color features for enhanced visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>line_color</code> <code>Optional[str]</code> <p>Color for the area line in hex or rgba format. If not provided, the line_color field is not serialized.</p> <code>top_color</code> <code>Optional[str]</code> <p>Color for the top of the area fill in hex or rgba format. If not provided, the top_color field is not serialized.</p> <code>bottom_color</code> <code>Optional[str]</code> <p>Color for the bottom of the area fill in hex or rgba format. If not provided, the bottom_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/area_data.py</code> <pre><code>@dataclass\n@validated_field(\"line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_color\", str, validator=\"color\", allow_none=True)\nclass AreaData(SingleValueData):\n    \"\"\"Data class for area chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color fields for area chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding area-specific color features\n    for enhanced visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        line_color (Optional[str]): Color for the area line in hex or rgba format.\n            If not provided, the line_color field is not serialized.\n        top_color (Optional[str]): Color for the top of the area fill in hex or rgba format.\n            If not provided, the top_color field is not serialized.\n        bottom_color (Optional[str]): Color for the bottom of the area fill in hex or rgba format.\n            If not provided, the bottom_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data point with colors\n        data = AreaData(\n            time=\"2024-01-01T00:00:00\",\n            value=100.0,\n            line_color=\"#2196F3\",\n            top_color=\"rgba(33,150,243,0.3)\",\n            bottom_color=\"rgba(33,150,243,0.1)\",\n        )\n\n        # Create area data point without colors\n        data = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - area-specific color fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"line_color\", \"top_color\", \"bottom_color\"}\n\n    # Optional color field for the area line\n    line_color: Optional[str] = None\n    # Optional color field for the top of the area fill\n    top_color: Optional[str] = None\n    # Optional color field for the bottom of the area fill\n    bottom_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to strip whitespace from color values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Strips whitespace from color strings if provided\n        3. Sets empty/whitespace-only values to None to avoid serialization\n\n        Color validation is handled by @validated_field decorators.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Strip whitespace from color strings and clean up empty values\n        for color_attr in [\"line_color\", \"top_color\", \"bottom_color\"]:\n            color_value = getattr(self, color_attr)\n            if color_value is not None:\n                # Strip whitespace\n                stripped_value = color_value.strip()\n                # Set to None if empty after stripping to avoid serialization\n                setattr(self, color_attr, stripped_value if stripped_value else None)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html","title":"streamlit_lightweight_charts_pro.data.band","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band","title":"band","text":"<p>Band data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for band data points used in band charts such as Bollinger Bands and other envelope indicators.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band.BandData","title":"BandData  <code>dataclass</code>","text":"<p>Data point for band charts (e.g., Bollinger Bands).</p> <p>This class represents a band data point with upper, middle, and lower values, along with optional per-point color overrides. It's used for band charts that show multiple lines simultaneously, such as Bollinger Bands, Keltner Channels, or other envelope indicators.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>float</code> <p>The upper band value.</p> <code>middle</code> <code>float</code> <p>The middle band value (usually the main line).</p> <code>lower</code> <code>float</code> <p>The lower band value.</p> <code>upper_line_color</code> <code>Optional[str]</code> <p>Optional color override for upper line (hex or rgba format).</p> <code>middle_line_color</code> <code>Optional[str]</code> <p>Optional color override for middle line (hex or rgba format).</p> <code>lower_line_color</code> <code>Optional[str]</code> <p>Optional color override for lower line (hex or rgba format).</p> <code>upper_fill_color</code> <code>Optional[str]</code> <p>Optional color override for upper fill area (hex or rgba format).</p> <code>lower_fill_color</code> <code>Optional[str]</code> <p>Optional color override for lower fill area (hex or rgba format).</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BandData\n\n# Basic data point\ndata = BandData(time=\"2024-01-01\", upper=110, middle=105, lower=100)\n\n# Data point with custom per-point colors\ndata = BandData(\n    time=\"2024-01-01\",\n    upper=110,\n    middle=105,\n    lower=100,\n    upper_line_color=\"#ff0000\",\n    middle_line_color=\"#0000ff\",\n    lower_line_color=\"#00ff00\",\n    upper_fill_color=\"rgba(255,0,0,0.2)\",\n    lower_fill_color=\"rgba(0,255,0,0.2)\",\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/band.py</code> <pre><code>@dataclass\n@validated_field(\"upper_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"middle_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"upper_fill_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_fill_color\", str, validator=\"color\", allow_none=True)\nclass BandData(Data):\n    \"\"\"Data point for band charts (e.g., Bollinger Bands).\n\n    This class represents a band data point with upper, middle, and lower values,\n    along with optional per-point color overrides. It's used for band charts\n    that show multiple lines simultaneously, such as Bollinger Bands, Keltner\n    Channels, or other envelope indicators.\n\n    Attributes:\n        upper: The upper band value.\n        middle: The middle band value (usually the main line).\n        lower: The lower band value.\n        upper_line_color: Optional color override for upper line (hex or rgba format).\n        middle_line_color: Optional color override for middle line (hex or rgba format).\n        lower_line_color: Optional color override for lower line (hex or rgba format).\n        upper_fill_color: Optional color override for upper fill area (hex or rgba format).\n        lower_fill_color: Optional color override for lower fill area (hex or rgba format).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import BandData\n\n        # Basic data point\n        data = BandData(time=\"2024-01-01\", upper=110, middle=105, lower=100)\n\n        # Data point with custom per-point colors\n        data = BandData(\n            time=\"2024-01-01\",\n            upper=110,\n            middle=105,\n            lower=100,\n            upper_line_color=\"#ff0000\",\n            middle_line_color=\"#0000ff\",\n            lower_line_color=\"#00ff00\",\n            upper_fill_color=\"rgba(255,0,0,0.2)\",\n            lower_fill_color=\"rgba(0,255,0,0.2)\",\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"middle\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"upper_line_color\",\n        \"middle_line_color\",\n        \"lower_line_color\",\n        \"upper_fill_color\",\n        \"lower_fill_color\",\n    }\n\n    upper: float\n    middle: float\n    lower: float\n    upper_line_color: Optional[str] = None\n    middle_line_color: Optional[str] = None\n    lower_line_color: Optional[str] = None\n    upper_fill_color: Optional[str] = None\n    lower_fill_color: Optional[str] = None\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n        # Handle NaN in value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = 0.0\n        elif self.upper is None:\n            raise ValueValidationError(\"upper\", \"must not be None\")\n        if isinstance(self.middle, float) and math.isnan(self.middle):\n            self.middle = 0.0\n        elif self.middle is None:\n            raise ValueValidationError(\"middle\", \"must not be None\")\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = 0.0\n        elif self.lower is None:\n            raise ValueValidationError(\"lower\", \"must not be None\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html","title":"streamlit_lightweight_charts_pro.data.bar_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data","title":"bar_data","text":"<p>Bar chart data model for streamlit-lightweight-charts.</p> <p>This module provides the BarData class for representing individual bar chart data points with OHLC (Open, High, Low, Close) values and optional color customization.</p> <p>The BarData class extends OhlcData to provide bar-specific functionality while maintaining compatibility with the OHLC data structure used throughout the charting library.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BarData\n\n# Create a bar data point\nbar = BarData(\n    time=\"2024-01-01\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=103.0,\n    color=\"#4CAF50\",  # Optional: Green bar\n)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data.BarData","title":"BarData  <code>dataclass</code>","text":"<p>Data class for a single value (line/area/histogram) chart point.</p> <p>Inherits from SingleValueData and adds an optional color field.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point (hex or rgba).                    If not provided, not serialized.</p> <p>See also: SingleValueData</p> Note <ul> <li>Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/bar_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass BarData(OhlcData):\n    \"\"\"Data class for a single value (line/area/histogram) chart point.\n\n    Inherits from SingleValueData and adds an optional color field.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        color (Optional[str]): Color for this data point (hex or rgba).\n                               If not provided, not serialized.\n\n    See also: SingleValueData\n\n    Note:\n        - Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html","title":"streamlit_lightweight_charts_pro.data.baseline_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data","title":"baseline_data","text":"<p>Baseline data for streamlit-lightweight-charts.</p> <p>This module provides the BaselineData class for creating baseline chart data points that support both top and bottom area styling with individual color controls.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data.BaselineData","title":"BaselineData  <code>dataclass</code>","text":"<p>Data class for a baseline chart point.</p> <p>Inherits from SingleValueData and adds optional color properties for baseline series. Baseline series display data with both top and bottom areas, each with their own styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>top_fill_color1</code> <code>Optional[str]</code> <p>Optional top area top fill color (hex or rgba).</p> <code>top_fill_color2</code> <code>Optional[str]</code> <p>Optional top area bottom fill color (hex or rgba).</p> <code>top_line_color</code> <code>Optional[str]</code> <p>Optional top area line color (hex or rgba).</p> <code>bottom_fill_color1</code> <code>Optional[str]</code> <p>Optional bottom area top fill color (hex or rgba).</p> <code>bottom_fill_color2</code> <code>Optional[str]</code> <p>Optional bottom area bottom fill color (hex or rgba).</p> <code>bottom_line_color</code> <code>Optional[str]</code> <p>Optional bottom area line color (hex or rgba).</p> <p>See also: SingleValueData</p> Note <ul> <li>All color properties should be valid hex (e.g., #2196F3) or rgba strings   (e.g., rgba(33,150,243,1)).</li> </ul> <pre><code>- If color properties are not provided, colors from series options will be used.\n - Baseline series display data with both positive and negative areas relative\n   to a baseline value.\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/baseline_data.py</code> <pre><code>@dataclass\n@validated_field(\"top_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"top_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color1\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_fill_color2\", str, validator=\"color\", allow_none=True)\n@validated_field(\"bottom_line_color\", str, validator=\"color\", allow_none=True)\nclass BaselineData(SingleValueData):\n    \"\"\"Data class for a baseline chart point.\n\n    Inherits from SingleValueData and adds optional color properties for baseline series.\n    Baseline series display data with both top and bottom areas, each with their own\n    styling options.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        top_fill_color1 (Optional[str]): Optional top area top fill color (hex or rgba).\n        top_fill_color2 (Optional[str]): Optional top area bottom fill color (hex or rgba).\n        top_line_color (Optional[str]): Optional top area line color (hex or rgba).\n        bottom_fill_color1 (Optional[str]): Optional bottom area top fill color (hex or rgba).\n        bottom_fill_color2 (Optional[str]): Optional bottom area bottom fill color\n            (hex or rgba).\n        bottom_line_color (Optional[str]): Optional bottom area line color (hex or rgba).\n\n    See also: SingleValueData\n\n    Note:\n         - All color properties should be valid hex (e.g., #2196F3) or rgba strings\n           (e.g., rgba(33,150,243,1)).\n        - If color properties are not provided, colors from series options will be used.\n         - Baseline series display data with both positive and negative areas relative\n           to a baseline value.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"top_fill_color1\",\n        \"top_fill_color2\",\n        \"top_line_color\",\n        \"bottom_fill_color1\",\n        \"bottom_fill_color2\",\n        \"bottom_line_color\",\n    }\n\n    top_fill_color1: Optional[str] = None\n    top_fill_color2: Optional[str] = None\n    top_line_color: Optional[str] = None\n    bottom_fill_color1: Optional[str] = None\n    bottom_fill_color2: Optional[str] = None\n    bottom_line_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html","title":"streamlit_lightweight_charts_pro.data.candlestick_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data","title":"candlestick_data","text":"<p>Candlestick data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for candlestick chart data points with optional color styling capabilities. The CandlestickData class extends OhlcData with color validation and serialization features for candlestick visualization.</p> The module includes <ul> <li>CandlestickData: Data class for candlestick chart data points with color styling</li> <li>Color validation for candlestick body, border, and wick colors</li> <li>OHLC relationship validation and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>Optional color fields with validation (body, border, wick colors)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data.CandlestickData","title":"CandlestickData  <code>dataclass</code>","text":"<p>Data class for candlestick chart data points with optional color styling.</p> <p>This class extends OhlcData to add optional color fields for candlestick styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for candlestick visualization.</p> <p>The class automatically handles time normalization, OHLC validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>color</code> <code>Optional[str]</code> <p>Color for the candlestick body in hex or rgba format. If not provided, the color field is not serialized.</p> <code>border_color</code> <code>Optional[str]</code> <p>Border color for the candlestick in hex or rgba format. If not provided, the border_color field is not serialized.</p> <code>wick_color</code> <code>Optional[str]</code> <p>Wick color for the candlestick in hex or rgba format. If not provided, the wick_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Set containing color-related optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/candlestick_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"border_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"wick_color\", str, validator=\"color\", allow_none=True)\nclass CandlestickData(OhlcData):\n    \"\"\"Data class for candlestick chart data points with optional color styling.\n\n    This class extends OhlcData to add optional color fields for candlestick\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for candlestick visualization.\n\n    The class automatically handles time normalization, OHLC validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        color (Optional[str]): Color for the candlestick body in hex or rgba format.\n            If not provided, the color field is not serialized.\n        border_color (Optional[str]): Border color for the candlestick in hex or rgba format.\n            If not provided, the border_color field is not serialized.\n        wick_color (Optional[str]): Wick color for the candlestick in hex or rgba format.\n            If not provided, the wick_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Set containing color-related optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data point with colors\n        data = CandlestickData(\n            time=\"2024-01-01T00:00:00\",\n            open=100.0,\n            high=105.0,\n            low=98.0,\n            close=102.0,\n            color=\"#4CAF50\",  # Green body for bullish candle\n            border_color=\"#2E7D32\",\n            wick_color=\"#1B5E20\",\n        )\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color fields are optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\", \"border_color\", \"wick_color\"}\n\n    # Optional color field for the candlestick body\n    color: Optional[str] = None\n    # Optional color field for the candlestick border\n    border_color: Optional[str] = None\n    # Optional color field for the candlestick wick\n    wick_color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html","title":"streamlit_lightweight_charts_pro.data.data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data","title":"data","text":"<p>Data classes and utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides the base data class and utility functions for time format conversion used throughout the library for representing financial data points. The Data class serves as the foundation for all chart data structures, providing standardized serialization and time normalization capabilities.</p> The module includes <ul> <li>Data: Abstract base class for all chart data points</li> <li>classproperty: Descriptor for creating class-level properties</li> <li>Column management utilities for DataFrame conversion</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>CamelCase serialization for frontend communication</li> <li>NaN handling and NumPy type conversion</li> <li>Column management for DataFrame operations</li> <li>Enum value extraction for serialization</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import Data\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass MyData(Data):\n    value: float\n\n\n# Create data point with automatic time normalization\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize to frontend format\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.classproperty","title":"classproperty","text":"<p>Descriptor to create class-level properties.</p> <p>This class provides a way to define properties that work at the class level rather than the instance level. It's used for accessing class attributes that may be computed or inherited from parent classes.</p> <p>This pattern is correct, but pylint may not recognize it and will warn about missing 'self'.</p> Example <pre><code>class MyClass:\n    @classproperty\n    def required_columns(cls):\n        return {\"time\", \"value\"}\n\n\n# Usage\ncolumns = MyClass.required_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>class classproperty(property):  # noqa: N801\n    \"\"\"Descriptor to create class-level properties.\n\n    This class provides a way to define properties that work at the class level\n    rather than the instance level. It's used for accessing class attributes\n    that may be computed or inherited from parent classes.\n\n    This pattern is correct, but pylint may not recognize it and will warn about missing 'self'.\n\n    Example:\n        ```python\n        class MyClass:\n            @classproperty\n            def required_columns(cls):\n                return {\"time\", \"value\"}\n\n\n        # Usage\n        columns = MyClass.required_columns\n        ```\n    \"\"\"\n\n    def __get__(self, obj, cls):\n        \"\"\"Get the class property value.\n\n        Args:\n            obj: The instance (unused for class properties).\n            cls: The class object.\n\n        Returns:\n            The computed class property value.\n        \"\"\"\n        return self.fget(cls)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data","title":"Data  <code>dataclass</code>","text":"<p>Abstract base class for chart data points.</p> <p>All chart data classes should inherit from Data. This class provides the foundation for all data structures in the library, handling time normalization, serialization, and column management for DataFrame operations.</p> <p>Time normalization happens during serialization (asdict()) rather than at construction, allowing users to modify time values after creating data objects. This provides flexibility while ensuring all serialized data uses consistent UTC timestamps.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time value in various formats. Converted to UTC timestamp during serialization.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion. OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.</p> See also <p>LineData: Single value data points for line charts. OhlcData: OHLC data points for candlestick charts. OhlcvData: OHLCV data points with volume information.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.data import Data\n\n\n@dataclass\nclass MyData(Data):\n    value: float\n\n\n# Create data point\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Can modify time after construction\ndata.time = \"2024-01-02T00:00:00\"\n\n# Serialize for frontend (time normalized here)\nserialized = data.asdict()  # {'time': &lt;normalized_timestamp&gt;, 'value': 100.0}\n</code></pre> Note <ul> <li>All imports must be at the top of the file unless justified.</li> <li>Use specific exceptions and lazy string formatting for logging.</li> <li>Time values are normalized to UTC timestamps during serialization.</li> <li>NaN values are converted to 0.0 for frontend compatibility.</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@dataclass\nclass Data(SerializableMixin, ABC):\n    \"\"\"Abstract base class for chart data points.\n\n    All chart data classes should inherit from Data. This class provides the foundation\n    for all data structures in the library, handling time normalization, serialization,\n    and column management for DataFrame operations.\n\n    Time normalization happens during serialization (asdict()) rather than at construction,\n    allowing users to modify time values after creating data objects. This provides\n    flexibility while ensuring all serialized data uses consistent UTC timestamps.\n\n    Attributes:\n        time (Union[pd.Timestamp, datetime, str, int, float]): Time value in various\n            formats. Converted to UTC timestamp during serialization.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion.\n        OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.\n\n    See also:\n        LineData: Single value data points for line charts.\n        OhlcData: OHLC data points for candlestick charts.\n        OhlcvData: OHLCV data points with volume information.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.data import Data\n\n\n        @dataclass\n        class MyData(Data):\n            value: float\n\n\n        # Create data point\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Can modify time after construction\n        data.time = \"2024-01-02T00:00:00\"\n\n        # Serialize for frontend (time normalized here)\n        serialized = data.asdict()  # {'time': &lt;normalized_timestamp&gt;, 'value': 100.0}\n        ```\n\n    Note:\n        - All imports must be at the top of the file unless justified.\n        - Use specific exceptions and lazy string formatting for logging.\n        - Time values are normalized to UTC timestamps during serialization.\n        - NaN values are converted to 0.0 for frontend compatibility.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"time\"}  # Required columns for DataFrame conversion\n    OPTIONAL_COLUMNS: ClassVar[set] = set()  # Optional columns for DataFrame conversion\n\n    time: Any  # Accept any time format, normalize in asdict()\n\n    @classproperty\n    def required_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all required columns\n        defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All required columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n            class ChildData(ParentData):\n                REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n            # Returns {\"time\", \"value\", \"volume\"}\n            columns = ChildData.required_columns\n            ```\n        \"\"\"\n        required = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"REQUIRED_COLUMNS\"):\n                required |= base.REQUIRED_COLUMNS\n        return required\n\n    @classproperty\n    def optional_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all optional columns\n        defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All optional columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                OPTIONAL_COLUMNS = {\"color\"}\n\n\n            class ChildData(ParentData):\n                OPTIONAL_COLUMNS = {\"size\"}\n\n\n            # Returns {\"color\", \"size\"}\n            columns = ChildData.optional_columns\n            ```\n        \"\"\"\n        optional = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"OPTIONAL_COLUMNS\"):\n                optional |= base.OPTIONAL_COLUMNS\n        return optional\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing.\n\n        This method is automatically called after the dataclass is initialized.\n        Time normalization is intentionally NOT done here to allow users to\n        modify time values after construction. Normalization happens during\n        serialization in asdict().\n\n        Subclasses can override this method to add validation or processing.\n        \"\"\"\n        # Time normalization happens in asdict() to allow post-construction modification\n        # Subclasses may override this for additional processing\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n        Converts the data point to a dictionary format suitable for frontend\n        communication. This method handles various data type conversions and\n        ensures proper formatting for JavaScript consumption.\n\n        Time normalization happens here (not in __post_init__) to allow users\n        to modify time values after construction and have changes reflected\n        in serialization.\n\n        The method performs the following transformations:\n        - Normalizes time values to UNIX timestamps (fresh conversion each call)\n        - Converts field names from snake_case to camelCase\n        - Converts NaN values to 0.0 for frontend compatibility\n        - Converts NumPy scalar types to Python native types\n        - Extracts enum values using their .value property\n        - Skips None values and empty strings\n\n        Returns:\n            Dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            @dataclass\n            class MyData(Data):\n                value: float\n                color: str = \"red\"\n\n\n            data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n            result = data.asdict()\n            # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n            # Can modify time after construction\n            data.time = \"2024-01-02T00:00:00\"\n            result2 = data.asdict()\n            # Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n            ```\n\n        Note:\n            - Time is normalized fresh each call (no caching)\n            - NaN values are converted to 0.0\n            - NumPy scalar types are converted to Python native types\n            - Enum values are extracted using their .value property\n            - Time column uses standardized ColumnNames.TIME.value\n        \"\"\"\n        # Normalize time during serialization (not cached in __post_init__)\n        normalized_time = normalize_time(self.time)\n\n        # Use the inherited serialization from SerializableMixin\n        result = dict(self._serialize_to_dict())\n\n        # Override the time field with normalized value\n        result[ColumnNames.TIME.value] = normalized_time\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.required_columns","title":"required_columns","text":"<pre><code>required_columns()\n</code></pre> <p>Return the union of all REQUIRED_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all required columns defined in REQUIRED_COLUMNS class attributes. It ensures that all required columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All required columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\nclass ChildData(ParentData):\n    REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n# Returns {\"time\", \"value\", \"volume\"}\ncolumns = ChildData.required_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef required_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all required columns\n    defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All required columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n        class ChildData(ParentData):\n            REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n        # Returns {\"time\", \"value\", \"volume\"}\n        columns = ChildData.required_columns\n        ```\n    \"\"\"\n    required = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"REQUIRED_COLUMNS\"):\n            required |= base.REQUIRED_COLUMNS\n    return required\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.optional_columns","title":"optional_columns","text":"<pre><code>optional_columns()\n</code></pre> <p>Return the union of all OPTIONAL_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all optional columns defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All optional columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    OPTIONAL_COLUMNS = {\"color\"}\n\n\nclass ChildData(ParentData):\n    OPTIONAL_COLUMNS = {\"size\"}\n\n\n# Returns {\"color\", \"size\"}\ncolumns = ChildData.optional_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef optional_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all optional columns\n    defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All optional columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            OPTIONAL_COLUMNS = {\"color\"}\n\n\n        class ChildData(ParentData):\n            OPTIONAL_COLUMNS = {\"size\"}\n\n\n        # Returns {\"color\", \"size\"}\n        columns = ChildData.optional_columns\n        ```\n    \"\"\"\n    optional = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"OPTIONAL_COLUMNS\"):\n            optional |= base.OPTIONAL_COLUMNS\n    return optional\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the data class to a dict with camelCase keys for frontend.</p> <p>Converts the data point to a dictionary format suitable for frontend communication. This method handles various data type conversions and ensures proper formatting for JavaScript consumption.</p> <p>Time normalization happens here (not in post_init) to allow users to modify time values after construction and have changes reflected in serialization.</p> <p>The method performs the following transformations: - Normalizes time values to UNIX timestamps (fresh conversion each call) - Converts field names from snake_case to camelCase - Converts NaN values to 0.0 for frontend compatibility - Converts NumPy scalar types to Python native types - Extracts enum values using their .value property - Skips None values and empty strings</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized data with camelCase keys ready for frontend consumption.</p> Example <pre><code>@dataclass\nclass MyData(Data):\n    value: float\n    color: str = \"red\"\n\n\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\nresult = data.asdict()\n# Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n# Can modify time after construction\ndata.time = \"2024-01-02T00:00:00\"\nresult2 = data.asdict()\n# Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n</code></pre> Note <ul> <li>Time is normalized fresh each call (no caching)</li> <li>NaN values are converted to 0.0</li> <li>NumPy scalar types are converted to Python native types</li> <li>Enum values are extracted using their .value property</li> <li>Time column uses standardized ColumnNames.TIME.value</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n    Converts the data point to a dictionary format suitable for frontend\n    communication. This method handles various data type conversions and\n    ensures proper formatting for JavaScript consumption.\n\n    Time normalization happens here (not in __post_init__) to allow users\n    to modify time values after construction and have changes reflected\n    in serialization.\n\n    The method performs the following transformations:\n    - Normalizes time values to UNIX timestamps (fresh conversion each call)\n    - Converts field names from snake_case to camelCase\n    - Converts NaN values to 0.0 for frontend compatibility\n    - Converts NumPy scalar types to Python native types\n    - Extracts enum values using their .value property\n    - Skips None values and empty strings\n\n    Returns:\n        Dict[str, Any]: Serialized data with camelCase keys ready for\n            frontend consumption.\n\n    Example:\n        ```python\n        @dataclass\n        class MyData(Data):\n            value: float\n            color: str = \"red\"\n\n\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n        result = data.asdict()\n        # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n\n        # Can modify time after construction\n        data.time = \"2024-01-02T00:00:00\"\n        result2 = data.asdict()\n        # Returns: {'time': 1704153600, 'value': 100.0, 'color': 'blue'}\n        ```\n\n    Note:\n        - Time is normalized fresh each call (no caching)\n        - NaN values are converted to 0.0\n        - NumPy scalar types are converted to Python native types\n        - Enum values are extracted using their .value property\n        - Time column uses standardized ColumnNames.TIME.value\n    \"\"\"\n    # Normalize time during serialization (not cached in __post_init__)\n    normalized_time = normalize_time(self.time)\n\n    # Use the inherited serialization from SerializableMixin\n    result = dict(self._serialize_to_dict())\n\n    # Override the time field with normalized value\n    result[ColumnNames.TIME.value] = normalized_time\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html","title":"streamlit_lightweight_charts_pro.data.gradient_ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon","title":"gradient_ribbon","text":"<p>Gradient ribbon data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for gradient ribbon data points used in ribbon charts that display upper and lower bands with gradient fill areas.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon.GradientRibbonData","title":"GradientRibbonData  <code>dataclass</code>","text":"<p>Data point for gradient ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional fill color override and gradient value for color calculation. It's used for ribbon charts that show upper and lower bands with gradient fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>Optional[float]</code> <p>The upper band value.</p> <code>lower</code> <code>Optional[float]</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional fill color override (highest priority).</p> <code>gradient</code> <code>Optional[float]</code> <p>Optional gradient value for color calculation (0.0 to 1.0 or raw value).</p> Source code in <code>streamlit_lightweight_charts_pro/data/gradient_ribbon.py</code> <pre><code>@dataclass\nclass GradientRibbonData(RibbonData):\n    \"\"\"Data point for gradient ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional fill color override and gradient value for color calculation.\n    It's used for ribbon charts that show upper and lower bands with gradient\n    fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional fill color override (highest priority).\n        gradient: Optional gradient value for color calculation (0.0 to 1.0 or raw value).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\", \"gradient\"}\n\n    # upper and lower inherited from RibbonData\n    gradient: Optional[float] = None\n\n    def __post_init__(self):\n        # Call parent's __post_init__ for time normalization and NaN handling\n        super().__post_init__()\n\n        # Validate gradient if provided\n        if self.gradient is not None:\n            if not isinstance(self.gradient, (int, float)):\n                raise ValueValidationError(\"gradient\", \"must be numeric\")\n            if math.isnan(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be NaN\")\n            if math.isinf(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be infinite\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html","title":"streamlit_lightweight_charts_pro.data.histogram_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data","title":"histogram_data","text":"<p>Histogram data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for histogram chart data points with optional color styling capabilities. The HistogramData class extends SingleValueData with color validation and serialization features.</p> The module includes <ul> <li>HistogramData: Data class for histogram chart data points with color styling</li> <li>Color validation for hex and rgba color formats</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color field with validation</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data.HistogramData","title":"HistogramData  <code>dataclass</code>","text":"<p>Data class for histogram chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for histogram chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for histogram visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. AreaData: Similar data class for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/histogram_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass HistogramData(SingleValueData):\n    \"\"\"Data class for histogram chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for histogram chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for histogram visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data point with color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n        # Create histogram data point without color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        AreaData: Similar data class for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this histogram data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html","title":"streamlit_lightweight_charts_pro.data.line_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data","title":"line_data","text":"<p>Line data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for line chart data points with optional color styling capabilities. The LineData class extends SingleValueData with color validation and serialization features.</p> The module includes <ul> <li>LineData: Data class for line chart data points with optional color</li> <li>Color validation for hex and rgba color formats</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color field with validation</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data.LineData","title":"LineData  <code>dataclass</code>","text":"<p>Data class for line chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for line chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. AreaData: Similar data class for area charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/line_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass LineData(SingleValueData):\n    \"\"\"Data class for line chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for line chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data point with color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n        # Create line data point without color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        AreaData: Similar data class for area charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this data point\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html","title":"streamlit_lightweight_charts_pro.data.marker","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker","title":"marker","text":"<p>Marker data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for chart markers used to highlight specific data points or events on charts, following the TradingView Lightweight Charts API. The module includes different types of markers for various positioning scenarios.</p> The module includes <ul> <li>MarkerBase: Base class for all chart markers</li> <li>PriceMarker: Marker positioned at exact price levels</li> <li>BarMarker: Marker positioned relative to bars</li> <li>Marker: Backward compatibility alias for BarMarker</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Position validation for different marker types</li> <li>Shape and color customization</li> <li>Optional text and ID fields</li> <li>Size control for marker appearance</li> <li>Enum-based position and shape validation</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import Marker, PriceMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create bar marker\nbar_marker = Marker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#FF0000\",\n    text=\"Important Event\",\n)\n\n# Create price marker\nprice_marker = PriceMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.AT_PRICE_TOP,\n    shape=MarkerShape.ARROW_DOWN,\n    price=100.0,\n    color=\"#00FF00\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase","title":"MarkerBase  <code>dataclass</code>","text":"<p>Base chart marker definition for highlighting data points.</p> <p>This class represents the base marker that can be displayed on charts to highlight specific data points, events, or annotations. Based on the TradingView Lightweight Charts SeriesMarkerBase interface, it provides the foundation for all marker types in the library.</p> <p>The class automatically handles time normalization, position and shape validation, and provides a flexible interface for marker customization.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Where to position the marker relative to the data point. Can be a string or MarkerPosition enum. Defaults to ABOVE_BAR.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker. Can be a string or MarkerShape enum. Defaults to CIRCLE.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker. If not provided, the id field is not serialized.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker. If not provided, the text field is not serialized.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import MarkerBase\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create base marker\nmarker = MarkerBase(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#FF0000\",\n    text=\"Important Event\",\n    size=2,\n)\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. PriceMarker: Marker positioned at exact price levels. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass MarkerBase(Data):\n    \"\"\"Base chart marker definition for highlighting data points.\n\n    This class represents the base marker that can be displayed on charts to\n    highlight specific data points, events, or annotations. Based on the\n    TradingView Lightweight Charts SeriesMarkerBase interface, it provides\n    the foundation for all marker types in the library.\n\n    The class automatically handles time normalization, position and shape\n    validation, and provides a flexible interface for marker customization.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Where to position the marker\n            relative to the data point. Can be a string or MarkerPosition enum.\n            Defaults to ABOVE_BAR.\n        shape (Union[str, MarkerShape]): Shape of the marker. Can be a string\n            or MarkerShape enum. Defaults to CIRCLE.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n            If not provided, the id field is not serialized.\n        text (Optional[str]): Optional text to display with the marker.\n            If not provided, the text field is not serialized.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import MarkerBase\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create base marker\n        marker = MarkerBase(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#FF0000\",\n            text=\"Important Event\",\n            size=2,\n        )\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        PriceMarker: Marker positioned at exact price levels.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - position and shape are required\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - styling and metadata fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Position of the marker relative to the data point - defaults to above bar\n    position: Union[str, MarkerPosition] = MarkerPosition.ABOVE_BAR\n    # Shape of the marker - defaults to circle\n    shape: Union[str, MarkerShape] = MarkerShape.CIRCLE\n    # Color of the marker in hex format - defaults to blue\n    color: str = \"#2196F3\"\n    # Optional unique identifier for the marker\n    id: Optional[str] = None\n    # Optional text to display with the marker\n    text: Optional[str] = None\n    # Size of the marker in pixels - defaults to 1\n    size: int = 1\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize enums and validate data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Converts string position values to MarkerPosition enum\n        3. Converts string shape values to MarkerShape enum\n\n        The method ensures that all marker data points have properly normalized\n        enum values that can be safely serialized and transmitted to the frontend.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Convert position string to enum if it's provided as a string\n        if isinstance(self.position, str):\n            self.position = MarkerPosition(self.position)\n\n        # Convert shape string to enum if it's provided as a string\n        if isinstance(self.shape, str):\n            self.shape = MarkerShape(self.shape)\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for this marker type.\n\n        This method provides a base implementation that allows all positions.\n        Subclasses should override this method to implement position-specific\n        validation logic for their marker types.\n\n        Returns:\n            bool: True if position is valid, False otherwise. Base implementation\n                always returns True.\n        \"\"\"\n        # Base class allows all positions - subclasses will override with specific validation\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for this marker type.</p> <p>This method provides a base implementation that allows all positions. Subclasses should override this method to implement position-specific validation logic for their marker types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid, False otherwise. Base implementation always returns True.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for this marker type.\n\n    This method provides a base implementation that allows all positions.\n    Subclasses should override this method to implement position-specific\n    validation logic for their marker types.\n\n    Returns:\n        bool: True if position is valid, False otherwise. Base implementation\n            always returns True.\n    \"\"\"\n    # Base class allows all positions - subclasses will override with specific validation\n    return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker","title":"PriceMarker  <code>dataclass</code>","text":"<p>Price marker for exact Y-axis positioning on charts.</p> <p>This class represents a marker that can be positioned at exact price levels on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice interface, it provides precise positioning control for markers that need to be placed at specific price values.</p> <p>The class automatically handles time normalization, price validation, and position validation for price-specific positioning scenarios.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of AT_PRICE_TOP, AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>price</code> <code>float</code> <p>Price value for exact Y-axis positioning. Required field that must be greater than 0.0.</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"     as required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import PriceMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create price marker at resistance level\nprice_marker = PriceMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.AT_PRICE_TOP,\n    shape=MarkerShape.ARROW_DOWN,\n    price=100.0,\n    color=\"#FF0000\",\n    text=\"Resistance Level\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>RequiredFieldError</code> <p>If the price field is 0.0 or missing.</p> See also <p>MarkerBase: Base class providing marker functionality. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass PriceMarker(MarkerBase):\n    \"\"\"Price marker for exact Y-axis positioning on charts.\n\n    This class represents a marker that can be positioned at exact price levels\n    on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice\n    interface, it provides precise positioning control for markers that need\n    to be placed at specific price values.\n\n    The class automatically handles time normalization, price validation, and\n    position validation for price-specific positioning scenarios.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of AT_PRICE_TOP,\n            AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        price (float): Price value for exact Y-axis positioning. Required field\n            that must be greater than 0.0.\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"\n            as required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import PriceMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create price marker at resistance level\n        price_marker = PriceMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.AT_PRICE_TOP,\n            shape=MarkerShape.ARROW_DOWN,\n            price=100.0,\n            color=\"#FF0000\",\n            text=\"Resistance Level\",\n        )\n        ```\n\n    Raises:\n        RequiredFieldError: If the price field is 0.0 or missing.\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - price is additional requirement\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\", \"price\"}\n\n    # Define optional columns for DataFrame conversion - same as base class\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Price value for exact Y-axis positioning - required for price markers\n    price: float = 0.0\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate price value.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize time and enums\n        2. Validates that the price field is provided and not 0.0\n\n        The method ensures that all price markers have valid price values\n        for proper Y-axis positioning.\n\n        Raises:\n            RequiredFieldError: If the price field is 0.0 or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize time and convert enums\n        super().__post_init__()\n\n        # Validate that price is provided and not 0.0 (required field)\n        if self.price == 0.0:\n            raise RequiredFieldError(\"Price\")\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for price markers.\n\n        This method validates that the position is one of the valid price-specific\n        positions that work with exact Y-axis positioning.\n\n        Returns:\n            bool: True if position is valid for price markers, False otherwise.\n        \"\"\"\n        # Define valid positions for price markers - must be price-specific positions\n        valid_positions = {\n            MarkerPosition.AT_PRICE_TOP,\n            MarkerPosition.AT_PRICE_BOTTOM,\n            MarkerPosition.AT_PRICE_MIDDLE,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for price markers.</p> <p>This method validates that the position is one of the valid price-specific positions that work with exact Y-axis positioning.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for price markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for price markers.\n\n    This method validates that the position is one of the valid price-specific\n    positions that work with exact Y-axis positioning.\n\n    Returns:\n        bool: True if position is valid for price markers, False otherwise.\n    \"\"\"\n    # Define valid positions for price markers - must be price-specific positions\n    valid_positions = {\n        MarkerPosition.AT_PRICE_TOP,\n        MarkerPosition.AT_PRICE_BOTTOM,\n        MarkerPosition.AT_PRICE_MIDDLE,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker","title":"BarMarker  <code>dataclass</code>","text":"<p>Bar marker for positioning relative to bars on charts.</p> <p>This class represents a marker that can be positioned relative to bars on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar interface, it provides flexible positioning options for markers that need to be placed relative to chart bars or candlesticks.</p> <p>The class automatically handles time normalization, position validation, and provides optional price positioning for enhanced flexibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of ABOVE_BAR, BELOW_BAR, or IN_BAR for bar markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> <code>price</code> <code>Optional[float]</code> <p>Optional price value for exact Y-axis positioning. If provided, overrides the relative bar positioning.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns including     \"price\" for enhanced positioning flexibility.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BarMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create bar marker above the bar\nbar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#00FF00\",\n    text=\"Buy Signal\",\n)\n\n# Create bar marker with exact price positioning\nprice_bar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.ARROW_UP,\n    price=105.0,\n    color=\"#FF0000\",\n)\n</code></pre> See also <p>MarkerBase: Base class providing marker functionality. PriceMarker: Marker positioned at exact price levels. Marker: Backward compatibility alias for BarMarker.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass BarMarker(MarkerBase):\n    \"\"\"Bar marker for positioning relative to bars on charts.\n\n    This class represents a marker that can be positioned relative to bars\n    on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar\n    interface, it provides flexible positioning options for markers that need\n    to be placed relative to chart bars or candlesticks.\n\n    The class automatically handles time normalization, position validation,\n    and provides optional price positioning for enhanced flexibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of ABOVE_BAR,\n            BELOW_BAR, or IN_BAR for bar markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n        price (Optional[float]): Optional price value for exact Y-axis positioning.\n            If provided, overrides the relative bar positioning.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns including\n            \"price\" for enhanced positioning flexibility.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import BarMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create bar marker above the bar\n        bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#00FF00\",\n            text=\"Buy Signal\",\n        )\n\n        # Create bar marker with exact price positioning\n        price_bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.ARROW_UP,\n            price=105.0,\n            color=\"#FF0000\",\n        )\n        ```\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        PriceMarker: Marker positioned at exact price levels.\n        Marker: Backward compatibility alias for BarMarker.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - same as base class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - includes price for flexibility\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\", \"price\"}\n\n    # Optional price value for exact Y-axis positioning - provides enhanced flexibility\n    price: Optional[float] = None\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for bar markers.\n\n        This method validates that the position is one of the valid bar-relative\n        positions that work with bar and candlestick charts.\n\n        Returns:\n            bool: True if position is valid for bar markers, False otherwise.\n        \"\"\"\n        # Define valid positions for bar markers - must be bar-relative positions\n        valid_positions = {\n            MarkerPosition.ABOVE_BAR,\n            MarkerPosition.BELOW_BAR,\n            MarkerPosition.IN_BAR,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for bar markers.</p> <p>This method validates that the position is one of the valid bar-relative positions that work with bar and candlestick charts.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for bar markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for bar markers.\n\n    This method validates that the position is one of the valid bar-relative\n    positions that work with bar and candlestick charts.\n\n    Returns:\n        bool: True if position is valid for bar markers, False otherwise.\n    \"\"\"\n    # Define valid positions for bar markers - must be bar-relative positions\n    valid_positions = {\n        MarkerPosition.ABOVE_BAR,\n        MarkerPosition.BELOW_BAR,\n        MarkerPosition.IN_BAR,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html","title":"streamlit_lightweight_charts_pro.data.ohlc_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data","title":"ohlc_data","text":"<p>OHLC data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for OHLC (Open, High, Low, Close) data points used in candlestick and bar charts. The OhlcData class extends the base Data class with OHLC-specific validation and serialization capabilities.</p> The module includes <ul> <li>OhlcData: Data class for OHLC data points</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>NaN handling and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high must be &gt;= low)</li> <li>Non-negative value validation for all price fields</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for all OHLC parameters</li> <li>CamelCase serialization for frontend communication</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import OhlcData\n\n# Create OHLC data point\ndata = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n# Serialize to frontend format\nserialized = data.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data.OhlcData","title":"OhlcData  <code>dataclass</code>","text":"<p>Data class for OHLC (Open, High, Low, Close) data points in financial charts.</p> <p>This class represents an OHLC data point commonly used in candlestick and bar charts for displaying financial market data. It extends the base Data class with OHLC-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships (high &gt;= low), ensures all values are non-negative, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"open\", \"high\", \"low\", and \"close\"     as required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcData\n\n# Create OHLC data point\ndata = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>Data: Base class providing time normalization and serialization. OhlcvData: OHLC data with additional volume information. CandlestickData: Specialized OHLC data for candlestick charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlc_data.py</code> <pre><code>@dataclass\nclass OhlcData(Data):\n    \"\"\"Data class for OHLC (Open, High, Low, Close) data points in financial charts.\n\n    This class represents an OHLC data point commonly used in candlestick and bar charts\n    for displaying financial market data. It extends the base Data class with OHLC-specific\n    validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships (high &gt;= low), ensures all values\n    are non-negative, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"open\", \"high\", \"low\", and \"close\"\n            as required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcData\n\n        # Create OHLC data point\n        data = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        OhlcvData: OHLC data with additional volume information.\n        CandlestickData: Specialized OHLC data for candlestick charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - all OHLC fields are required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"open\", \"high\", \"low\", \"close\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Opening price for the time period\n    open: float\n    # Highest price reached during the time period\n    high: float\n    # Lowest price reached during the time period\n    low: float\n    # Closing price for the time period\n    close: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLC data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates OHLC relationships (high must be &gt;= low)\n        3. Validates that all values are non-negative\n        4. Handles NaN values by converting them to 0.0\n        5. Validates that all required fields are present and not None\n\n        The method ensures that all OHLC data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If high &lt; low (invalid OHLC relationship).\n            NonNegativeValueError: If any OHLC value is negative.\n            RequiredFieldError: If any required OHLC field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Validate OHLC relationships - high must be greater than or equal to low\n        if self.high &lt; self.low:\n            raise ValueValidationError(\"high\", \"must be greater than or equal to low\")\n\n        # Validate that all OHLC values are non-negative (prices cannot be negative)\n        if self.open &lt; 0 or self.high &lt; 0 or self.low &lt; 0 or self.close &lt; 0:\n            raise ValueValidationError.non_negative_value(\"all OHLC values\")\n\n        # Handle NaN values in all OHLC fields - convert to 0.0 for frontend compatibility\n        for field_name in [\"open\", \"high\", \"low\", \"close\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - all OHLC fields are required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html","title":"streamlit_lightweight_charts_pro.data.ohlcv_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data","title":"ohlcv_data","text":"<p>OHLCV data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for OHLCV (Open, High, Low, Close, Volume) data points used in candlestick and bar charts with volume information. The OhlcvData class extends OhlcData with volume validation and serialization capabilities.</p> The module includes <ul> <li>OhlcvData: Data class for OHLCV data points with volume</li> <li>Volume validation and non-negative value checking</li> <li>OHLC relationship validation and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>Volume validation (must be non-negative)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for all OHLCV parameters</li> <li>CamelCase serialization for frontend communication</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize to frontend format\nserialized = data.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data.OhlcvData","title":"OhlcvData  <code>dataclass</code>","text":"<p>Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.</p> <p>This class represents an OHLCV data point commonly used in candlestick and bar charts for displaying financial market data with volume information. It extends the OhlcData class with volume-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships, ensures all values are non-negative, validates volume data, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>volume</code> <code>float</code> <p>Trading volume for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column     beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship) or volume &lt; 0.</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLCV field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. CandlestickData: OHLC data with color styling capabilities. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlcv_data.py</code> <pre><code>@dataclass\nclass OhlcvData(OhlcData):\n    \"\"\"Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.\n\n    This class represents an OHLCV data point commonly used in candlestick and bar charts\n    for displaying financial market data with volume information. It extends the OhlcData\n    class with volume-specific validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships, ensures all values are non-negative,\n    validates volume data, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        volume (float): Trading volume for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column\n            beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcvData\n\n        # Create OHLCV data point with volume\n        data = OhlcvData(\n            time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n        )\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship) or volume &lt; 0.\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLCV field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        CandlestickData: OHLC data with color styling capabilities.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - volume is additional requirement\n    # beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = {\"volume\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Trading volume for the time period - must be non-negative\n    volume: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLCV data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate OHLC data and time\n        2. Validates that volume is non-negative\n        3. Handles NaN values in the volume field\n        4. Validates that volume is not None\n\n        The method ensures that all OHLCV data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If volume &lt; 0 (volume cannot be negative).\n            RequiredFieldError: If volume field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to validate OHLC data and time normalization\n        super().__post_init__()\n\n        # Validate that volume is non-negative (volume cannot be negative)\n        if self.volume &lt; 0:\n            raise ValueValidationError(\"volume\", \"must be non-negative\")\n\n        # Handle NaN values in volume field - convert to 0.0 for frontend compatibility\n        for field_name in [\"volume\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - volume is required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html","title":"streamlit_lightweight_charts_pro.data.ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon","title":"ribbon","text":"<p>Ribbon data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for ribbon data points used in ribbon charts that display upper and lower bands with fill areas.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon.RibbonData","title":"RibbonData  <code>dataclass</code>","text":"<p>Data point for ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional per-point color overrides. It's used for ribbon charts that show upper and lower bands with fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>Optional[float]</code> <p>The upper band value.</p> <code>lower</code> <code>Optional[float]</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional color for the fill area (hex or rgba format).</p> <code>upper_line_color</code> <code>Optional[str]</code> <p>Optional color override for upper line (hex or rgba format).</p> <code>lower_line_color</code> <code>Optional[str]</code> <p>Optional color override for lower line (hex or rgba format).</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import RibbonData\n\n# Basic data point\ndata = RibbonData(time=\"2024-01-01\", upper=110, lower=100)\n\n# Data point with custom per-point colors\ndata = RibbonData(\n    time=\"2024-01-01\",\n    upper=110,\n    lower=100,\n    fill=\"rgba(255,0,0,0.2)\",\n    upper_line_color=\"#ff0000\",\n    lower_line_color=\"#00ff00\",\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/ribbon.py</code> <pre><code>@dataclass\n@validated_field(\"fill\", str, validator=\"color\", allow_none=True)\n@validated_field(\"upper_line_color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"lower_line_color\", str, validator=\"color\", allow_none=True)\nclass RibbonData(Data):\n    \"\"\"Data point for ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional per-point color overrides. It's used for ribbon charts\n    that show upper and lower bands with fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional color for the fill area (hex or rgba format).\n        upper_line_color: Optional color override for upper line (hex or rgba format).\n        lower_line_color: Optional color override for lower line (hex or rgba format).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import RibbonData\n\n        # Basic data point\n        data = RibbonData(time=\"2024-01-01\", upper=110, lower=100)\n\n        # Data point with custom per-point colors\n        data = RibbonData(\n            time=\"2024-01-01\",\n            upper=110,\n            lower=100,\n            fill=\"rgba(255,0,0,0.2)\",\n            upper_line_color=\"#ff0000\",\n            lower_line_color=\"#00ff00\",\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\", \"upper_line_color\", \"lower_line_color\"}\n\n    upper: Optional[float]\n    lower: Optional[float]\n    fill: Optional[str] = None\n    upper_line_color: Optional[str] = None\n    lower_line_color: Optional[str] = None\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n\n        # Handle NaN in upper value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = None\n        # Allow None for missing data (no validation error)\n\n        # Handle NaN in lower value\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html","title":"streamlit_lightweight_charts_pro.data.signal_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data","title":"signal_data","text":"<p>Signal data for background coloring in charts.</p> <p>This module provides the SignalData class for creating signal-based background coloring in financial charts. Signal data consists of time points with binary or ternary values that determine background colors for specific time periods.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data.SignalData","title":"SignalData  <code>dataclass</code>","text":"<p>Signal data point for background coloring.</p> <p>SignalData represents a single time point with a signal value that determines the background color for that time period. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[str, datetime]</code> <p>Time point for the signal. Can be a string in ISO format (YYYY-MM-DD) or a datetime object.</p> <code>value</code> <code>Union[int, bool]</code> <p>Signal value that determines background color. Accepts both integers and booleans (converted to int automatically): - 0 or False: First color (typically neutral/gray) - 1 or True: Second color (typically signal/blue) - 2: Third color (optional, for ternary signals/alerts)</p> Example <pre><code># Create signal data for background coloring\n# Using integers (0, 1, 2)\nsignal_data_int = [\n    SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n    SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n]\n\n# Using booleans (False, True) - more natural for binary signals\nsignal_data_bool = [\n    SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n    SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n    SignalData(\"2024-01-03\", False),  # Neutral\n    SignalData(\"2024-01-04\", True),  # Signal\n]\n\n# Use with SignalSeries\nsignal_series = SignalSeries(\n    data=signal_data_bool,  # Works with both int and bool values\n    neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n    signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/signal_data.py</code> <pre><code>@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\nclass SignalData(SingleValueData):\n    \"\"\"Signal data point for background coloring.\n\n    SignalData represents a single time point with a signal value that determines\n    the background color for that time period. This is commonly used in financial\n    charts to highlight specific market conditions, trading signals, or events.\n\n    Attributes:\n        time (Union[str, datetime]): Time point for the signal. Can be a string\n            in ISO format (YYYY-MM-DD) or a datetime object.\n        value (Union[int, bool]): Signal value that determines background color.\n            Accepts both integers and booleans (converted to int automatically):\n            - 0 or False: First color (typically neutral/gray)\n            - 1 or True: Second color (typically signal/blue)\n            - 2: Third color (optional, for ternary signals/alerts)\n\n    Example:\n        ```python\n        # Create signal data for background coloring\n        # Using integers (0, 1, 2)\n        signal_data_int = [\n            SignalData(\"2024-01-01\", 0),  # Neutral (uses neutral_color)\n            SignalData(\"2024-01-02\", 1),  # Signal (uses signal_color)\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Custom light green\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Custom light red\n        ]\n\n        # Using booleans (False, True) - more natural for binary signals\n        signal_data_bool = [\n            SignalData(\"2024-01-01\", False),  # Neutral (False \u2192 0)\n            SignalData(\"2024-01-02\", True),  # Signal (True \u2192 1)\n            SignalData(\"2024-01-03\", False),  # Neutral\n            SignalData(\"2024-01-04\", True),  # Signal\n        ]\n\n        # Use with SignalSeries\n        signal_series = SignalSeries(\n            data=signal_data_bool,  # Works with both int and bool values\n            neutral_color=\"#808080\",  # Gray for False/0 (neutral)\n            signal_color=\"#2962FF\",  # Blue for True/1 (signal)\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html","title":"streamlit_lightweight_charts_pro.data.single_value_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data","title":"single_value_data","text":"<p>Single value data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for single value data points used in line charts, area charts, and other chart types that display a single numeric value per time point. The SingleValueData class extends the base Data class with value-specific validation and serialization capabilities.</p> The module includes <ul> <li>SingleValueData: Data class for single value data points</li> <li>Value validation and NaN handling</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for value parameter</li> <li>CamelCase serialization for frontend communication</li> <li>Column management for DataFrame conversion operations</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize to frontend format\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data.SingleValueData","title":"SingleValueData  <code>dataclass</code>","text":"<p>Data class for single value data points used in line and area charts.</p> <p>This class represents a single numeric value at a specific time point, commonly used for line charts, area charts, and other chart types that display one value per time. It extends the base Data class with value-specific validation and NaN handling.</p> <p>The class automatically handles time normalization, value validation, and serialization to camelCase dictionaries suitable for frontend communication.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"value\" as the required column     for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize for frontend\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. LineData: Specialized single value data for line charts. AreaData: Specialized single value data for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/single_value_data.py</code> <pre><code>@dataclass\nclass SingleValueData(Data):\n    \"\"\"Data class for single value data points used in line and area charts.\n\n    This class represents a single numeric value at a specific time point, commonly used\n    for line charts, area charts, and other chart types that display one value per time.\n    It extends the base Data class with value-specific validation and NaN handling.\n\n    The class automatically handles time normalization, value validation, and serialization\n    to camelCase dictionaries suitable for frontend communication.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"value\" as the required column\n            for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create single value data point\n        data = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        LineData: Specialized single value data for line charts.\n        AreaData: Specialized single value data for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - only \"value\" is required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"value\"}\n\n    # Define optional columns for DataFrame conversion - none for this simple data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # The single numeric value for this data point\n    value: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates the value field for None values\n        3. Converts NaN values to 0.0 for frontend compatibility\n\n        The method ensures that all data points have valid, non-NaN values\n        that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            RequiredFieldError: If the value field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Handle NaN values in the value field - convert to 0.0 for frontend compatibility\n        if isinstance(self.value, float) and math.isnan(self.value):\n            self.value = 0.0\n        # Validate that value is not None - this is a required field\n        elif self.value is None:\n            raise RequiredFieldError(\"value\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html","title":"streamlit_lightweight_charts_pro.data.tooltip","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip","title":"tooltip","text":"<p>Tooltip data structures and utilities for Lightweight Charts.</p> <p>This module provides comprehensive tooltip functionality with support for dynamic content using placeholders, multiple tooltip types, and flexible configuration options.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField","title":"TooltipField  <code>dataclass</code>","text":"<p>Represents a single field in a tooltip.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Display label for the field</p> <code>value_key</code> <code>str</code> <p>Key to access the value from data</p> <code>formatter</code> <code>Optional[Callable[[Any], str]]</code> <p>Optional function to format the value</p> <code>color</code> <code>Optional[str]</code> <p>Optional color for the field</p> <code>font_size</code> <code>Optional[int]</code> <p>Optional font size for the field</p> <code>font_weight</code> <code>Optional[str]</code> <p>Optional font weight for the field</p> <code>prefix</code> <code>Optional[str]</code> <p>Optional prefix to add before the value</p> <code>suffix</code> <code>Optional[str]</code> <p>Optional suffix to add after the value</p> <code>precision</code> <code>Optional[int]</code> <p>Optional decimal precision for numeric values</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipField:\n    \"\"\"Represents a single field in a tooltip.\n\n    Attributes:\n        label: Display label for the field\n        value_key: Key to access the value from data\n        formatter: Optional function to format the value\n        color: Optional color for the field\n        font_size: Optional font size for the field\n        font_weight: Optional font weight for the field\n        prefix: Optional prefix to add before the value\n        suffix: Optional suffix to add after the value\n        precision: Optional decimal precision for numeric values\n    \"\"\"\n\n    label: str\n    value_key: str\n    formatter: Optional[Callable[[Any], str]] = None\n    color: Optional[str] = None\n    font_size: Optional[int] = None\n    font_weight: Optional[str] = None\n    prefix: Optional[str] = None\n    suffix: Optional[str] = None\n    precision: Optional[int] = None\n\n    def format_value(self, value: Any) -&gt; str:\n        \"\"\"Format the value according to field configuration.\"\"\"\n        if self.formatter:\n            return self.formatter(value)\n\n        # Apply precision for numeric values\n        if self.precision is not None and isinstance(value, (int, float)):\n            value = f\"{value:.{self.precision}f}\"\n        else:\n            value = str(value)\n\n        # Add prefix and suffix\n        result = value\n        if self.prefix:\n            result = f\"{self.prefix}{result}\"\n        if self.suffix:\n            result = f\"{result}{self.suffix}\"\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField.format_value","title":"format_value","text":"<pre><code>format_value(value: Any) -&gt; str\n</code></pre> <p>Format the value according to field configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_value(self, value: Any) -&gt; str:\n    \"\"\"Format the value according to field configuration.\"\"\"\n    if self.formatter:\n        return self.formatter(value)\n\n    # Apply precision for numeric values\n    if self.precision is not None and isinstance(value, (int, float)):\n        value = f\"{value:.{self.precision}f}\"\n    else:\n        value = str(value)\n\n    # Add prefix and suffix\n    result = value\n    if self.prefix:\n        result = f\"{self.prefix}{result}\"\n    if self.suffix:\n        result = f\"{result}{self.suffix}\"\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipStyle","title":"TooltipStyle  <code>dataclass</code>","text":"<p>Styling configuration for tooltips.</p> <p>Attributes:</p> Name Type Description <code>background_color</code> <code>str</code> <p>Background color of the tooltip</p> <code>border_color</code> <code>str</code> <p>Border color of the tooltip</p> <code>border_width</code> <code>int</code> <p>Border width in pixels</p> <code>border_radius</code> <code>int</code> <p>Border radius in pixels</p> <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>font_size</code> <code>int</code> <p>Font size in pixels</p> <code>font_family</code> <code>str</code> <p>Font family</p> <code>color</code> <code>str</code> <p>Text color</p> <code>box_shadow</code> <code>str</code> <p>CSS box shadow</p> <code>z_index</code> <code>int</code> <p>Z-index for layering</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipStyle:\n    \"\"\"Styling configuration for tooltips.\n\n    Attributes:\n        background_color: Background color of the tooltip\n        border_color: Border color of the tooltip\n        border_width: Border width in pixels\n        border_radius: Border radius in pixels\n        padding: Padding in pixels\n        font_size: Font size in pixels\n        font_family: Font family\n        color: Text color\n        box_shadow: CSS box shadow\n        z_index: Z-index for layering\n    \"\"\"\n\n    background_color: str = \"rgba(255, 255, 255, 0.95)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    font_size: int = 12\n    font_family: str = \"sans-serif\"\n    color: str = \"#131722\"\n    box_shadow: str = \"0 2px 4px rgba(0, 0, 0, 0.1)\"\n    z_index: int = 1000\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig","title":"TooltipConfig  <code>dataclass</code>","text":"<p>Configuration for tooltip functionality.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether tooltips are enabled</p> <code>type</code> <code>TooltipType</code> <p>Type of tooltip to display</p> <code>template</code> <code>Optional[str]</code> <p>Template string with placeholders</p> <code>fields</code> <code>List[TooltipField]</code> <p>List of tooltip fields</p> <code>position</code> <code>TooltipPosition</code> <p>Tooltip positioning</p> <code>offset</code> <code>Optional[Dict[str, int]]</code> <p>Offset from cursor or fixed position</p> <code>style</code> <code>TooltipStyle</code> <p>Tooltip styling</p> <code>show_date</code> <code>bool</code> <p>Whether to show date</p> <code>date_format</code> <code>str</code> <p>Date format string</p> <code>show_time</code> <code>bool</code> <p>Whether to show time</p> <code>time_format</code> <code>str</code> <p>Time format string</p> <code>custom_formatters</code> <code>Dict[str, Callable[[Any], str]]</code> <p>Custom formatter functions</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipConfig:\n    \"\"\"Configuration for tooltip functionality.\n\n    Attributes:\n        enabled: Whether tooltips are enabled\n        type: Type of tooltip to display\n        template: Template string with placeholders\n        fields: List of tooltip fields\n        position: Tooltip positioning\n        offset: Offset from cursor or fixed position\n        style: Tooltip styling\n        show_date: Whether to show date\n        date_format: Date format string\n        show_time: Whether to show time\n        time_format: Time format string\n        custom_formatters: Custom formatter functions\n    \"\"\"\n\n    enabled: bool = True\n    type: TooltipType = TooltipType.OHLC\n    template: Optional[str] = None\n    fields: List[TooltipField] = field(default_factory=list)\n    position: TooltipPosition = TooltipPosition.CURSOR\n    offset: Optional[Dict[str, int]] = None\n    style: TooltipStyle = field(default_factory=TooltipStyle)\n    show_date: bool = True\n    date_format: str = \"%Y-%m-%d\"\n    show_time: bool = True\n    time_format: str = \"%H:%M:%S\"\n    custom_formatters: Dict[str, Callable[[Any], str]] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize default fields based on tooltip type.\"\"\"\n        if not self.fields and self.type == TooltipType.OHLC:\n            self.fields = self._get_default_ohlc_fields()\n        elif not self.fields and self.type == TooltipType.SINGLE:\n            self.fields = self._get_default_single_fields()\n        elif not self.fields and self.type == TooltipType.TRADE:\n            self.fields = self._get_default_trade_fields()\n\n    def _get_default_ohlc_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for OHLC tooltip.\"\"\"\n        return [\n            TooltipField(\"Open\", \"open\", precision=2, prefix=\"$\"),\n            TooltipField(\"High\", \"high\", precision=2, prefix=\"$\"),\n            TooltipField(\"Low\", \"low\", precision=2, prefix=\"$\"),\n            TooltipField(\"Close\", \"close\", precision=2, prefix=\"$\"),\n            TooltipField(\"Volume\", \"volume\", formatter=self._format_volume),\n        ]\n\n    def _get_default_single_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for single value tooltip.\"\"\"\n        return [\n            TooltipField(\"Value\", \"value\", precision=2),\n        ]\n\n    def _get_default_trade_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for trade tooltip.\"\"\"\n        return [\n            TooltipField(\"Entry\", \"entryPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Exit\", \"exitPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Quantity\", \"quantity\"),\n            TooltipField(\"P&amp;L\", \"pnl\", precision=2, prefix=\"$\"),\n            TooltipField(\"P&amp;L %\", \"pnlPercentage\", precision=1, suffix=\"%\"),\n        ]\n\n    def _format_volume(self, value: Any) -&gt; str:\n        \"\"\"Format volume with K, M, B suffixes.\"\"\"\n        if not isinstance(value, (int, float)):\n            return str(value)\n\n        if value &gt;= 1e9:\n            return f\"{value / 1e9:.1f}B\"\n        if value &gt;= 1e6:\n            return f\"{value / 1e6:.1f}M\"\n        if value &gt;= 1e3:\n            return f\"{value / 1e3:.1f}K\"\n        return f\"{value:,.0f}\"\n\n    def format_tooltip(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip content using template or fields.\n\n        Args:\n            data: Data dictionary containing values\n            time_value: Optional time value for date/time formatting\n\n        Returns:\n            Formatted tooltip string\n        \"\"\"\n        if self.template:\n            return self._format_with_template(data, time_value)\n        return self._format_with_fields(data, time_value)\n\n    def _format_with_template(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using template string with placeholders.\"\"\"\n        if not self.template:\n            return \"\"\n\n        # Start with the template\n        result = self.template\n\n        # Replace placeholders with actual values\n        for key, value in data.items():\n            placeholder = f\"{{{key}}}\"\n            if placeholder in result:\n                # Format the value based on field configuration\n                field = next((f for f in self.fields if f.value_key == key), None)\n                formatted_value = field.format_value(value) if field else str(value)\n                result = result.replace(placeholder, formatted_value)\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                result = f\"{time_str}\\n{result}\"\n\n        return result\n\n    def _format_with_fields(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using field configuration.\"\"\"\n        lines = []\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                lines.append(time_str)\n\n        # Add field values\n        for tooltip_field in self.fields:\n            if tooltip_field.value_key in data:\n                value = data[tooltip_field.value_key]\n                formatted_value = tooltip_field.format_value(value)\n                lines.append(f\"{tooltip_field.label}: {formatted_value}\")\n\n        return \"\\n\".join(lines)\n\n    def _format_time(self, time_value: Union[int, str, pd.Timestamp]) -&gt; str:\n        \"\"\"Format time value according to configuration.\"\"\"\n        try:\n            if isinstance(time_value, (int, float)):\n                # Convert timestamp to datetime\n                dt = pd.to_datetime(time_value, unit=\"s\")\n            elif isinstance(time_value, str):\n                dt = pd.to_datetime(time_value)\n            else:\n                dt = pd.to_datetime(time_value)\n\n            parts = []\n            if self.show_date:\n                parts.append(dt.strftime(self.date_format))\n            if self.show_time:\n                parts.append(dt.strftime(self.time_format))\n\n            return \" \".join(parts)\n        except Exception:\n            return str(time_value)\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n        return {\n            \"enabled\": self.enabled,\n            \"type\": self.type.value,\n            \"template\": self.template,\n            \"fields\": [self._field_to_dict(field) for field in self.fields],\n            \"position\": self.position.value,\n            \"offset\": self.offset,\n            \"style\": self._style_to_dict(self.style),\n            \"showDate\": self.show_date,\n            \"dateFormat\": self.date_format,\n            \"showTime\": self.show_time,\n            \"timeFormat\": self.time_format,\n        }\n\n    def _field_to_dict(self, field: TooltipField) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip field to dictionary.\"\"\"\n        return {\n            \"label\": field.label,\n            \"valueKey\": field.value_key,\n            \"color\": field.color,\n            \"fontSize\": field.font_size,\n            \"fontWeight\": field.font_weight,\n            \"prefix\": field.prefix,\n            \"suffix\": field.suffix,\n            \"precision\": field.precision,\n        }\n\n    def _style_to_dict(self, style: TooltipStyle) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip style to dictionary.\"\"\"\n        return {\n            \"backgroundColor\": style.background_color,\n            \"borderColor\": style.border_color,\n            \"borderWidth\": style.border_width,\n            \"borderRadius\": style.border_radius,\n            \"padding\": style.padding,\n            \"fontSize\": style.font_size,\n            \"fontFamily\": style.font_family,\n            \"color\": style.color,\n            \"boxShadow\": style.box_shadow,\n            \"zIndex\": style.z_index,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(data: Dict[str, Any], time_value: Optional[Union[int, str, Timestamp]] = None) -&gt; str\n</code></pre> <p>Format tooltip content using template or fields.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Data dictionary containing values</p> required <code>time_value</code> <code>Optional[Union[int, str, Timestamp]]</code> <p>Optional time value for date/time formatting</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted tooltip string</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip content using template or fields.\n\n    Args:\n        data: Data dictionary containing values\n        time_value: Optional time value for date/time formatting\n\n    Returns:\n        Formatted tooltip string\n    \"\"\"\n    if self.template:\n        return self._format_with_template(data, time_value)\n    return self._format_with_fields(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert tooltip config to dictionary for serialization.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n    return {\n        \"enabled\": self.enabled,\n        \"type\": self.type.value,\n        \"template\": self.template,\n        \"fields\": [self._field_to_dict(field) for field in self.fields],\n        \"position\": self.position.value,\n        \"offset\": self.offset,\n        \"style\": self._style_to_dict(self.style),\n        \"showDate\": self.show_date,\n        \"dateFormat\": self.date_format,\n        \"showTime\": self.show_time,\n        \"timeFormat\": self.time_format,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager","title":"TooltipManager","text":"<p>Manages tooltip functionality across multiple series and data types.</p> <p>This class provides centralized tooltip management with support for different data types, dynamic content, and consistent formatting.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>class TooltipManager:\n    \"\"\"Manages tooltip functionality across multiple series and data types.\n\n    This class provides centralized tooltip management with support for\n    different data types, dynamic content, and consistent formatting.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize tooltip manager.\"\"\"\n        self.configs: Dict[str, TooltipConfig] = {}\n        self.custom_formatters: Dict[str, Callable[[Any], str]] = {}\n\n    def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n        \"\"\"Add a tooltip configuration.\"\"\"\n        self.configs[name] = config\n        return self\n\n    def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n        \"\"\"Get a tooltip configuration by name.\"\"\"\n        return self.configs.get(name)\n\n    def remove_config(self, name: str) -&gt; bool:\n        \"\"\"Remove a tooltip configuration.\"\"\"\n        if name in self.configs:\n            del self.configs[name]\n            return True\n        return False\n\n    def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n        \"\"\"Add a custom formatter function.\"\"\"\n        self.custom_formatters[name] = formatter\n        return self\n\n    def format_tooltip(\n        self,\n        config_name: str,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using specified configuration.\"\"\"\n        config = self.get_config(config_name)\n        if not config:\n            return \"\"\n\n        # Add custom formatters to config\n        config.custom_formatters.update(self.custom_formatters)\n\n        return config.format_tooltip(data, time_value)\n\n    def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n        \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.OHLC)\n        self.add_config(name, config)\n        return config\n\n    def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n        \"\"\"Create a standard trade tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.TRADE)\n        self.add_config(name, config)\n        return config\n\n    def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n        \"\"\"Create a custom tooltip configuration with template.\"\"\"\n        config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n        self.add_config(name, config)\n        return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.add_config","title":"add_config","text":"<pre><code>add_config(name: str, config: TooltipConfig) -&gt; TooltipManager\n</code></pre> <p>Add a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n    \"\"\"Add a tooltip configuration.\"\"\"\n    self.configs[name] = config\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.get_config","title":"get_config","text":"<pre><code>get_config(name: str) -&gt; Optional[TooltipConfig]\n</code></pre> <p>Get a tooltip configuration by name.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n    \"\"\"Get a tooltip configuration by name.\"\"\"\n    return self.configs.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.remove_config","title":"remove_config","text":"<pre><code>remove_config(name: str) -&gt; bool\n</code></pre> <p>Remove a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def remove_config(self, name: str) -&gt; bool:\n    \"\"\"Remove a tooltip configuration.\"\"\"\n    if name in self.configs:\n        del self.configs[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.add_custom_formatter","title":"add_custom_formatter","text":"<pre><code>add_custom_formatter(name: str, formatter: Callable[[Any], str]) -&gt; TooltipManager\n</code></pre> <p>Add a custom formatter function.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n    \"\"\"Add a custom formatter function.\"\"\"\n    self.custom_formatters[name] = formatter\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(config_name: str, data: Dict[str, Any], time_value: Optional[Union[int, str, Timestamp]] = None) -&gt; str\n</code></pre> <p>Format tooltip using specified configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    config_name: str,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip using specified configuration.\"\"\"\n    config = self.get_config(config_name)\n    if not config:\n        return \"\"\n\n    # Add custom formatters to config\n    config.custom_formatters.update(self.custom_formatters)\n\n    return config.format_tooltip(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip(name: str = 'default') -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.OHLC)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip(name: str = 'trade') -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.TRADE)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(template: str, name: str = 'custom') -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.OHLC)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.TRADE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(template: str) -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(template: str) -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    return TooltipConfig(type=TooltipType.CUSTOM, template=template)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_single_value_tooltip","title":"create_single_value_tooltip","text":"<pre><code>create_single_value_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a single value tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_single_value_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a single value tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.SINGLE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_multi_series_tooltip","title":"create_multi_series_tooltip","text":"<pre><code>create_multi_series_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a multi-series tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_multi_series_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a multi-series tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.MULTI)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html","title":"streamlit_lightweight_charts_pro.data.trade","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade","title":"trade","text":"<p>Trade data model for visualizing trades on charts.</p> <p>This module provides the TradeData class for representing individual trades with entry and exit information, profit/loss calculations, and flexible metadata storage. Trade visualization (markers, rectangles, tooltips) is handled by the frontend using template-based rendering.</p> The module includes <ul> <li>TradeData: Complete trade representation with entry/exit data</li> <li>Automatic profit/loss calculations and percentage calculations</li> <li>Flexible additional_data for custom trade metadata</li> <li>Comprehensive serialization for frontend communication</li> </ul> Key Features <ul> <li>Entry and exit time/price tracking with validation</li> <li>Automatic profit/loss and percentage calculations</li> <li>Flexible additional_data dictionary for custom fields</li> <li>Tooltip text generation with trade details</li> <li>Time normalization and validation</li> <li>Frontend-compatible serialization with camelCase keys</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")\nprint(f\"Profitable: {trade.is_profitable}\")\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData","title":"TradeData  <code>dataclass</code>","text":"<p>Represents a single trade with entry and exit information.</p> <p>This class provides a comprehensive representation of a trading transaction, including entry and exit details, profit/loss calculations, and visualization capabilities. It supports both long and short trades with automatic P&amp;L calculations and marker generation for chart display.</p> <p>The class automatically validates trade data, normalizes time values, and provides computed properties for profit/loss analysis. It can convert trades to marker representations for visual display on charts.</p> <p>Attributes:</p> Name Type Description <code>entry_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Entry time in various formats (automatically normalized to UTC timestamp).</p> <code>entry_price</code> <code>Union[float, int]</code> <p>Entry price for the trade.</p> <code>exit_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Exit time in various formats (automatically normalized to UTC timestamp).</p> <code>exit_price</code> <code>Union[float, int]</code> <p>Exit price for the trade.</p> <code>is_profitable</code> <code>bool</code> <p>Whether the trade was profitable (True) or not (False).</p> <code>id</code> <code>str</code> <p>Unique identifier for the trade (required).</p> <code>additional_data</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing any additional trade data such as quantity, trade_type, notes, etc. This provides maximum flexibility for custom fields.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a profitable long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\nprint(f\"Profitable: {trade.is_profitable}\")  # True\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> Note <ul> <li>Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised</li> <li>Price values are automatically converted to appropriate numeric types</li> <li>Time values are normalized to UTC timestamps for consistent handling</li> <li>All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data</li> <li>The id field is required for trade identification</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>@dataclass\nclass TradeData(SerializableMixin):\n    \"\"\"Represents a single trade with entry and exit information.\n\n    This class provides a comprehensive representation of a trading transaction,\n    including entry and exit details, profit/loss calculations, and visualization\n    capabilities. It supports both long and short trades with automatic P&amp;L\n    calculations and marker generation for chart display.\n\n    The class automatically validates trade data, normalizes time values, and\n    provides computed properties for profit/loss analysis. It can convert trades\n    to marker representations for visual display on charts.\n\n    Attributes:\n        entry_time (Union[pd.Timestamp, datetime, str, int, float]): Entry time\n            in various formats (automatically normalized to UTC timestamp).\n        entry_price (Union[float, int]): Entry price for the trade.\n        exit_time (Union[pd.Timestamp, datetime, str, int, float]): Exit time\n            in various formats (automatically normalized to UTC timestamp).\n        exit_price (Union[float, int]): Exit price for the trade.\n        is_profitable (bool): Whether the trade was profitable (True) or not (False).\n        id (str): Unique identifier for the trade (required).\n        additional_data (Optional[Dict[str, Any]]): Optional dictionary containing\n            any additional trade data such as quantity, trade_type, notes, etc.\n            This provides maximum flexibility for custom fields.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n        # Create a profitable long trade\n        trade = TradeData(\n            entry_time=\"2024-01-01T09:00:00\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01T16:00:00\",\n            exit_price=105.0,\n            is_profitable=True,\n            id=\"trade_001\",\n            additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n        )\n\n        # Access calculated properties\n        print(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\n        print(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\n        print(f\"Profitable: {trade.is_profitable}\")  # True\n\n        # Serialize for frontend\n        trade_dict = trade.asdict()\n        ```\n\n    Note:\n        - Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised\n        - Price values are automatically converted to appropriate numeric types\n        - Time values are normalized to UTC timestamps for consistent handling\n        - All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data\n        - The id field is required for trade identification\n    \"\"\"\n\n    # Core fields required for trade visualization\n    entry_time: Union[pd.Timestamp, datetime, str, int, float]\n    entry_price: Union[float, int]\n    exit_time: Union[pd.Timestamp, datetime, str, int, float]\n    exit_price: Union[float, int]\n    is_profitable: bool\n    id: str  # Required for trade identification\n\n    # All other data moved to additional_data for maximum flexibility\n    additional_data: Optional[Dict[str, Any]] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize and validate trade data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Converts price values to appropriate numeric types\n        2. Validates that exit time is after entry time\n        3. Ensures is_profitable is a boolean\n\n        Raises:\n            ExitTimeAfterEntryTimeError: If exit time is not after entry time.\n            ValueValidationError: If time validation fails.\n        \"\"\"\n        # Step 1: Convert price values to float for consistent calculations\n        # This ensures prices are always numeric, regardless of input type\n        self.entry_price = float(self.entry_price)\n        self.exit_price = float(self.exit_price)\n\n        # Step 2: Ensure is_profitable is a boolean for consistent logic\n        # Converts any truthy/falsy value to explicit True/False\n        self.is_profitable = bool(self.is_profitable)\n\n        # Step 3: Validate that exit time is after entry time\n        # Convert times temporarily for validation only\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # This is critical for trade logic - a trade cannot exit before it enters\n        if isinstance(entry_timestamp, (int, float)) and isinstance(\n            exit_timestamp,\n            (int, float),\n        ):\n            # Case 1: Both timestamps are numeric - compare directly\n            if exit_timestamp &lt;= entry_timestamp:\n                raise ExitTimeAfterEntryTimeError()\n        elif (\n            isinstance(entry_timestamp, str)\n            and isinstance(exit_timestamp, str)\n            and exit_timestamp &lt;= entry_timestamp\n        ):\n            # Case 2: Both timestamps are strings - compare lexicographically\n            raise ValueValidationError(\"Exit time\", \"must be after entry time\")\n\n    def generate_tooltip_text(self) -&gt; str:\n        \"\"\"Generate tooltip text for the trade.\n\n        Creates a comprehensive tooltip text that displays key trade information\n        including entry/exit prices, quantity, profit/loss, and optional notes.\n        The tooltip is designed to be informative and easy to read when displayed\n        on charts.\n\n        Returns:\n            str: Formatted tooltip text with trade details and P&amp;L information.\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                quantity=100,\n                trade_type=TradeType.LONG,\n            )\n            tooltip = trade.generate_tooltip_text()\n            # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n            ```\n        \"\"\"\n        # Step 1: Calculate profit/loss metrics for tooltip display\n        # Uses the pnl and pnl_percentage properties which check additional_data first\n        pnl = self.pnl\n        pnl_pct = self.pnl_percentage\n\n        # Step 2: Determine win/loss label based on P&amp;L value\n        # Positive P&amp;L = Win, negative or zero = Loss\n        win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n        # Step 3: Build tooltip components with formatted trade information\n        # Start with core entry/exit prices (always shown)\n        tooltip_parts = [\n            f\"Entry: {self.entry_price:.2f}\",\n            f\"Exit: {self.exit_price:.2f}\",\n        ]\n\n        # Step 4: Add quantity if available in additional_data\n        # Quantity is optional and only shown if user provided it\n        if self.additional_data and \"quantity\" in self.additional_data:\n            tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n        # Step 5: Add P&amp;L information (always shown)\n        # Shows both absolute P&amp;L and percentage for complete picture\n        tooltip_parts.extend(\n            [\n                f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n                f\"{win_loss}\",\n            ],\n        )\n\n        # Step 6: Add custom notes if provided for additional context\n        # Notes are optional and only shown if user provided them\n        if self.additional_data and \"notes\" in self.additional_data:\n            tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n        # Step 7: Join all parts with newlines for multi-line tooltip display\n        return \"\\n\".join(tooltip_parts)\n\n    @property\n    def pnl(self) -&gt; float:\n        \"\"\"Get profit/loss amount from additional_data or calculate basic price difference.\n\n        First checks if P&amp;L is provided in additional_data, otherwise calculates\n        basic price difference. This allows users to provide their own P&amp;L calculation\n        logic while maintaining a fallback for basic visualization.\n\n        Returns:\n            float: Profit/loss amount. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl\n            trade = TradeData(..., additional_data={\"pnl\": 500.0})\n            trade.pnl  # Returns: 500.0\n\n            # Without additional_data, calculates basic difference\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl  # Returns: 5.0 (basic price difference)\n            ```\n        \"\"\"\n        # Check if P&amp;L is provided in additional_data dictionary\n        # User may provide custom P&amp;L calculation (e.g., accounting for fees, quantity)\n        if self.additional_data and \"pnl\" in self.additional_data:\n            return float(self.additional_data[\"pnl\"])\n\n        # Fallback: Calculate basic price difference for visualization\n        # Simple formula: exit_price - entry_price (doesn't account for quantity or fees)\n        return float(self.exit_price - self.entry_price)\n\n    @property\n    def pnl_percentage(self) -&gt; float:\n        \"\"\"Get profit/loss percentage from additional_data or calculate basic percentage.\n\n        First checks if P&amp;L percentage is provided in additional_data, otherwise\n        calculates basic percentage based on price difference relative to entry price.\n\n        Returns:\n            float: Profit/loss percentage. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl_percentage\n            trade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\n            trade.pnl_percentage  # Returns: 5.0\n\n            # Without additional_data, calculates basic percentage\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl_percentage  # Returns: 5.0 (5% gain)\n            ```\n        \"\"\"\n        # Check if P&amp;L percentage is provided in additional_data dictionary\n        # User may provide custom percentage calculation\n        if self.additional_data and \"pnl_percentage\" in self.additional_data:\n            return float(self.additional_data[\"pnl_percentage\"])\n\n        # Fallback: Calculate basic percentage from price difference\n        # Formula: ((exit - entry) / entry) * 100\n        if self.entry_price != 0:\n            return ((self.exit_price - self.entry_price) / self.entry_price) * 100\n\n        # Edge case: Return 0.0 if entry price is zero to avoid division by zero\n        return 0.0\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n        Converts the trade to a dictionary format suitable for frontend\n        communication. Converts times to UTC timestamps at serialization time\n        to handle any changes made to entry_time or exit_time after construction.\n\n        Returns:\n            Dict[str, Any]: Serialized trade with camelCase keys ready for\n                frontend consumption. Contains:\n                - entryTime: Entry timestamp (converted from entry_time)\n                - entryPrice: Entry price\n                - exitTime: Exit timestamp (converted from exit_time)\n                - exitPrice: Exit price\n                - isProfitable: Profitability status\n                - pnl: Profit/loss amount (from additional_data or calculated)\n                - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n                - All fields from additional_data (merged for template access)\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                is_profitable=True,\n                additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n            )\n\n            result = trade.asdict()\n            # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n            #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n            #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n            ```\n        \"\"\"\n        # Step 1: Convert times to UTC timestamps at serialization time\n        # This ensures we always use current entry_time/exit_time values\n        entry_timestamp = to_utc_timestamp(self.entry_time)\n        exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # Step 2: Create base trade dictionary with core fields\n        # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n        trade_dict = {\n            \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n            \"entryPrice\": self.entry_price,  # Entry price as float\n            \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n            \"exitPrice\": self.exit_price,  # Exit price as float\n            \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n            \"id\": self.id,  # Unique trade identifier (required)\n            \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n            \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n        }\n\n        # Step 3: Merge additional data into the trade dict for template access\n        # This allows frontend templates to access custom fields like quantity, notes, etc.\n        if self.additional_data:\n            trade_dict.update(self.additional_data)\n\n        return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.pnl","title":"pnl  <code>property</code>","text":"<pre><code>pnl: float\n</code></pre> <p>Get profit/loss amount from additional_data or calculate basic price difference.</p> <p>First checks if P&amp;L is provided in additional_data, otherwise calculates basic price difference. This allows users to provide their own P&amp;L calculation logic while maintaining a fallback for basic visualization.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss amount. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl\ntrade = TradeData(..., additional_data={\"pnl\": 500.0})\ntrade.pnl  # Returns: 500.0\n\n# Without additional_data, calculates basic difference\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl  # Returns: 5.0 (basic price difference)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.pnl_percentage","title":"pnl_percentage  <code>property</code>","text":"<pre><code>pnl_percentage: float\n</code></pre> <p>Get profit/loss percentage from additional_data or calculate basic percentage.</p> <p>First checks if P&amp;L percentage is provided in additional_data, otherwise calculates basic percentage based on price difference relative to entry price.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss percentage. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl_percentage\ntrade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\ntrade.pnl_percentage  # Returns: 5.0\n\n# Without additional_data, calculates basic percentage\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl_percentage  # Returns: 5.0 (5% gain)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.generate_tooltip_text","title":"generate_tooltip_text","text":"<pre><code>generate_tooltip_text() -&gt; str\n</code></pre> <p>Generate tooltip text for the trade.</p> <pre><code>    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\n</code></pre> <p>Exit: 105.00 Qty: 100.00 P&amp;L: 500.00 (5.0%) Win\"             ```</p> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def generate_tooltip_text(self) -&gt; str:\n    \"\"\"Generate tooltip text for the trade.\n\n    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n        ```\n    \"\"\"\n    # Step 1: Calculate profit/loss metrics for tooltip display\n    # Uses the pnl and pnl_percentage properties which check additional_data first\n    pnl = self.pnl\n    pnl_pct = self.pnl_percentage\n\n    # Step 2: Determine win/loss label based on P&amp;L value\n    # Positive P&amp;L = Win, negative or zero = Loss\n    win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n    # Step 3: Build tooltip components with formatted trade information\n    # Start with core entry/exit prices (always shown)\n    tooltip_parts = [\n        f\"Entry: {self.entry_price:.2f}\",\n        f\"Exit: {self.exit_price:.2f}\",\n    ]\n\n    # Step 4: Add quantity if available in additional_data\n    # Quantity is optional and only shown if user provided it\n    if self.additional_data and \"quantity\" in self.additional_data:\n        tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n    # Step 5: Add P&amp;L information (always shown)\n    # Shows both absolute P&amp;L and percentage for complete picture\n    tooltip_parts.extend(\n        [\n            f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n            f\"{win_loss}\",\n        ],\n    )\n\n    # Step 6: Add custom notes if provided for additional context\n    # Notes are optional and only shown if user provided them\n    if self.additional_data and \"notes\" in self.additional_data:\n        tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n    # Step 7: Join all parts with newlines for multi-line tooltip display\n    return \"\\n\".join(tooltip_parts)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the trade data to a dict with camelCase keys for frontend.</p> <p>Converts the trade to a dictionary format suitable for frontend communication. Converts times to UTC timestamps at serialization time to handle any changes made to entry_time or exit_time after construction.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized trade with camelCase keys ready for frontend consumption. Contains: - entryTime: Entry timestamp (converted from entry_time) - entryPrice: Entry price - exitTime: Exit timestamp (converted from exit_time) - exitPrice: Exit price - isProfitable: Profitability status - pnl: Profit/loss amount (from additional_data or calculated) - pnlPercentage: Profit/loss percentage (from additional_data or calculated) - All fields from additional_data (merged for template access)</p> Example <pre><code>trade = TradeData(\n    entry_time=\"2024-01-01\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01\",\n    exit_price=105.0,\n    is_profitable=True,\n    additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n)\n\nresult = trade.asdict()\n# Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n#          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n#          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n    Converts the trade to a dictionary format suitable for frontend\n    communication. Converts times to UTC timestamps at serialization time\n    to handle any changes made to entry_time or exit_time after construction.\n\n    Returns:\n        Dict[str, Any]: Serialized trade with camelCase keys ready for\n            frontend consumption. Contains:\n            - entryTime: Entry timestamp (converted from entry_time)\n            - entryPrice: Entry price\n            - exitTime: Exit timestamp (converted from exit_time)\n            - exitPrice: Exit price\n            - isProfitable: Profitability status\n            - pnl: Profit/loss amount (from additional_data or calculated)\n            - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n            - All fields from additional_data (merged for template access)\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            is_profitable=True,\n            additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n        )\n\n        result = trade.asdict()\n        # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n        #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n        #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n        ```\n    \"\"\"\n    # Step 1: Convert times to UTC timestamps at serialization time\n    # This ensures we always use current entry_time/exit_time values\n    entry_timestamp = to_utc_timestamp(self.entry_time)\n    exit_timestamp = to_utc_timestamp(self.exit_time)\n\n    # Step 2: Create base trade dictionary with core fields\n    # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n    trade_dict = {\n        \"entryTime\": entry_timestamp,  # Normalized UTC timestamp\n        \"entryPrice\": self.entry_price,  # Entry price as float\n        \"exitTime\": exit_timestamp,  # Normalized UTC timestamp\n        \"exitPrice\": self.exit_price,  # Exit price as float\n        \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n        \"id\": self.id,  # Unique trade identifier (required)\n        \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n        \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n    }\n\n    # Step 3: Merge additional data into the trade dict for template access\n    # This allows frontend templates to access custom fields like quantity, notes, etc.\n    if self.additional_data:\n        trade_dict.update(self.additional_data)\n\n    return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html","title":"streamlit_lightweight_charts_pro.data.trend_fill","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill","title":"trend_fill","text":"<p>Trend fill data classes for streamlit-lightweight-charts.</p> <p>This module provides TrendFillData class for creating trend-based fill charts that display fills between trend lines and base lines, similar to Supertrend indicators with dynamic trend-colored backgrounds.</p> <p>The class now uses a simplified approach with a single trendLine field: - Uptrend (+1): Shows trend line above price, base line for reference - Downtrend (-1): Shows trend line below price, base line for reference - Neutral (0): No trend line displayed</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData","title":"TrendFillData  <code>dataclass</code>","text":"<p>Trend fill data for lightweight charts.</p> <p>This data class represents a single data point for trend fill charts, with simplified trend line handling:</p> <ul> <li>Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference</li> <li>Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference</li> <li>Neutral (0): No trend line displayed</li> </ul> <p>The fill area is created between the trend line and base line, with colors automatically selected based on trend direction.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Any</code> <p>Time value for the data point</p> <code>baseLine</code> <code>Any</code> <p>Base line value (e.g., candle body midpoint, price level)</p> <code>trendLine</code> <code>Any</code> <p>Value of the trend line (used for both uptrend and downtrend)</p> <code>trendDirection</code> <code>Any</code> <p>Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)</p> <code>uptrendFillColor</code> <code>Any</code> <p>Optional custom uptrend fill color</p> <code>downtrendFillColor</code> <code>Any</code> <p>Optional custom downtrend fill color</p> Source code in <code>streamlit_lightweight_charts_pro/data/trend_fill.py</code> <pre><code>@dataclass\nclass TrendFillData(Data):\n    \"\"\"Trend fill data for lightweight charts.\n\n    This data class represents a single data point for trend fill charts,\n    with simplified trend line handling:\n\n    - Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference\n    - Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference\n    - Neutral (0): No trend line displayed\n\n    The fill area is created between the trend line and base line,\n    with colors automatically selected based on trend direction.\n\n    Attributes:\n        time: Time value for the data point\n        baseLine: Base line value (e.g., candle body midpoint, price level)\n        trendLine: Value of the trend line (used for both uptrend and downtrend)\n        trendDirection: Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)\n\n        # Fill color fields\n        uptrendFillColor: Optional custom uptrend fill color\n        downtrendFillColor: Optional custom downtrend fill color\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"base_line\", \"trend_line\", \"trend_direction\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"uptrend_fill_color\",\n        \"downtrend_fill_color\",\n    }\n\n    # Core fields\n    base_line: float = 0\n    trend_line: float = 0\n    trend_direction: int = 0\n\n    # Fill color fields\n    uptrend_fill_color: Optional[str] = None\n    downtrend_fill_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Validate and process data after initialization.\"\"\"\n        super().__post_init__()\n\n        # Handle NaN values for trend line fields\n        if isinstance(self.trend_line, float) and math.isnan(self.trend_line):\n            self.trend_line = None\n        if isinstance(self.base_line, float) and math.isnan(self.base_line):\n            self.base_line = None\n\n        # Validate trend_direction\n        if not isinstance(self.trend_direction, int):\n            raise TrendDirectionIntegerError(\n                \"trend_direction\",\n                \"integer\",\n                type(self.trend_direction).__name__,\n            )\n\n        if self.trend_direction not in [-1, 0, 1]:\n            raise ValueValidationError(\"trend_direction\", \"must be -1, 0, or 1\")\n\n        # Validate fill colors if provided\n        if self.uptrend_fill_color is not None and not isinstance(self.uptrend_fill_color, str):\n            raise TypeValidationError(\"uptrend_fill_color\", \"string\")\n        if self.downtrend_fill_color is not None and not isinstance(self.downtrend_fill_color, str):\n            raise TypeValidationError(\"downtrend_fill_color\", \"string\")\n\n    @property\n    def is_uptrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents an uptrend.\"\"\"\n        return self.trend_direction == 1\n\n    @property\n    def is_downtrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents a downtrend.\"\"\"\n        return self.trend_direction == -1\n\n    @property\n    def is_neutral(self) -&gt; bool:\n        \"\"\"Check if this data point represents a neutral trend.\"\"\"\n        return self.trend_direction == 0\n\n    @property\n    def has_valid_fill_data(self) -&gt; bool:\n        \"\"\"Check if this data point has valid data for creating fills.\n\n        Returns True if we have a valid trend line and base line,\n        with the appropriate trend line based on direction.\n        \"\"\"\n        if self.trend_direction == 0 or self.base_line is None:\n            return False\n\n        # Check if we have a valid trend line\n        return self.trend_line is not None\n\n    @property\n    def has_valid_uptrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid uptrend fill data.\"\"\"\n        return (\n            self.base_line is not None and self.trend_direction == 1 and self.trend_line is not None\n        )\n\n    @property\n    def has_valid_downtrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid downtrend fill data.\"\"\"\n        return (\n            self.base_line is not None\n            and self.trend_direction == -1\n            and self.trend_line is not None\n        )\n\n    @property\n    def active_trend_line(self) -&gt; Optional[float]:\n        \"\"\"Get the active trend line value based on trend direction.\n\n        Returns the trend line value for the current trend direction:\n        - Uptrend (+1): Returns trend_line (trend line above price)\n        - Downtrend (-1): Returns trend_line (trend line below price)\n        \"\"\"\n        if self.trend_direction in [1, -1]:  # Both uptrend and downtrend use trend_line\n            return self.trend_line\n        return None\n\n    @property\n    def active_fill_color(self) -&gt; Optional[str]:\n        \"\"\"Get the active fill color based on trend direction.\n\n        Returns the appropriate fill color for the current trend direction,\n        prioritizing direction-specific colors.\n        \"\"\"\n        if self.trend_direction == 1:  # Uptrend\n            return self.uptrend_fill_color\n        if self.trend_direction == -1:  # Downtrend\n            return self.downtrend_fill_color\n        return None\n\n    @property\n    def trend_line_type(self) -&gt; Optional[str]:\n        \"\"\"Get the type of trend line being displayed.\n\n        Returns:\n            'upper' for uptrend (trend line above price)\n            'lower' for downtrend (trend line below price)\n            None for neutral\n        \"\"\"\n        if self.trend_direction == 1:\n            return \"upper\"\n        if self.trend_direction == -1:\n            return \"lower\"\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_uptrend","title":"is_uptrend  <code>property</code>","text":"<pre><code>is_uptrend: bool\n</code></pre> <p>Check if this data point represents an uptrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_downtrend","title":"is_downtrend  <code>property</code>","text":"<pre><code>is_downtrend: bool\n</code></pre> <p>Check if this data point represents a downtrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_neutral","title":"is_neutral  <code>property</code>","text":"<pre><code>is_neutral: bool\n</code></pre> <p>Check if this data point represents a neutral trend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_fill_data","title":"has_valid_fill_data  <code>property</code>","text":"<pre><code>has_valid_fill_data: bool\n</code></pre> <p>Check if this data point has valid data for creating fills.</p> <p>Returns True if we have a valid trend line and base line, with the appropriate trend line based on direction.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_uptrend_fill","title":"has_valid_uptrend_fill  <code>property</code>","text":"<pre><code>has_valid_uptrend_fill: bool\n</code></pre> <p>Check if this data point has valid uptrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_downtrend_fill","title":"has_valid_downtrend_fill  <code>property</code>","text":"<pre><code>has_valid_downtrend_fill: bool\n</code></pre> <p>Check if this data point has valid downtrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.active_trend_line","title":"active_trend_line  <code>property</code>","text":"<pre><code>active_trend_line: Optional[float]\n</code></pre> <p>Get the active trend line value based on trend direction.</p> <p>Returns the trend line value for the current trend direction: - Uptrend (+1): Returns trend_line (trend line above price) - Downtrend (-1): Returns trend_line (trend line below price)</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.active_fill_color","title":"active_fill_color  <code>property</code>","text":"<pre><code>active_fill_color: Optional[str]\n</code></pre> <p>Get the active fill color based on trend direction.</p> <p>Returns the appropriate fill color for the current trend direction, prioritizing direction-specific colors.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.trend_line_type","title":"trend_line_type  <code>property</code>","text":"<pre><code>trend_line_type: Optional[str]\n</code></pre> <p>Get the type of trend line being displayed.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>'upper' for uptrend (trend line above price)</p> <code>Optional[str]</code> <p>'lower' for downtrend (trend line below price)</p> <code>Optional[str]</code> <p>None for neutral</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html","title":"streamlit_lightweight_charts_pro.type_definitions","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions","title":"type_definitions","text":"<p>Type definitions for Streamlit Lightweight Charts Pro.</p> <p>This module provides type definitions, enums, and color classes used throughout the charting library. It includes enumerations for chart configuration options, color definitions, and other type-safe constants.</p> The module exports <ul> <li>Enums: ChartType, LineStyle, MarkerShape, etc.</li> <li>Color classes: Background, BackgroundSolid, BackgroundGradient</li> <li>Position and alignment enums: AnnotationPosition, HorzAlign, VertAlign</li> <li>Trade-related enums: TradeType, TradeVisualization</li> </ul> <p>These type definitions ensure consistency and type safety across the library, providing clear interfaces for chart configuration and data handling.</p> Example Usage <pre><code>from streamlit_lightweight_charts_pro.type_definitions import (\n    ChartType,\n    LineStyle,\n    MarkerShape,\n    Background,\n)\n\n# Using enums for type safety\nchart_type = ChartType.CANDLESTICK\nline_style = LineStyle.SOLID\nmarker_shape = MarkerShape.CIRCLE\n\n# Using color classes\nbackground = BackgroundSolid(color=\"#ffffff\")\ngradient = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#f0f0f0\")\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.BackgroundGradient","title":"BackgroundGradient  <code>dataclass</code>","text":"<p>Gradient background configuration.</p> <p>This class represents a gradient background for charts, transitioning from a top color to a bottom color. It provides type safety and validation for both color values.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>top_color</code> <code>str</code> <p>The top color string in any valid CSS format. Defaults to white.</p> <code>bottom_color</code> <code>str</code> <p>The bottom color string in any valid CSS format. Defaults to black.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to VERTICAL_GRADIENT for this class.</p> Example <pre><code># Create a white to black gradient\nbg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n# Create a blue to red gradient\nbg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either color format is invalid.</p> Note <p>Both top_color and bottom_color are validated during initialization using the _is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundGradient(Options, ABC):\n    \"\"\"Gradient background configuration.\n\n    This class represents a gradient background for charts, transitioning\n    from a top color to a bottom color. It provides type safety and\n    validation for both color values.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        top_color: The top color string in any valid CSS format. Defaults to white.\n        bottom_color: The bottom color string in any valid CSS format. Defaults to black.\n        style: The background style, always set to VERTICAL_GRADIENT for this class.\n\n    Example:\n        ```python\n        # Create a white to black gradient\n        bg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n        # Create a blue to red gradient\n        bg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If either color format is invalid.\n\n    Note:\n        Both top_color and bottom_color are validated during initialization\n        using the _is_valid_color function.\n    \"\"\"\n\n    top_color: str = \"#ffffff\"\n    bottom_color: str = \"#000000\"\n    style: BackgroundStyle = BackgroundStyle.VERTICAL_GRADIENT\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates both color formats after the dataclass is initialized.\n        Raises a ValueError if either color is not in a valid format.\n\n        Raises:\n            ValueError: If either color format is invalid.\n        \"\"\"\n        # Validate the top color format using the comprehensive validation function\n        # This ensures that the top color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.top_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the top color\n            raise ColorValidationError(\"top_color\", self.top_color)\n\n        # Validate the bottom color format using the comprehensive validation function\n        # This ensures that the bottom color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.bottom_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the bottom color\n            raise ColorValidationError(\"bottom_color\", self.bottom_color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.BackgroundSolid","title":"BackgroundSolid  <code>dataclass</code>","text":"<p>Solid background color configuration.</p> <p>This class represents a solid color background for charts. It provides type safety and validation for color values, ensuring that only valid color formats are accepted.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>The color string in any valid CSS format. Defaults to white.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to SOLID for this class.</p> Example <pre><code># Create a solid white background\nbg = BackgroundSolid(color=\"#ffffff\")\n\n# Create a solid red background\nbg = BackgroundSolid(color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color format is invalid.</p> Note <p>The color attribute is validated during initialization using the is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundSolid(Options, ABC):\n    \"\"\"Solid background color configuration.\n\n    This class represents a solid color background for charts. It provides\n    type safety and validation for color values, ensuring that only valid\n    color formats are accepted.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        color: The color string in any valid CSS format. Defaults to white.\n        style: The background style, always set to SOLID for this class.\n\n    Example:\n        ```python\n        # Create a solid white background\n        bg = BackgroundSolid(color=\"#ffffff\")\n\n        # Create a solid red background\n        bg = BackgroundSolid(color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If the color format is invalid.\n\n    Note:\n        The color attribute is validated during initialization using\n        the is_valid_color function.\n    \"\"\"\n\n    color: str = \"#ffffff\"\n    style: BackgroundStyle = BackgroundStyle.SOLID\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates the color format after the dataclass is initialized.\n        Raises a ValueError if the color is not in a valid format.\n\n        Raises:\n            ValueError: If the color format is invalid.\n        \"\"\"\n        # Validate the color format using the comprehensive validation function\n        # This ensures that only valid CSS color formats are accepted\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong during initialization\n            raise ColorValidationError(\"color\", self.color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.AnnotationPosition","title":"AnnotationPosition","text":"<p>Annotation position enumeration.</p> <p>Defines where annotations should be positioned relative to the data point or price level on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE</code> <p>Position annotation above the data point.</p> <code>BELOW</code> <p>Position annotation below the data point.</p> <code>INLINE</code> <p>Position annotation inline with the data point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationPosition(str, Enum):\n    \"\"\"Annotation position enumeration.\n\n    Defines where annotations should be positioned relative to the data point\n    or price level on the chart.\n\n    Attributes:\n        ABOVE: Position annotation above the data point.\n        BELOW: Position annotation below the data point.\n        INLINE: Position annotation inline with the data point.\n    \"\"\"\n\n    ABOVE = \"above\"\n    BELOW = \"below\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.AnnotationType","title":"AnnotationType","text":"<p>Annotation type enumeration.</p> <p>Defines the available types of annotations that can be placed on charts to mark important points, draw shapes, or add visual indicators.</p> <p>Attributes:</p> Name Type Description <code>TEXT</code> <p>Text annotation - displays text at a specific location.</p> <code>ARROW</code> <p>Arrow annotation - points to a specific location with an arrow.</p> <code>SHAPE</code> <p>Shape annotation - draws geometric shapes (circles, squares, etc.).</p> <code>LINE</code> <p>Line annotation - draws horizontal or vertical lines.</p> <code>RECTANGLE</code> <p>Rectangle annotation - draws rectangular shapes.</p> <code>CIRCLE</code> <p>Circle annotation - draws circular shapes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationType(str, Enum):\n    \"\"\"Annotation type enumeration.\n\n    Defines the available types of annotations that can be placed on charts\n    to mark important points, draw shapes, or add visual indicators.\n\n    Attributes:\n        TEXT: Text annotation - displays text at a specific location.\n        ARROW: Arrow annotation - points to a specific location with an arrow.\n        SHAPE: Shape annotation - draws geometric shapes (circles, squares, etc.).\n        LINE: Line annotation - draws horizontal or vertical lines.\n        RECTANGLE: Rectangle annotation - draws rectangular shapes.\n        CIRCLE: Circle annotation - draws circular shapes.\n    \"\"\"\n\n    TEXT = \"text\"\n    ARROW = \"arrow\"\n    SHAPE = \"shape\"\n    LINE = \"line\"\n    RECTANGLE = \"rectangle\"\n    CIRCLE = \"circle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.ChartType","title":"ChartType","text":"<p>Chart type enumeration.</p> <p>Defines the available chart types that can be created and rendered. Each chart type corresponds to a specific visualization style and data format requirements.</p> <p>Attributes:</p> Name Type Description <code>AREA</code> <p>Area chart - filled area below a line.</p> <code>BAND</code> <p>Band chart - multiple lines with fill areas (e.g., Bollinger Bands).</p> <code>BASELINE</code> <p>Baseline chart - values relative to a baseline.</p> <code>HISTOGRAM</code> <p>Histogram chart - bar chart for volume or distribution.</p> <code>LINE</code> <p>Line chart - simple line connecting data points.</p> <code>BAR</code> <p>Bar chart - OHLC bars for price data.</p> <code>CANDLESTICK</code> <p>Candlestick chart - traditional Japanese candlesticks.</p> <code>RIBBON</code> <p>Ribbon chart - upper and lower bands with fill areas.</p> <code>GRADIENT_RIBBON</code> <p>Gradient ribbon chart - ribbon with gradient fills.</p> <code>TREND_FILL</code> <p>Trend fill chart - fills between trend lines and candle body midpoints.</p> <code>SIGNAL</code> <p>Signal chart - background coloring based on signal values.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ChartType(str, Enum):\n    \"\"\"Chart type enumeration.\n\n    Defines the available chart types that can be created and rendered.\n    Each chart type corresponds to a specific visualization style and\n    data format requirements.\n\n    Attributes:\n        AREA: Area chart - filled area below a line.\n        BAND: Band chart - multiple lines with fill areas (e.g., Bollinger Bands).\n        BASELINE: Baseline chart - values relative to a baseline.\n        HISTOGRAM: Histogram chart - bar chart for volume or distribution.\n        LINE: Line chart - simple line connecting data points.\n        BAR: Bar chart - OHLC bars for price data.\n        CANDLESTICK: Candlestick chart - traditional Japanese candlesticks.\n        RIBBON: Ribbon chart - upper and lower bands with fill areas.\n        GRADIENT_RIBBON: Gradient ribbon chart - ribbon with gradient fills.\n        TREND_FILL: Trend fill chart - fills between trend lines and candle body midpoints.\n        SIGNAL: Signal chart - background coloring based on signal values.\n    \"\"\"\n\n    AREA = \"area\"\n    BAND = \"band\"\n    BASELINE = \"baseline\"\n    HISTOGRAM = \"histogram\"\n    LINE = \"line\"\n    BAR = \"bar\"\n    CANDLESTICK = \"candlestick\"\n    RIBBON = \"ribbon\"\n    GRADIENT_RIBBON = \"gradient_ribbon\"\n    TREND_FILL = \"trend_fill\"\n    SIGNAL = \"signal\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.ColorType","title":"ColorType","text":"<p>Color type enumeration.</p> <p>Defines how colors should be applied to chart elements. Controls whether colors are solid or use gradient effects.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid color - uniform color across the element.</p> <code>VERTICAL_GRADIENT</code> <p>Vertical gradient - color gradient from top to bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColorType(str, Enum):\n    \"\"\"Color type enumeration.\n\n    Defines how colors should be applied to chart elements.\n    Controls whether colors are solid or use gradient effects.\n\n    Attributes:\n        SOLID: Solid color - uniform color across the element.\n        VERTICAL_GRADIENT: Vertical gradient - color gradient from top to bottom.\n    \"\"\"\n\n    SOLID = \"solid\"\n    VERTICAL_GRADIENT = \"gradient\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.ColumnNames","title":"ColumnNames","text":"<p>Column name enumeration for DataFrame integration.</p> <p>Defines the standard column names used when converting pandas DataFrames to chart data. These names ensure consistent mapping between DataFrame columns and chart data fields.</p> <p>Attributes:</p> Name Type Description <code>TIME</code> <p>Time or datetime column.</p> <code>OPEN</code> <p>Open price column (for OHLC data).</p> <code>HIGH</code> <p>High price column (for OHLC data).</p> <code>LOW</code> <p>Low price column (for OHLC data).</p> <code>CLOSE</code> <p>Close price column (for OHLC data).</p> <code>VOLUME</code> <p>Volume column (for OHLCV data).</p> <code>DATETIME</code> <p>Datetime column (alternative to TIME).</p> <code>VALUE</code> <p>Value column (for single-value data like line charts).</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColumnNames(str, Enum):\n    \"\"\"Column name enumeration for DataFrame integration.\n\n    Defines the standard column names used when converting pandas DataFrames\n    to chart data. These names ensure consistent mapping between DataFrame\n    columns and chart data fields.\n\n    Attributes:\n        TIME: Time or datetime column.\n        OPEN: Open price column (for OHLC data).\n        HIGH: High price column (for OHLC data).\n        LOW: Low price column (for OHLC data).\n        CLOSE: Close price column (for OHLC data).\n        VOLUME: Volume column (for OHLCV data).\n        DATETIME: Datetime column (alternative to TIME).\n        VALUE: Value column (for single-value data like line charts).\n    \"\"\"\n\n    TIME = \"time\"\n    OPEN = \"open\"\n    HIGH = \"high\"\n    LOW = \"low\"\n    CLOSE = \"close\"\n    VOLUME = \"volume\"\n    DATETIME = \"datetime\"\n    VALUE = \"value\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.CrosshairMode","title":"CrosshairMode","text":"<p>Crosshair mode enumeration.</p> <p>Defines how the crosshair behaves when hovering over the chart. Controls whether the crosshair snaps to data points or moves freely.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal mode - crosshair moves freely across the chart.</p> <code>MAGNET</code> <p>Magnet mode - crosshair snaps to nearest data points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class CrosshairMode(IntEnum):\n    \"\"\"Crosshair mode enumeration.\n\n    Defines how the crosshair behaves when hovering over the chart.\n    Controls whether the crosshair snaps to data points or moves freely.\n\n    Attributes:\n        NORMAL: Normal mode - crosshair moves freely across the chart.\n        MAGNET: Magnet mode - crosshair snaps to nearest data points.\n    \"\"\"\n\n    NORMAL = 0\n    MAGNET = 1\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.HorzAlign","title":"HorzAlign","text":"<p>Horizontal alignment enumeration.</p> <p>Defines horizontal text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left alignment - text aligned to the left.</p> <code>CENTER</code> <p>Center alignment - text centered horizontally.</p> <code>RIGHT</code> <p>Right alignment - text aligned to the right.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class HorzAlign(str, Enum):\n    \"\"\"Horizontal alignment enumeration.\n\n    Defines horizontal text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        LEFT: Left alignment - text aligned to the left.\n        CENTER: Center alignment - text centered horizontally.\n        RIGHT: Right alignment - text aligned to the right.\n    \"\"\"\n\n    LEFT = \"left\"\n    CENTER = \"center\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.LastPriceAnimationMode","title":"LastPriceAnimationMode","text":"<p>Last price animation mode enumeration.</p> <p>Defines how the last price line should be animated when new data is added to the chart.</p> <p>Attributes:</p> Name Type Description <code>DISABLED</code> <p>No animation - last price line updates instantly.</p> <code>CONTINUOUS</code> <p>Continuous animation - smooth transitions for all updates.</p> <code>ON_DATA_UPDATE</code> <p>Update animation - animation only when new data arrives.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LastPriceAnimationMode(IntEnum):\n    \"\"\"Last price animation mode enumeration.\n\n    Defines how the last price line should be animated when new data\n    is added to the chart.\n\n    Attributes:\n        DISABLED: No animation - last price line updates instantly.\n        CONTINUOUS: Continuous animation - smooth transitions for all updates.\n        ON_DATA_UPDATE: Update animation - animation only when new data arrives.\n    \"\"\"\n\n    DISABLED = 0\n    CONTINUOUS = 1\n    ON_DATA_UPDATE = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.LineStyle","title":"LineStyle","text":"<p>Line style enumeration.</p> <p>Defines the visual style of lines in charts, including borders, grid lines, and series lines.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid line - continuous line without breaks.</p> <code>DOTTED</code> <p>Dotted line - series of dots.</p> <code>DASHED</code> <p>Dashed line - series of short dashes.</p> <code>LARGE_DASHED</code> <p>Large dashed line - series of long dashes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineStyle(IntEnum):\n    \"\"\"Line style enumeration.\n\n    Defines the visual style of lines in charts, including borders,\n    grid lines, and series lines.\n\n    Attributes:\n        SOLID: Solid line - continuous line without breaks.\n        DOTTED: Dotted line - series of dots.\n        DASHED: Dashed line - series of short dashes.\n        LARGE_DASHED: Large dashed line - series of long dashes.\n    \"\"\"\n\n    SOLID = 0\n    DOTTED = 1\n    DASHED = 2\n    LARGE_DASHED = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.LineType","title":"LineType","text":"<p>Line type enumeration.</p> <p>Defines how lines should be drawn between data points. Controls the interpolation method used for line series.</p> <p>Attributes:</p> Name Type Description <code>SIMPLE</code> <p>Simple line - straight lines between points.</p> <code>CURVED</code> <p>Curved line - smooth curves between points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineType(IntEnum):\n    \"\"\"Line type enumeration.\n\n    Defines how lines should be drawn between data points.\n    Controls the interpolation method used for line series.\n\n    Attributes:\n        SIMPLE: Simple line - straight lines between points.\n        CURVED: Curved line - smooth curves between points.\n    \"\"\"\n\n    SIMPLE = 0\n    WITH_STEPS = 1\n    CURVED = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.MarkerPosition","title":"MarkerPosition","text":"<p>Marker position enumeration for chart markers.</p> <p>Defines where markers should be positioned relative to the data bars or points on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE_BAR</code> <p>Position marker above the data bar/point.</p> <code>BELOW_BAR</code> <p>Position marker below the data bar/point.</p> <code>IN_BAR</code> <p>Position marker inside the data bar/point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerPosition(str, Enum):\n    \"\"\"Marker position enumeration for chart markers.\n\n    Defines where markers should be positioned relative to the data bars\n    or points on the chart.\n\n    Attributes:\n        ABOVE_BAR: Position marker above the data bar/point.\n        BELOW_BAR: Position marker below the data bar/point.\n        IN_BAR: Position marker inside the data bar/point.\n    \"\"\"\n\n    ABOVE_BAR = \"aboveBar\"\n    BELOW_BAR = \"belowBar\"\n    IN_BAR = \"inBar\"\n    AT_PRICE_TOP = \"atPriceTop\"\n    AT_PRICE_BOTTOM = \"atPriceBottom\"\n    AT_PRICE_MIDDLE = \"atPriceMiddle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.MarkerShape","title":"MarkerShape","text":"<p>Marker shape enumeration for chart markers.</p> <p>Defines the available shapes for chart markers that can be displayed on charts to highlight specific data points or events.</p> <p>Attributes:</p> Name Type Description <code>CIRCLE</code> <p>Circular marker shape.</p> <code>SQUARE</code> <p>Square marker shape.</p> <code>ARROW_UP</code> <p>Upward-pointing arrow marker.</p> <code>ARROW_DOWN</code> <p>Downward-pointing arrow marker.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerShape(str, Enum):\n    \"\"\"Marker shape enumeration for chart markers.\n\n    Defines the available shapes for chart markers that can be displayed\n    on charts to highlight specific data points or events.\n\n    Attributes:\n        CIRCLE: Circular marker shape.\n        SQUARE: Square marker shape.\n        ARROW_UP: Upward-pointing arrow marker.\n        ARROW_DOWN: Downward-pointing arrow marker.\n    \"\"\"\n\n    CIRCLE = \"circle\"\n    SQUARE = \"square\"\n    ARROW_UP = \"arrowUp\"\n    ARROW_DOWN = \"arrowDown\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.PriceScaleMode","title":"PriceScaleMode","text":"<p>Price scale mode enumeration.</p> <p>Defines how the price scale (y-axis) should be displayed and calculated. Controls the scale type and reference point for price values.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal scale - linear price scale.</p> <code>LOGARITHMIC</code> <p>Logarithmic scale - log-based price scale.</p> <code>PERCENTAGE</code> <p>Percentage scale - values as percentages.</p> <code>INDEXED_TO_100</code> <p>Indexed scale - values relative to 100.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class PriceScaleMode(IntEnum):\n    \"\"\"Price scale mode enumeration.\n\n    Defines how the price scale (y-axis) should be displayed and calculated.\n    Controls the scale type and reference point for price values.\n\n    Attributes:\n        NORMAL: Normal scale - linear price scale.\n        LOGARITHMIC: Logarithmic scale - log-based price scale.\n        PERCENTAGE: Percentage scale - values as percentages.\n        INDEXED_TO_100: Indexed scale - values relative to 100.\n    \"\"\"\n\n    NORMAL = 0\n    LOGARITHMIC = 1\n    PERCENTAGE = 2\n    INDEXED_TO_100 = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.TrackingActivationMode","title":"TrackingActivationMode","text":"<p>Tracking activation mode enumeration.</p> <p>Defines when the tracking mode should be activated.</p> <p>Attributes:</p> Name Type Description <code>ON_MOUSE_ENTER</code> <p>Activate tracking mode when mouse enters chart.</p> <code>ON_TOUCH_START</code> <p>Activate tracking mode when touch starts.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingActivationMode(str, Enum):\n    \"\"\"Tracking activation mode enumeration.\n\n    Defines when the tracking mode should be activated.\n\n    Attributes:\n        ON_MOUSE_ENTER: Activate tracking mode when mouse enters chart.\n        ON_TOUCH_START: Activate tracking mode when touch starts.\n    \"\"\"\n\n    ON_MOUSE_ENTER = \"ON_MOUSE_ENTER\"\n    ON_TOUCH_START = \"ON_TOUCH_START\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.TrackingExitMode","title":"TrackingExitMode","text":"<p>Tracking exit mode enumeration.</p> <p>Defines when the tracking mode should exit.</p> <p>Attributes:</p> Name Type Description <code>EXIT_ON_MOVE</code> <p>Exit tracking mode when mouse moves.</p> <code>EXIT_ON_CROSS</code> <p>Exit tracking mode when crosshair crosses series.</p> <code>NEVER_EXIT</code> <p>Never exit tracking mode automatically.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingExitMode(str, Enum):\n    \"\"\"Tracking exit mode enumeration.\n\n    Defines when the tracking mode should exit.\n\n    Attributes:\n        EXIT_ON_MOVE: Exit tracking mode when mouse moves.\n        EXIT_ON_CROSS: Exit tracking mode when crosshair crosses series.\n        NEVER_EXIT: Never exit tracking mode automatically.\n    \"\"\"\n\n    EXIT_ON_MOVE = \"EXIT_ON_MOVE\"\n    EXIT_ON_CROSS = \"EXIT_ON_CROSS\"\n    NEVER_EXIT = \"NEVER_EXIT\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.TradeType","title":"TradeType","text":"<p>Trade type enumeration.</p> <p>Defines the direction of a trade (long or short). Used for trade visualization and profit/loss calculations.</p> <p>Attributes:</p> Name Type Description <code>LONG</code> <p>Long trade - profit when price goes up.</p> <code>SHORT</code> <p>Short trade - profit when price goes down.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeType(str, Enum):\n    \"\"\"Trade type enumeration.\n\n    Defines the direction of a trade (long or short).\n    Used for trade visualization and profit/loss calculations.\n\n    Attributes:\n        LONG: Long trade - profit when price goes up.\n        SHORT: Short trade - profit when price goes down.\n    \"\"\"\n\n    LONG = \"long\"\n    SHORT = \"short\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.TradeVisualization","title":"TradeVisualization","text":"<p>Trade visualization style enumeration.</p> <p>Defines how trades should be visualized on the chart. Multiple visualization styles can be combined to create comprehensive trade displays.</p> <p>Attributes:</p> Name Type Description <code>MARKERS</code> <p>Display entry/exit markers only.</p> <code>RECTANGLES</code> <p>Display rectangle spanning from entry to exit.</p> <code>BOTH</code> <p>Display both markers and rectangles.</p> <code>LINES</code> <p>Display connecting lines between entry and exit.</p> <code>ARROWS</code> <p>Display directional arrows from entry to exit.</p> <code>ZONES</code> <p>Display colored zones with transparency around trades.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeVisualization(str, Enum):\n    \"\"\"Trade visualization style enumeration.\n\n    Defines how trades should be visualized on the chart.\n    Multiple visualization styles can be combined to create\n    comprehensive trade displays.\n\n    Attributes:\n        MARKERS: Display entry/exit markers only.\n        RECTANGLES: Display rectangle spanning from entry to exit.\n        BOTH: Display both markers and rectangles.\n        LINES: Display connecting lines between entry and exit.\n        ARROWS: Display directional arrows from entry to exit.\n        ZONES: Display colored zones with transparency around trades.\n    \"\"\"\n\n    MARKERS = \"markers\"  # Just entry/exit markers\n    RECTANGLES = \"rectangles\"  # Rectangle from entry to exit\n    BOTH = \"both\"  # Both markers and rectangles\n    LINES = \"lines\"  # Lines connecting entry to exit\n    ARROWS = \"arrows\"  # Arrows from entry to exit\n    ZONES = \"zones\"  # Colored zones with transparency\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/index.html#streamlit_lightweight_charts_pro.type_definitions.VertAlign","title":"VertAlign","text":"<p>Vertical alignment enumeration.</p> <p>Defines vertical text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>TOP</code> <p>Top alignment - text aligned to the top.</p> <code>CENTER</code> <p>Center alignment - text centered vertically.</p> <code>BOTTOM</code> <p>Bottom alignment - text aligned to the bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class VertAlign(str, Enum):\n    \"\"\"Vertical alignment enumeration.\n\n    Defines vertical text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        TOP: Top alignment - text aligned to the top.\n        CENTER: Center alignment - text centered vertically.\n        BOTTOM: Bottom alignment - text aligned to the bottom.\n    \"\"\"\n\n    TOP = \"top\"\n    CENTER = \"center\"\n    BOTTOM = \"bottom\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html","title":"streamlit_lightweight_charts_pro.type_definitions.colors","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors","title":"colors","text":"<p>Color-related classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides comprehensive background classes for chart backgrounds with proper validation and type safety. It includes classes for solid colors and gradient backgrounds, with extensive color format validation supporting hex, RGB/RGBA, and named colors commonly used in financial chart visualization.</p> The module provides <ul> <li>BackgroundSolid: For solid color backgrounds with validation</li> <li>BackgroundGradient: For gradient backgrounds with color transitions</li> <li>Background: Union type for both background types</li> <li>Color validation utilities with comprehensive format support</li> <li>Background style enumeration for different rendering modes</li> </ul> <p>These classes ensure type safety, proper color formatting, and validation for chart backgrounds, with automatic validation during initialization and comprehensive error handling for invalid color formats.</p> Key Features <ul> <li>Comprehensive color format validation (hex, RGB, RGBA, named colors)</li> <li>Type-safe background configuration with validation</li> <li>Gradient support with top and bottom color specification</li> <li>Automatic color format normalization and validation</li> <li>Clear error messages for invalid color formats</li> <li>Support for transparency and alpha channels</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.type_definitions.colors import (\n    BackgroundSolid,\n    BackgroundGradient,\n    Background,\n)\n\n# Solid background with validation\nsolid_bg = BackgroundSolid(color=\"#ffffff\")\n\n# Gradient background with color transitions\ngradient_bg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#f0f0f0\")\n\n# Using with charts\nchart = Chart().set_background(solid_bg)\n</code></pre> Supported Color Formats <ul> <li>Hex: \"#FF0000\", \"#F00\" (3 or 6 digit hex codes)</li> <li>RGB: \"rgb(255, 0, 0)\" (with or without spaces)</li> <li>RGBA: \"rgba(255, 0, 0, 0.5)\" (with alpha channel support)</li> <li>Named colors: \"red\", \"blue\", \"white\", \"transparent\", etc.</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors.BackgroundSolid","title":"BackgroundSolid  <code>dataclass</code>","text":"<p>Solid background color configuration.</p> <p>This class represents a solid color background for charts. It provides type safety and validation for color values, ensuring that only valid color formats are accepted.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>The color string in any valid CSS format. Defaults to white.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to SOLID for this class.</p> Example <pre><code># Create a solid white background\nbg = BackgroundSolid(color=\"#ffffff\")\n\n# Create a solid red background\nbg = BackgroundSolid(color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color format is invalid.</p> Note <p>The color attribute is validated during initialization using the is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundSolid(Options, ABC):\n    \"\"\"Solid background color configuration.\n\n    This class represents a solid color background for charts. It provides\n    type safety and validation for color values, ensuring that only valid\n    color formats are accepted.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        color: The color string in any valid CSS format. Defaults to white.\n        style: The background style, always set to SOLID for this class.\n\n    Example:\n        ```python\n        # Create a solid white background\n        bg = BackgroundSolid(color=\"#ffffff\")\n\n        # Create a solid red background\n        bg = BackgroundSolid(color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If the color format is invalid.\n\n    Note:\n        The color attribute is validated during initialization using\n        the is_valid_color function.\n    \"\"\"\n\n    color: str = \"#ffffff\"\n    style: BackgroundStyle = BackgroundStyle.SOLID\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates the color format after the dataclass is initialized.\n        Raises a ValueError if the color is not in a valid format.\n\n        Raises:\n            ValueError: If the color format is invalid.\n        \"\"\"\n        # Validate the color format using the comprehensive validation function\n        # This ensures that only valid CSS color formats are accepted\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong during initialization\n            raise ColorValidationError(\"color\", self.color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors.BackgroundGradient","title":"BackgroundGradient  <code>dataclass</code>","text":"<p>Gradient background configuration.</p> <p>This class represents a gradient background for charts, transitioning from a top color to a bottom color. It provides type safety and validation for both color values.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>top_color</code> <code>str</code> <p>The top color string in any valid CSS format. Defaults to white.</p> <code>bottom_color</code> <code>str</code> <p>The bottom color string in any valid CSS format. Defaults to black.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to VERTICAL_GRADIENT for this class.</p> Example <pre><code># Create a white to black gradient\nbg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n# Create a blue to red gradient\nbg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either color format is invalid.</p> Note <p>Both top_color and bottom_color are validated during initialization using the _is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundGradient(Options, ABC):\n    \"\"\"Gradient background configuration.\n\n    This class represents a gradient background for charts, transitioning\n    from a top color to a bottom color. It provides type safety and\n    validation for both color values.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        top_color: The top color string in any valid CSS format. Defaults to white.\n        bottom_color: The bottom color string in any valid CSS format. Defaults to black.\n        style: The background style, always set to VERTICAL_GRADIENT for this class.\n\n    Example:\n        ```python\n        # Create a white to black gradient\n        bg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n        # Create a blue to red gradient\n        bg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If either color format is invalid.\n\n    Note:\n        Both top_color and bottom_color are validated during initialization\n        using the _is_valid_color function.\n    \"\"\"\n\n    top_color: str = \"#ffffff\"\n    bottom_color: str = \"#000000\"\n    style: BackgroundStyle = BackgroundStyle.VERTICAL_GRADIENT\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates both color formats after the dataclass is initialized.\n        Raises a ValueError if either color is not in a valid format.\n\n        Raises:\n            ValueError: If either color format is invalid.\n        \"\"\"\n        # Validate the top color format using the comprehensive validation function\n        # This ensures that the top color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.top_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the top color\n            raise ColorValidationError(\"top_color\", self.top_color)\n\n        # Validate the bottom color format using the comprehensive validation function\n        # This ensures that the bottom color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.bottom_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the bottom color\n            raise ColorValidationError(\"bottom_color\", self.bottom_color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html","title":"streamlit_lightweight_charts_pro.type_definitions.enums","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums","title":"enums","text":"<p>Enum definitions for streamlit-lightweight-charts.</p> <p>This module contains comprehensive enumeration types used throughout the library for defining chart types, styling options, configuration parameters, and behavior modes. These enums ensure type safety, provide a consistent interface for chart configuration, and enable IntelliSense support for better developer experience.</p> The module provides enums for <ul> <li>Chart types and visualization modes</li> <li>Color and styling options</li> <li>Line styles and types</li> <li>Crosshair and interaction modes</li> <li>Price scale and time scale configurations</li> <li>Marker positions and shapes</li> <li>Animation and tracking modes</li> </ul> <p>These enums are designed to be compatible with TradingView's Lightweight Charts library while providing a Python-native interface for configuration.</p> Key Features <ul> <li>Type-safe enum values with proper string/int representations</li> <li>Comprehensive coverage of all chart configuration options</li> <li>Clear documentation for each enum value</li> <li>Compatibility with frontend JavaScript enum values</li> <li>IntelliSense support for IDE autocompletion</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.type_definitions.enums import (\n    ChartType,\n    LineStyle,\n    MarkerPosition,\n    PriceScaleMode,\n)\n\n# Use enums for type-safe configuration\nchart_type = ChartType.CANDLESTICK\nline_style = LineStyle.SOLID\nmarker_pos = MarkerPosition.ABOVE_BAR\nscale_mode = PriceScaleMode.NORMAL\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ChartType","title":"ChartType","text":"<p>Chart type enumeration.</p> <p>Defines the available chart types that can be created and rendered. Each chart type corresponds to a specific visualization style and data format requirements.</p> <p>Attributes:</p> Name Type Description <code>AREA</code> <p>Area chart - filled area below a line.</p> <code>BAND</code> <p>Band chart - multiple lines with fill areas (e.g., Bollinger Bands).</p> <code>BASELINE</code> <p>Baseline chart - values relative to a baseline.</p> <code>HISTOGRAM</code> <p>Histogram chart - bar chart for volume or distribution.</p> <code>LINE</code> <p>Line chart - simple line connecting data points.</p> <code>BAR</code> <p>Bar chart - OHLC bars for price data.</p> <code>CANDLESTICK</code> <p>Candlestick chart - traditional Japanese candlesticks.</p> <code>RIBBON</code> <p>Ribbon chart - upper and lower bands with fill areas.</p> <code>GRADIENT_RIBBON</code> <p>Gradient ribbon chart - ribbon with gradient fills.</p> <code>TREND_FILL</code> <p>Trend fill chart - fills between trend lines and candle body midpoints.</p> <code>SIGNAL</code> <p>Signal chart - background coloring based on signal values.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ChartType(str, Enum):\n    \"\"\"Chart type enumeration.\n\n    Defines the available chart types that can be created and rendered.\n    Each chart type corresponds to a specific visualization style and\n    data format requirements.\n\n    Attributes:\n        AREA: Area chart - filled area below a line.\n        BAND: Band chart - multiple lines with fill areas (e.g., Bollinger Bands).\n        BASELINE: Baseline chart - values relative to a baseline.\n        HISTOGRAM: Histogram chart - bar chart for volume or distribution.\n        LINE: Line chart - simple line connecting data points.\n        BAR: Bar chart - OHLC bars for price data.\n        CANDLESTICK: Candlestick chart - traditional Japanese candlesticks.\n        RIBBON: Ribbon chart - upper and lower bands with fill areas.\n        GRADIENT_RIBBON: Gradient ribbon chart - ribbon with gradient fills.\n        TREND_FILL: Trend fill chart - fills between trend lines and candle body midpoints.\n        SIGNAL: Signal chart - background coloring based on signal values.\n    \"\"\"\n\n    AREA = \"area\"\n    BAND = \"band\"\n    BASELINE = \"baseline\"\n    HISTOGRAM = \"histogram\"\n    LINE = \"line\"\n    BAR = \"bar\"\n    CANDLESTICK = \"candlestick\"\n    RIBBON = \"ribbon\"\n    GRADIENT_RIBBON = \"gradient_ribbon\"\n    TREND_FILL = \"trend_fill\"\n    SIGNAL = \"signal\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ColorType","title":"ColorType","text":"<p>Color type enumeration.</p> <p>Defines how colors should be applied to chart elements. Controls whether colors are solid or use gradient effects.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid color - uniform color across the element.</p> <code>VERTICAL_GRADIENT</code> <p>Vertical gradient - color gradient from top to bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColorType(str, Enum):\n    \"\"\"Color type enumeration.\n\n    Defines how colors should be applied to chart elements.\n    Controls whether colors are solid or use gradient effects.\n\n    Attributes:\n        SOLID: Solid color - uniform color across the element.\n        VERTICAL_GRADIENT: Vertical gradient - color gradient from top to bottom.\n    \"\"\"\n\n    SOLID = \"solid\"\n    VERTICAL_GRADIENT = \"gradient\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LineStyle","title":"LineStyle","text":"<p>Line style enumeration.</p> <p>Defines the visual style of lines in charts, including borders, grid lines, and series lines.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid line - continuous line without breaks.</p> <code>DOTTED</code> <p>Dotted line - series of dots.</p> <code>DASHED</code> <p>Dashed line - series of short dashes.</p> <code>LARGE_DASHED</code> <p>Large dashed line - series of long dashes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineStyle(IntEnum):\n    \"\"\"Line style enumeration.\n\n    Defines the visual style of lines in charts, including borders,\n    grid lines, and series lines.\n\n    Attributes:\n        SOLID: Solid line - continuous line without breaks.\n        DOTTED: Dotted line - series of dots.\n        DASHED: Dashed line - series of short dashes.\n        LARGE_DASHED: Large dashed line - series of long dashes.\n    \"\"\"\n\n    SOLID = 0\n    DOTTED = 1\n    DASHED = 2\n    LARGE_DASHED = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LineType","title":"LineType","text":"<p>Line type enumeration.</p> <p>Defines how lines should be drawn between data points. Controls the interpolation method used for line series.</p> <p>Attributes:</p> Name Type Description <code>SIMPLE</code> <p>Simple line - straight lines between points.</p> <code>CURVED</code> <p>Curved line - smooth curves between points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineType(IntEnum):\n    \"\"\"Line type enumeration.\n\n    Defines how lines should be drawn between data points.\n    Controls the interpolation method used for line series.\n\n    Attributes:\n        SIMPLE: Simple line - straight lines between points.\n        CURVED: Curved line - smooth curves between points.\n    \"\"\"\n\n    SIMPLE = 0\n    WITH_STEPS = 1\n    CURVED = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.CrosshairMode","title":"CrosshairMode","text":"<p>Crosshair mode enumeration.</p> <p>Defines how the crosshair behaves when hovering over the chart. Controls whether the crosshair snaps to data points or moves freely.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal mode - crosshair moves freely across the chart.</p> <code>MAGNET</code> <p>Magnet mode - crosshair snaps to nearest data points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class CrosshairMode(IntEnum):\n    \"\"\"Crosshair mode enumeration.\n\n    Defines how the crosshair behaves when hovering over the chart.\n    Controls whether the crosshair snaps to data points or moves freely.\n\n    Attributes:\n        NORMAL: Normal mode - crosshair moves freely across the chart.\n        MAGNET: Magnet mode - crosshair snaps to nearest data points.\n    \"\"\"\n\n    NORMAL = 0\n    MAGNET = 1\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LastPriceAnimationMode","title":"LastPriceAnimationMode","text":"<p>Last price animation mode enumeration.</p> <p>Defines how the last price line should be animated when new data is added to the chart.</p> <p>Attributes:</p> Name Type Description <code>DISABLED</code> <p>No animation - last price line updates instantly.</p> <code>CONTINUOUS</code> <p>Continuous animation - smooth transitions for all updates.</p> <code>ON_DATA_UPDATE</code> <p>Update animation - animation only when new data arrives.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LastPriceAnimationMode(IntEnum):\n    \"\"\"Last price animation mode enumeration.\n\n    Defines how the last price line should be animated when new data\n    is added to the chart.\n\n    Attributes:\n        DISABLED: No animation - last price line updates instantly.\n        CONTINUOUS: Continuous animation - smooth transitions for all updates.\n        ON_DATA_UPDATE: Update animation - animation only when new data arrives.\n    \"\"\"\n\n    DISABLED = 0\n    CONTINUOUS = 1\n    ON_DATA_UPDATE = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.PriceScaleMode","title":"PriceScaleMode","text":"<p>Price scale mode enumeration.</p> <p>Defines how the price scale (y-axis) should be displayed and calculated. Controls the scale type and reference point for price values.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal scale - linear price scale.</p> <code>LOGARITHMIC</code> <p>Logarithmic scale - log-based price scale.</p> <code>PERCENTAGE</code> <p>Percentage scale - values as percentages.</p> <code>INDEXED_TO_100</code> <p>Indexed scale - values relative to 100.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class PriceScaleMode(IntEnum):\n    \"\"\"Price scale mode enumeration.\n\n    Defines how the price scale (y-axis) should be displayed and calculated.\n    Controls the scale type and reference point for price values.\n\n    Attributes:\n        NORMAL: Normal scale - linear price scale.\n        LOGARITHMIC: Logarithmic scale - log-based price scale.\n        PERCENTAGE: Percentage scale - values as percentages.\n        INDEXED_TO_100: Indexed scale - values relative to 100.\n    \"\"\"\n\n    NORMAL = 0\n    LOGARITHMIC = 1\n    PERCENTAGE = 2\n    INDEXED_TO_100 = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.HorzAlign","title":"HorzAlign","text":"<p>Horizontal alignment enumeration.</p> <p>Defines horizontal text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left alignment - text aligned to the left.</p> <code>CENTER</code> <p>Center alignment - text centered horizontally.</p> <code>RIGHT</code> <p>Right alignment - text aligned to the right.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class HorzAlign(str, Enum):\n    \"\"\"Horizontal alignment enumeration.\n\n    Defines horizontal text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        LEFT: Left alignment - text aligned to the left.\n        CENTER: Center alignment - text centered horizontally.\n        RIGHT: Right alignment - text aligned to the right.\n    \"\"\"\n\n    LEFT = \"left\"\n    CENTER = \"center\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.VertAlign","title":"VertAlign","text":"<p>Vertical alignment enumeration.</p> <p>Defines vertical text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>TOP</code> <p>Top alignment - text aligned to the top.</p> <code>CENTER</code> <p>Center alignment - text centered vertically.</p> <code>BOTTOM</code> <p>Bottom alignment - text aligned to the bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class VertAlign(str, Enum):\n    \"\"\"Vertical alignment enumeration.\n\n    Defines vertical text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        TOP: Top alignment - text aligned to the top.\n        CENTER: Center alignment - text centered vertically.\n        BOTTOM: Bottom alignment - text aligned to the bottom.\n    \"\"\"\n\n    TOP = \"top\"\n    CENTER = \"center\"\n    BOTTOM = \"bottom\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TrackingExitMode","title":"TrackingExitMode","text":"<p>Tracking exit mode enumeration.</p> <p>Defines when the tracking mode should exit.</p> <p>Attributes:</p> Name Type Description <code>EXIT_ON_MOVE</code> <p>Exit tracking mode when mouse moves.</p> <code>EXIT_ON_CROSS</code> <p>Exit tracking mode when crosshair crosses series.</p> <code>NEVER_EXIT</code> <p>Never exit tracking mode automatically.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingExitMode(str, Enum):\n    \"\"\"Tracking exit mode enumeration.\n\n    Defines when the tracking mode should exit.\n\n    Attributes:\n        EXIT_ON_MOVE: Exit tracking mode when mouse moves.\n        EXIT_ON_CROSS: Exit tracking mode when crosshair crosses series.\n        NEVER_EXIT: Never exit tracking mode automatically.\n    \"\"\"\n\n    EXIT_ON_MOVE = \"EXIT_ON_MOVE\"\n    EXIT_ON_CROSS = \"EXIT_ON_CROSS\"\n    NEVER_EXIT = \"NEVER_EXIT\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TrackingActivationMode","title":"TrackingActivationMode","text":"<p>Tracking activation mode enumeration.</p> <p>Defines when the tracking mode should be activated.</p> <p>Attributes:</p> Name Type Description <code>ON_MOUSE_ENTER</code> <p>Activate tracking mode when mouse enters chart.</p> <code>ON_TOUCH_START</code> <p>Activate tracking mode when touch starts.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingActivationMode(str, Enum):\n    \"\"\"Tracking activation mode enumeration.\n\n    Defines when the tracking mode should be activated.\n\n    Attributes:\n        ON_MOUSE_ENTER: Activate tracking mode when mouse enters chart.\n        ON_TOUCH_START: Activate tracking mode when touch starts.\n    \"\"\"\n\n    ON_MOUSE_ENTER = \"ON_MOUSE_ENTER\"\n    ON_TOUCH_START = \"ON_TOUCH_START\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.MarkerPosition","title":"MarkerPosition","text":"<p>Marker position enumeration for chart markers.</p> <p>Defines where markers should be positioned relative to the data bars or points on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE_BAR</code> <p>Position marker above the data bar/point.</p> <code>BELOW_BAR</code> <p>Position marker below the data bar/point.</p> <code>IN_BAR</code> <p>Position marker inside the data bar/point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerPosition(str, Enum):\n    \"\"\"Marker position enumeration for chart markers.\n\n    Defines where markers should be positioned relative to the data bars\n    or points on the chart.\n\n    Attributes:\n        ABOVE_BAR: Position marker above the data bar/point.\n        BELOW_BAR: Position marker below the data bar/point.\n        IN_BAR: Position marker inside the data bar/point.\n    \"\"\"\n\n    ABOVE_BAR = \"aboveBar\"\n    BELOW_BAR = \"belowBar\"\n    IN_BAR = \"inBar\"\n    AT_PRICE_TOP = \"atPriceTop\"\n    AT_PRICE_BOTTOM = \"atPriceBottom\"\n    AT_PRICE_MIDDLE = \"atPriceMiddle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.MarkerShape","title":"MarkerShape","text":"<p>Marker shape enumeration for chart markers.</p> <p>Defines the available shapes for chart markers that can be displayed on charts to highlight specific data points or events.</p> <p>Attributes:</p> Name Type Description <code>CIRCLE</code> <p>Circular marker shape.</p> <code>SQUARE</code> <p>Square marker shape.</p> <code>ARROW_UP</code> <p>Upward-pointing arrow marker.</p> <code>ARROW_DOWN</code> <p>Downward-pointing arrow marker.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerShape(str, Enum):\n    \"\"\"Marker shape enumeration for chart markers.\n\n    Defines the available shapes for chart markers that can be displayed\n    on charts to highlight specific data points or events.\n\n    Attributes:\n        CIRCLE: Circular marker shape.\n        SQUARE: Square marker shape.\n        ARROW_UP: Upward-pointing arrow marker.\n        ARROW_DOWN: Downward-pointing arrow marker.\n    \"\"\"\n\n    CIRCLE = \"circle\"\n    SQUARE = \"square\"\n    ARROW_UP = \"arrowUp\"\n    ARROW_DOWN = \"arrowDown\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.AnnotationType","title":"AnnotationType","text":"<p>Annotation type enumeration.</p> <p>Defines the available types of annotations that can be placed on charts to mark important points, draw shapes, or add visual indicators.</p> <p>Attributes:</p> Name Type Description <code>TEXT</code> <p>Text annotation - displays text at a specific location.</p> <code>ARROW</code> <p>Arrow annotation - points to a specific location with an arrow.</p> <code>SHAPE</code> <p>Shape annotation - draws geometric shapes (circles, squares, etc.).</p> <code>LINE</code> <p>Line annotation - draws horizontal or vertical lines.</p> <code>RECTANGLE</code> <p>Rectangle annotation - draws rectangular shapes.</p> <code>CIRCLE</code> <p>Circle annotation - draws circular shapes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationType(str, Enum):\n    \"\"\"Annotation type enumeration.\n\n    Defines the available types of annotations that can be placed on charts\n    to mark important points, draw shapes, or add visual indicators.\n\n    Attributes:\n        TEXT: Text annotation - displays text at a specific location.\n        ARROW: Arrow annotation - points to a specific location with an arrow.\n        SHAPE: Shape annotation - draws geometric shapes (circles, squares, etc.).\n        LINE: Line annotation - draws horizontal or vertical lines.\n        RECTANGLE: Rectangle annotation - draws rectangular shapes.\n        CIRCLE: Circle annotation - draws circular shapes.\n    \"\"\"\n\n    TEXT = \"text\"\n    ARROW = \"arrow\"\n    SHAPE = \"shape\"\n    LINE = \"line\"\n    RECTANGLE = \"rectangle\"\n    CIRCLE = \"circle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.AnnotationPosition","title":"AnnotationPosition","text":"<p>Annotation position enumeration.</p> <p>Defines where annotations should be positioned relative to the data point or price level on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE</code> <p>Position annotation above the data point.</p> <code>BELOW</code> <p>Position annotation below the data point.</p> <code>INLINE</code> <p>Position annotation inline with the data point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationPosition(str, Enum):\n    \"\"\"Annotation position enumeration.\n\n    Defines where annotations should be positioned relative to the data point\n    or price level on the chart.\n\n    Attributes:\n        ABOVE: Position annotation above the data point.\n        BELOW: Position annotation below the data point.\n        INLINE: Position annotation inline with the data point.\n    \"\"\"\n\n    ABOVE = \"above\"\n    BELOW = \"below\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ColumnNames","title":"ColumnNames","text":"<p>Column name enumeration for DataFrame integration.</p> <p>Defines the standard column names used when converting pandas DataFrames to chart data. These names ensure consistent mapping between DataFrame columns and chart data fields.</p> <p>Attributes:</p> Name Type Description <code>TIME</code> <p>Time or datetime column.</p> <code>OPEN</code> <p>Open price column (for OHLC data).</p> <code>HIGH</code> <p>High price column (for OHLC data).</p> <code>LOW</code> <p>Low price column (for OHLC data).</p> <code>CLOSE</code> <p>Close price column (for OHLC data).</p> <code>VOLUME</code> <p>Volume column (for OHLCV data).</p> <code>DATETIME</code> <p>Datetime column (alternative to TIME).</p> <code>VALUE</code> <p>Value column (for single-value data like line charts).</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColumnNames(str, Enum):\n    \"\"\"Column name enumeration for DataFrame integration.\n\n    Defines the standard column names used when converting pandas DataFrames\n    to chart data. These names ensure consistent mapping between DataFrame\n    columns and chart data fields.\n\n    Attributes:\n        TIME: Time or datetime column.\n        OPEN: Open price column (for OHLC data).\n        HIGH: High price column (for OHLC data).\n        LOW: Low price column (for OHLC data).\n        CLOSE: Close price column (for OHLC data).\n        VOLUME: Volume column (for OHLCV data).\n        DATETIME: Datetime column (alternative to TIME).\n        VALUE: Value column (for single-value data like line charts).\n    \"\"\"\n\n    TIME = \"time\"\n    OPEN = \"open\"\n    HIGH = \"high\"\n    LOW = \"low\"\n    CLOSE = \"close\"\n    VOLUME = \"volume\"\n    DATETIME = \"datetime\"\n    VALUE = \"value\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TradeType","title":"TradeType","text":"<p>Trade type enumeration.</p> <p>Defines the direction of a trade (long or short). Used for trade visualization and profit/loss calculations.</p> <p>Attributes:</p> Name Type Description <code>LONG</code> <p>Long trade - profit when price goes up.</p> <code>SHORT</code> <p>Short trade - profit when price goes down.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeType(str, Enum):\n    \"\"\"Trade type enumeration.\n\n    Defines the direction of a trade (long or short).\n    Used for trade visualization and profit/loss calculations.\n\n    Attributes:\n        LONG: Long trade - profit when price goes up.\n        SHORT: Short trade - profit when price goes down.\n    \"\"\"\n\n    LONG = \"long\"\n    SHORT = \"short\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TradeVisualization","title":"TradeVisualization","text":"<p>Trade visualization style enumeration.</p> <p>Defines how trades should be visualized on the chart. Multiple visualization styles can be combined to create comprehensive trade displays.</p> <p>Attributes:</p> Name Type Description <code>MARKERS</code> <p>Display entry/exit markers only.</p> <code>RECTANGLES</code> <p>Display rectangle spanning from entry to exit.</p> <code>BOTH</code> <p>Display both markers and rectangles.</p> <code>LINES</code> <p>Display connecting lines between entry and exit.</p> <code>ARROWS</code> <p>Display directional arrows from entry to exit.</p> <code>ZONES</code> <p>Display colored zones with transparency around trades.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeVisualization(str, Enum):\n    \"\"\"Trade visualization style enumeration.\n\n    Defines how trades should be visualized on the chart.\n    Multiple visualization styles can be combined to create\n    comprehensive trade displays.\n\n    Attributes:\n        MARKERS: Display entry/exit markers only.\n        RECTANGLES: Display rectangle spanning from entry to exit.\n        BOTH: Display both markers and rectangles.\n        LINES: Display connecting lines between entry and exit.\n        ARROWS: Display directional arrows from entry to exit.\n        ZONES: Display colored zones with transparency around trades.\n    \"\"\"\n\n    MARKERS = \"markers\"  # Just entry/exit markers\n    RECTANGLES = \"rectangles\"  # Rectangle from entry to exit\n    BOTH = \"both\"  # Both markers and rectangles\n    LINES = \"lines\"  # Lines connecting entry to exit\n    ARROWS = \"arrows\"  # Arrows from entry to exit\n    ZONES = \"zones\"  # Colored zones with transparency\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.BackgroundStyle","title":"BackgroundStyle","text":"<p>Background style enumeration.</p> <p>Defines how chart backgrounds should be styled. Controls whether backgrounds use solid colors or gradients.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid background color.</p> <code>VERTICAL_GRADIENT</code> <p>Vertical gradient background.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class BackgroundStyle(str, Enum):\n    \"\"\"Background style enumeration.\n\n    Defines how chart backgrounds should be styled.\n    Controls whether backgrounds use solid colors or gradients.\n\n    Attributes:\n        SOLID: Solid background color.\n        VERTICAL_GRADIENT: Vertical gradient background.\n    \"\"\"\n\n    SOLID = \"solid\"\n    VERTICAL_GRADIENT = \"gradient\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.PriceLineSource","title":"PriceLineSource","text":"<p>Price line source enumeration.</p> <p>Defines the source to use for the value of the price line. Controls which data point determines the price line position.</p> <p>Attributes:</p> Name Type Description <code>LAST_BAR</code> <p>Last bar - use the last visible bar's price.</p> <code>LAST_VISIBLE</code> <p>Last visible - use the last visible data point's price.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class PriceLineSource(str, Enum):\n    \"\"\"Price line source enumeration.\n\n    Defines the source to use for the value of the price line.\n    Controls which data point determines the price line position.\n\n    Attributes:\n        LAST_BAR: Last bar - use the last visible bar's price.\n        LAST_VISIBLE: Last visible - use the last visible data point's price.\n    \"\"\"\n\n    LAST_BAR = \"lastBar\"\n    LAST_VISIBLE = \"lastVisible\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TooltipType","title":"TooltipType","text":"<p>Tooltip type enumeration.</p> <p>Defines the types of tooltips supported by the system. Each type corresponds to a specific data format and display style.</p> <p>Attributes:</p> Name Type Description <code>OHLC</code> <p>OHLC tooltip - displays open, high, low, close, and volume data.</p> <code>SINGLE</code> <p>Single value tooltip - displays a single data value.</p> <code>MULTI</code> <p>Multi-series tooltip - displays data from multiple series.</p> <code>CUSTOM</code> <p>Custom tooltip - displays custom content using templates.</p> <code>TRADE</code> <p>Trade tooltip - displays trade information (entry, exit, P&amp;L).</p> <code>MARKER</code> <p>Marker tooltip - displays marker-specific information.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipType(str, Enum):\n    \"\"\"Tooltip type enumeration.\n\n    Defines the types of tooltips supported by the system.\n    Each type corresponds to a specific data format and display style.\n\n    Attributes:\n        OHLC: OHLC tooltip - displays open, high, low, close, and volume data.\n        SINGLE: Single value tooltip - displays a single data value.\n        MULTI: Multi-series tooltip - displays data from multiple series.\n        CUSTOM: Custom tooltip - displays custom content using templates.\n        TRADE: Trade tooltip - displays trade information (entry, exit, P&amp;L).\n        MARKER: Marker tooltip - displays marker-specific information.\n    \"\"\"\n\n    OHLC = \"ohlc\"\n    SINGLE = \"single\"\n    MULTI = \"multi\"\n    CUSTOM = \"custom\"\n    TRADE = \"trade\"\n    MARKER = \"marker\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TooltipPosition","title":"TooltipPosition","text":"<p>Tooltip position enumeration.</p> <p>Defines how tooltips should be positioned relative to the cursor or chart elements.</p> <p>Attributes:</p> Name Type Description <code>CURSOR</code> <p>Cursor position - tooltip follows the mouse cursor.</p> <code>FIXED</code> <p>Fixed position - tooltip appears at a fixed location.</p> <code>AUTO</code> <p>Auto position - tooltip position is automatically determined.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipPosition(str, Enum):\n    \"\"\"Tooltip position enumeration.\n\n    Defines how tooltips should be positioned relative to the cursor\n    or chart elements.\n\n    Attributes:\n        CURSOR: Cursor position - tooltip follows the mouse cursor.\n        FIXED: Fixed position - tooltip appears at a fixed location.\n        AUTO: Auto position - tooltip position is automatically determined.\n    \"\"\"\n\n    CURSOR = \"cursor\"\n    FIXED = \"fixed\"\n    AUTO = \"auto\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html","title":"streamlit_lightweight_charts_pro.types","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types","title":"types","text":"<p>Type definitions for streamlit-lightweight-charts-pro.</p>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigBackendData","title":"SeriesConfigBackendData  <code>dataclass</code>","text":"<p>Backend data passed to frontend for series configuration initialization.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"complete_state\", dict)\nclass SeriesConfigBackendData(Options):\n    \"\"\"Backend data passed to frontend for series configuration initialization.\"\"\"\n\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigChange","title":"SeriesConfigChange  <code>dataclass</code>","text":"<p>Represents a single series configuration change from frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"pane_id\", int)\n@chainable_field(\"series_id\", str)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"config\", dict)\n@chainable_field(\"timestamp\", int)\n@chainable_field(\"chart_id\", str)\nclass SeriesConfigChange(Options):\n    \"\"\"Represents a single series configuration change from frontend.\"\"\"\n\n    pane_id: int = 0\n    series_id: str = \"\"\n    series_type: str = \"\"\n    config: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n    chart_id: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigChangesResult","title":"SeriesConfigChangesResult  <code>dataclass</code>","text":"<p>Result object from frontend containing series configuration changes.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str)\n@chainable_field(\"changes\", list)\n@chainable_field(\"complete_state\", dict)\n@chainable_field(\"timestamp\", int)\nclass SeriesConfigChangesResult(Options):\n    \"\"\"Result object from frontend containing series configuration changes.\"\"\"\n\n    type: str = \"series_config_changes\"\n    changes: list[SeriesConfigChange] = field(default_factory=list)\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n        \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n        changes = [\n            SeriesConfigChange.fromdict(change_data)  # type: ignore[attr-defined]\n            for change_data in data.get(\"changes\", [])\n        ]\n\n        return cls(\n            type=data.get(\"type\", \"series_config_changes\"),\n            changes=changes,\n            complete_state=data.get(\"completeState\", {}),\n            timestamp=data.get(\"timestamp\", 0),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigChangesResult-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigChangesResult.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfigChangesResult\n</code></pre> <p>Create from dictionary with proper change object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n    \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n    changes = [\n        SeriesConfigChange.fromdict(change_data)  # type: ignore[attr-defined]\n        for change_data in data.get(\"changes\", [])\n    ]\n\n    return cls(\n        type=data.get(\"type\", \"series_config_changes\"),\n        changes=changes,\n        complete_state=data.get(\"completeState\", {}),\n        timestamp=data.get(\"timestamp\", 0),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigPersistenceOptions","title":"SeriesConfigPersistenceOptions  <code>dataclass</code>","text":"<p>Options for series configuration persistence.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"auto_save\", bool)\n@chainable_field(\"session_key\", str)\n@chainable_field(\"export_format\", str)\nclass SeriesConfigPersistenceOptions(Options):\n    \"\"\"Options for series configuration persistence.\"\"\"\n\n    enabled: bool = True\n    auto_save: bool = True\n    session_key: str = \"series_configs\"\n    export_format: Literal[\"json\", \"yaml\"] = \"json\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfigState","title":"SeriesConfigState  <code>dataclass</code>","text":"<p>Represents the complete series configuration state structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"config\", dict)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"last_modified\", int)\nclass SeriesConfigState(Options):\n    \"\"\"Represents the complete series configuration state structure.\"\"\"\n\n    config: Dict[str, Any] = field(default_factory=dict)\n    series_type: str = \"\"\n    last_modified: int = 0\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfiguration","title":"SeriesConfiguration  <code>dataclass</code>","text":"<p>Complete series configuration structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", SeriesStyleConfig)\n@chainable_field(\"visibility\", SeriesVisibilityConfig)\n@chainable_field(\"inputs\", SeriesInputConfig)\nclass SeriesConfiguration(Options):\n    \"\"\"Complete series configuration structure.\"\"\"\n\n    style: Optional[SeriesStyleConfig] = None\n    visibility: Optional[SeriesVisibilityConfig] = None\n    inputs: Optional[SeriesInputConfig] = None\n\n    # Legacy support for flat structure (backwards compatibility)\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    visible: Optional[bool] = None\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n        \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n        style = None\n        if \"style\" in data:\n            style = SeriesStyleConfig.fromdict(data[\"style\"])  # type: ignore[attr-defined]\n\n        visibility = None\n        if \"visibility\" in data:\n            visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])  # type: ignore[attr-defined]\n\n        inputs = None\n        if \"inputs\" in data:\n            inputs = SeriesInputConfig.fromdict(data[\"inputs\"])  # type: ignore[attr-defined]\n\n        return cls(\n            style=style,\n            visibility=visibility,\n            inputs=inputs,\n            # Legacy flat properties\n            color=data.get(\"color\"),\n            opacity=data.get(\"opacity\"),\n            line_width=data.get(\"lineWidth\"),\n            line_style=data.get(\"lineStyle\"),\n            last_price_visible=data.get(\"lastPriceVisible\"),\n            price_line_visible=data.get(\"priceLineVisible\"),\n            visible=data.get(\"visible\"),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfiguration-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesConfiguration.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfiguration\n</code></pre> <p>Create from dictionary with proper nested object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n    \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n    style = None\n    if \"style\" in data:\n        style = SeriesStyleConfig.fromdict(data[\"style\"])  # type: ignore[attr-defined]\n\n    visibility = None\n    if \"visibility\" in data:\n        visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])  # type: ignore[attr-defined]\n\n    inputs = None\n    if \"inputs\" in data:\n        inputs = SeriesInputConfig.fromdict(data[\"inputs\"])  # type: ignore[attr-defined]\n\n    return cls(\n        style=style,\n        visibility=visibility,\n        inputs=inputs,\n        # Legacy flat properties\n        color=data.get(\"color\"),\n        opacity=data.get(\"opacity\"),\n        line_width=data.get(\"lineWidth\"),\n        line_style=data.get(\"lineStyle\"),\n        last_price_visible=data.get(\"lastPriceVisible\"),\n        price_line_visible=data.get(\"priceLineVisible\"),\n        visible=data.get(\"visible\"),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesInputConfig","title":"SeriesInputConfig  <code>dataclass</code>","text":"<p>Input configuration options for series (series-specific parameters).</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\nclass SeriesInputConfig(Options):\n    \"\"\"Input configuration options for series (series-specific parameters).\"\"\"\n\n    # This will contain series-specific properties dynamically\n    # Examples for different series types:\n    # Line series: none typically\n    # Candlestick: upColor, downColor, wickUpColor, wickDownColor\n    # Histogram: base value\n    # Area: topColor, bottomColor\n    # Ribbon: upperLineColor, lowerLineColor, fillColor\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize with dynamic properties based on series type.\"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesStyleConfig","title":"SeriesStyleConfig  <code>dataclass</code>","text":"<p>Style configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str)\n@chainable_field(\"opacity\", float)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"last_price_visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"base_line_visible\", bool)\n@chainable_field(\"base_line_color\", str)\n@chainable_field(\"base_line_style\", str)\n@chainable_field(\"base_line_width\", int)\nclass SeriesStyleConfig(Options):\n    \"\"\"Style configuration options for series.\"\"\"\n\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    base_line_visible: Optional[bool] = None\n    base_line_color: Optional[str] = None\n    base_line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    base_line_width: Optional[int] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/index.html#streamlit_lightweight_charts_pro.types.SeriesVisibilityConfig","title":"SeriesVisibilityConfig  <code>dataclass</code>","text":"<p>Visibility configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"last_value_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"price_format\", dict)\n@chainable_field(\"precision\", int)\n@chainable_field(\"min_move\", float)\nclass SeriesVisibilityConfig(Options):\n    \"\"\"Visibility configuration options for series.\"\"\"\n\n    visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    last_value_visible: Optional[bool] = None\n    title: Optional[str] = None\n    price_format: Optional[Dict[str, Any]] = None\n    precision: Optional[int] = None\n    min_move: Optional[float] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html","title":"streamlit_lightweight_charts_pro.types.series_config_types","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types","title":"series_config_types","text":"<p>Type definitions for series configuration system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChange","title":"SeriesConfigChange  <code>dataclass</code>","text":"<p>Represents a single series configuration change from frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"pane_id\", int)\n@chainable_field(\"series_id\", str)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"config\", dict)\n@chainable_field(\"timestamp\", int)\n@chainable_field(\"chart_id\", str)\nclass SeriesConfigChange(Options):\n    \"\"\"Represents a single series configuration change from frontend.\"\"\"\n\n    pane_id: int = 0\n    series_id: str = \"\"\n    series_type: str = \"\"\n    config: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n    chart_id: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigState","title":"SeriesConfigState  <code>dataclass</code>","text":"<p>Represents the complete series configuration state structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"config\", dict)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"last_modified\", int)\nclass SeriesConfigState(Options):\n    \"\"\"Represents the complete series configuration state structure.\"\"\"\n\n    config: Dict[str, Any] = field(default_factory=dict)\n    series_type: str = \"\"\n    last_modified: int = 0\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigBackendData","title":"SeriesConfigBackendData  <code>dataclass</code>","text":"<p>Backend data passed to frontend for series configuration initialization.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"complete_state\", dict)\nclass SeriesConfigBackendData(Options):\n    \"\"\"Backend data passed to frontend for series configuration initialization.\"\"\"\n\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult","title":"SeriesConfigChangesResult  <code>dataclass</code>","text":"<p>Result object from frontend containing series configuration changes.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str)\n@chainable_field(\"changes\", list)\n@chainable_field(\"complete_state\", dict)\n@chainable_field(\"timestamp\", int)\nclass SeriesConfigChangesResult(Options):\n    \"\"\"Result object from frontend containing series configuration changes.\"\"\"\n\n    type: str = \"series_config_changes\"\n    changes: list[SeriesConfigChange] = field(default_factory=list)\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n        \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n        changes = [\n            SeriesConfigChange.fromdict(change_data)  # type: ignore[attr-defined]\n            for change_data in data.get(\"changes\", [])\n        ]\n\n        return cls(\n            type=data.get(\"type\", \"series_config_changes\"),\n            changes=changes,\n            complete_state=data.get(\"completeState\", {}),\n            timestamp=data.get(\"timestamp\", 0),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfigChangesResult\n</code></pre> <p>Create from dictionary with proper change object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n    \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n    changes = [\n        SeriesConfigChange.fromdict(change_data)  # type: ignore[attr-defined]\n        for change_data in data.get(\"changes\", [])\n    ]\n\n    return cls(\n        type=data.get(\"type\", \"series_config_changes\"),\n        changes=changes,\n        complete_state=data.get(\"completeState\", {}),\n        timestamp=data.get(\"timestamp\", 0),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigPersistenceOptions","title":"SeriesConfigPersistenceOptions  <code>dataclass</code>","text":"<p>Options for series configuration persistence.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"auto_save\", bool)\n@chainable_field(\"session_key\", str)\n@chainable_field(\"export_format\", str)\nclass SeriesConfigPersistenceOptions(Options):\n    \"\"\"Options for series configuration persistence.\"\"\"\n\n    enabled: bool = True\n    auto_save: bool = True\n    session_key: str = \"series_configs\"\n    export_format: Literal[\"json\", \"yaml\"] = \"json\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesStyleConfig","title":"SeriesStyleConfig  <code>dataclass</code>","text":"<p>Style configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str)\n@chainable_field(\"opacity\", float)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"last_price_visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"base_line_visible\", bool)\n@chainable_field(\"base_line_color\", str)\n@chainable_field(\"base_line_style\", str)\n@chainable_field(\"base_line_width\", int)\nclass SeriesStyleConfig(Options):\n    \"\"\"Style configuration options for series.\"\"\"\n\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    base_line_visible: Optional[bool] = None\n    base_line_color: Optional[str] = None\n    base_line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    base_line_width: Optional[int] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesVisibilityConfig","title":"SeriesVisibilityConfig  <code>dataclass</code>","text":"<p>Visibility configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"last_value_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"price_format\", dict)\n@chainable_field(\"precision\", int)\n@chainable_field(\"min_move\", float)\nclass SeriesVisibilityConfig(Options):\n    \"\"\"Visibility configuration options for series.\"\"\"\n\n    visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    last_value_visible: Optional[bool] = None\n    title: Optional[str] = None\n    price_format: Optional[Dict[str, Any]] = None\n    precision: Optional[int] = None\n    min_move: Optional[float] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesInputConfig","title":"SeriesInputConfig  <code>dataclass</code>","text":"<p>Input configuration options for series (series-specific parameters).</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\nclass SeriesInputConfig(Options):\n    \"\"\"Input configuration options for series (series-specific parameters).\"\"\"\n\n    # This will contain series-specific properties dynamically\n    # Examples for different series types:\n    # Line series: none typically\n    # Candlestick: upColor, downColor, wickUpColor, wickDownColor\n    # Histogram: base value\n    # Area: topColor, bottomColor\n    # Ribbon: upperLineColor, lowerLineColor, fillColor\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize with dynamic properties based on series type.\"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration","title":"SeriesConfiguration  <code>dataclass</code>","text":"<p>Complete series configuration structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", SeriesStyleConfig)\n@chainable_field(\"visibility\", SeriesVisibilityConfig)\n@chainable_field(\"inputs\", SeriesInputConfig)\nclass SeriesConfiguration(Options):\n    \"\"\"Complete series configuration structure.\"\"\"\n\n    style: Optional[SeriesStyleConfig] = None\n    visibility: Optional[SeriesVisibilityConfig] = None\n    inputs: Optional[SeriesInputConfig] = None\n\n    # Legacy support for flat structure (backwards compatibility)\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    visible: Optional[bool] = None\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n        \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n        style = None\n        if \"style\" in data:\n            style = SeriesStyleConfig.fromdict(data[\"style\"])  # type: ignore[attr-defined]\n\n        visibility = None\n        if \"visibility\" in data:\n            visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])  # type: ignore[attr-defined]\n\n        inputs = None\n        if \"inputs\" in data:\n            inputs = SeriesInputConfig.fromdict(data[\"inputs\"])  # type: ignore[attr-defined]\n\n        return cls(\n            style=style,\n            visibility=visibility,\n            inputs=inputs,\n            # Legacy flat properties\n            color=data.get(\"color\"),\n            opacity=data.get(\"opacity\"),\n            line_width=data.get(\"lineWidth\"),\n            line_style=data.get(\"lineStyle\"),\n            last_price_visible=data.get(\"lastPriceVisible\"),\n            price_line_visible=data.get(\"priceLineVisible\"),\n            visible=data.get(\"visible\"),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfiguration\n</code></pre> <p>Create from dictionary with proper nested object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n    \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n    style = None\n    if \"style\" in data:\n        style = SeriesStyleConfig.fromdict(data[\"style\"])  # type: ignore[attr-defined]\n\n    visibility = None\n    if \"visibility\" in data:\n        visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])  # type: ignore[attr-defined]\n\n    inputs = None\n    if \"inputs\" in data:\n        inputs = SeriesInputConfig.fromdict(data[\"inputs\"])  # type: ignore[attr-defined]\n\n    return cls(\n        style=style,\n        visibility=visibility,\n        inputs=inputs,\n        # Legacy flat properties\n        color=data.get(\"color\"),\n        opacity=data.get(\"opacity\"),\n        line_width=data.get(\"lineWidth\"),\n        line_style=data.get(\"lineStyle\"),\n        last_price_visible=data.get(\"lastPriceVisible\"),\n        price_line_visible=data.get(\"priceLineVisible\"),\n        visible=data.get(\"visible\"),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html","title":"streamlit_lightweight_charts_pro.utils","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils","title":"utils","text":"<p>Utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides utility functions and decorators that enhance the functionality of the charting library. It includes tools for method chaining, data processing, and other common operations used throughout the package.</p> The module exports <ul> <li>chainable_property: Decorator for creating chainable properties</li> <li>chainable_field: Decorator for creating chainable fields</li> </ul> <p>These utilities enable the fluent API design pattern used throughout the library, allowing for intuitive method chaining when building charts and configuring options.</p> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils import chainable_property, chainable_field\n\n\nclass ChartConfig:\n    @chainable_property\n    def height(self, value: int):\n        self._height = value\n        return self\n\n    @chainable_field\n    def width(self):\n        return self._width\n</code></pre> Note <p>Trade visualization utilities have been moved to frontend plugins to avoid circular imports with the options module. The functionality is still available but accessed directly from the relevant modules when needed.</p> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.SerializableMixin","title":"SerializableMixin","text":"<p>Mixin class that provides standardized serialization capabilities.</p> <p>This mixin provides a consistent interface for serializing Python objects to frontend-compatible dictionaries. It handles common transformations including enum conversion, type normalization, and camelCase key conversion.</p> <p>Classes using this mixin should be dataclasses and implement asdict() by calling _serialize_to_dict() with optional custom configuration.</p> The mixin handles the complete serialization pipeline <ol> <li>Iterate through all dataclass fields</li> <li>Apply filtering based on configuration (skip None, empty, etc.)</li> <li>Convert field names (snake_case to camelCase)</li> <li>Transform values (enums to values, NaN to zero, etc.)</li> <li>Recursively serialize nested objects</li> <li>Handle special field flattening rules</li> </ol> Features <ul> <li>Automatic snake_case to camelCase conversion</li> <li>Enum value extraction for JavaScript compatibility</li> <li>NaN to zero conversion for JSON compatibility</li> <li>NumPy type conversion to Python native types</li> <li>Recursive serialization of nested objects</li> <li>Configurable filtering of None/empty values</li> <li>Support for special field names (like 'time' -&gt; ColumnNames.TIME)</li> <li>Field override support for custom transformations</li> </ul> Example <p>Basic usage::</p> <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import (\n    SerializableMixin\n)\n\n@dataclass\nclass ChartConfig(SerializableMixin):\n    title_text: str = \"My Chart\"\n    is_visible: bool = True\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n\nconfig = ChartConfig()\nresult = config.asdict()\n# Returns: {\"titleText\": \"My Chart\", \"isVisible\": True}\n</code></pre> <p>With custom config::</p> <pre><code>@dataclass\nclass StrictConfig(SerializableMixin):\n    value: Optional[int] = None\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        custom_config = SerializationConfig(skip_none=False)\n        return dict(self._serialize_to_dict(custom_config))\n\nconfig = StrictConfig()\nresult = config.asdict()\n# Returns: {\"value\": None}  # None kept due to custom config\n</code></pre> Note <p>This class is designed to work with dataclasses. It uses the dataclasses.fields() function to introspect the class structure. Non-dataclass usage may result in errors.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializableMixin:\n    \"\"\"Mixin class that provides standardized serialization capabilities.\n\n    This mixin provides a consistent interface for serializing Python objects\n    to frontend-compatible dictionaries. It handles common transformations\n    including enum conversion, type normalization, and camelCase key conversion.\n\n    Classes using this mixin should be dataclasses and implement asdict() by\n    calling _serialize_to_dict() with optional custom configuration.\n\n    The mixin handles the complete serialization pipeline:\n        1. Iterate through all dataclass fields\n        2. Apply filtering based on configuration (skip None, empty, etc.)\n        3. Convert field names (snake_case to camelCase)\n        4. Transform values (enums to values, NaN to zero, etc.)\n        5. Recursively serialize nested objects\n        6. Handle special field flattening rules\n\n    Features:\n        - Automatic snake_case to camelCase conversion\n        - Enum value extraction for JavaScript compatibility\n        - NaN to zero conversion for JSON compatibility\n        - NumPy type conversion to Python native types\n        - Recursive serialization of nested objects\n        - Configurable filtering of None/empty values\n        - Support for special field names (like 'time' -&gt; ColumnNames.TIME)\n        - Field override support for custom transformations\n\n    Example:\n        Basic usage::\n\n            from dataclasses import dataclass\n            from streamlit_lightweight_charts_pro.utils.serialization import (\n                SerializableMixin\n            )\n\n            @dataclass\n            class ChartConfig(SerializableMixin):\n                title_text: str = \"My Chart\"\n                is_visible: bool = True\n\n                def asdict(self) -&gt; Dict[str, Any]:\n                    return dict(self._serialize_to_dict())\n\n            config = ChartConfig()\n            result = config.asdict()\n            # Returns: {\"titleText\": \"My Chart\", \"isVisible\": True}\n\n        With custom config::\n\n            @dataclass\n            class StrictConfig(SerializableMixin):\n                value: Optional[int] = None\n\n                def asdict(self) -&gt; Dict[str, Any]:\n                    custom_config = SerializationConfig(skip_none=False)\n                    return dict(self._serialize_to_dict(custom_config))\n\n            config = StrictConfig()\n            result = config.asdict()\n            # Returns: {\"value\": None}  # None kept due to custom config\n\n    Note:\n        This class is designed to work with dataclasses. It uses the\n        dataclasses.fields() function to introspect the class structure.\n        Non-dataclass usage may result in errors.\n    \"\"\"\n\n    def _serialize_to_dict(\n        self,\n        config: SerializationConfig = DEFAULT_CONFIG,\n        override_fields: dict[str, Any] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize the object to a dictionary with camelCase keys.\n\n        This method provides the core serialization logic that handles\n        type conversion, key transformation, and field filtering. It's\n        designed to be called by subclasses' asdict() implementations.\n\n        The serialization process follows these steps:\n            1. Initialize result dictionary and process field overrides\n            2. Iterate through all dataclass fields\n            3. Get field value (from override dict or instance attribute)\n            4. Apply filtering based on config (skip None, empty, etc.)\n            5. Process value (convert types, serialize nested objects)\n            6. Process field name (snake_case to camelCase)\n            7. Handle special flattening for '_options' fields\n            8. Add processed key-value pair to result\n\n        Args:\n            config (SerializationConfig, optional): Configuration instance\n                controlling serialization behavior. Defaults to DEFAULT_CONFIG\n                which provides sensible defaults for most cases.\n            override_fields (dict[str, Any] | None, optional): Dictionary of\n                field overrides. Values in this dict replace computed values\n                during serialization. Useful for custom transformations on\n                specific fields. Defaults to None.\n\n        Returns:\n            dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption. The dictionary is fully JSON-serializable\n                and compatible with JavaScript naming conventions.\n\n        Example:\n            Basic serialization::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Document(SerializableMixin):\n                ...     title: str = \"Test\"\n                ...     page_count: int = 42\n                ...     notes: str = \"\"\n                ...\n                ...     def asdict(self) -&gt; Dict[str, Any]:\n                ...         return dict(self._serialize_to_dict())\n                &gt;&gt;&gt; data = Document()\n                &gt;&gt;&gt; result = data._serialize_to_dict()\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 42}  # notes skipped (empty)\n\n            Custom config::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_strings=False)\n                &gt;&gt;&gt; result = data._serialize_to_dict(config)\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 42, \"notes\": \"\"}\n\n            With field overrides::\n\n                &gt;&gt;&gt; overrides = {\"page_count\": 100}\n                &gt;&gt;&gt; result = data._serialize_to_dict(\n                ...     override_fields=overrides\n                ... )\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 100}\n\n        Note:\n            This method must be called on a dataclass instance. It uses\n            dataclasses.fields() to introspect the object structure.\n        \"\"\"\n        # Step 1: Initialize result dictionary that will hold serialized data\n        result: dict[str, Any] = {}\n\n        # Initialize override_fields to empty dict if not provided\n        # This allows us to use .get() without None checks\n        override_fields = override_fields or {}\n\n        # Step 2: Iterate through all dataclass fields\n        # fields() returns a tuple of Field objects representing each field\n        # Cast self to Any to satisfy mypy - SerializableMixin is always\n        # used with dataclasses but mypy can't infer this\n        for field in fields(self):  # type: ignore[arg-type]\n            # Extract the field name (e.g., \"title_text\", \"is_visible\")\n            field_name = field.name\n\n            # Step 3: Get field value (use override if provided, otherwise\n            # get from instance)\n            # Overrides allow callers to customize specific field values\n            # during serialization without modifying the object\n            value = override_fields.get(field_name, getattr(self, field_name))\n\n            # Step 4: Apply config-based filtering\n            # Check if this value should be included based on config rules\n            # (skip None, skip empty strings, skip empty dicts)\n            if not self._should_include_value(value, config):\n                # Value should be skipped, move to next field\n                continue\n\n            # Step 5: Process value for serialization\n            # This handles type conversions:\n            # - NaN -&gt; 0.0\n            # - Enum -&gt; enum.value\n            # - NumPy types -&gt; Python types\n            # - Nested objects -&gt; recursive serialization\n            processed_value = self._process_value_for_serialization(\n                value, config\n            )\n\n            # Step 6: Process field name for serialization\n            # Convert snake_case to camelCase and handle special fields\n            # like 'time' and 'value'\n            processed_field = self._process_field_name_for_serialization(\n                field_name, config\n            )\n\n            # Step 7: Handle special flattening rules\n            # Some fields like 'background_options' should have their\n            # contents merged into the parent dict instead of being nested\n            if (\n                config.flatten_options_fields\n                and field_name.endswith(\"_options\")\n                and isinstance(processed_value, dict)\n                and field_name == \"background_options\"  # Only flatten specific\n            ):\n                # Merge flattened fields directly into result dictionary\n                # This converts {\"background_options\": {\"color\": \"red\"}}\n                # to {\"color\": \"red\"} in the output\n                result.update(processed_value)\n            else:\n                # Normal field: add as key-value pair in result\n                result[processed_field] = processed_value\n\n        # Step 8: Return the fully processed dictionary\n        # This dictionary is ready for JSON serialization and frontend use\n        return result\n\n    def _should_include_value(\n        self, value: Any, config: SerializationConfig\n    ) -&gt; bool:\n        \"\"\"Determine if a value should be included in serialized output.\n\n        This method applies filtering rules based on the configuration to\n        decide whether a field value should be included in the serialized\n        dictionary. It helps reduce payload size by omitting unwanted values.\n\n        The checks are performed in order:\n            1. Check if value is None and should be skipped\n            2. Check if value is empty string and should be skipped\n            3. Check if value is empty dict and should be skipped\n\n        Args:\n            value (Any): The value to check. Can be any Python type.\n            config (SerializationConfig): Serialization configuration that\n                controls which values should be filtered out.\n\n        Returns:\n            bool: True if the value should be included in the serialized\n                output, False if it should be omitted.\n\n        Example:\n            Check None values::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_none=True)\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; mixin._should_include_value(None, config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value(\"text\", config)\n                True\n\n            Check empty strings::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_strings=True)\n                &gt;&gt;&gt; mixin._should_include_value(\"\", config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value(\"hello\", config)\n                True\n\n            Check empty dicts::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_dicts=True)\n                &gt;&gt;&gt; mixin._should_include_value({}, config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value({\"key\": \"value\"}, config)\n                True\n\n        Note:\n            This method doesn't check type validity or perform conversions.\n            It only determines inclusion based on the filtering rules.\n        \"\"\"\n        # Check 1: Skip None values if configured\n        # None values typically represent unset optional fields\n        # Omitting them reduces payload size without losing information\n        if value is None and config.skip_none:\n            return False\n\n        # Check 2: Skip empty strings if configured\n        # Empty strings can clutter the output and provide no value\n        # to the frontend\n        if value == \"\" and config.skip_empty_strings:\n            return False\n\n        # Check 3: Skip empty dictionaries if configured\n        # Returns True if value is not an empty dict, or if we should\n        # keep empty dicts\n        # Empty dicts create unnecessary nesting in the output\n        return not (value == {} and config.skip_empty_dicts)\n\n    def _process_value_for_serialization(\n        self,\n        value: Any,\n        config: SerializationConfig,\n    ) -&gt; Any:\n        \"\"\"Process a value during serialization with type-specific conversions.\n\n        This method handles all value transformations needed to make Python\n        objects compatible with JavaScript/JSON. It processes values\n        recursively, handling nested objects, collections, and special types.\n\n        The processing pipeline:\n            1. Convert NaN floats to zero for JSON compatibility\n            2. Convert NumPy scalar types to Python native types\n            3. Extract enum values for JavaScript compatibility\n            4. Recursively serialize nested SerializableMixin objects\n            5. Recursively process lists\n            6. Recursively process dictionaries with key conversion\n            7. Return processed value\n\n        Args:\n            value (Any): The value to process. Can be any Python type.\n            config (SerializationConfig): Configuration controlling the\n                conversion behavior.\n\n        Returns:\n            Any: The processed value ready for JSON serialization. The value\n                will be JSON-compatible and use JavaScript naming conventions.\n\n        Example:\n            NaN conversion::\n\n                &gt;&gt;&gt; import math\n                &gt;&gt;&gt; config = SerializationConfig(convert_nan_to_zero=True)\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; mixin._process_value_for_serialization(math.nan, config)\n                0.0\n\n            Enum conversion::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Color(Enum):\n                ...     RED = \"red\"\n                &gt;&gt;&gt; config = SerializationConfig(convert_enums=True)\n                &gt;&gt;&gt; mixin._process_value_for_serialization(Color.RED, config)\n                'red'\n\n            Nested object serialization::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Inner(SerializableMixin):\n                ...     value: int = 42\n                ...     def asdict(self):\n                ...         return {\"value\": self.value}\n                &gt;&gt;&gt; inner = Inner()\n                &gt;&gt;&gt; mixin._process_value_for_serialization(inner, config)\n                {'value': 42}\n\n        Note:\n            This method is recursive and will process deeply nested structures.\n            Circular references will cause infinite recursion.\n        \"\"\"\n        # Step 1: Handle NaN floats - convert to zero for JSON compatibility\n        # JSON spec doesn't support NaN, Infinity, or -Infinity\n        # JavaScript charts typically treat NaN as zero anyway\n        if (\n            isinstance(value, float)\n            and math.isnan(value)\n            and config.convert_nan_to_zero\n        ):\n            return 0.0\n\n        # Step 2: Convert NumPy scalar types to Python native types\n        # NumPy types like np.int64, np.float32 aren't JSON-serializable\n        # The .item() method extracts the Python scalar value\n        if hasattr(value, \"item\"):  # NumPy scalar types have .item() method\n            value = value.item()\n\n        # Step 3: Convert enums to their values\n        # JavaScript doesn't understand Python enum types\n        # Extract the underlying value (string, int, etc.)\n        if config.convert_enums and isinstance(value, Enum):\n            value = value.value\n\n        # Step 4: Handle nested serializable objects\n        # Objects with asdict() method are serialized recursively\n        # This enables deep serialization of complex object hierarchies\n        if hasattr(value, \"asdict\") and callable(value.asdict):\n            value = value.asdict()\n\n        # Step 5: Handle serializable lists recursively\n        # Lists may contain nested objects that also need serialization\n        elif isinstance(value, list):\n            return self._serialize_list_recursively(value, config)\n\n        # Step 6: Handle nested dictionaries recursively\n        # Dictionaries need key conversion (snake_case to camelCase)\n        # and recursive value processing\n        elif isinstance(value, dict):\n            return self._serialize_dict_recursively(value, config)\n\n        # Step 7: Return the processed value\n        # At this point, the value has been fully processed and is\n        # ready for JSON serialization\n        return value\n\n    def _serialize_list_recursively(\n        self,\n        items: list[Any],\n        config: SerializationConfig,\n    ) -&gt; list[Any]:\n        \"\"\"Serialize a list recursively.\n\n        This method processes each item in a list, applying the same\n        serialization logic as the parent object. It ensures that nested\n        objects, enums, and special types within lists are properly\n        converted for frontend consumption.\n\n        Args:\n            items (list[Any]): List of items to serialize. Items can be\n                any Python type including nested objects, primitives,\n                enums, dicts, or other lists.\n            config (SerializationConfig): Configuration controlling the\n                serialization behavior for each item.\n\n        Returns:\n            list[Any]: Recursively serialized list with all items processed\n                according to the configuration. The list is ready for JSON\n                serialization.\n\n        Example:\n            List of primitives::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; mixin._serialize_list_recursively([1, 2, 3], config)\n                [1, 2, 3]\n\n            List with enums::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Status(Enum):\n                ...     ACTIVE = \"active\"\n                ...     INACTIVE = \"inactive\"\n                &gt;&gt;&gt; items = [Status.ACTIVE, Status.INACTIVE]\n                &gt;&gt;&gt; mixin._serialize_list_recursively(items, config)\n                ['active', 'inactive']\n\n            List with nested objects::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Point(SerializableMixin):\n                ...     x: int\n                ...     y: int\n                ...     def asdict(self):\n                ...         return {\"x\": self.x, \"y\": self.y}\n                &gt;&gt;&gt; items = [Point(1, 2), Point(3, 4)]\n                &gt;&gt;&gt; mixin._serialize_list_recursively(items, config)\n                [{'x': 1, 'y': 2}, {'x': 3, 'y': 4}]\n\n        Note:\n            This method is recursive and will process deeply nested lists.\n            Circular references will cause infinite recursion.\n        \"\"\"\n        # Initialize result list to hold processed items\n        processed_items = []\n\n        # Iterate through each item in the input list\n        for item in items:\n            # Process each item using the same serialization logic\n            # This ensures consistency between top-level and nested values\n            # Handles: enums, nested objects, dicts, other lists, etc.\n            processed_item = self._process_value_for_serialization(\n                item, config\n            )\n\n            # Add the processed item to result list\n            processed_items.append(processed_item)\n\n        # Return the fully processed list\n        return processed_items\n\n    def _serialize_dict_recursively(\n        self,\n        data: dict[str, Any],\n        config: SerializationConfig,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize a dictionary recursively with key conversion.\n\n        This method processes dictionaries by converting keys from snake_case\n        to camelCase and recursively serializing values. It ensures that\n        nested dictionaries follow JavaScript naming conventions.\n\n        Args:\n            data (dict[str, Any]): Dictionary to serialize. Keys should be\n                strings (typically in snake_case), values can be any type.\n            config (SerializationConfig): Configuration controlling the\n                serialization behavior for values.\n\n        Returns:\n            dict[str, Any]: Recursively processed dictionary with camelCase\n                keys and serialized values. Ready for JSON serialization.\n\n        Example:\n            Simple dict with snake_case keys::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; data = {\"first_name\": \"John\", \"last_name\": \"Doe\"}\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'firstName': 'John', 'lastName': 'Doe'}\n\n            Nested dict::\n\n                &gt;&gt;&gt; data = {\n                ...     \"user_info\": {\n                ...         \"first_name\": \"John\",\n                ...         \"age_years\": 30\n                ...     }\n                ... }\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'userInfo': {'firstName': 'John', 'ageYears': 30}}\n\n            Dict with enum values::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Status(Enum):\n                ...     ACTIVE = \"active\"\n                &gt;&gt;&gt; data = {\"user_status\": Status.ACTIVE}\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'userStatus': 'active'}\n\n        Note:\n            Non-string keys are converted to strings before camelCase\n            conversion. This ensures consistent behavior with JavaScript\n            object keys which are always strings.\n        \"\"\"\n        # Initialize result dictionary to hold processed key-value pairs\n        result = {}\n\n        # Iterate through each key-value pair in the input dictionary\n        for key, value in data.items():\n            # Step 1: Convert key to camelCase for JavaScript compatibility\n            # JavaScript conventionally uses camelCase for object keys\n            # If key is not a string, convert it to string first\n            # (JavaScript object keys are always strings)\n            processed_key = (\n                snake_to_camel(key) if isinstance(key, str) else str(key)\n            )\n\n            # Step 2: Process value recursively\n            # Apply the full serialization pipeline to the value\n            # This handles nested objects, enums, lists, dicts, etc.\n            processed_value = self._process_value_for_serialization(\n                value, config\n            )\n\n            # Step 3: Add processed key-value pair to result dictionary\n            result[processed_key] = processed_value\n\n        # Return the fully processed dictionary\n        return result\n\n    def _process_field_name_for_serialization(\n        self,\n        field_name: str,\n        _config: SerializationConfig,\n    ) -&gt; str:\n        \"\"\"Process field name for serialization with special handling.\n\n        This method converts field names from Python's snake_case convention\n        to JavaScript's camelCase convention. It also handles special field\n        names that need to map to specific constants for frontend compatibility.\n\n        Special field handling:\n            - 'time' -&gt; Maps to ColumnNames.TIME enum value\n            - 'value' -&gt; Maps to ColumnNames.VALUE enum value\n            - All other fields -&gt; Standard snake_case to camelCase conversion\n\n        Args:\n            field_name (str): Original Python field name in snake_case\n                (e.g., \"title_text\", \"is_visible\").\n            _config (SerializationConfig): Serialization configuration\n                (currently unused but kept for interface consistency).\n\n        Returns:\n            str: Processed field name in camelCase or special constant value.\n                Ready for use as JavaScript object key.\n\n        Example:\n            Regular field conversion::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\n                ...     \"title_text\", config\n                ... )\n                'titleText'\n\n            Special field handling::\n\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\"time\", config)\n                'time'  # Maps to ColumnNames.TIME.value\n\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\"value\", config)\n                'value'  # Maps to ColumnNames.VALUE.value\n\n        Note:\n            The function imports ColumnNames dynamically to avoid circular\n            import issues. If the import fails, it falls back to standard\n            camelCase conversion.\n        \"\"\"\n        # Special handling for known column names to match frontend expectations\n        # These special cases ensure consistent naming with the JavaScript chart\n        # library which expects specific field names for time and value data\n\n        if field_name == \"time\":\n            # Case 1: \"time\" field - use ColumnNames enum for consistency\n            # The \"time\" field is critical for chart data and must match\n            # exactly what the JavaScript library expects\n            try:\n                # Import inside function to avoid circular import issues\n                # The enum module may depend on this serialization module\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                    ColumnNames,\n                )\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                # This ensures serialization still works even if enums\n                # module isn't available (e.g., during testing)\n                return snake_to_camel(field_name)\n            else:\n                # Return the canonical time field name from enum\n                return ColumnNames.TIME.value\n\n        elif field_name == \"value\":\n            # Case 2: \"value\" field - use ColumnNames enum for consistency\n            # The \"value\" field is used for chart data points and must\n            # match the JavaScript library's expectations\n            try:\n                # Import inside function to avoid circular import issues\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                    ColumnNames,\n                )\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                return snake_to_camel(field_name)\n            else:\n                # Return the canonical value field name from enum\n                return ColumnNames.VALUE.value\n\n        else:\n            # Case 3: Regular field - convert snake_case to camelCase\n            # This is the standard conversion for most fields\n            # Examples: title_text -&gt; titleText, is_visible -&gt; isVisible\n            return snake_to_camel(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.SerializationConfig","title":"SerializationConfig","text":"<p>Configuration for serialization behavior.</p> <p>This class controls how objects are serialized to dictionaries for frontend consumption. It provides fine-grained control over which values are included, how they're transformed, and how special fields are handled.</p> <p>The configuration allows different classes to have different serialization rules without duplicating code. For example, some classes may want to keep None values while others skip them.</p> <p>Attributes:</p> Name Type Description <code>skip_none</code> <code>bool</code> <p>If True, fields with None values are omitted from serialized output. Reduces payload size for optional fields.</p> <code>skip_empty_strings</code> <code>bool</code> <p>If True, fields with empty string values (\"\") are omitted. Useful for preventing empty labels in charts.</p> <code>skip_empty_dicts</code> <code>bool</code> <p>If True, fields with empty dictionary values ({}) are omitted. Prevents unnecessary nested empty objects.</p> <code>convert_nan_to_zero</code> <code>bool</code> <p>If True, NaN float values are converted to 0.0. Required for JSON compatibility as JSON doesn't support NaN.</p> <code>convert_enums</code> <code>bool</code> <p>If True, Enum instances are converted to their underlying values. JavaScript doesn't understand Python enums.</p> <code>flatten_options_fields</code> <code>bool</code> <p>If True, fields ending in '_options' like 'background_options' have their contents merged into the parent dictionary instead of being nested.</p> Example <p>Create custom config for strict serialization::</p> <pre><code>&gt;&gt;&gt; config = SerializationConfig(\n...     skip_none=False,  # Keep None values\n...     skip_empty_strings=False,  # Keep empty strings\n...     convert_nan_to_zero=False  # Keep NaN as-is\n... )\n</code></pre> <p>Create config for minimal payload::</p> <pre><code>&gt;&gt;&gt; config = SerializationConfig(\n...     skip_none=True,\n...     skip_empty_strings=True,\n...     skip_empty_dicts=True\n... )\n</code></pre> Note <p>The DEFAULT_CONFIG instance uses sensible defaults for most use cases: skip None/empty values, convert NaN to zero, convert enums.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializationConfig:\n    \"\"\"Configuration for serialization behavior.\n\n    This class controls how objects are serialized to dictionaries for\n    frontend consumption. It provides fine-grained control over which\n    values are included, how they're transformed, and how special fields\n    are handled.\n\n    The configuration allows different classes to have different\n    serialization rules without duplicating code. For example, some\n    classes may want to keep None values while others skip them.\n\n    Attributes:\n        skip_none (bool): If True, fields with None values are omitted\n            from serialized output. Reduces payload size for optional fields.\n        skip_empty_strings (bool): If True, fields with empty string values\n            (\"\") are omitted. Useful for preventing empty labels in charts.\n        skip_empty_dicts (bool): If True, fields with empty dictionary values\n            ({}) are omitted. Prevents unnecessary nested empty objects.\n        convert_nan_to_zero (bool): If True, NaN float values are converted\n            to 0.0. Required for JSON compatibility as JSON doesn't support NaN.\n        convert_enums (bool): If True, Enum instances are converted to their\n            underlying values. JavaScript doesn't understand Python enums.\n        flatten_options_fields (bool): If True, fields ending in '_options'\n            like 'background_options' have their contents merged into the\n            parent dictionary instead of being nested.\n\n    Example:\n        Create custom config for strict serialization::\n\n            &gt;&gt;&gt; config = SerializationConfig(\n            ...     skip_none=False,  # Keep None values\n            ...     skip_empty_strings=False,  # Keep empty strings\n            ...     convert_nan_to_zero=False  # Keep NaN as-is\n            ... )\n\n        Create config for minimal payload::\n\n            &gt;&gt;&gt; config = SerializationConfig(\n            ...     skip_none=True,\n            ...     skip_empty_strings=True,\n            ...     skip_empty_dicts=True\n            ... )\n\n    Note:\n        The DEFAULT_CONFIG instance uses sensible defaults for most use\n        cases: skip None/empty values, convert NaN to zero, convert enums.\n    \"\"\"\n\n    def __init__(\n        self,\n        skip_none: bool = True,\n        skip_empty_strings: bool = True,\n        skip_empty_dicts: bool = True,\n        convert_nan_to_zero: bool = True,\n        convert_enums: bool = True,\n        flatten_options_fields: bool = True,\n    ):\n        \"\"\"Initialize serialization configuration.\n\n        Args:\n            skip_none (bool, optional): Whether to skip None values in\n                serialization. Defaults to True. When True, optional fields\n                set to None are omitted from output.\n            skip_empty_strings (bool, optional): Whether to skip empty string\n                values. Defaults to True. When True, fields with \"\" values\n                are omitted.\n            skip_empty_dicts (bool, optional): Whether to skip empty dictionary\n                values. Defaults to True. When True, fields with {} values\n                are omitted.\n            convert_nan_to_zero (bool, optional): Whether to convert NaN float\n                values to 0.0. Defaults to True. Required for JSON compatibility\n                since JSON spec doesn't support NaN.\n            convert_enums (bool, optional): Whether to convert Enum objects to\n                their values. Defaults to True. JavaScript can't understand\n                Python enum types directly.\n            flatten_options_fields (bool, optional): Whether to flatten fields\n                ending in '_options'. Defaults to True. When True, fields like\n                'background_options' have their dict contents merged into parent\n                instead of being nested.\n\n        Example:\n            Default configuration::\n\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; config.skip_none\n                True\n\n            Custom configuration::\n\n                &gt;&gt;&gt; config = SerializationConfig(\n                ...     skip_none=False,\n                ...     convert_nan_to_zero=False\n                ... )\n                &gt;&gt;&gt; config.skip_none\n                False\n        \"\"\"\n        # Store skip_none setting for filtering None values\n        self.skip_none = skip_none\n\n        # Store skip_empty_strings setting for filtering empty strings\n        self.skip_empty_strings = skip_empty_strings\n\n        # Store skip_empty_dicts setting for filtering empty dictionaries\n        self.skip_empty_dicts = skip_empty_dicts\n\n        # Store NaN conversion setting for JSON compatibility\n        self.convert_nan_to_zero = convert_nan_to_zero\n\n        # Store enum conversion setting for JavaScript compatibility\n        self.convert_enums = convert_enums\n\n        # Store field flattening setting for special options handling\n        self.flatten_options_fields = flatten_options_fields\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.SimpleSerializableMixin","title":"SimpleSerializableMixin","text":"<p>Simplified mixin for basic classes that need basic serialization.</p> <p>This variant provides a more straightforward serialization approach for simple data classes that don't need complex nested serialization or special field handling. It implements a default asdict() method that uses DEFAULT_CONFIG, saving boilerplate code in simple classes.</p> Use this when <ul> <li>Your class has simple fields (strings, ints, bools)</li> <li>You don't need custom serialization config</li> <li>You don't need special field transformations</li> <li>Default filtering rules (skip None, empty strings) are acceptable</li> </ul> Example <p>Simple data class::</p> <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import (\n    SimpleSerializableMixin\n)\n\n@dataclass\nclass ChartTitle(SimpleSerializableMixin):\n    text: str\n    font_size: int = 14\n    is_visible: bool = True\n\ntitle = ChartTitle(text=\"My Chart\")\nresult = title.asdict()\n# Returns: {\"text\": \"My Chart\", \"fontSize\": 14, \"isVisible\": True}\n</code></pre> Note <p>If you need custom serialization config or field overrides, inherit from SerializableMixin instead and implement your own asdict() method.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SimpleSerializableMixin(SerializableMixin):\n    \"\"\"Simplified mixin for basic classes that need basic serialization.\n\n    This variant provides a more straightforward serialization approach\n    for simple data classes that don't need complex nested serialization\n    or special field handling. It implements a default asdict() method\n    that uses DEFAULT_CONFIG, saving boilerplate code in simple classes.\n\n    Use this when:\n        - Your class has simple fields (strings, ints, bools)\n        - You don't need custom serialization config\n        - You don't need special field transformations\n        - Default filtering rules (skip None, empty strings) are acceptable\n\n    Example:\n        Simple data class::\n\n            from dataclasses import dataclass\n            from streamlit_lightweight_charts_pro.utils.serialization import (\n                SimpleSerializableMixin\n            )\n\n            @dataclass\n            class ChartTitle(SimpleSerializableMixin):\n                text: str\n                font_size: int = 14\n                is_visible: bool = True\n\n            title = ChartTitle(text=\"My Chart\")\n            result = title.asdict()\n            # Returns: {\"text\": \"My Chart\", \"fontSize\": 14, \"isVisible\": True}\n\n    Note:\n        If you need custom serialization config or field overrides,\n        inherit from SerializableMixin instead and implement your own\n        asdict() method.\n    \"\"\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n        This method provides a default implementation that uses the\n        DEFAULT_CONFIG for serialization. It's suitable for most simple\n        classes that don't need special handling.\n\n        Returns:\n            dict[str, Any]: Serialized representation with camelCase keys,\n                filtered according to DEFAULT_CONFIG rules (skip None,\n                empty strings, empty dicts).\n\n        Example:\n            &gt;&gt;&gt; @dataclass\n            ... class Point(SimpleSerializableMixin):\n            ...     x_coord: int\n            ...     y_coord: int\n            &gt;&gt;&gt; point = Point(x_coord=10, y_coord=20)\n            &gt;&gt;&gt; point.asdict()\n            {'xCoord': 10, 'yCoord': 20}\n        \"\"\"\n        # Use the base class _serialize_to_dict with DEFAULT_CONFIG\n        # This applies standard serialization rules without customization\n        return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.SimpleSerializableMixin-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.SimpleSerializableMixin.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[str, Any]\n</code></pre> <p>Serialize to dictionary with basic camelCase conversion.</p> <p>This method provides a default implementation that uses the DEFAULT_CONFIG for serialization. It's suitable for most simple classes that don't need special handling.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Serialized representation with camelCase keys, filtered according to DEFAULT_CONFIG rules (skip None, empty strings, empty dicts).</p> Example <p>@dataclass ... class Point(SimpleSerializableMixin): ...     x_coord: int ...     y_coord: int point = Point(x_coord=10, y_coord=20) point.asdict()</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n    This method provides a default implementation that uses the\n    DEFAULT_CONFIG for serialization. It's suitable for most simple\n    classes that don't need special handling.\n\n    Returns:\n        dict[str, Any]: Serialized representation with camelCase keys,\n            filtered according to DEFAULT_CONFIG rules (skip None,\n            empty strings, empty dicts).\n\n    Example:\n        &gt;&gt;&gt; @dataclass\n        ... class Point(SimpleSerializableMixin):\n        ...     x_coord: int\n        ...     y_coord: int\n        &gt;&gt;&gt; point = Point(x_coord=10, y_coord=20)\n        &gt;&gt;&gt; point.asdict()\n        {'xCoord': 10, 'yCoord': 20}\n    \"\"\"\n    # Use the base class _serialize_to_dict with DEFAULT_CONFIG\n    # This applies standard serialization rules without customization\n    return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.chainable_field","title":"chainable_field","text":"<pre><code>chainable_field(field_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False)\n</code></pre> <p>Decorator that creates a setter method for dataclass fields with optional validation.</p> <p>This decorator enables method chaining for dataclass fields by creating a setter method that applies validation and returns the instance for chaining. Unlike chainable_property, this only creates the method and doesn't override direct assignment behavior.</p> <p>The created method follows the naming convention <code>set_{field_name}</code> and applies the same validation logic as chainable_property, but only when the method is explicitly called.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the dataclass field to create a setter for. The method will be named <code>set_{field_name}</code>.</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add a setter method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the field name conflicts with existing attributes.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"line_options\", LineOptions, allow_none=True)\nclass MyOptions:\n    color: str = \"#000000\"\n    width: int = 800\n    line_options: Optional[LineOptions] = None\n\n\n# Usage examples\noptions = MyOptions()\n\n# Method chaining (with validation)\noptions.set_color(\"#ff0000\").set_width(600)\n\n# Direct assignment (no validation)\noptions.color = \"invalid_color\"  # No validation applied\noptions.set_color(\"invalid_color\")  # Raises ValueError\n\n# With None values when allow_none=True\noptions.set_line_options(None)  # Valid due to allow_none=True\n</code></pre> Note <p>Direct assignment to dataclass fields bypasses validation. Use the generated setter methods when validation is required.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n):\n    \"\"\"Decorator that creates a setter method for dataclass fields with optional validation.\n\n    This decorator enables method chaining for dataclass fields by creating a setter\n    method that applies validation and returns the instance for chaining. Unlike\n    chainable_property, this only creates the method and doesn't override direct\n    assignment behavior.\n\n    The created method follows the naming convention `set_{field_name}` and applies\n    the same validation logic as chainable_property, but only when the method is\n    explicitly called.\n\n    Args:\n        field_name: The name of the dataclass field to create a setter for.\n            The method will be named `set_{field_name}`.\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n\n    Returns:\n        Decorator function that modifies the class to add a setter method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the field name conflicts with existing attributes.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n        @dataclass\n        @chainable_field(\"color\", str, validator=\"color\")\n        @chainable_field(\"width\", int)\n        @chainable_field(\"line_options\", LineOptions, allow_none=True)\n        class MyOptions:\n            color: str = \"#000000\"\n            width: int = 800\n            line_options: Optional[LineOptions] = None\n\n\n        # Usage examples\n        options = MyOptions()\n\n        # Method chaining (with validation)\n        options.set_color(\"#ff0000\").set_width(600)\n\n        # Direct assignment (no validation)\n        options.color = \"invalid_color\"  # No validation applied\n        options.set_color(\"invalid_color\")  # Raises ValueError\n\n        # With None values when allow_none=True\n        options.set_line_options(None)  # Valid due to allow_none=True\n        ```\n\n    Note:\n        Direct assignment to dataclass fields bypasses validation. Use the\n        generated setter methods when validation is required.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the dataclass.\n\n        Args:\n            cls: The dataclass to be decorated.\n\n        Returns:\n            The modified class with added setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{field_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation for dataclass fields.\n\n            Args:\n                self: The dataclass instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, field_name, None)\n                return self\n\n            # Step 2: Apply validation and transformation\n            validated_value = _validate_value(field_name, value, value_type, validator)\n\n            # Step 3: Set the validated value directly on the dataclass field\n            setattr(self, field_name, validated_value)\n\n            # Step 4: Return self to enable method chaining\n            return self\n\n        # Step 2: Add the generated setter method to the class\n        setattr(cls, setter_name, setter_method)\n\n        # Step 3: Return the modified class\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.chainable_property","title":"chainable_property","text":"<pre><code>chainable_property(attr_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False, top_level: bool = False)\n</code></pre> <p>Decorator that creates both a property setter and a chaining method with optional validation.</p> <p>This decorator enables two usage patterns for the same attribute: 1. Property assignment: <code>obj.attr = value</code> 2. Method chaining: <code>obj.set_attr(value).other_method()</code></p> <p>The decorator automatically creates both the property setter and a chaining method, applying the same validation logic to both. This provides flexibility in how developers interact with the API while maintaining consistency.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of the attribute to manage. This will be used to create both the property name and the setter method name (e.g., \"color\" creates both a \"color\" property and a \"set_color\" method).</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <code>top_level</code> <code>bool</code> <p>Whether this property should be output at the top level in asdict() instead of in the options dictionary. Useful for properties that should be serialized separately from the main options.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add both property and method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the attribute name conflicts with existing attributes.</p> Example <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"width\", int)\n@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=validate_base_value)\n@chainable_property(\"price_scale_id\", top_level=True)\nclass MySeries(Series):\n    def __init__(self):\n        self._color = \"#000000\"\n        self._width = 800\n        self._line_options = None\n        self._base_value = 0\n        self._price_scale_id = \"right\"\n\n\n# Usage examples\nseries = MySeries()\n\n# Property assignment\nseries.color = \"#ff0000\"\nseries.width = 600\n\n# Method chaining\nseries.set_color(\"#00ff00\").set_width(800)\n\n# With validation\nseries.set_color(\"invalid\")  # Raises ValueError\nseries.set_width(\"not_a_number\")  # Raises TypeError\n</code></pre> Note <p>The decorator creates both a property setter and a method, so the class must have the corresponding private attribute (e.g., <code>_color</code> for <code>color</code>). The property getter is not created automatically - you may need to add it manually if needed.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_property(\n    attr_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n    top_level: bool = False,\n):\n    \"\"\"Decorator that creates both a property setter and a chaining method with optional validation.\n\n    This decorator enables two usage patterns for the same attribute:\n    1. Property assignment: `obj.attr = value`\n    2. Method chaining: `obj.set_attr(value).other_method()`\n\n    The decorator automatically creates both the property setter and a chaining\n    method, applying the same validation logic to both. This provides flexibility\n    in how developers interact with the API while maintaining consistency.\n\n    Args:\n        attr_name: The name of the attribute to manage. This will be used to create\n            both the property name and the setter method name (e.g., \"color\" creates\n            both a \"color\" property and a \"set_color\" method).\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n        top_level: Whether this property should be output at the top level in\n            asdict() instead of in the options dictionary. Useful for properties\n            that should be serialized separately from the main options.\n\n    Returns:\n        Decorator function that modifies the class to add both property and method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the attribute name conflicts with existing attributes.\n\n    Example:\n        ```python\n        @chainable_property(\"color\", str, validator=\"color\")\n        @chainable_property(\"width\", int)\n        @chainable_property(\"line_options\", LineOptions, allow_none=True)\n        @chainable_property(\"base_value\", validator=validate_base_value)\n        @chainable_property(\"price_scale_id\", top_level=True)\n        class MySeries(Series):\n            def __init__(self):\n                self._color = \"#000000\"\n                self._width = 800\n                self._line_options = None\n                self._base_value = 0\n                self._price_scale_id = \"right\"\n\n\n        # Usage examples\n        series = MySeries()\n\n        # Property assignment\n        series.color = \"#ff0000\"\n        series.width = 600\n\n        # Method chaining\n        series.set_color(\"#00ff00\").set_width(800)\n\n        # With validation\n        series.set_color(\"invalid\")  # Raises ValueError\n        series.set_width(\"not_a_number\")  # Raises TypeError\n        ```\n\n    Note:\n        The decorator creates both a property setter and a method, so the class\n        must have the corresponding private attribute (e.g., `_color` for `color`).\n        The property getter is not created automatically - you may need to add\n        it manually if needed.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the class.\n\n        Args:\n            cls: The class to be decorated.\n\n        Returns:\n            The modified class with added property and setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{attr_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return self\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # Case 1: Boolean type - strict validation (no truthy/falsy coercion)\n                    # Only accept actual True/False, not 1/0 or other truthy values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif not isinstance(value, value_type):\n                    # Case 2: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # Case 3: Complex types (classes, custom types)\n                        # Indicate whether None is allowed in the error message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # Case 4: Union types like (int, float)\n                        # Create friendly error message from type names\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        # Special handling for numeric union types\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Step 3: Apply custom validation if specified\n            # Custom validators can transform values or perform additional checks\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Case 1: Built-in validators (string identifiers)\n                    # These are predefined validators for common chart properties\n                    if validator == \"color\":\n                        # Color validator: Accepts hex codes and rgba values\n                        # Empty string is treated as \"no color\" (converted to None)\n                        if value == \"\":\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        # Price format type validator\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        # Precision validator (for decimal places)\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        # Minimum move validator (for price scales)\n                        value = validate_min_move(value)\n                    else:\n                        # Unknown validator string\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Case 2: Custom validator function\n                    # Allows users to provide their own validation/transformation logic\n                    value = validator(value)\n\n            # Step 4: Set the validated value on the private attribute\n            # Uses the private attribute convention (_attr_name)\n            setattr(self, f\"_{attr_name}\", value)\n\n            # Step 5: Return self to enable method chaining\n            return self\n\n        def property_getter(self):\n            \"\"\"Property getter for accessing the attribute value.\n\n            Args:\n                self: The instance.\n\n            Returns:\n                The current value of the attribute.\n            \"\"\"\n            return getattr(self, f\"_{attr_name}\")\n\n        def property_setter(self, value):\n            \"\"\"Property setter for direct assignment with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # For boolean properties, only accept actual boolean values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif _is_list_of_markers(value_type):\n                    # Case 2a: Special handling for List[MarkerBase] and similar types\n                    # Markers require special validation due to their complex structure\n                    _validate_list_of_markers(value, attr_name)\n                elif not isinstance(value, value_type):\n                    # Case 2b: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # For complex types, use a more user-friendly message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # For tuple types like (int, float), create a user-friendly message\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Apply custom validation if specified\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Built-in validators\n                    if validator == \"color\":\n                        # Treat empty strings as valid (meaning \"no color\")\n                        if value == \"\":\n                            # Convert empty string to None for consistent handling\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        value = validate_min_move(value)\n                    else:\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Custom validator function\n                    value = validator(value)\n\n            setattr(self, f\"_{attr_name}\", value)\n\n        # Create the property\n        prop = property(property_getter, property_setter)\n\n        # Add the property and method to the class\n        setattr(cls, attr_name, prop)\n        setattr(cls, setter_name, setter_method)\n\n        # Store metadata about serialization\n        if not hasattr(cls, \"_chainable_properties\"):\n            # pylint: disable=protected-access\n            cls._chainable_properties = {}\n\n        # pylint: disable=protected-access\n        cls._chainable_properties[attr_name] = {\n            \"allow_none\": allow_none,\n            \"value_type\": value_type,\n            \"top_level\": top_level,\n        }\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.validated_field","title":"validated_field","text":"<pre><code>validated_field(field_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False)\n</code></pre> <p>Decorator that validates dataclass fields on initialization and provides setter methods.</p> <p>This decorator extends chainable_field by adding validation during post_init. It ensures that field values are validated both when constructed and when using setter methods, providing consistent validation across the entire lifecycle.</p> <p>The decorator creates both a setter method (like chainable_field) and hooks into the dataclass post_init to validate the field value after initialization.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the dataclass field to validate. The method will be named <code>set_{field_name}</code>.</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add validation and setter.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils import validated_field\n\n\n@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"width\", int)\nclass MyData:\n    color: Optional[str] = None\n    width: int = 100\n\n\n# Valid usage\ndata = MyData(color=\"#ff0000\", width=200)  # Validated on init\ndata.set_color(\"#00ff00\")  # Validated on setter\n\n# Invalid usage - validation catches errors\ndata = MyData(color=\"invalid_color\")  # Raises ColorValidationError\ndata = MyData(width=\"not_a_number\")  # Raises TypeValidationError\n</code></pre> Note <p>This decorator should be applied BEFORE the @dataclass decorator in the decorator stack. It works by wrapping the post_init method to add validation logic after dataclass initialization.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def validated_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n):\n    \"\"\"Decorator that validates dataclass fields on initialization and provides setter methods.\n\n    This decorator extends chainable_field by adding validation during __post_init__.\n    It ensures that field values are validated both when constructed and when using\n    setter methods, providing consistent validation across the entire lifecycle.\n\n    The decorator creates both a setter method (like chainable_field) and hooks into\n    the dataclass __post_init__ to validate the field value after initialization.\n\n    Args:\n        field_name: The name of the dataclass field to validate.\n            The method will be named `set_{field_name}`.\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n\n    Returns:\n        Decorator function that modifies the class to add validation and setter.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils import validated_field\n\n\n        @dataclass\n        @validated_field(\"color\", str, validator=\"color\", allow_none=True)\n        @validated_field(\"width\", int)\n        class MyData:\n            color: Optional[str] = None\n            width: int = 100\n\n\n        # Valid usage\n        data = MyData(color=\"#ff0000\", width=200)  # Validated on init\n        data.set_color(\"#00ff00\")  # Validated on setter\n\n        # Invalid usage - validation catches errors\n        data = MyData(color=\"invalid_color\")  # Raises ColorValidationError\n        data = MyData(width=\"not_a_number\")  # Raises TypeValidationError\n        ```\n\n    Note:\n        This decorator should be applied BEFORE the @dataclass decorator in the\n        decorator stack. It works by wrapping the __post_init__ method to add\n        validation logic after dataclass initialization.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the dataclass.\n\n        Args:\n            cls: The dataclass to be decorated.\n\n        Returns:\n            The modified class with validation and setter method.\n        \"\"\"\n        # Step 1: First apply chainable_field to get the setter method\n        cls = chainable_field(field_name, value_type, validator, allow_none)(cls)\n\n        # Step 2: Store the original __post_init__ if it exists\n        original_post_init = getattr(cls, \"__post_init__\", None)\n\n        # Step 3: Create new __post_init__ that adds validation\n        def new_post_init(self):\n            \"\"\"Enhanced __post_init__ that validates fields after initialization.\n\n            This method runs after the dataclass __init__ completes, validating\n            the field value and applying any necessary transformations.\n\n            Args:\n                self: The dataclass instance being initialized.\n            \"\"\"\n            # First, call the original __post_init__ if it exists\n            if original_post_init is not None:\n                original_post_init(self)\n\n            # Get the current field value\n            value = getattr(self, field_name)\n\n            # Skip validation if None and allow_none is True\n            if value is None and allow_none:\n                return\n\n            # Apply validation using the same logic as the setter\n            try:\n                validated_value = _validate_value(field_name, value, value_type, validator)\n                # Set the validated (and possibly transformed) value back\n                setattr(self, field_name, validated_value)\n            except (TypeError, ValueError) as e:\n                # Re-raise with more context about initialization\n                raise type(e)(\n                    f\"Validation error during initialization of '{field_name}': {e}\"\n                ) from e\n\n        # Step 4: Replace the __post_init__ method\n        cls.__post_init__ = new_post_init\n\n        # Step 5: Track which fields have validation for debugging\n        if not hasattr(cls, \"_validated_fields\"):\n            cls._validated_fields = []\n        cls._validated_fields.append(field_name)\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.add_opacity","title":"add_opacity","text":"<pre><code>add_opacity(color: str, opacity: float = 0.3) -&gt; str\n</code></pre> <p>Convert hex color to rgba format with specified opacity.</p> <p>Takes a hex color string (e.g., \"#4CAF50\") and converts it to rgba format with the specified opacity level. This is useful for creating semi-transparent colors for overlays, backgrounds, or layered visualizations.</p> <p>If the input is already in rgba/rgb format or any non-hex format (like named colors), it is returned unchanged to avoid double conversion.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Hex color string starting with '#' (e.g., \"#4CAF50\"). Must be in format #RRGGBB (7 characters total). If the color doesn't start with '#', it's returned as-is.</p> required <code>opacity</code> <code>float</code> <p>Opacity level between 0.0 (fully transparent) and 1.0 (fully opaque). Defaults to 0.3 (30% opacity).</p> <code>0.3</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RGBA color string in format \"rgba(r, g, b, opacity)\" if input is hex, otherwise returns the original color string unchanged.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If hex color format is invalid (not exactly 7 characters or contains non-hexadecimal digits).</p> Example <p>add_opacity(\"#4CAF50\", 0.3) 'rgba(76, 175, 80, 0.3)'</p> <p>add_opacity(\"#FF0000\", 0.5) 'rgba(255, 0, 0, 0.5)'</p> <p>add_opacity(\"rgba(255, 0, 0, 0.5)\", 0.3) 'rgba(255, 0, 0, 0.5)'</p> Note <p>The function does not validate the opacity value range. Values outside 0.0-1.0 will be accepted but may produce unexpected results in the browser.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def add_opacity(color: str, opacity: float = 0.3) -&gt; str:\n    \"\"\"Convert hex color to rgba format with specified opacity.\n\n    Takes a hex color string (e.g., \"#4CAF50\") and converts it to\n    rgba format with the specified opacity level. This is useful for\n    creating semi-transparent colors for overlays, backgrounds, or\n    layered visualizations.\n\n    If the input is already in rgba/rgb format or any non-hex format\n    (like named colors), it is returned unchanged to avoid double\n    conversion.\n\n    Args:\n        color (str): Hex color string starting with '#' (e.g., \"#4CAF50\").\n            Must be in format #RRGGBB (7 characters total).\n            If the color doesn't start with '#', it's returned as-is.\n        opacity (float, optional): Opacity level between 0.0 (fully\n            transparent) and 1.0 (fully opaque). Defaults to 0.3 (30%\n            opacity).\n\n    Returns:\n        str: RGBA color string in format \"rgba(r, g, b, opacity)\" if\n            input is hex, otherwise returns the original color string\n            unchanged.\n\n    Raises:\n        ValueError: If hex color format is invalid (not exactly 7\n            characters or contains non-hexadecimal digits).\n\n    Example:\n        &gt;&gt;&gt; add_opacity(\"#4CAF50\", 0.3)\n        'rgba(76, 175, 80, 0.3)'\n\n        &gt;&gt;&gt; add_opacity(\"#FF0000\", 0.5)\n        'rgba(255, 0, 0, 0.5)'\n\n        &gt;&gt;&gt; add_opacity(\"rgba(255, 0, 0, 0.5)\", 0.3)\n        'rgba(255, 0, 0, 0.5)'\n\n    Note:\n        The function does not validate the opacity value range.\n        Values outside 0.0-1.0 will be accepted but may produce\n        unexpected results in the browser.\n    \"\"\"\n    # Check if color starts with '#' to identify hex format\n    # If not hex, it could be rgba, rgb, or named color - return unchanged\n    if not color.startswith(\"#\"):\n        return color\n\n    # Validate hex color format: must be exactly 7 characters (#RRGGBB)\n    # This ensures we have the full 6-digit hex color format\n    if len(color) != 7:\n        raise ValueError(\n            f\"Invalid hex color format: {color}. \"\n            f\"Expected format: #RRGGBB (7 characters including #)\"\n        )\n\n    try:\n        # Extract red component from characters 1-2 (after #)\n        # Convert from hexadecimal (base 16) to decimal (base 10)\n        r = int(color[1:3], 16)\n\n        # Extract green component from characters 3-4\n        g = int(color[3:5], 16)\n\n        # Extract blue component from characters 5-6\n        b = int(color[5:7], 16)\n\n    except ValueError as e:\n        # int() raises ValueError if the string contains non-hex characters\n        # Re-raise with more descriptive error message\n        raise ValueError(\n            f\"Invalid hex color: {color}. Must contain valid hexadecimal \"\n            f\"digits (0-9, A-F).\"\n        ) from e\n    else:\n        # All conversions successful, return formatted rgba string\n        # Format: rgba(red, green, blue, opacity)\n        return f\"rgba({r}, {g}, {b}, {opacity})\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.hex_to_rgba","title":"hex_to_rgba","text":"<pre><code>hex_to_rgba(hex_color: str, alpha: Optional[float] = None) -&gt; str\n</code></pre> <p>Convert hex color to rgba or rgb format.</p> <p>This function provides a more intuitive API for hex to rgba conversion compared to add_opacity(). When alpha is None, it returns rgb format instead of rgba, which is useful when opacity is not needed.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>Hex color string (e.g., \"#4CAF50\"). Must be in format #RRGGBB (7 characters total). Non-hex colors are returned unchanged.</p> required <code>alpha</code> <code>Optional[float]</code> <p>Alpha/opacity value (0.0-1.0). If None, returns \"rgb(r, g, b)\" format without alpha channel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RGBA color string \"rgba(r, g, b, alpha)\" if alpha is provided, or RGB color string \"rgb(r, g, b)\" if alpha is None. Non-hex colors are returned unchanged.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If hex color format is invalid.</p> Example <p>Convert to rgba with alpha::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"#4CAF50\", 0.5)\n'rgba(76, 175, 80, 0.5)'\n</code></pre> <p>Convert to rgb without alpha::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"#4CAF50\")\n'rgb(76, 175, 80)'\n</code></pre> <p>Non-hex colors pass through::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"red\", 0.5)\n'red'\n</code></pre> Note <p>This is a convenience wrapper around add_opacity() that provides more flexibility with the alpha channel.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def hex_to_rgba(hex_color: str, alpha: Optional[float] = None) -&gt; str:\n    \"\"\"Convert hex color to rgba or rgb format.\n\n    This function provides a more intuitive API for hex to rgba conversion\n    compared to add_opacity(). When alpha is None, it returns rgb format\n    instead of rgba, which is useful when opacity is not needed.\n\n    Args:\n        hex_color (str): Hex color string (e.g., \"#4CAF50\"). Must be in\n            format #RRGGBB (7 characters total). Non-hex colors are\n            returned unchanged.\n        alpha (Optional[float]): Alpha/opacity value (0.0-1.0). If None,\n            returns \"rgb(r, g, b)\" format without alpha channel.\n\n    Returns:\n        str: RGBA color string \"rgba(r, g, b, alpha)\" if alpha is\n            provided, or RGB color string \"rgb(r, g, b)\" if alpha is None.\n            Non-hex colors are returned unchanged.\n\n    Raises:\n        ValueError: If hex color format is invalid.\n\n    Example:\n        Convert to rgba with alpha::\n\n            &gt;&gt;&gt; hex_to_rgba(\"#4CAF50\", 0.5)\n            'rgba(76, 175, 80, 0.5)'\n\n        Convert to rgb without alpha::\n\n            &gt;&gt;&gt; hex_to_rgba(\"#4CAF50\")\n            'rgb(76, 175, 80)'\n\n        Non-hex colors pass through::\n\n            &gt;&gt;&gt; hex_to_rgba(\"red\", 0.5)\n            'red'\n\n    Note:\n        This is a convenience wrapper around add_opacity() that provides\n        more flexibility with the alpha channel.\n    \"\"\"\n    # If alpha is None, we want rgb format (no alpha channel)\n    if alpha is None:\n        # Check if input is hex format\n        if not hex_color.startswith(\"#\"):\n            # Not hex, return unchanged (could be rgba, rgb, named color)\n            return hex_color\n\n        # Validate hex color length\n        if len(hex_color) != 7:\n            raise ValueError(f\"Invalid hex color format: {hex_color}\")\n\n        # Convert hex to decimal RGB values\n        # Extract and convert red component\n        r = int(hex_color[1:3], 16)\n        # Extract and convert green component\n        g = int(hex_color[3:5], 16)\n        # Extract and convert blue component\n        b = int(hex_color[5:7], 16)\n\n        # Return RGB format without alpha channel\n        return f\"rgb({r}, {g}, {b})\"\n\n    # If alpha is provided, use add_opacity to get rgba format\n    return add_opacity(hex_color, alpha)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/index.html#streamlit_lightweight_charts_pro.utils.is_hex_color","title":"is_hex_color","text":"<pre><code>is_hex_color(color: str) -&gt; bool\n</code></pre> <p>Check if a string is a valid hex color.</p> <p>Validates that a string follows the standard hex color format (#RRGGBB - 7 characters total). This is useful for input validation before attempting color conversion.</p> The function checks <ul> <li>Input is a string type</li> <li>String starts with '#'</li> <li>String is exactly 7 characters long</li> <li>Last 6 characters are valid hexadecimal digits (0-9, A-F)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color string to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is a valid hex color in #RRGGBB format, False otherwise.</p> Example <p>Valid hex colors::</p> <pre><code>&gt;&gt;&gt; is_hex_color(\"#4CAF50\")\nTrue\n\n&gt;&gt;&gt; is_hex_color(\"#FF0000\")\nTrue\n</code></pre> <p>Invalid formats::</p> <pre><code>&gt;&gt;&gt; is_hex_color(\"rgba(76, 175, 80, 0.3)\")\nFalse\n\n&gt;&gt;&gt; is_hex_color(\"#FFF\")\nFalse  # Too short (must be 6 digits)\n\n&gt;&gt;&gt; is_hex_color(\"red\")\nFalse  # Named color, not hex\n\n&gt;&gt;&gt; is_hex_color(\"#GGGGGG\")\nFalse  # Invalid hex digits\n</code></pre> Note <p>This function only validates the standard 6-digit hex format. Short format (#RGB) and 8-digit format with alpha (#RRGGBBAA) are not considered valid by this function.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def is_hex_color(color: str) -&gt; bool:\n    \"\"\"Check if a string is a valid hex color.\n\n    Validates that a string follows the standard hex color format\n    (#RRGGBB - 7 characters total). This is useful for input validation\n    before attempting color conversion.\n\n    The function checks:\n        - Input is a string type\n        - String starts with '#'\n        - String is exactly 7 characters long\n        - Last 6 characters are valid hexadecimal digits (0-9, A-F)\n\n    Args:\n        color (str): Color string to validate.\n\n    Returns:\n        bool: True if the string is a valid hex color in #RRGGBB format,\n            False otherwise.\n\n    Example:\n        Valid hex colors::\n\n            &gt;&gt;&gt; is_hex_color(\"#4CAF50\")\n            True\n\n            &gt;&gt;&gt; is_hex_color(\"#FF0000\")\n            True\n\n        Invalid formats::\n\n            &gt;&gt;&gt; is_hex_color(\"rgba(76, 175, 80, 0.3)\")\n            False\n\n            &gt;&gt;&gt; is_hex_color(\"#FFF\")\n            False  # Too short (must be 6 digits)\n\n            &gt;&gt;&gt; is_hex_color(\"red\")\n            False  # Named color, not hex\n\n            &gt;&gt;&gt; is_hex_color(\"#GGGGGG\")\n            False  # Invalid hex digits\n\n    Note:\n        This function only validates the standard 6-digit hex format.\n        Short format (#RGB) and 8-digit format with alpha (#RRGGBBAA)\n        are not considered valid by this function.\n    \"\"\"\n    # First check: ensure input is a string type\n    # This prevents errors when trying to call string methods\n    if not isinstance(color, str):\n        return False\n\n    # Second check: hex colors must start with '#'\n    if not color.startswith(\"#\"):\n        return False\n\n    # Third check: must be exactly 7 characters (#RRGGBB)\n    # This ensures we have the standard hex format\n    if len(color) != 7:\n        return False\n\n    # Fourth check: validate that characters after '#' are hex digits\n    try:\n        # Try to convert the 6 characters after '#' to an integer\n        # using base 16 (hexadecimal)\n        # This will raise ValueError if any character is not 0-9 or A-F\n        int(color[1:], 16)\n    except ValueError:\n        # Not valid hexadecimal digits\n        return False\n    else:\n        # All checks passed - this is a valid hex color\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html","title":"streamlit_lightweight_charts_pro.utils.case_converter","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter","title":"case_converter","text":"<p>Case conversion utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides a single source of truth for case conversion between Python's snake_case naming convention and JavaScript's camelCase convention.</p> <p>All case conversion logic is centralized here to ensure consistency and maintainability across the entire codebase. This prevents bugs that arise from having multiple implementations with slightly different behavior.</p> <p>The module serves as a critical bridge between Python and JavaScript naming conventions, enabling seamless data exchange between the Python backend and the JavaScript frontend chart library. Without proper case conversion, chart options and data would be misnamed and fail to work correctly.</p> Key Features <ul> <li>Snake_case to camelCase conversion</li> <li>CamelCase to snake_case conversion</li> <li>Recursive dictionary key conversion</li> <li>List processing with nested structure support</li> <li>Comprehensive edge case handling (numbers, special characters, etc.)</li> <li>Type-safe with proper error handling</li> <li>Pre-compiled regex patterns for optimal performance</li> <li>Thread-safe static methods</li> </ul> Architecture <p>The module follows a utility class pattern with all static methods, eliminating the need for instance creation. This design ensures:     - Zero instantiation overhead     - Thread-safe operations (no shared state)     - Simple import and usage patterns     - Centralized logic for easy maintenance</p> <p>Conversion Strategy:     snake_to_camel:         - Removes underscores         - Capitalizes first letter of each word after underscore         - Preserves numbers in their original positions         - Handles edge cases (leading/trailing underscores, etc.)</p> <pre><code>camel_to_snake:\n    - Inserts underscores before capital letters\n    - Converts all letters to lowercase\n    - Handles consecutive capitals (HTTP \u2192 http)\n    - Preserves numbers in their original positions\n\nconvert_dict_keys:\n    - Recursively processes nested dictionaries\n    - Handles lists containing dictionaries\n    - Preserves non-string keys\n    - Creates new dictionary (doesn't modify original)\n</code></pre> Example Usage <p>Basic string conversion::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.case_converter import (\n    CaseConverter\n)\n\n# Convert Python naming to JavaScript naming\njs_name = CaseConverter.snake_to_camel(\"price_scale_id\")\nprint(js_name)  # \"priceScaleId\"\n\n# Convert JavaScript naming back to Python naming\npy_name = CaseConverter.camel_to_snake(\"priceScaleId\")\nprint(py_name)  # \"price_scale_id\"\n</code></pre> <p>Dictionary key conversion for chart options::</p> <pre><code># Prepare chart options for JavaScript frontend\npython_options = {\n    \"price_scale_id\": \"right\",\n    \"line_width\": 2,\n    \"line_color\": \"#FF0000\"\n}\n\n# Convert to JavaScript-compatible format\njs_options = CaseConverter.convert_dict_keys(\n    python_options,\n    to_camel=True\n)\n# Result: {\n#     \"priceScaleId\": \"right\",\n#     \"lineWidth\": 2,\n#     \"lineColor\": \"#FF0000\"\n# }\n</code></pre> <p>Nested structure conversion::</p> <pre><code># Complex nested chart configuration\npython_config = {\n    \"chart_options\": {\n        \"time_scale\": {\"visible\": True},\n        \"price_scale\": {\"auto_scale\": False}\n    },\n    \"series_options\": {\n        \"line_width\": 2\n    }\n}\n\n# Recursively convert all keys\njs_config = CaseConverter.convert_dict_keys(python_config)\n# Result: {\n#     \"chartOptions\": {\n#         \"timeScale\": {\"visible\": True},\n#         \"priceScale\": {\"autoScale\": False}\n#     },\n#     \"seriesOptions\": {\n#         \"lineWidth\": 2\n#     }\n# }\n</code></pre> <p>Shallow conversion (top-level only)::</p> <pre><code># Only convert top-level keys\ndata = {\"price_scale\": {\"visible\": True}}\nresult = CaseConverter.convert_keys_shallow(data)\n# Result: {\"priceScale\": {\"visible\": True}}\n# Note: nested \"visible\" stays unchanged\n</code></pre> <p>Using convenience functions::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.case_converter import (\n    snake_to_camel,\n    camel_to_snake\n)\n\n# These wrap CaseConverter methods for backward compatibility\njs_name = snake_to_camel(\"price_scale_id\")  # \"priceScaleId\"\npy_name = camel_to_snake(\"priceScaleId\")    # \"price_scale_id\"\n</code></pre> Note <p>This module is performance-optimized:     - Regex patterns are pre-compiled at module load time     - No unnecessary string allocations     - Efficient recursive algorithms     - Zero instance overhead (all static methods)</p> <p>Edge cases handled:     - Leading underscores: \"private\" \u2192 \"Private\"     - Trailing underscores: \"value\" \u2192 \"value\"     - Multiple underscores: \"a___b\" \u2192 \"aB\"     - Numbers: \"value_123_test\" \u2192 \"value123Test\"     - Already converted: idempotent conversions     - Empty strings: returns empty string     - Non-string keys: preserved as-is</p> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter","title":"CaseConverter","text":"<p>Single source of truth for case conversion operations.</p> <p>This class provides static methods for converting between snake_case (Python convention) and camelCase (JavaScript convention). It handles various edge cases and supports recursive conversion of nested structures.</p> <p>All methods are static, eliminating the need for instance creation and ensuring thread-safe operations with zero overhead.</p> Design Patterns <ul> <li>Utility Class: All methods are static, no instance state</li> <li>Single Responsibility: Only handles case conversion</li> <li>DRY: Single implementation used throughout codebase</li> <li>Pre-compilation: Regex patterns compiled at class definition</li> </ul> Performance Characteristics <ul> <li>Pre-compiled regex: O(n) string processing</li> <li>No instance overhead: Zero memory allocation</li> <li>Recursive dict conversion: O(n*m) where n=keys, m=nesting depth</li> <li>Thread-safe: No shared mutable state</li> </ul> Thread Safety <p>All methods are thread-safe as they don't maintain any mutable state. Multiple threads can safely call these methods concurrently.</p> Example <p>CaseConverter.snake_to_camel(\"price_scale_id\") 'priceScaleId' CaseConverter.camel_to_snake(\"priceScaleId\") 'price_scale_id'</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>class CaseConverter:\n    \"\"\"Single source of truth for case conversion operations.\n\n    This class provides static methods for converting between snake_case\n    (Python convention) and camelCase (JavaScript convention). It handles\n    various edge cases and supports recursive conversion of nested structures.\n\n    All methods are static, eliminating the need for instance creation and\n    ensuring thread-safe operations with zero overhead.\n\n    Design Patterns:\n        - Utility Class: All methods are static, no instance state\n        - Single Responsibility: Only handles case conversion\n        - DRY: Single implementation used throughout codebase\n        - Pre-compilation: Regex patterns compiled at class definition\n\n    Performance Characteristics:\n        - Pre-compiled regex: O(n) string processing\n        - No instance overhead: Zero memory allocation\n        - Recursive dict conversion: O(n*m) where n=keys, m=nesting depth\n        - Thread-safe: No shared mutable state\n\n    Thread Safety:\n        All methods are thread-safe as they don't maintain any mutable state.\n        Multiple threads can safely call these methods concurrently.\n\n    Example:\n        &gt;&gt;&gt; CaseConverter.snake_to_camel(\"price_scale_id\")\n        'priceScaleId'\n        &gt;&gt;&gt; CaseConverter.camel_to_snake(\"priceScaleId\")\n        'price_scale_id'\n    \"\"\"\n\n    # Pre-compiled regex patterns for performance optimization\n    # These are compiled once at class definition time and reused for all conversions\n\n    # Pattern for identifying camelCase word boundaries\n    # (?&lt;!^) - Negative lookbehind: don't match at string start\n    # (?=[A-Z]) - Positive lookahead: match position before uppercase letter\n    # Result: Matches positions where we need to insert underscores\n    # Example: \"priceScaleId\" \u2192 matches before 'S' and 'I'\n    _CAMEL_PATTERN = re.compile(r\"(?&lt;!^)(?=[A-Z])\")\n\n    # Pattern for identifying snake_case word boundaries\n    # _([a-z0-9]) - Matches underscore followed by lowercase letter or digit\n    # The capturing group (parentheses) captures the letter/digit to preserve it\n    # Example: \"price_scale_id\" \u2192 matches \"_s\" and \"_i\"\n    _SNAKE_PATTERN = re.compile(r\"_([a-z0-9])\")\n\n    @staticmethod\n    def snake_to_camel(snake_case: str) -&gt; str:\n        \"\"\"Convert snake_case string to camelCase.\n\n        This function converts strings from Python's snake_case format to\n        JavaScript's camelCase format. The first character remains lowercase\n        (unless there are leading underscores), and each word after an\n        underscore is capitalized with the underscore removed.\n\n        The conversion process:\n            1. Strip and count leading underscores (affect first letter)\n            2. Strip trailing underscores (always removed)\n            3. Split on underscores to get word components\n            4. Filter out empty components (from multiple underscores)\n            5. Keep first word lowercase (or capitalize if leading underscores)\n            6. Capitalize subsequent words\n            7. Join all words together\n\n        Args:\n            snake_case (str): String in snake_case format. Examples:\n                \"price_scale_id\", \"line_color\", \"http_status_code\"\n\n        Returns:\n            str: String in camelCase format. Examples:\n                \"priceScaleId\", \"lineColor\", \"httpStatusCode\"\n\n        Examples:\n            Basic conversions::\n\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"price_scale_id\")\n                'priceScaleId'\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"line_color\")\n                'lineColor'\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"http_status_code\")\n                'httpStatusCode'\n\n            Edge cases::\n\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"single_word\")\n                'singleWord'\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"with_123_numbers\")\n                'with123Numbers'\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"_leading_underscore\")\n                'LeadingUnderscore'  # Leading underscore capitalizes first letter\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"trailing_underscore_\")\n                'trailingUnderscore'  # Trailing underscore removed\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"multiple___underscores\")\n                'multipleUnderscores'  # Multiple underscores treated as one\n                &gt;&gt;&gt; CaseConverter.snake_to_camel(\"\")\n                ''  # Empty string returns empty string\n\n        Note:\n            Edge case handling:\n                - Leading underscores result in capitalized first letter\n                - Trailing underscores are removed\n                - Multiple consecutive underscores are treated as one\n                - Empty strings return empty strings\n                - Strings with no underscores return unchanged (except leading/trailing)\n                - Numbers are preserved in their original positions\n        \"\"\"\n        # Handle empty string case immediately\n        if not snake_case:\n            return snake_case\n\n        # Step 1: Handle leading underscores specially\n        # Leading underscores indicate \"private\" or \"protected\" in Python\n        # In JavaScript, this typically means we capitalize the first letter\n        # Count how many leading underscores we have\n        leading_underscores = len(snake_case) - len(snake_case.lstrip(\"_\"))\n        # Remove leading underscores for processing\n        snake_case = snake_case.lstrip(\"_\")\n\n        # Step 2: Handle trailing underscores\n        # Trailing underscores are uncommon and should be removed\n        snake_case = snake_case.rstrip(\"_\")\n\n        # If string is now empty (was only underscores), return empty string\n        if not snake_case:\n            return \"\"\n\n        # Step 3: Split on underscores to get word components\n        # Example: \"price_scale_id\" \u2192 [\"price\", \"scale\", \"id\"]\n        components = snake_case.split(\"_\")\n\n        # Step 4: Filter out empty strings from multiple consecutive underscores\n        # Example: \"price___scale\" \u2192 [\"price\", \"\", \"\", \"scale\"] \u2192 [\"price\", \"scale\"]\n        components = [c for c in components if c]\n\n        # If no valid components remain, return empty string\n        if not components:\n            return \"\"\n\n        # Step 5: Process first component\n        # Keep it lowercase unless there were leading underscores\n        result = components[0]\n        if leading_underscores &gt; 0:\n            # Leading underscores mean we capitalize the first letter\n            # Example: \"_private_method\" \u2192 \"PrivateMethod\"\n            result = result.capitalize()\n\n        # Step 6: Process subsequent components\n        # Capitalize the first letter of each word and join them\n        # Example: [\"price\", \"scale\", \"id\"] \u2192 \"price\" + \"Scale\" + \"Id\"\n        result += \"\".join(word.capitalize() for word in components[1:])\n\n        # Return the fully converted camelCase string\n        return result\n\n    @staticmethod\n    def camel_to_snake(camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase string to snake_case.\n\n        This function converts strings from JavaScript's camelCase format to\n        Python's snake_case format. Capital letters (except the first character)\n        are converted to lowercase and preceded by an underscore.\n\n        The conversion process:\n            1. Use regex to find positions before capital letters\n            2. Insert underscore at those positions\n            3. Convert entire string to lowercase\n\n        The regex pattern handles consecutive capitals correctly:\n            - \"HTTPStatusCode\" \u2192 \"http_status_code\"\n            - \"IOError\" \u2192 \"io_error\"\n\n        Args:\n            camel_case (str): String in camelCase format. Examples:\n                \"priceScaleId\", \"lineColor\", \"HTTPStatusCode\"\n\n        Returns:\n            str: String in snake_case format. Examples:\n                \"price_scale_id\", \"line_color\", \"http_status_code\"\n\n        Examples:\n            Basic conversions::\n\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"priceScaleId\")\n                'price_scale_id'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"lineColor\")\n                'line_color'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"singleWord\")\n                'single_word'\n\n            Handling acronyms and numbers::\n\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPStatusCode\")\n                'http_status_code'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"IOError\")\n                'io_error'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPSConnection\")\n                'https_connection'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"getHTTPResponseCode\")\n                'get_http_response_code'\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"with123Numbers\")\n                'with123_numbers'\n\n            Edge cases::\n\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"\")\n                ''  # Empty string returns empty string\n                &gt;&gt;&gt; CaseConverter.camel_to_snake(\"alreadySnake\")\n                'already_snake'\n\n        Note:\n            Conversion characteristics:\n                - Consecutive capital letters are kept together until lowercase\n                  (HTTP \u2192 http, not H_T_T_P \u2192 h_t_t_p)\n                - Numbers are preserved in their original position\n                - Already snake_case strings pass through unchanged\n                - Empty strings return empty strings\n                - First character is never preceded by underscore\n\n            The regex pattern (?&lt;!^)(?=[A-Z]) means:\n                - (?&lt;!^): Negative lookbehind - don't match at start\n                - (?=[A-Z]): Positive lookahead - match before uppercase\n                This ensures we insert underscores before capitals but not\n                at the beginning of the string.\n        \"\"\"\n        # Handle empty string case immediately\n        if not camel_case:\n            return camel_case\n\n        # Step 1: Insert underscore before uppercase letters using regex\n        # The pattern finds positions before capital letters (except at start)\n        # Example: \"priceScaleId\" \u2192 \"price_Scale_Id\"\n        snake_case = CaseConverter._CAMEL_PATTERN.sub(\"_\", camel_case)\n\n        # Step 2: Convert entire string to lowercase\n        # Example: \"price_Scale_Id\" \u2192 \"price_scale_id\"\n        return snake_case.lower()\n\n    @staticmethod\n    def convert_dict_keys(\n        data: Dict[str, Any], to_camel: bool = True, recursive: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Convert all dictionary keys between snake_case and camelCase.\n\n        This function converts dictionary keys while preserving the structure\n        and values. It can optionally recurse into nested dictionaries and lists,\n        enabling complete conversion of complex nested structures like chart\n        configurations.\n\n        The conversion process:\n            1. Validate input is a dictionary\n            2. Select conversion function based on direction\n            3. Iterate through key-value pairs\n            4. Convert each key (if it's a string)\n            5. Recursively process nested structures if enabled\n            6. Return new dictionary with converted keys\n\n        Args:\n            data (Dict[str, Any]): Dictionary with keys to convert. Can contain\n                nested dictionaries, lists, or any other types.\n            to_camel (bool, optional): Direction of conversion. Defaults to True.\n                - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript)\n                - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)\n            recursive (bool, optional): Whether to recursively convert nested\n                structures. Defaults to True.\n                - True: Convert keys in nested dicts and lists\n                - False: Only convert top-level keys\n\n        Returns:\n            Dict[str, Any]: New dictionary with converted keys. The original\n                dictionary is not modified. Structure and values are preserved,\n                only keys are converted.\n\n        Examples:\n            Basic dictionary conversion::\n\n                &gt;&gt;&gt; data = {\"price_scale\": {\"visible\": True}}\n                &gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n                {'priceScale': {'visible': True}}\n\n            Reverse conversion::\n\n                &gt;&gt;&gt; data = {\"priceScale\": {\"autoScale\": False}}\n                &gt;&gt;&gt; CaseConverter.convert_dict_keys(data, to_camel=False)\n                {'price_scale': {'auto_scale': False}}\n\n            Nested structures with lists::\n\n                &gt;&gt;&gt; data = {\n                ...     \"chart_options\": {\n                ...         \"series\": [\n                ...             {\"line_color\": \"red\"},\n                ...             {\"line_color\": \"blue\"}\n                ...         ]\n                ...     }\n                ... }\n                &gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n                {\n                    'chartOptions': {\n                        'series': [\n                            {'lineColor': 'red'},\n                            {'lineColor': 'blue'}\n                        ]\n                    }\n                }\n\n            Shallow conversion (non-recursive)::\n\n                &gt;&gt;&gt; data = {\"price_scale\": {\"auto_scale\": True}}\n                &gt;&gt;&gt; CaseConverter.convert_dict_keys(data, recursive=False)\n                {'priceScale': {'auto_scale': True}}\n                # Note: nested 'auto_scale' key is not converted\n\n        Note:\n            Conversion behavior:\n                - Non-string keys are preserved as-is (ints, tuples, etc.)\n                - Nested dictionaries are converted if recursive=True\n                - Lists containing dicts are processed if recursive=True\n                - Original dictionary is never modified (returns new dict)\n                - Value types are preserved exactly\n                - Order is preserved (Python 3.7+ dict insertion order)\n\n            Performance considerations:\n                - Creates a new dictionary (doesn't modify original)\n                - Recursive conversion is O(n*m) where n=keys, m=nesting depth\n                - Non-recursive conversion is O(n) where n=keys\n        \"\"\"\n        # Validate input is a dictionary\n        # If not, return unchanged (protects against misuse)\n        if not isinstance(data, dict):\n            return data\n\n        # Step 1: Select appropriate conversion function based on direction\n        # This is done once at the start to avoid repeated conditionals\n        converter = (\n            CaseConverter.snake_to_camel\n            if to_camel\n            else CaseConverter.camel_to_snake\n        )\n\n        # Step 2: Initialize result dictionary\n        # We create a new dict rather than modifying the original\n        result = {}\n\n        # Step 3: Iterate through all key-value pairs\n        for key, value in data.items():\n            # Step 3a: Convert key if it's a string\n            # Non-string keys (int, tuple, etc.) are preserved as-is\n            # Example: \"price_scale\" \u2192 \"priceScale\" (if to_camel=True)\n            new_key = converter(key) if isinstance(key, str) else key\n\n            # Step 3b: Process value based on type and recursion setting\n            if recursive:\n                # Recursive mode: process nested structures\n                if isinstance(value, dict):\n                    # Value is a nested dictionary - recursively convert it\n                    # Example: {\"auto_scale\": True} \u2192 {\"autoScale\": True}\n                    result[new_key] = CaseConverter.convert_dict_keys(\n                        value, to_camel, recursive\n                    )\n                elif isinstance(value, list):\n                    # Value is a list - may contain dicts that need conversion\n                    # Example: [{\"line_color\": \"red\"}] \u2192 [{\"lineColor\": \"red\"}]\n                    result[new_key] = CaseConverter._convert_list(\n                        value, to_camel, recursive\n                    )\n                else:\n                    # Value is a primitive type (str, int, bool, etc.)\n                    # Keep it as-is\n                    result[new_key] = value\n            else:\n                # Non-recursive mode: just copy the value as-is\n                # Even if value is a dict or list, don't process it\n                result[new_key] = value\n\n        # Return the new dictionary with converted keys\n        return result\n\n    @staticmethod\n    def _convert_list(\n        items: List[Any], to_camel: bool, recursive: bool\n    ) -&gt; List[Any]:\n        \"\"\"Convert dictionary keys in a list of items.\n\n        This is a helper method for convert_dict_keys to handle lists that\n        may contain dictionaries or nested lists. It processes each item in\n        the list, converting dictionaries while leaving other types unchanged.\n\n        The method is called recursively when lists contain nested lists,\n        ensuring complete conversion of deeply nested structures.\n\n        Args:\n            items (List[Any]): List of items to process. May contain any types:\n                - Dictionaries (will be converted)\n                - Lists (will be recursively processed if recursive=True)\n                - Primitives (will be passed through unchanged)\n            to_camel (bool): Direction of conversion (True = to camelCase)\n            recursive (bool): Whether to recurse into nested structures\n\n        Returns:\n            List[Any]: New list with converted items. Original list is not\n                modified. Dictionaries in the list have their keys converted,\n                while other types are preserved exactly.\n\n        Example:\n            &gt;&gt;&gt; items = [\n            ...     {\"line_color\": \"red\"},\n            ...     \"some_string\",\n            ...     42,\n            ...     [{\"nested_color\": \"blue\"}]\n            ... ]\n            &gt;&gt;&gt; CaseConverter._convert_list(items, to_camel=True, recursive=True)\n            [\n                {\"lineColor\": \"red\"},\n                \"some_string\",\n                42,\n                [{\"nestedColor\": \"blue\"}]\n            ]\n\n        Note:\n            This is an internal method. Use convert_dict_keys instead of\n            calling this directly. It's designed to be called by\n            convert_dict_keys when it encounters list values.\n\n            The method handles:\n                - Dictionaries: Recursively converts keys\n                - Nested lists: Recursively processes if recursive=True\n                - Primitives: Passes through unchanged\n                - Mixed types: Handles lists with heterogeneous types\n        \"\"\"\n        # Initialize result list to hold processed items\n        result = []\n\n        # Process each item in the input list\n        for item in items:\n            if isinstance(item, dict):\n                # Item is a dictionary - convert its keys recursively\n                # This ensures nested dicts within lists are also converted\n                # Example: {\"line_color\": \"red\"} \u2192 {\"lineColor\": \"red\"}\n                result.append(\n                    CaseConverter.convert_dict_keys(item, to_camel, recursive)\n                )\n            elif isinstance(item, list) and recursive:\n                # Item is a nested list and we're in recursive mode\n                # Recursively process the nested list\n                # Example: [{\"nested_key\": \"value\"}] \u2192 [{\"nestedKey\": \"value\"}]\n                result.append(\n                    CaseConverter._convert_list(item, to_camel, recursive)\n                )\n            else:\n                # Item is a primitive type (str, int, bool, etc.) or we're not\n                # recursing into lists\n                # Keep it unchanged\n                result.append(item)\n\n        # Return the new list with processed items\n        return result\n\n    @staticmethod\n    def convert_keys_shallow(\n        data: Dict[str, Any], to_camel: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Convert dictionary keys without recursing into nested structures.\n\n        This is a convenience method equivalent to calling convert_dict_keys\n        with recursive=False. Use this when you only want to convert the\n        top-level keys and leave nested structures unchanged.\n\n        This is useful when:\n            - You only need to convert the outermost keys\n            - Performance is critical and deep recursion is expensive\n            - Nested structures are already in the correct format\n            - You want fine-grained control over conversion depth\n\n        Args:\n            data (Dict[str, Any]): Dictionary with keys to convert. Nested\n                dictionaries and lists will not have their keys converted.\n            to_camel (bool, optional): Direction of conversion. Defaults to True.\n                - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript)\n                - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)\n\n        Returns:\n            Dict[str, Any]: New dictionary with converted top-level keys only.\n                Nested structures are preserved exactly as-is.\n\n        Examples:\n            Shallow conversion::\n\n                &gt;&gt;&gt; data = {\n                ...     \"price_scale\": {\"auto_scale\": True},\n                ...     \"line_width\": 2\n                ... }\n                &gt;&gt;&gt; CaseConverter.convert_keys_shallow(data)\n                {\n                    'priceScale': {'auto_scale': True},\n                    'lineWidth': 2\n                }\n                # Note: nested 'auto_scale' is not converted\n\n            Compare with recursive conversion::\n\n                &gt;&gt;&gt; # Shallow conversion\n                &gt;&gt;&gt; shallow = CaseConverter.convert_keys_shallow(data)\n                &gt;&gt;&gt; shallow[\"priceScale\"]\n                {'auto_scale': True}  # Nested key unchanged\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Recursive conversion\n                &gt;&gt;&gt; deep = CaseConverter.convert_dict_keys(data)\n                &gt;&gt;&gt; deep[\"priceScale\"]\n                {'autoScale': True}  # Nested key converted\n\n        See Also:\n            convert_dict_keys: For recursive conversion of nested structures.\n\n        Note:\n            This is simply a convenience wrapper that calls convert_dict_keys\n            with recursive=False. It's provided for:\n                - Improved code readability (intent is clearer)\n                - Convenience (don't need to remember parameter name)\n                - API consistency (matches common use cases)\n        \"\"\"\n        # Call convert_dict_keys with recursive=False\n        # This converts only top-level keys\n        return CaseConverter.convert_dict_keys(data, to_camel, recursive=False)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter.snake_to_camel","title":"snake_to_camel  <code>staticmethod</code>","text":"<pre><code>snake_to_camel(snake_case: str) -&gt; str\n</code></pre> <p>Convert snake_case string to camelCase.</p> <p>This function converts strings from Python's snake_case format to JavaScript's camelCase format. The first character remains lowercase (unless there are leading underscores), and each word after an underscore is capitalized with the underscore removed.</p> The conversion process <ol> <li>Strip and count leading underscores (affect first letter)</li> <li>Strip trailing underscores (always removed)</li> <li>Split on underscores to get word components</li> <li>Filter out empty components (from multiple underscores)</li> <li>Keep first word lowercase (or capitalize if leading underscores)</li> <li>Capitalize subsequent words</li> <li>Join all words together</li> </ol> <p>Parameters:</p> Name Type Description Default <code>snake_case</code> <code>str</code> <p>String in snake_case format. Examples: \"price_scale_id\", \"line_color\", \"http_status_code\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in camelCase format. Examples: \"priceScaleId\", \"lineColor\", \"httpStatusCode\"</p> <p>Examples:</p> <p>Basic conversions::</p> <pre><code>&gt;&gt;&gt; CaseConverter.snake_to_camel(\"price_scale_id\")\n'priceScaleId'\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"line_color\")\n'lineColor'\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"http_status_code\")\n'httpStatusCode'\n</code></pre> <p>Edge cases::</p> <pre><code>&gt;&gt;&gt; CaseConverter.snake_to_camel(\"single_word\")\n'singleWord'\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"with_123_numbers\")\n'with123Numbers'\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"_leading_underscore\")\n'LeadingUnderscore'  # Leading underscore capitalizes first letter\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"trailing_underscore_\")\n'trailingUnderscore'  # Trailing underscore removed\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"multiple___underscores\")\n'multipleUnderscores'  # Multiple underscores treated as one\n&gt;&gt;&gt; CaseConverter.snake_to_camel(\"\")\n''  # Empty string returns empty string\n</code></pre> Note <p>Edge case handling:     - Leading underscores result in capitalized first letter     - Trailing underscores are removed     - Multiple consecutive underscores are treated as one     - Empty strings return empty strings     - Strings with no underscores return unchanged (except leading/trailing)     - Numbers are preserved in their original positions</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>@staticmethod\ndef snake_to_camel(snake_case: str) -&gt; str:\n    \"\"\"Convert snake_case string to camelCase.\n\n    This function converts strings from Python's snake_case format to\n    JavaScript's camelCase format. The first character remains lowercase\n    (unless there are leading underscores), and each word after an\n    underscore is capitalized with the underscore removed.\n\n    The conversion process:\n        1. Strip and count leading underscores (affect first letter)\n        2. Strip trailing underscores (always removed)\n        3. Split on underscores to get word components\n        4. Filter out empty components (from multiple underscores)\n        5. Keep first word lowercase (or capitalize if leading underscores)\n        6. Capitalize subsequent words\n        7. Join all words together\n\n    Args:\n        snake_case (str): String in snake_case format. Examples:\n            \"price_scale_id\", \"line_color\", \"http_status_code\"\n\n    Returns:\n        str: String in camelCase format. Examples:\n            \"priceScaleId\", \"lineColor\", \"httpStatusCode\"\n\n    Examples:\n        Basic conversions::\n\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"price_scale_id\")\n            'priceScaleId'\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"line_color\")\n            'lineColor'\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"http_status_code\")\n            'httpStatusCode'\n\n        Edge cases::\n\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"single_word\")\n            'singleWord'\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"with_123_numbers\")\n            'with123Numbers'\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"_leading_underscore\")\n            'LeadingUnderscore'  # Leading underscore capitalizes first letter\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"trailing_underscore_\")\n            'trailingUnderscore'  # Trailing underscore removed\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"multiple___underscores\")\n            'multipleUnderscores'  # Multiple underscores treated as one\n            &gt;&gt;&gt; CaseConverter.snake_to_camel(\"\")\n            ''  # Empty string returns empty string\n\n    Note:\n        Edge case handling:\n            - Leading underscores result in capitalized first letter\n            - Trailing underscores are removed\n            - Multiple consecutive underscores are treated as one\n            - Empty strings return empty strings\n            - Strings with no underscores return unchanged (except leading/trailing)\n            - Numbers are preserved in their original positions\n    \"\"\"\n    # Handle empty string case immediately\n    if not snake_case:\n        return snake_case\n\n    # Step 1: Handle leading underscores specially\n    # Leading underscores indicate \"private\" or \"protected\" in Python\n    # In JavaScript, this typically means we capitalize the first letter\n    # Count how many leading underscores we have\n    leading_underscores = len(snake_case) - len(snake_case.lstrip(\"_\"))\n    # Remove leading underscores for processing\n    snake_case = snake_case.lstrip(\"_\")\n\n    # Step 2: Handle trailing underscores\n    # Trailing underscores are uncommon and should be removed\n    snake_case = snake_case.rstrip(\"_\")\n\n    # If string is now empty (was only underscores), return empty string\n    if not snake_case:\n        return \"\"\n\n    # Step 3: Split on underscores to get word components\n    # Example: \"price_scale_id\" \u2192 [\"price\", \"scale\", \"id\"]\n    components = snake_case.split(\"_\")\n\n    # Step 4: Filter out empty strings from multiple consecutive underscores\n    # Example: \"price___scale\" \u2192 [\"price\", \"\", \"\", \"scale\"] \u2192 [\"price\", \"scale\"]\n    components = [c for c in components if c]\n\n    # If no valid components remain, return empty string\n    if not components:\n        return \"\"\n\n    # Step 5: Process first component\n    # Keep it lowercase unless there were leading underscores\n    result = components[0]\n    if leading_underscores &gt; 0:\n        # Leading underscores mean we capitalize the first letter\n        # Example: \"_private_method\" \u2192 \"PrivateMethod\"\n        result = result.capitalize()\n\n    # Step 6: Process subsequent components\n    # Capitalize the first letter of each word and join them\n    # Example: [\"price\", \"scale\", \"id\"] \u2192 \"price\" + \"Scale\" + \"Id\"\n    result += \"\".join(word.capitalize() for word in components[1:])\n\n    # Return the fully converted camelCase string\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter.camel_to_snake","title":"camel_to_snake  <code>staticmethod</code>","text":"<pre><code>camel_to_snake(camel_case: str) -&gt; str\n</code></pre> <p>Convert camelCase string to snake_case.</p> <p>This function converts strings from JavaScript's camelCase format to Python's snake_case format. Capital letters (except the first character) are converted to lowercase and preceded by an underscore.</p> The conversion process <ol> <li>Use regex to find positions before capital letters</li> <li>Insert underscore at those positions</li> <li>Convert entire string to lowercase</li> </ol> The regex pattern handles consecutive capitals correctly <ul> <li>\"HTTPStatusCode\" \u2192 \"http_status_code\"</li> <li>\"IOError\" \u2192 \"io_error\"</li> </ul> <p>Parameters:</p> Name Type Description Default <code>camel_case</code> <code>str</code> <p>String in camelCase format. Examples: \"priceScaleId\", \"lineColor\", \"HTTPStatusCode\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in snake_case format. Examples: \"price_scale_id\", \"line_color\", \"http_status_code\"</p> <p>Examples:</p> <p>Basic conversions::</p> <pre><code>&gt;&gt;&gt; CaseConverter.camel_to_snake(\"priceScaleId\")\n'price_scale_id'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"lineColor\")\n'line_color'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"singleWord\")\n'single_word'\n</code></pre> <p>Handling acronyms and numbers::</p> <pre><code>&gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPStatusCode\")\n'http_status_code'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"IOError\")\n'io_error'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPSConnection\")\n'https_connection'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"getHTTPResponseCode\")\n'get_http_response_code'\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"with123Numbers\")\n'with123_numbers'\n</code></pre> <p>Edge cases::</p> <pre><code>&gt;&gt;&gt; CaseConverter.camel_to_snake(\"\")\n''  # Empty string returns empty string\n&gt;&gt;&gt; CaseConverter.camel_to_snake(\"alreadySnake\")\n'already_snake'\n</code></pre> Note <p>Conversion characteristics:     - Consecutive capital letters are kept together until lowercase       (HTTP \u2192 http, not H_T_T_P \u2192 h_t_t_p)     - Numbers are preserved in their original position     - Already snake_case strings pass through unchanged     - Empty strings return empty strings     - First character is never preceded by underscore</p> <p>The regex pattern (?&lt;!^)(?=[A-Z]) means:     - (?&lt;!^): Negative lookbehind - don't match at start     - (?=[A-Z]): Positive lookahead - match before uppercase     This ensures we insert underscores before capitals but not     at the beginning of the string.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>@staticmethod\ndef camel_to_snake(camel_case: str) -&gt; str:\n    \"\"\"Convert camelCase string to snake_case.\n\n    This function converts strings from JavaScript's camelCase format to\n    Python's snake_case format. Capital letters (except the first character)\n    are converted to lowercase and preceded by an underscore.\n\n    The conversion process:\n        1. Use regex to find positions before capital letters\n        2. Insert underscore at those positions\n        3. Convert entire string to lowercase\n\n    The regex pattern handles consecutive capitals correctly:\n        - \"HTTPStatusCode\" \u2192 \"http_status_code\"\n        - \"IOError\" \u2192 \"io_error\"\n\n    Args:\n        camel_case (str): String in camelCase format. Examples:\n            \"priceScaleId\", \"lineColor\", \"HTTPStatusCode\"\n\n    Returns:\n        str: String in snake_case format. Examples:\n            \"price_scale_id\", \"line_color\", \"http_status_code\"\n\n    Examples:\n        Basic conversions::\n\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"priceScaleId\")\n            'price_scale_id'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"lineColor\")\n            'line_color'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"singleWord\")\n            'single_word'\n\n        Handling acronyms and numbers::\n\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPStatusCode\")\n            'http_status_code'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"IOError\")\n            'io_error'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"HTTPSConnection\")\n            'https_connection'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"getHTTPResponseCode\")\n            'get_http_response_code'\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"with123Numbers\")\n            'with123_numbers'\n\n        Edge cases::\n\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"\")\n            ''  # Empty string returns empty string\n            &gt;&gt;&gt; CaseConverter.camel_to_snake(\"alreadySnake\")\n            'already_snake'\n\n    Note:\n        Conversion characteristics:\n            - Consecutive capital letters are kept together until lowercase\n              (HTTP \u2192 http, not H_T_T_P \u2192 h_t_t_p)\n            - Numbers are preserved in their original position\n            - Already snake_case strings pass through unchanged\n            - Empty strings return empty strings\n            - First character is never preceded by underscore\n\n        The regex pattern (?&lt;!^)(?=[A-Z]) means:\n            - (?&lt;!^): Negative lookbehind - don't match at start\n            - (?=[A-Z]): Positive lookahead - match before uppercase\n            This ensures we insert underscores before capitals but not\n            at the beginning of the string.\n    \"\"\"\n    # Handle empty string case immediately\n    if not camel_case:\n        return camel_case\n\n    # Step 1: Insert underscore before uppercase letters using regex\n    # The pattern finds positions before capital letters (except at start)\n    # Example: \"priceScaleId\" \u2192 \"price_Scale_Id\"\n    snake_case = CaseConverter._CAMEL_PATTERN.sub(\"_\", camel_case)\n\n    # Step 2: Convert entire string to lowercase\n    # Example: \"price_Scale_Id\" \u2192 \"price_scale_id\"\n    return snake_case.lower()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter.convert_dict_keys","title":"convert_dict_keys  <code>staticmethod</code>","text":"<pre><code>convert_dict_keys(data: Dict[str, Any], to_camel: bool = True, recursive: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>Convert all dictionary keys between snake_case and camelCase.</p> <p>This function converts dictionary keys while preserving the structure and values. It can optionally recurse into nested dictionaries and lists, enabling complete conversion of complex nested structures like chart configurations.</p> The conversion process <ol> <li>Validate input is a dictionary</li> <li>Select conversion function based on direction</li> <li>Iterate through key-value pairs</li> <li>Convert each key (if it's a string)</li> <li>Recursively process nested structures if enabled</li> <li>Return new dictionary with converted keys</li> </ol> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary with keys to convert. Can contain nested dictionaries, lists, or any other types.</p> required <code>to_camel</code> <code>bool</code> <p>Direction of conversion. Defaults to True. - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript) - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Whether to recursively convert nested structures. Defaults to True. - True: Convert keys in nested dicts and lists - False: Only convert top-level keys</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: New dictionary with converted keys. The original dictionary is not modified. Structure and values are preserved, only keys are converted.</p> <p>Examples:</p> <p>Basic dictionary conversion::</p> <pre><code>&gt;&gt;&gt; data = {\"price_scale\": {\"visible\": True}}\n&gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n{'priceScale': {'visible': True}}\n</code></pre> <p>Reverse conversion::</p> <pre><code>&gt;&gt;&gt; data = {\"priceScale\": {\"autoScale\": False}}\n&gt;&gt;&gt; CaseConverter.convert_dict_keys(data, to_camel=False)\n{'price_scale': {'auto_scale': False}}\n</code></pre> <p>Nested structures with lists::</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"chart_options\": {\n...         \"series\": [\n...             {\"line_color\": \"red\"},\n...             {\"line_color\": \"blue\"}\n...         ]\n...     }\n... }\n&gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n{\n    'chartOptions': {\n        'series': [\n            {'lineColor': 'red'},\n            {'lineColor': 'blue'}\n        ]\n    }\n}\n</code></pre> <p>Shallow conversion (non-recursive)::</p> <pre><code>&gt;&gt;&gt; data = {\"price_scale\": {\"auto_scale\": True}}\n&gt;&gt;&gt; CaseConverter.convert_dict_keys(data, recursive=False)\n{'priceScale': {'auto_scale': True}}\n# Note: nested 'auto_scale' key is not converted\n</code></pre> Note <p>Conversion behavior:     - Non-string keys are preserved as-is (ints, tuples, etc.)     - Nested dictionaries are converted if recursive=True     - Lists containing dicts are processed if recursive=True     - Original dictionary is never modified (returns new dict)     - Value types are preserved exactly     - Order is preserved (Python 3.7+ dict insertion order)</p> <p>Performance considerations:     - Creates a new dictionary (doesn't modify original)     - Recursive conversion is O(n*m) where n=keys, m=nesting depth     - Non-recursive conversion is O(n) where n=keys</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>@staticmethod\ndef convert_dict_keys(\n    data: Dict[str, Any], to_camel: bool = True, recursive: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert all dictionary keys between snake_case and camelCase.\n\n    This function converts dictionary keys while preserving the structure\n    and values. It can optionally recurse into nested dictionaries and lists,\n    enabling complete conversion of complex nested structures like chart\n    configurations.\n\n    The conversion process:\n        1. Validate input is a dictionary\n        2. Select conversion function based on direction\n        3. Iterate through key-value pairs\n        4. Convert each key (if it's a string)\n        5. Recursively process nested structures if enabled\n        6. Return new dictionary with converted keys\n\n    Args:\n        data (Dict[str, Any]): Dictionary with keys to convert. Can contain\n            nested dictionaries, lists, or any other types.\n        to_camel (bool, optional): Direction of conversion. Defaults to True.\n            - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript)\n            - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)\n        recursive (bool, optional): Whether to recursively convert nested\n            structures. Defaults to True.\n            - True: Convert keys in nested dicts and lists\n            - False: Only convert top-level keys\n\n    Returns:\n        Dict[str, Any]: New dictionary with converted keys. The original\n            dictionary is not modified. Structure and values are preserved,\n            only keys are converted.\n\n    Examples:\n        Basic dictionary conversion::\n\n            &gt;&gt;&gt; data = {\"price_scale\": {\"visible\": True}}\n            &gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n            {'priceScale': {'visible': True}}\n\n        Reverse conversion::\n\n            &gt;&gt;&gt; data = {\"priceScale\": {\"autoScale\": False}}\n            &gt;&gt;&gt; CaseConverter.convert_dict_keys(data, to_camel=False)\n            {'price_scale': {'auto_scale': False}}\n\n        Nested structures with lists::\n\n            &gt;&gt;&gt; data = {\n            ...     \"chart_options\": {\n            ...         \"series\": [\n            ...             {\"line_color\": \"red\"},\n            ...             {\"line_color\": \"blue\"}\n            ...         ]\n            ...     }\n            ... }\n            &gt;&gt;&gt; CaseConverter.convert_dict_keys(data)\n            {\n                'chartOptions': {\n                    'series': [\n                        {'lineColor': 'red'},\n                        {'lineColor': 'blue'}\n                    ]\n                }\n            }\n\n        Shallow conversion (non-recursive)::\n\n            &gt;&gt;&gt; data = {\"price_scale\": {\"auto_scale\": True}}\n            &gt;&gt;&gt; CaseConverter.convert_dict_keys(data, recursive=False)\n            {'priceScale': {'auto_scale': True}}\n            # Note: nested 'auto_scale' key is not converted\n\n    Note:\n        Conversion behavior:\n            - Non-string keys are preserved as-is (ints, tuples, etc.)\n            - Nested dictionaries are converted if recursive=True\n            - Lists containing dicts are processed if recursive=True\n            - Original dictionary is never modified (returns new dict)\n            - Value types are preserved exactly\n            - Order is preserved (Python 3.7+ dict insertion order)\n\n        Performance considerations:\n            - Creates a new dictionary (doesn't modify original)\n            - Recursive conversion is O(n*m) where n=keys, m=nesting depth\n            - Non-recursive conversion is O(n) where n=keys\n    \"\"\"\n    # Validate input is a dictionary\n    # If not, return unchanged (protects against misuse)\n    if not isinstance(data, dict):\n        return data\n\n    # Step 1: Select appropriate conversion function based on direction\n    # This is done once at the start to avoid repeated conditionals\n    converter = (\n        CaseConverter.snake_to_camel\n        if to_camel\n        else CaseConverter.camel_to_snake\n    )\n\n    # Step 2: Initialize result dictionary\n    # We create a new dict rather than modifying the original\n    result = {}\n\n    # Step 3: Iterate through all key-value pairs\n    for key, value in data.items():\n        # Step 3a: Convert key if it's a string\n        # Non-string keys (int, tuple, etc.) are preserved as-is\n        # Example: \"price_scale\" \u2192 \"priceScale\" (if to_camel=True)\n        new_key = converter(key) if isinstance(key, str) else key\n\n        # Step 3b: Process value based on type and recursion setting\n        if recursive:\n            # Recursive mode: process nested structures\n            if isinstance(value, dict):\n                # Value is a nested dictionary - recursively convert it\n                # Example: {\"auto_scale\": True} \u2192 {\"autoScale\": True}\n                result[new_key] = CaseConverter.convert_dict_keys(\n                    value, to_camel, recursive\n                )\n            elif isinstance(value, list):\n                # Value is a list - may contain dicts that need conversion\n                # Example: [{\"line_color\": \"red\"}] \u2192 [{\"lineColor\": \"red\"}]\n                result[new_key] = CaseConverter._convert_list(\n                    value, to_camel, recursive\n                )\n            else:\n                # Value is a primitive type (str, int, bool, etc.)\n                # Keep it as-is\n                result[new_key] = value\n        else:\n            # Non-recursive mode: just copy the value as-is\n            # Even if value is a dict or list, don't process it\n            result[new_key] = value\n\n    # Return the new dictionary with converted keys\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.CaseConverter.convert_keys_shallow","title":"convert_keys_shallow  <code>staticmethod</code>","text":"<pre><code>convert_keys_shallow(data: Dict[str, Any], to_camel: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>Convert dictionary keys without recursing into nested structures.</p> <p>This is a convenience method equivalent to calling convert_dict_keys with recursive=False. Use this when you only want to convert the top-level keys and leave nested structures unchanged.</p> This is useful when <ul> <li>You only need to convert the outermost keys</li> <li>Performance is critical and deep recursion is expensive</li> <li>Nested structures are already in the correct format</li> <li>You want fine-grained control over conversion depth</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary with keys to convert. Nested dictionaries and lists will not have their keys converted.</p> required <code>to_camel</code> <code>bool</code> <p>Direction of conversion. Defaults to True. - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript) - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: New dictionary with converted top-level keys only. Nested structures are preserved exactly as-is.</p> <p>Examples:</p> <p>Shallow conversion::</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"price_scale\": {\"auto_scale\": True},\n...     \"line_width\": 2\n... }\n&gt;&gt;&gt; CaseConverter.convert_keys_shallow(data)\n{\n    'priceScale': {'auto_scale': True},\n    'lineWidth': 2\n}\n# Note: nested 'auto_scale' is not converted\n</code></pre> <p>Compare with recursive conversion::</p> <pre><code>&gt;&gt;&gt; # Shallow conversion\n&gt;&gt;&gt; shallow = CaseConverter.convert_keys_shallow(data)\n&gt;&gt;&gt; shallow[\"priceScale\"]\n{'auto_scale': True}  # Nested key unchanged\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Recursive conversion\n&gt;&gt;&gt; deep = CaseConverter.convert_dict_keys(data)\n&gt;&gt;&gt; deep[\"priceScale\"]\n{'autoScale': True}  # Nested key converted\n</code></pre> See Also <p>convert_dict_keys: For recursive conversion of nested structures.</p> Note <p>This is simply a convenience wrapper that calls convert_dict_keys with recursive=False. It's provided for:     - Improved code readability (intent is clearer)     - Convenience (don't need to remember parameter name)     - API consistency (matches common use cases)</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>@staticmethod\ndef convert_keys_shallow(\n    data: Dict[str, Any], to_camel: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert dictionary keys without recursing into nested structures.\n\n    This is a convenience method equivalent to calling convert_dict_keys\n    with recursive=False. Use this when you only want to convert the\n    top-level keys and leave nested structures unchanged.\n\n    This is useful when:\n        - You only need to convert the outermost keys\n        - Performance is critical and deep recursion is expensive\n        - Nested structures are already in the correct format\n        - You want fine-grained control over conversion depth\n\n    Args:\n        data (Dict[str, Any]): Dictionary with keys to convert. Nested\n            dictionaries and lists will not have their keys converted.\n        to_camel (bool, optional): Direction of conversion. Defaults to True.\n            - True: Convert snake_case \u2192 camelCase (Python \u2192 JavaScript)\n            - False: Convert camelCase \u2192 snake_case (JavaScript \u2192 Python)\n\n    Returns:\n        Dict[str, Any]: New dictionary with converted top-level keys only.\n            Nested structures are preserved exactly as-is.\n\n    Examples:\n        Shallow conversion::\n\n            &gt;&gt;&gt; data = {\n            ...     \"price_scale\": {\"auto_scale\": True},\n            ...     \"line_width\": 2\n            ... }\n            &gt;&gt;&gt; CaseConverter.convert_keys_shallow(data)\n            {\n                'priceScale': {'auto_scale': True},\n                'lineWidth': 2\n            }\n            # Note: nested 'auto_scale' is not converted\n\n        Compare with recursive conversion::\n\n            &gt;&gt;&gt; # Shallow conversion\n            &gt;&gt;&gt; shallow = CaseConverter.convert_keys_shallow(data)\n            &gt;&gt;&gt; shallow[\"priceScale\"]\n            {'auto_scale': True}  # Nested key unchanged\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Recursive conversion\n            &gt;&gt;&gt; deep = CaseConverter.convert_dict_keys(data)\n            &gt;&gt;&gt; deep[\"priceScale\"]\n            {'autoScale': True}  # Nested key converted\n\n    See Also:\n        convert_dict_keys: For recursive conversion of nested structures.\n\n    Note:\n        This is simply a convenience wrapper that calls convert_dict_keys\n        with recursive=False. It's provided for:\n            - Improved code readability (intent is clearer)\n            - Convenience (don't need to remember parameter name)\n            - API consistency (matches common use cases)\n    \"\"\"\n    # Call convert_dict_keys with recursive=False\n    # This converts only top-level keys\n    return CaseConverter.convert_dict_keys(data, to_camel, recursive=False)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.snake_to_camel","title":"snake_to_camel","text":"<pre><code>snake_to_camel(snake_case: str) -&gt; str\n</code></pre> <p>Convert snake_case to camelCase.</p> <p>This is a convenience function that wraps CaseConverter.snake_to_camel() for backward compatibility with existing code and simplified imports.</p> <p>Parameters:</p> Name Type Description Default <code>snake_case</code> <code>str</code> <p>String in snake_case format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in camelCase format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snake_to_camel(\"price_scale_id\")\n'priceScaleId'\n&gt;&gt;&gt; snake_to_camel(\"line_color\")\n'lineColor'\n</code></pre> See Also <p>CaseConverter.snake_to_camel: The main implementation with full     documentation and examples.</p> Note <p>This function exists for:     - Backward compatibility with code written before CaseConverter     - Simpler imports (can import function directly)     - Shorter code when class prefix is not needed For new code, consider using CaseConverter.snake_to_camel directly for clarity.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>def snake_to_camel(snake_case: str) -&gt; str:\n    \"\"\"Convert snake_case to camelCase.\n\n    This is a convenience function that wraps CaseConverter.snake_to_camel()\n    for backward compatibility with existing code and simplified imports.\n\n    Args:\n        snake_case (str): String in snake_case format.\n\n    Returns:\n        str: String in camelCase format.\n\n    Examples:\n        &gt;&gt;&gt; snake_to_camel(\"price_scale_id\")\n        'priceScaleId'\n        &gt;&gt;&gt; snake_to_camel(\"line_color\")\n        'lineColor'\n\n    See Also:\n        CaseConverter.snake_to_camel: The main implementation with full\n            documentation and examples.\n\n    Note:\n        This function exists for:\n            - Backward compatibility with code written before CaseConverter\n            - Simpler imports (can import function directly)\n            - Shorter code when class prefix is not needed\n        For new code, consider using CaseConverter.snake_to_camel directly\n        for clarity.\n    \"\"\"\n    # Delegate to CaseConverter static method\n    return CaseConverter.snake_to_camel(snake_case)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/case_converter.html#streamlit_lightweight_charts_pro.utils.case_converter.camel_to_snake","title":"camel_to_snake","text":"<pre><code>camel_to_snake(camel_case: str) -&gt; str\n</code></pre> <p>Convert camelCase to snake_case.</p> <p>This is a convenience function that wraps CaseConverter.camel_to_snake() for backward compatibility with existing code and simplified imports.</p> <p>Parameters:</p> Name Type Description Default <code>camel_case</code> <code>str</code> <p>String in camelCase format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in snake_case format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel_to_snake(\"priceScaleId\")\n'price_scale_id'\n&gt;&gt;&gt; camel_to_snake(\"lineColor\")\n'line_color'\n</code></pre> See Also <p>CaseConverter.camel_to_snake: The main implementation with full     documentation and examples.</p> Note <p>This function exists for:     - Backward compatibility with code written before CaseConverter     - Simpler imports (can import function directly)     - Shorter code when class prefix is not needed For new code, consider using CaseConverter.camel_to_snake directly for clarity.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/case_converter.py</code> <pre><code>def camel_to_snake(camel_case: str) -&gt; str:\n    \"\"\"Convert camelCase to snake_case.\n\n    This is a convenience function that wraps CaseConverter.camel_to_snake()\n    for backward compatibility with existing code and simplified imports.\n\n    Args:\n        camel_case (str): String in camelCase format.\n\n    Returns:\n        str: String in snake_case format.\n\n    Examples:\n        &gt;&gt;&gt; camel_to_snake(\"priceScaleId\")\n        'price_scale_id'\n        &gt;&gt;&gt; camel_to_snake(\"lineColor\")\n        'line_color'\n\n    See Also:\n        CaseConverter.camel_to_snake: The main implementation with full\n            documentation and examples.\n\n    Note:\n        This function exists for:\n            - Backward compatibility with code written before CaseConverter\n            - Simpler imports (can import function directly)\n            - Shorter code when class prefix is not needed\n        For new code, consider using CaseConverter.camel_to_snake directly\n        for clarity.\n    \"\"\"\n    # Delegate to CaseConverter static method\n    return CaseConverter.camel_to_snake(camel_case)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html","title":"streamlit_lightweight_charts_pro.utils.chainable","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable","title":"chainable","text":"<p>Chainable decorators for enabling fluent API design in financial chart configuration.</p> <p>This module provides powerful decorators that automatically create setter methods for properties and dataclass fields, enabling both direct assignment and method chaining styles with comprehensive type validation and error handling.</p> <p>The module implements the fluent API design pattern used throughout the library, allowing for intuitive and readable method chaining when building charts and configuring options. This creates a more developer-friendly experience while maintaining type safety and validation.</p> Key Features <ul> <li>Automatic type validation with customizable validators</li> <li>Support for both property assignment and method chaining</li> <li>Built-in validators for common chart types (colors, precision, etc.)</li> <li>Special handling for complex types (marker lists, nested objects)</li> <li>Optional None value support for flexible configuration</li> <li>Top-level property configuration for serialization control</li> <li>Comprehensive error handling with descriptive messages</li> <li>Support for Union types and generic type checking</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils import chainable_property, chainable_field\nfrom dataclasses import dataclass\n\n\n# Using chainable_property for class properties\n@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"width\", int)\nclass ChartConfig:\n    def __init__(self):\n        self._color = \"#000000\"\n        self._width = 800\n\n\n# Using chainable_field for dataclass fields\n@dataclass\n@chainable_field(\"color\", str)\n@chainable_field(\"width\", int)\nclass Options:\n    color: str = \"#000000\"\n    width: int = 800\n\n\n# Usage examples\nconfig = ChartConfig()\nconfig.color = \"#ff0000\"  # Direct property assignment\nconfig.set_width(600).set_color(\"#00ff00\")  # Method chaining\n</code></pre> Built-in Validators <ul> <li>\"color\": Validates hex color codes and rgba values</li> <li>\"price_format_type\": Validates price format types</li> <li>\"precision\": Validates precision values for price formatting</li> <li>\"min_move\": Validates minimum move values for price scales</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable.chainable_property","title":"chainable_property","text":"<pre><code>chainable_property(attr_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False, top_level: bool = False)\n</code></pre> <p>Decorator that creates both a property setter and a chaining method with optional validation.</p> <p>This decorator enables two usage patterns for the same attribute: 1. Property assignment: <code>obj.attr = value</code> 2. Method chaining: <code>obj.set_attr(value).other_method()</code></p> <p>The decorator automatically creates both the property setter and a chaining method, applying the same validation logic to both. This provides flexibility in how developers interact with the API while maintaining consistency.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of the attribute to manage. This will be used to create both the property name and the setter method name (e.g., \"color\" creates both a \"color\" property and a \"set_color\" method).</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <code>top_level</code> <code>bool</code> <p>Whether this property should be output at the top level in asdict() instead of in the options dictionary. Useful for properties that should be serialized separately from the main options.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add both property and method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the attribute name conflicts with existing attributes.</p> Example <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"width\", int)\n@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=validate_base_value)\n@chainable_property(\"price_scale_id\", top_level=True)\nclass MySeries(Series):\n    def __init__(self):\n        self._color = \"#000000\"\n        self._width = 800\n        self._line_options = None\n        self._base_value = 0\n        self._price_scale_id = \"right\"\n\n\n# Usage examples\nseries = MySeries()\n\n# Property assignment\nseries.color = \"#ff0000\"\nseries.width = 600\n\n# Method chaining\nseries.set_color(\"#00ff00\").set_width(800)\n\n# With validation\nseries.set_color(\"invalid\")  # Raises ValueError\nseries.set_width(\"not_a_number\")  # Raises TypeError\n</code></pre> Note <p>The decorator creates both a property setter and a method, so the class must have the corresponding private attribute (e.g., <code>_color</code> for <code>color</code>). The property getter is not created automatically - you may need to add it manually if needed.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_property(\n    attr_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n    top_level: bool = False,\n):\n    \"\"\"Decorator that creates both a property setter and a chaining method with optional validation.\n\n    This decorator enables two usage patterns for the same attribute:\n    1. Property assignment: `obj.attr = value`\n    2. Method chaining: `obj.set_attr(value).other_method()`\n\n    The decorator automatically creates both the property setter and a chaining\n    method, applying the same validation logic to both. This provides flexibility\n    in how developers interact with the API while maintaining consistency.\n\n    Args:\n        attr_name: The name of the attribute to manage. This will be used to create\n            both the property name and the setter method name (e.g., \"color\" creates\n            both a \"color\" property and a \"set_color\" method).\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n        top_level: Whether this property should be output at the top level in\n            asdict() instead of in the options dictionary. Useful for properties\n            that should be serialized separately from the main options.\n\n    Returns:\n        Decorator function that modifies the class to add both property and method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the attribute name conflicts with existing attributes.\n\n    Example:\n        ```python\n        @chainable_property(\"color\", str, validator=\"color\")\n        @chainable_property(\"width\", int)\n        @chainable_property(\"line_options\", LineOptions, allow_none=True)\n        @chainable_property(\"base_value\", validator=validate_base_value)\n        @chainable_property(\"price_scale_id\", top_level=True)\n        class MySeries(Series):\n            def __init__(self):\n                self._color = \"#000000\"\n                self._width = 800\n                self._line_options = None\n                self._base_value = 0\n                self._price_scale_id = \"right\"\n\n\n        # Usage examples\n        series = MySeries()\n\n        # Property assignment\n        series.color = \"#ff0000\"\n        series.width = 600\n\n        # Method chaining\n        series.set_color(\"#00ff00\").set_width(800)\n\n        # With validation\n        series.set_color(\"invalid\")  # Raises ValueError\n        series.set_width(\"not_a_number\")  # Raises TypeError\n        ```\n\n    Note:\n        The decorator creates both a property setter and a method, so the class\n        must have the corresponding private attribute (e.g., `_color` for `color`).\n        The property getter is not created automatically - you may need to add\n        it manually if needed.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the class.\n\n        Args:\n            cls: The class to be decorated.\n\n        Returns:\n            The modified class with added property and setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{attr_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return self\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # Case 1: Boolean type - strict validation (no truthy/falsy coercion)\n                    # Only accept actual True/False, not 1/0 or other truthy values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif not isinstance(value, value_type):\n                    # Case 2: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # Case 3: Complex types (classes, custom types)\n                        # Indicate whether None is allowed in the error message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # Case 4: Union types like (int, float)\n                        # Create friendly error message from type names\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        # Special handling for numeric union types\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Step 3: Apply custom validation if specified\n            # Custom validators can transform values or perform additional checks\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Case 1: Built-in validators (string identifiers)\n                    # These are predefined validators for common chart properties\n                    if validator == \"color\":\n                        # Color validator: Accepts hex codes and rgba values\n                        # Empty string is treated as \"no color\" (converted to None)\n                        if value == \"\":\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        # Price format type validator\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        # Precision validator (for decimal places)\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        # Minimum move validator (for price scales)\n                        value = validate_min_move(value)\n                    else:\n                        # Unknown validator string\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Case 2: Custom validator function\n                    # Allows users to provide their own validation/transformation logic\n                    value = validator(value)\n\n            # Step 4: Set the validated value on the private attribute\n            # Uses the private attribute convention (_attr_name)\n            setattr(self, f\"_{attr_name}\", value)\n\n            # Step 5: Return self to enable method chaining\n            return self\n\n        def property_getter(self):\n            \"\"\"Property getter for accessing the attribute value.\n\n            Args:\n                self: The instance.\n\n            Returns:\n                The current value of the attribute.\n            \"\"\"\n            return getattr(self, f\"_{attr_name}\")\n\n        def property_setter(self, value):\n            \"\"\"Property setter for direct assignment with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # For boolean properties, only accept actual boolean values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif _is_list_of_markers(value_type):\n                    # Case 2a: Special handling for List[MarkerBase] and similar types\n                    # Markers require special validation due to their complex structure\n                    _validate_list_of_markers(value, attr_name)\n                elif not isinstance(value, value_type):\n                    # Case 2b: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # For complex types, use a more user-friendly message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # For tuple types like (int, float), create a user-friendly message\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Apply custom validation if specified\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Built-in validators\n                    if validator == \"color\":\n                        # Treat empty strings as valid (meaning \"no color\")\n                        if value == \"\":\n                            # Convert empty string to None for consistent handling\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        value = validate_min_move(value)\n                    else:\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Custom validator function\n                    value = validator(value)\n\n            setattr(self, f\"_{attr_name}\", value)\n\n        # Create the property\n        prop = property(property_getter, property_setter)\n\n        # Add the property and method to the class\n        setattr(cls, attr_name, prop)\n        setattr(cls, setter_name, setter_method)\n\n        # Store metadata about serialization\n        if not hasattr(cls, \"_chainable_properties\"):\n            # pylint: disable=protected-access\n            cls._chainable_properties = {}\n\n        # pylint: disable=protected-access\n        cls._chainable_properties[attr_name] = {\n            \"allow_none\": allow_none,\n            \"value_type\": value_type,\n            \"top_level\": top_level,\n        }\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable.chainable_field","title":"chainable_field","text":"<pre><code>chainable_field(field_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False)\n</code></pre> <p>Decorator that creates a setter method for dataclass fields with optional validation.</p> <p>This decorator enables method chaining for dataclass fields by creating a setter method that applies validation and returns the instance for chaining. Unlike chainable_property, this only creates the method and doesn't override direct assignment behavior.</p> <p>The created method follows the naming convention <code>set_{field_name}</code> and applies the same validation logic as chainable_property, but only when the method is explicitly called.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the dataclass field to create a setter for. The method will be named <code>set_{field_name}</code>.</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add a setter method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the field name conflicts with existing attributes.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"line_options\", LineOptions, allow_none=True)\nclass MyOptions:\n    color: str = \"#000000\"\n    width: int = 800\n    line_options: Optional[LineOptions] = None\n\n\n# Usage examples\noptions = MyOptions()\n\n# Method chaining (with validation)\noptions.set_color(\"#ff0000\").set_width(600)\n\n# Direct assignment (no validation)\noptions.color = \"invalid_color\"  # No validation applied\noptions.set_color(\"invalid_color\")  # Raises ValueError\n\n# With None values when allow_none=True\noptions.set_line_options(None)  # Valid due to allow_none=True\n</code></pre> Note <p>Direct assignment to dataclass fields bypasses validation. Use the generated setter methods when validation is required.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n):\n    \"\"\"Decorator that creates a setter method for dataclass fields with optional validation.\n\n    This decorator enables method chaining for dataclass fields by creating a setter\n    method that applies validation and returns the instance for chaining. Unlike\n    chainable_property, this only creates the method and doesn't override direct\n    assignment behavior.\n\n    The created method follows the naming convention `set_{field_name}` and applies\n    the same validation logic as chainable_property, but only when the method is\n    explicitly called.\n\n    Args:\n        field_name: The name of the dataclass field to create a setter for.\n            The method will be named `set_{field_name}`.\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n\n    Returns:\n        Decorator function that modifies the class to add a setter method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the field name conflicts with existing attributes.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n        @dataclass\n        @chainable_field(\"color\", str, validator=\"color\")\n        @chainable_field(\"width\", int)\n        @chainable_field(\"line_options\", LineOptions, allow_none=True)\n        class MyOptions:\n            color: str = \"#000000\"\n            width: int = 800\n            line_options: Optional[LineOptions] = None\n\n\n        # Usage examples\n        options = MyOptions()\n\n        # Method chaining (with validation)\n        options.set_color(\"#ff0000\").set_width(600)\n\n        # Direct assignment (no validation)\n        options.color = \"invalid_color\"  # No validation applied\n        options.set_color(\"invalid_color\")  # Raises ValueError\n\n        # With None values when allow_none=True\n        options.set_line_options(None)  # Valid due to allow_none=True\n        ```\n\n    Note:\n        Direct assignment to dataclass fields bypasses validation. Use the\n        generated setter methods when validation is required.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the dataclass.\n\n        Args:\n            cls: The dataclass to be decorated.\n\n        Returns:\n            The modified class with added setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{field_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation for dataclass fields.\n\n            Args:\n                self: The dataclass instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, field_name, None)\n                return self\n\n            # Step 2: Apply validation and transformation\n            validated_value = _validate_value(field_name, value, value_type, validator)\n\n            # Step 3: Set the validated value directly on the dataclass field\n            setattr(self, field_name, validated_value)\n\n            # Step 4: Return self to enable method chaining\n            return self\n\n        # Step 2: Add the generated setter method to the class\n        setattr(cls, setter_name, setter_method)\n\n        # Step 3: Return the modified class\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable.validated_field","title":"validated_field","text":"<pre><code>validated_field(field_name: str, value_type: Optional[Union[Type, tuple]] = None, validator: Optional[Union[Callable[[Any], Any], str]] = None, allow_none: bool = False)\n</code></pre> <p>Decorator that validates dataclass fields on initialization and provides setter methods.</p> <p>This decorator extends chainable_field by adding validation during post_init. It ensures that field values are validated both when constructed and when using setter methods, providing consistent validation across the entire lifecycle.</p> <p>The decorator creates both a setter method (like chainable_field) and hooks into the dataclass post_init to validate the field value after initialization.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the dataclass field to validate. The method will be named <code>set_{field_name}</code>.</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add validation and setter.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils import validated_field\n\n\n@dataclass\n@validated_field(\"color\", str, validator=\"color\", allow_none=True)\n@validated_field(\"width\", int)\nclass MyData:\n    color: Optional[str] = None\n    width: int = 100\n\n\n# Valid usage\ndata = MyData(color=\"#ff0000\", width=200)  # Validated on init\ndata.set_color(\"#00ff00\")  # Validated on setter\n\n# Invalid usage - validation catches errors\ndata = MyData(color=\"invalid_color\")  # Raises ColorValidationError\ndata = MyData(width=\"not_a_number\")  # Raises TypeValidationError\n</code></pre> Note <p>This decorator should be applied BEFORE the @dataclass decorator in the decorator stack. It works by wrapping the post_init method to add validation logic after dataclass initialization.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def validated_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n):\n    \"\"\"Decorator that validates dataclass fields on initialization and provides setter methods.\n\n    This decorator extends chainable_field by adding validation during __post_init__.\n    It ensures that field values are validated both when constructed and when using\n    setter methods, providing consistent validation across the entire lifecycle.\n\n    The decorator creates both a setter method (like chainable_field) and hooks into\n    the dataclass __post_init__ to validate the field value after initialization.\n\n    Args:\n        field_name: The name of the dataclass field to validate.\n            The method will be named `set_{field_name}`.\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n\n    Returns:\n        Decorator function that modifies the class to add validation and setter.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils import validated_field\n\n\n        @dataclass\n        @validated_field(\"color\", str, validator=\"color\", allow_none=True)\n        @validated_field(\"width\", int)\n        class MyData:\n            color: Optional[str] = None\n            width: int = 100\n\n\n        # Valid usage\n        data = MyData(color=\"#ff0000\", width=200)  # Validated on init\n        data.set_color(\"#00ff00\")  # Validated on setter\n\n        # Invalid usage - validation catches errors\n        data = MyData(color=\"invalid_color\")  # Raises ColorValidationError\n        data = MyData(width=\"not_a_number\")  # Raises TypeValidationError\n        ```\n\n    Note:\n        This decorator should be applied BEFORE the @dataclass decorator in the\n        decorator stack. It works by wrapping the __post_init__ method to add\n        validation logic after dataclass initialization.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the dataclass.\n\n        Args:\n            cls: The dataclass to be decorated.\n\n        Returns:\n            The modified class with validation and setter method.\n        \"\"\"\n        # Step 1: First apply chainable_field to get the setter method\n        cls = chainable_field(field_name, value_type, validator, allow_none)(cls)\n\n        # Step 2: Store the original __post_init__ if it exists\n        original_post_init = getattr(cls, \"__post_init__\", None)\n\n        # Step 3: Create new __post_init__ that adds validation\n        def new_post_init(self):\n            \"\"\"Enhanced __post_init__ that validates fields after initialization.\n\n            This method runs after the dataclass __init__ completes, validating\n            the field value and applying any necessary transformations.\n\n            Args:\n                self: The dataclass instance being initialized.\n            \"\"\"\n            # First, call the original __post_init__ if it exists\n            if original_post_init is not None:\n                original_post_init(self)\n\n            # Get the current field value\n            value = getattr(self, field_name)\n\n            # Skip validation if None and allow_none is True\n            if value is None and allow_none:\n                return\n\n            # Apply validation using the same logic as the setter\n            try:\n                validated_value = _validate_value(field_name, value, value_type, validator)\n                # Set the validated (and possibly transformed) value back\n                setattr(self, field_name, validated_value)\n            except (TypeError, ValueError) as e:\n                # Re-raise with more context about initialization\n                raise type(e)(\n                    f\"Validation error during initialization of '{field_name}': {e}\"\n                ) from e\n\n        # Step 4: Replace the __post_init__ method\n        cls.__post_init__ = new_post_init\n\n        # Step 5: Track which fields have validation for debugging\n        if not hasattr(cls, \"_validated_fields\"):\n            cls._validated_fields = []\n        cls._validated_fields.append(field_name)\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html","title":"streamlit_lightweight_charts_pro.utils.color_utils","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html#streamlit_lightweight_charts_pro.utils.color_utils","title":"color_utils","text":"<p>Color utility functions for chart styling.</p> <p>This module provides comprehensive utilities for color manipulation and validation used throughout the streamlit-lightweight-charts-pro package. It handles conversions between color formats, opacity adjustments, and validation of color strings.</p> The module supports <ul> <li>Hex color to RGBA conversion</li> <li>Opacity/alpha channel manipulation</li> <li>Color format validation</li> <li>Automatic format detection</li> </ul> Key Features <ul> <li>Handles hex colors (#RRGGBB format)</li> <li>Preserves non-hex colors (rgba, rgb, named colors)</li> <li>Validates hex color format before conversion</li> <li>Provides both functional and convenience APIs</li> </ul> Example <p>Convert hex colors to rgba with opacity::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.color_utils import (\n    add_opacity\n)\n\n# Add 30% opacity to green color\nrgba_color = add_opacity(\"#4CAF50\", 0.3)\nprint(rgba_color)  # \"rgba(76, 175, 80, 0.3)\"\n</code></pre> <p>Validate hex colors::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.color_utils import (\n    is_hex_color\n)\n\nis_valid = is_hex_color(\"#FF0000\")  # True\nis_valid = is_hex_color(\"red\")      # False\n</code></pre> Note <p>This module only handles standard hex format (#RRGGBB - 6 digits). Short hex format (#RGB - 3 digits) is not currently supported.</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html#streamlit_lightweight_charts_pro.utils.color_utils-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html#streamlit_lightweight_charts_pro.utils.color_utils.add_opacity","title":"add_opacity","text":"<pre><code>add_opacity(color: str, opacity: float = 0.3) -&gt; str\n</code></pre> <p>Convert hex color to rgba format with specified opacity.</p> <p>Takes a hex color string (e.g., \"#4CAF50\") and converts it to rgba format with the specified opacity level. This is useful for creating semi-transparent colors for overlays, backgrounds, or layered visualizations.</p> <p>If the input is already in rgba/rgb format or any non-hex format (like named colors), it is returned unchanged to avoid double conversion.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Hex color string starting with '#' (e.g., \"#4CAF50\"). Must be in format #RRGGBB (7 characters total). If the color doesn't start with '#', it's returned as-is.</p> required <code>opacity</code> <code>float</code> <p>Opacity level between 0.0 (fully transparent) and 1.0 (fully opaque). Defaults to 0.3 (30% opacity).</p> <code>0.3</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RGBA color string in format \"rgba(r, g, b, opacity)\" if input is hex, otherwise returns the original color string unchanged.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If hex color format is invalid (not exactly 7 characters or contains non-hexadecimal digits).</p> Example <p>add_opacity(\"#4CAF50\", 0.3) 'rgba(76, 175, 80, 0.3)'</p> <p>add_opacity(\"#FF0000\", 0.5) 'rgba(255, 0, 0, 0.5)'</p> <p>add_opacity(\"rgba(255, 0, 0, 0.5)\", 0.3) 'rgba(255, 0, 0, 0.5)'</p> Note <p>The function does not validate the opacity value range. Values outside 0.0-1.0 will be accepted but may produce unexpected results in the browser.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def add_opacity(color: str, opacity: float = 0.3) -&gt; str:\n    \"\"\"Convert hex color to rgba format with specified opacity.\n\n    Takes a hex color string (e.g., \"#4CAF50\") and converts it to\n    rgba format with the specified opacity level. This is useful for\n    creating semi-transparent colors for overlays, backgrounds, or\n    layered visualizations.\n\n    If the input is already in rgba/rgb format or any non-hex format\n    (like named colors), it is returned unchanged to avoid double\n    conversion.\n\n    Args:\n        color (str): Hex color string starting with '#' (e.g., \"#4CAF50\").\n            Must be in format #RRGGBB (7 characters total).\n            If the color doesn't start with '#', it's returned as-is.\n        opacity (float, optional): Opacity level between 0.0 (fully\n            transparent) and 1.0 (fully opaque). Defaults to 0.3 (30%\n            opacity).\n\n    Returns:\n        str: RGBA color string in format \"rgba(r, g, b, opacity)\" if\n            input is hex, otherwise returns the original color string\n            unchanged.\n\n    Raises:\n        ValueError: If hex color format is invalid (not exactly 7\n            characters or contains non-hexadecimal digits).\n\n    Example:\n        &gt;&gt;&gt; add_opacity(\"#4CAF50\", 0.3)\n        'rgba(76, 175, 80, 0.3)'\n\n        &gt;&gt;&gt; add_opacity(\"#FF0000\", 0.5)\n        'rgba(255, 0, 0, 0.5)'\n\n        &gt;&gt;&gt; add_opacity(\"rgba(255, 0, 0, 0.5)\", 0.3)\n        'rgba(255, 0, 0, 0.5)'\n\n    Note:\n        The function does not validate the opacity value range.\n        Values outside 0.0-1.0 will be accepted but may produce\n        unexpected results in the browser.\n    \"\"\"\n    # Check if color starts with '#' to identify hex format\n    # If not hex, it could be rgba, rgb, or named color - return unchanged\n    if not color.startswith(\"#\"):\n        return color\n\n    # Validate hex color format: must be exactly 7 characters (#RRGGBB)\n    # This ensures we have the full 6-digit hex color format\n    if len(color) != 7:\n        raise ValueError(\n            f\"Invalid hex color format: {color}. \"\n            f\"Expected format: #RRGGBB (7 characters including #)\"\n        )\n\n    try:\n        # Extract red component from characters 1-2 (after #)\n        # Convert from hexadecimal (base 16) to decimal (base 10)\n        r = int(color[1:3], 16)\n\n        # Extract green component from characters 3-4\n        g = int(color[3:5], 16)\n\n        # Extract blue component from characters 5-6\n        b = int(color[5:7], 16)\n\n    except ValueError as e:\n        # int() raises ValueError if the string contains non-hex characters\n        # Re-raise with more descriptive error message\n        raise ValueError(\n            f\"Invalid hex color: {color}. Must contain valid hexadecimal \"\n            f\"digits (0-9, A-F).\"\n        ) from e\n    else:\n        # All conversions successful, return formatted rgba string\n        # Format: rgba(red, green, blue, opacity)\n        return f\"rgba({r}, {g}, {b}, {opacity})\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html#streamlit_lightweight_charts_pro.utils.color_utils.hex_to_rgba","title":"hex_to_rgba","text":"<pre><code>hex_to_rgba(hex_color: str, alpha: Optional[float] = None) -&gt; str\n</code></pre> <p>Convert hex color to rgba or rgb format.</p> <p>This function provides a more intuitive API for hex to rgba conversion compared to add_opacity(). When alpha is None, it returns rgb format instead of rgba, which is useful when opacity is not needed.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>Hex color string (e.g., \"#4CAF50\"). Must be in format #RRGGBB (7 characters total). Non-hex colors are returned unchanged.</p> required <code>alpha</code> <code>Optional[float]</code> <p>Alpha/opacity value (0.0-1.0). If None, returns \"rgb(r, g, b)\" format without alpha channel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RGBA color string \"rgba(r, g, b, alpha)\" if alpha is provided, or RGB color string \"rgb(r, g, b)\" if alpha is None. Non-hex colors are returned unchanged.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If hex color format is invalid.</p> Example <p>Convert to rgba with alpha::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"#4CAF50\", 0.5)\n'rgba(76, 175, 80, 0.5)'\n</code></pre> <p>Convert to rgb without alpha::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"#4CAF50\")\n'rgb(76, 175, 80)'\n</code></pre> <p>Non-hex colors pass through::</p> <pre><code>&gt;&gt;&gt; hex_to_rgba(\"red\", 0.5)\n'red'\n</code></pre> Note <p>This is a convenience wrapper around add_opacity() that provides more flexibility with the alpha channel.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def hex_to_rgba(hex_color: str, alpha: Optional[float] = None) -&gt; str:\n    \"\"\"Convert hex color to rgba or rgb format.\n\n    This function provides a more intuitive API for hex to rgba conversion\n    compared to add_opacity(). When alpha is None, it returns rgb format\n    instead of rgba, which is useful when opacity is not needed.\n\n    Args:\n        hex_color (str): Hex color string (e.g., \"#4CAF50\"). Must be in\n            format #RRGGBB (7 characters total). Non-hex colors are\n            returned unchanged.\n        alpha (Optional[float]): Alpha/opacity value (0.0-1.0). If None,\n            returns \"rgb(r, g, b)\" format without alpha channel.\n\n    Returns:\n        str: RGBA color string \"rgba(r, g, b, alpha)\" if alpha is\n            provided, or RGB color string \"rgb(r, g, b)\" if alpha is None.\n            Non-hex colors are returned unchanged.\n\n    Raises:\n        ValueError: If hex color format is invalid.\n\n    Example:\n        Convert to rgba with alpha::\n\n            &gt;&gt;&gt; hex_to_rgba(\"#4CAF50\", 0.5)\n            'rgba(76, 175, 80, 0.5)'\n\n        Convert to rgb without alpha::\n\n            &gt;&gt;&gt; hex_to_rgba(\"#4CAF50\")\n            'rgb(76, 175, 80)'\n\n        Non-hex colors pass through::\n\n            &gt;&gt;&gt; hex_to_rgba(\"red\", 0.5)\n            'red'\n\n    Note:\n        This is a convenience wrapper around add_opacity() that provides\n        more flexibility with the alpha channel.\n    \"\"\"\n    # If alpha is None, we want rgb format (no alpha channel)\n    if alpha is None:\n        # Check if input is hex format\n        if not hex_color.startswith(\"#\"):\n            # Not hex, return unchanged (could be rgba, rgb, named color)\n            return hex_color\n\n        # Validate hex color length\n        if len(hex_color) != 7:\n            raise ValueError(f\"Invalid hex color format: {hex_color}\")\n\n        # Convert hex to decimal RGB values\n        # Extract and convert red component\n        r = int(hex_color[1:3], 16)\n        # Extract and convert green component\n        g = int(hex_color[3:5], 16)\n        # Extract and convert blue component\n        b = int(hex_color[5:7], 16)\n\n        # Return RGB format without alpha channel\n        return f\"rgb({r}, {g}, {b})\"\n\n    # If alpha is provided, use add_opacity to get rgba format\n    return add_opacity(hex_color, alpha)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/color_utils.html#streamlit_lightweight_charts_pro.utils.color_utils.is_hex_color","title":"is_hex_color","text":"<pre><code>is_hex_color(color: str) -&gt; bool\n</code></pre> <p>Check if a string is a valid hex color.</p> <p>Validates that a string follows the standard hex color format (#RRGGBB - 7 characters total). This is useful for input validation before attempting color conversion.</p> The function checks <ul> <li>Input is a string type</li> <li>String starts with '#'</li> <li>String is exactly 7 characters long</li> <li>Last 6 characters are valid hexadecimal digits (0-9, A-F)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color string to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is a valid hex color in #RRGGBB format, False otherwise.</p> Example <p>Valid hex colors::</p> <pre><code>&gt;&gt;&gt; is_hex_color(\"#4CAF50\")\nTrue\n\n&gt;&gt;&gt; is_hex_color(\"#FF0000\")\nTrue\n</code></pre> <p>Invalid formats::</p> <pre><code>&gt;&gt;&gt; is_hex_color(\"rgba(76, 175, 80, 0.3)\")\nFalse\n\n&gt;&gt;&gt; is_hex_color(\"#FFF\")\nFalse  # Too short (must be 6 digits)\n\n&gt;&gt;&gt; is_hex_color(\"red\")\nFalse  # Named color, not hex\n\n&gt;&gt;&gt; is_hex_color(\"#GGGGGG\")\nFalse  # Invalid hex digits\n</code></pre> Note <p>This function only validates the standard 6-digit hex format. Short format (#RGB) and 8-digit format with alpha (#RRGGBBAA) are not considered valid by this function.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/color_utils.py</code> <pre><code>def is_hex_color(color: str) -&gt; bool:\n    \"\"\"Check if a string is a valid hex color.\n\n    Validates that a string follows the standard hex color format\n    (#RRGGBB - 7 characters total). This is useful for input validation\n    before attempting color conversion.\n\n    The function checks:\n        - Input is a string type\n        - String starts with '#'\n        - String is exactly 7 characters long\n        - Last 6 characters are valid hexadecimal digits (0-9, A-F)\n\n    Args:\n        color (str): Color string to validate.\n\n    Returns:\n        bool: True if the string is a valid hex color in #RRGGBB format,\n            False otherwise.\n\n    Example:\n        Valid hex colors::\n\n            &gt;&gt;&gt; is_hex_color(\"#4CAF50\")\n            True\n\n            &gt;&gt;&gt; is_hex_color(\"#FF0000\")\n            True\n\n        Invalid formats::\n\n            &gt;&gt;&gt; is_hex_color(\"rgba(76, 175, 80, 0.3)\")\n            False\n\n            &gt;&gt;&gt; is_hex_color(\"#FFF\")\n            False  # Too short (must be 6 digits)\n\n            &gt;&gt;&gt; is_hex_color(\"red\")\n            False  # Named color, not hex\n\n            &gt;&gt;&gt; is_hex_color(\"#GGGGGG\")\n            False  # Invalid hex digits\n\n    Note:\n        This function only validates the standard 6-digit hex format.\n        Short format (#RGB) and 8-digit format with alpha (#RRGGBBAA)\n        are not considered valid by this function.\n    \"\"\"\n    # First check: ensure input is a string type\n    # This prevents errors when trying to call string methods\n    if not isinstance(color, str):\n        return False\n\n    # Second check: hex colors must start with '#'\n    if not color.startswith(\"#\"):\n        return False\n\n    # Third check: must be exactly 7 characters (#RRGGBB)\n    # This ensures we have the standard hex format\n    if len(color) != 7:\n        return False\n\n    # Fourth check: validate that characters after '#' are hex digits\n    try:\n        # Try to convert the 6 characters after '#' to an integer\n        # using base 16 (hexadecimal)\n        # This will raise ValueError if any character is not 0-9 or A-F\n        int(color[1:], 16)\n    except ValueError:\n        # Not valid hexadecimal digits\n        return False\n    else:\n        # All checks passed - this is a valid hex color\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html","title":"streamlit_lightweight_charts_pro.utils.data_utils","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils","title":"data_utils","text":"<p>Data utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides comprehensive utility functions for data processing and manipulation used throughout the library. It includes functions for time normalization, data validation, format conversion, and other common data operations essential for financial chart rendering.</p> The module provides utilities for <ul> <li>Time conversion and normalization (UNIX timestamps)</li> <li>Color validation and format checking</li> <li>String format conversion (snake_case to camelCase)</li> <li>Data validation for chart configuration options</li> <li>Precision and minimum move validation for price formatting</li> <li>Type checking and conversion utilities</li> </ul> <p>These utilities ensure data consistency, proper formatting, and type safety across all components of the charting library, providing a robust foundation for financial data visualization.</p> Key Features <ul> <li>Robust time handling with multiple input format support</li> <li>Comprehensive color validation for hex and rgba formats</li> <li>Efficient string conversion utilities for frontend compatibility</li> <li>Type-safe validation with descriptive error messages</li> <li>NumPy type handling for scientific computing integration</li> <li>Pandas integration for DataFrame and Series processing</li> </ul> Example <p>Time normalization::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.data_utils import (\n    normalize_time\n)\n\n# Convert various time formats to UNIX timestamp\ntimestamp = normalize_time(\"2024-01-01T00:00:00\")\nprint(timestamp)  # 1704067200\n</code></pre> <p>Color validation::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.data_utils import (\n    is_valid_color\n)\n\n# Validate different color formats\nis_valid = is_valid_color(\"#FF0000\")  # True (hex)\nis_valid = is_valid_color(\"red\")      # True (named)\nis_valid = is_valid_color(\"invalid\")  # False\n</code></pre> <p>Format conversion for frontend::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.data_utils import (\n    snake_to_camel\n)\n\n# Convert Python naming to JavaScript naming\ncamel = snake_to_camel(\"price_scale_id\")\nprint(camel)  # \"priceScaleId\"\n</code></pre> Note <p>All time functions return UNIX timestamps in seconds (not milliseconds) for consistency with Python's datetime module and pandas.</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.normalize_time","title":"normalize_time","text":"<pre><code>normalize_time(time_value: Any) -&gt; int\n</code></pre> <p>Convert time input to UNIX seconds for consistent chart handling.</p> <p>This function handles various time input formats and converts them to UNIX timestamps (seconds since epoch). It supports multiple input types including integers, floats, strings, datetime objects, and pandas Timestamps, providing a unified interface for time data processing.</p> <p>The function is designed to be robust and handle edge cases such as numpy types and various string formats that pandas can parse, ensuring compatibility with different data sources and formats commonly used in financial applications.</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>Any</code> <p>Time value to convert. Supported types: - int/float: Already in UNIX seconds (returned as-is) - str: Date/time string (parsed by pandas.to_datetime()) - datetime: Python datetime object (converted to timestamp) - pd.Timestamp: Pandas timestamp object (converted to timestamp) - numpy types: Automatically converted to Python types first - date objects: Converted to midnight on that date</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UNIX timestamp in seconds since epoch (January 1, 1970 UTC), suitable for chart rendering.</p> <p>Raises:</p> Type Description <code>TimeValidationError</code> <p>If the input string cannot be parsed as a valid date/time.</p> <code>UnsupportedTimeTypeError</code> <p>If the input type is not supported or cannot be converted.</p> Example <p>Convert various formats::</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n\n# Integer timestamp (already in correct format)\n&gt;&gt;&gt; normalize_time(1640995200)\n1640995200\n\n# ISO format string\n&gt;&gt;&gt; normalize_time(\"2024-01-01T00:00:00\")\n1704067200\n\n# Python datetime\n&gt;&gt;&gt; normalize_time(datetime(2024, 1, 1))\n1704067200\n\n# Pandas timestamp\n&gt;&gt;&gt; normalize_time(pd.Timestamp(\"2024-01-01\"))\n1704067200\n</code></pre> Note <p>String inputs are parsed using pandas.to_datetime(), which supports a wide variety of date/time formats including ISO format, common date formats, and relative dates. This ensures maximum compatibility with different data sources.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def normalize_time(time_value: Any) -&gt; int:\n    \"\"\"Convert time input to UNIX seconds for consistent chart handling.\n\n    This function handles various time input formats and converts them to\n    UNIX timestamps (seconds since epoch). It supports multiple input types\n    including integers, floats, strings, datetime objects, and pandas\n    Timestamps, providing a unified interface for time data processing.\n\n    The function is designed to be robust and handle edge cases such as\n    numpy types and various string formats that pandas can parse, ensuring\n    compatibility with different data sources and formats commonly used\n    in financial applications.\n\n    Args:\n        time_value (Any): Time value to convert. Supported types:\n            - int/float: Already in UNIX seconds (returned as-is)\n            - str: Date/time string (parsed by pandas.to_datetime())\n            - datetime: Python datetime object (converted to timestamp)\n            - pd.Timestamp: Pandas timestamp object (converted to timestamp)\n            - numpy types: Automatically converted to Python types first\n            - date objects: Converted to midnight on that date\n\n    Returns:\n        int: UNIX timestamp in seconds since epoch (January 1, 1970 UTC),\n            suitable for chart rendering.\n\n    Raises:\n        TimeValidationError: If the input string cannot be parsed as a\n            valid date/time.\n        UnsupportedTimeTypeError: If the input type is not supported or\n            cannot be converted.\n\n    Example:\n        Convert various formats::\n\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; import pandas as pd\n\n            # Integer timestamp (already in correct format)\n            &gt;&gt;&gt; normalize_time(1640995200)\n            1640995200\n\n            # ISO format string\n            &gt;&gt;&gt; normalize_time(\"2024-01-01T00:00:00\")\n            1704067200\n\n            # Python datetime\n            &gt;&gt;&gt; normalize_time(datetime(2024, 1, 1))\n            1704067200\n\n            # Pandas timestamp\n            &gt;&gt;&gt; normalize_time(pd.Timestamp(\"2024-01-01\"))\n            1704067200\n\n    Note:\n        String inputs are parsed using pandas.to_datetime(), which supports\n        a wide variety of date/time formats including ISO format, common\n        date formats, and relative dates. This ensures maximum compatibility\n        with different data sources.\n    \"\"\"\n    # Step 1: Handle numpy types by converting to Python native types first\n    # NumPy types have different behavior and need special handling\n    # Check if object has 'item()' method (common NumPy scalar method)\n    if hasattr(time_value, \"item\"):\n        # Extract Python scalar value from NumPy type\n        # This converts numpy.int64 -&gt; int, numpy.float64 -&gt; float, etc.\n        time_value = time_value.item()\n\n    # Check if object has 'dtype' attribute (indicates NumPy array or similar)\n    elif hasattr(time_value, \"dtype\"):\n        # Try to extract scalar value from array-like object\n        try:\n            # item() works for 0-d arrays and scalar wrappers\n            time_value = time_value.item()\n        except (ValueError, TypeError):\n            # If item() fails, try type-specific conversion\n            # Check if object can be converted to int (has __int__ method)\n            if hasattr(time_value, \"__int__\"):\n                time_value = int(time_value)\n            else:\n                # Fall back to float conversion\n                time_value = float(time_value)\n\n    # Step 2: Handle already-converted integer timestamps\n    # If value is already an int, it's assumed to be a UNIX timestamp\n    # Simply return it without any conversion\n    if isinstance(time_value, int):\n        return time_value\n\n    # Step 3: Handle float timestamps (may have fractional seconds)\n    # Convert to int by truncating fractional part\n    # This rounds towards zero, so 1.9 becomes 1\n    if isinstance(time_value, float):\n        return int(time_value)\n\n    # Step 4: Handle string date/time representations\n    # Use pandas.to_datetime() for flexible parsing\n    if isinstance(time_value, str):\n        try:\n            # pandas.to_datetime() is very flexible and can parse:\n            # - ISO format: \"2024-01-01T00:00:00\"\n            # - Common formats: \"2024-01-01\", \"01/01/2024\", \"Jan 1, 2024\"\n            # - Relative dates: \"today\", \"yesterday\"\n            dt = pd.to_datetime(time_value)\n\n            # Convert pandas Timestamp to UNIX seconds\n            # timestamp() returns float, we convert to int\n            return int(dt.timestamp())\n\n        except (ValueError, TypeError) as exc:\n            # If parsing fails, raise custom exception with the invalid value\n            # 'from exc' preserves the original exception for debugging\n            raise TimeValidationError(time_value) from exc\n\n    # Step 5: Handle Python datetime objects\n    # datetime.timestamp() returns float seconds since epoch\n    if isinstance(time_value, datetime):\n        # Convert to UNIX timestamp and truncate to integer seconds\n        return int(time_value.timestamp())\n\n    # Step 6: Handle pandas Timestamp objects\n    # Similar to datetime but pandas-specific type\n    if isinstance(time_value, pd.Timestamp):\n        # Convert to UNIX timestamp and truncate to integer seconds\n        return int(time_value.timestamp())\n\n    # Step 7: Handle datetime.date objects (date without time)\n    # date objects don't have timestamp() method, need special handling\n    # Check for both 'date' and 'timetuple' methods to identify date objects\n    if hasattr(time_value, \"date\") and hasattr(time_value, \"timetuple\"):\n        # Combine date with minimum time (midnight) to create datetime\n        # datetime.min.time() returns time(0, 0, 0) - midnight\n        dt = datetime.combine(time_value, datetime.min.time())\n\n        # Convert combined datetime to UNIX timestamp\n        return int(dt.timestamp())\n\n    # Step 8: If we reach here, type is not supported\n    # Raise exception with the actual type information\n    raise UnsupportedTimeTypeError(type(time_value))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.to_utc_timestamp","title":"to_utc_timestamp","text":"<pre><code>to_utc_timestamp(time_value: Any) -&gt; int\n</code></pre> <p>Convert time input to UNIX seconds.</p> <p>This is an alias for normalize_time() maintained for backward compatibility. It provides exactly the same functionality as normalize_time() and delegates all work to that function.</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>Any</code> <p>Time value to convert. Supported types are: int, float, str, datetime, pd.Timestamp, numpy types.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UNIX timestamp in seconds since epoch.</p> <p>Raises:</p> Type Description <code>TimeValidationError</code> <p>If the input cannot be parsed.</p> <code>UnsupportedTimeTypeError</code> <p>If the input type is not supported.</p> Example <p>to_utc_timestamp(\"2024-01-01\") 1704067200</p> See Also <p>normalize_time: The main function that performs the conversion.</p> Note <p>This function exists for backward compatibility with older code. New code should use normalize_time() directly.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def to_utc_timestamp(time_value: Any) -&gt; int:\n    \"\"\"Convert time input to UNIX seconds.\n\n    This is an alias for normalize_time() maintained for backward\n    compatibility. It provides exactly the same functionality as\n    normalize_time() and delegates all work to that function.\n\n    Args:\n        time_value (Any): Time value to convert. Supported types are:\n            int, float, str, datetime, pd.Timestamp, numpy types.\n\n    Returns:\n        int: UNIX timestamp in seconds since epoch.\n\n    Raises:\n        TimeValidationError: If the input cannot be parsed.\n        UnsupportedTimeTypeError: If the input type is not supported.\n\n    Example:\n        &gt;&gt;&gt; to_utc_timestamp(\"2024-01-01\")\n        1704067200\n\n    See Also:\n        normalize_time: The main function that performs the conversion.\n\n    Note:\n        This function exists for backward compatibility with older code.\n        New code should use normalize_time() directly.\n    \"\"\"\n    # Simply delegate to normalize_time()\n    # This maintains backward compatibility while keeping single source of truth\n    return normalize_time(time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.from_utc_timestamp","title":"from_utc_timestamp","text":"<pre><code>from_utc_timestamp(timestamp: int) -&gt; str\n</code></pre> <p>Convert UNIX timestamp to ISO format string.</p> <p>This function converts a UNIX timestamp (seconds since epoch) to an ISO format datetime string. The output is always in UTC timezone, making it suitable for consistent time display across timezones.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>UNIX timestamp in seconds since epoch (January 1, 1970 00:00:00 UTC).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO format datetime string in UTC timezone. Format: \"YYYY-MM-DDTHH:MM:SS\"</p> Example <p>Convert timestamps to readable format::</p> <pre><code>&gt;&gt;&gt; from_utc_timestamp(1640995200)\n'2022-01-01T00:00:00'\n\n&gt;&gt;&gt; from_utc_timestamp(1704067200)\n'2024-01-01T00:00:00'\n</code></pre> Note <p>The function uses datetime.utcfromtimestamp() to ensure the output is always in UTC timezone, regardless of the system's local timezone. This is important for consistent time display in web applications.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def from_utc_timestamp(timestamp: int) -&gt; str:\n    \"\"\"Convert UNIX timestamp to ISO format string.\n\n    This function converts a UNIX timestamp (seconds since epoch) to an\n    ISO format datetime string. The output is always in UTC timezone,\n    making it suitable for consistent time display across timezones.\n\n    Args:\n        timestamp (int): UNIX timestamp in seconds since epoch\n            (January 1, 1970 00:00:00 UTC).\n\n    Returns:\n        str: ISO format datetime string in UTC timezone.\n            Format: \"YYYY-MM-DDTHH:MM:SS\"\n\n    Example:\n        Convert timestamps to readable format::\n\n            &gt;&gt;&gt; from_utc_timestamp(1640995200)\n            '2022-01-01T00:00:00'\n\n            &gt;&gt;&gt; from_utc_timestamp(1704067200)\n            '2024-01-01T00:00:00'\n\n    Note:\n        The function uses datetime.utcfromtimestamp() to ensure the output\n        is always in UTC timezone, regardless of the system's local timezone.\n        This is important for consistent time display in web applications.\n    \"\"\"\n    # Convert UNIX timestamp to UTC datetime object\n    # utcfromtimestamp() interprets the timestamp as UTC time\n    # This is different from fromtimestamp() which uses local timezone\n    dt = datetime.utcfromtimestamp(timestamp)\n\n    # Convert datetime to ISO format string\n    # isoformat() returns \"YYYY-MM-DDTHH:MM:SS\" format\n    # The 'T' separates date and time per ISO 8601 standard\n    return dt.isoformat()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.snake_to_camel","title":"snake_to_camel","text":"<pre><code>snake_to_camel(snake_str: str) -&gt; str\n</code></pre> <p>Convert snake_case string to camelCase.</p> <p>This function converts strings from Python's snake_case naming convention (e.g., \"price_scale_id\") to JavaScript's camelCase convention (e.g., \"priceScaleId\"). This is commonly used when converting Python property names to JavaScript property names for frontend communication.</p> <p>This is a convenience wrapper around CaseConverter.snake_to_camel() maintained for backward compatibility and simpler imports.</p> <p>Parameters:</p> Name Type Description Default <code>snake_str</code> <code>str</code> <p>String in snake_case format. Example: \"price_scale_id\", \"line_color\", \"background_color\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in camelCase format. Example: \"priceScaleId\", \"lineColor\", \"backgroundColor\"</p> Example <p>Convert Python naming to JavaScript naming::</p> <pre><code>&gt;&gt;&gt; snake_to_camel(\"price_scale_id\")\n'priceScaleId'\n\n&gt;&gt;&gt; snake_to_camel(\"line_color\")\n'lineColor'\n\n&gt;&gt;&gt; snake_to_camel(\"background_color\")\n'backgroundColor'\n\n&gt;&gt;&gt; snake_to_camel(\"single_word\")\n'singleWord'\n</code></pre> Note <p>The function assumes the input string is in valid snake_case format. If the input contains no underscores, it returns the string as-is. The function is deterministic - same input always produces same output.</p> See Also <p>CaseConverter.snake_to_camel: The main implementation that handles     the actual conversion logic.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def snake_to_camel(snake_str: str) -&gt; str:\n    \"\"\"Convert snake_case string to camelCase.\n\n    This function converts strings from Python's snake_case naming\n    convention (e.g., \"price_scale_id\") to JavaScript's camelCase\n    convention (e.g., \"priceScaleId\"). This is commonly used when\n    converting Python property names to JavaScript property names\n    for frontend communication.\n\n    This is a convenience wrapper around CaseConverter.snake_to_camel()\n    maintained for backward compatibility and simpler imports.\n\n    Args:\n        snake_str (str): String in snake_case format. Example:\n            \"price_scale_id\", \"line_color\", \"background_color\"\n\n    Returns:\n        str: String in camelCase format. Example:\n            \"priceScaleId\", \"lineColor\", \"backgroundColor\"\n\n    Example:\n        Convert Python naming to JavaScript naming::\n\n            &gt;&gt;&gt; snake_to_camel(\"price_scale_id\")\n            'priceScaleId'\n\n            &gt;&gt;&gt; snake_to_camel(\"line_color\")\n            'lineColor'\n\n            &gt;&gt;&gt; snake_to_camel(\"background_color\")\n            'backgroundColor'\n\n            &gt;&gt;&gt; snake_to_camel(\"single_word\")\n            'singleWord'\n\n    Note:\n        The function assumes the input string is in valid snake_case format.\n        If the input contains no underscores, it returns the string as-is.\n        The function is deterministic - same input always produces same output.\n\n    See Also:\n        CaseConverter.snake_to_camel: The main implementation that handles\n            the actual conversion logic.\n    \"\"\"\n    # Delegate to CaseConverter for actual conversion logic\n    # This keeps the conversion logic centralized and maintainable\n    return CaseConverter.snake_to_camel(snake_str)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.is_valid_color","title":"is_valid_color","text":"<pre><code>is_valid_color(color: str) -&gt; bool\n</code></pre> <p>Check if a color string is valid.</p> <p>This function validates color strings in various formats commonly used in web development and chart styling. It supports hex colors with various lengths, RGB/RGBA colors, and a comprehensive set of named colors.</p> <p>The validation is permissive to accept common variations while still catching obvious errors. It's designed for frontend color properties where browsers accept multiple formats.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color string to validate. Supported formats: - Hex colors: \"#FF0000\" (6-digit), \"#F00\" (3-digit),   \"#FF0000AA\" (8-digit with alpha), \"#F00A\" (4-digit with alpha) - RGB colors: \"rgb(255, 0, 0)\" - RGBA colors: \"rgba(255, 0, 0, 1)\" or \"rgba(255, 0, 0, 0.5)\" - Named colors: \"red\", \"blue\", \"white\", \"transparent\", etc.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if color is valid in any supported format, False if color is invalid or empty.</p> Example <p>Validate different color formats::</p> <pre><code># Hex colors (all valid)\n&gt;&gt;&gt; is_valid_color(\"#FF0000\")\nTrue\n&gt;&gt;&gt; is_valid_color(\"#F00\")\nTrue\n&gt;&gt;&gt; is_valid_color(\"#FF0000AA\")\nTrue\n\n# RGB/RGBA (valid)\n&gt;&gt;&gt; is_valid_color(\"rgb(255, 0, 0)\")\nTrue\n&gt;&gt;&gt; is_valid_color(\"rgba(255, 0, 0, 1)\")\nTrue\n\n# Named colors (valid, case-insensitive)\n&gt;&gt;&gt; is_valid_color(\"red\")\nTrue\n&gt;&gt;&gt; is_valid_color(\"RED\")\nTrue\n\n# Invalid colors\n&gt;&gt;&gt; is_valid_color(\"\")\nFalse\n&gt;&gt;&gt; is_valid_color(\"invalid\")\nFalse\n&gt;&gt;&gt; is_valid_color(\"#GG0000\")\nFalse\n</code></pre> Note <ul> <li>The function is permissive with whitespace in RGB/RGBA formats</li> <li>Accepts both 3-digit (#RGB) and 6-digit (#RRGGBB) hex codes</li> <li>Named colors are case-insensitive for user convenience</li> <li>Empty strings are explicitly rejected as invalid</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def is_valid_color(color: str) -&gt; bool:\n    \"\"\"Check if a color string is valid.\n\n    This function validates color strings in various formats commonly used\n    in web development and chart styling. It supports hex colors with\n    various lengths, RGB/RGBA colors, and a comprehensive set of named colors.\n\n    The validation is permissive to accept common variations while still\n    catching obvious errors. It's designed for frontend color properties\n    where browsers accept multiple formats.\n\n    Args:\n        color (str): Color string to validate. Supported formats:\n            - Hex colors: \"#FF0000\" (6-digit), \"#F00\" (3-digit),\n              \"#FF0000AA\" (8-digit with alpha), \"#F00A\" (4-digit with alpha)\n            - RGB colors: \"rgb(255, 0, 0)\"\n            - RGBA colors: \"rgba(255, 0, 0, 1)\" or \"rgba(255, 0, 0, 0.5)\"\n            - Named colors: \"red\", \"blue\", \"white\", \"transparent\", etc.\n\n    Returns:\n        bool: True if color is valid in any supported format, False if\n            color is invalid or empty.\n\n    Example:\n        Validate different color formats::\n\n            # Hex colors (all valid)\n            &gt;&gt;&gt; is_valid_color(\"#FF0000\")\n            True\n            &gt;&gt;&gt; is_valid_color(\"#F00\")\n            True\n            &gt;&gt;&gt; is_valid_color(\"#FF0000AA\")\n            True\n\n            # RGB/RGBA (valid)\n            &gt;&gt;&gt; is_valid_color(\"rgb(255, 0, 0)\")\n            True\n            &gt;&gt;&gt; is_valid_color(\"rgba(255, 0, 0, 1)\")\n            True\n\n            # Named colors (valid, case-insensitive)\n            &gt;&gt;&gt; is_valid_color(\"red\")\n            True\n            &gt;&gt;&gt; is_valid_color(\"RED\")\n            True\n\n            # Invalid colors\n            &gt;&gt;&gt; is_valid_color(\"\")\n            False\n            &gt;&gt;&gt; is_valid_color(\"invalid\")\n            False\n            &gt;&gt;&gt; is_valid_color(\"#GG0000\")\n            False\n\n    Note:\n        - The function is permissive with whitespace in RGB/RGBA formats\n        - Accepts both 3-digit (#RGB) and 6-digit (#RRGGBB) hex codes\n        - Named colors are case-insensitive for user convenience\n        - Empty strings are explicitly rejected as invalid\n    \"\"\"\n    # Step 1: Validate input is a string type\n    # Non-string inputs (int, None, list, etc.) are invalid\n    if not isinstance(color, str):\n        return False\n\n    # Step 2: Reject empty strings as invalid colors\n    # Empty strings could cause frontend errors\n    if color == \"\":\n        return False\n\n    # Step 3: Check for hex color pattern\n    # Supports multiple hex formats:\n    # - #RGB (3 digits): short form, e.g., #F00 = #FF0000\n    # - #RGBA (4 digits): short form with alpha, e.g., #F008\n    # - #RRGGBB (6 digits): standard form, e.g., #FF0000\n    # - #RRGGBBAA (8 digits): with alpha channel, e.g., #FF000080\n    # Pattern breakdown:\n    # ^ = start of string\n    # # = literal hash character\n    # [A-Fa-f0-9] = any hex digit (0-9, A-F, a-f)\n    # {3}|{4}|{6}|{8} = exactly 3, 4, 6, or 8 of those digits\n    # $ = end of string\n    hex_pattern = r\"^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$\"\n\n    # Use regex to check if color matches hex pattern\n    if re.match(hex_pattern, color):\n        return True\n\n    # Step 4: Check for RGB/RGBA pattern\n    # Supports both rgb(r,g,b) and rgba(r,g,b,a) formats\n    # Pattern breakdown:\n    # rgba? = \"rgb\" or \"rgba\" (? makes 'a' optional)\n    # \\( \\) = literal parentheses\n    # \\s* = optional whitespace (0 or more spaces)\n    # \\d+ = one or more digits (for r, g, b values)\n    # [\\d.]+ = digits or decimal point (for alpha value)\n    # (?:...)? = non-capturing optional group (for alpha)\n    # Allows flexible spacing: \"rgb(255, 0, 0)\" or \"rgb(255,0,0)\"\n    rgba_pattern = r\"^rgba?\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*(?:,\\s*[\\d.]+\\s*)?\\)$\"\n\n    # Use regex to check if color matches RGB/RGBA pattern\n    if re.match(rgba_pattern, color):\n        return True\n\n    # Step 5: Check against named colors set\n    # Define set of common named colors supported by browsers\n    # Using a set for O(1) lookup performance\n    named_colors = {\n        # Basic colors\n        \"black\",\n        \"white\",\n        \"red\",\n        \"green\",\n        \"blue\",\n        \"yellow\",\n        \"cyan\",\n        \"magenta\",\n        # Gray variants\n        \"gray\",\n        \"grey\",\n        # Extended colors\n        \"orange\",\n        \"purple\",\n        \"brown\",\n        \"pink\",\n        \"lime\",\n        \"navy\",\n        \"teal\",\n        \"silver\",\n        \"gold\",\n        \"maroon\",\n        \"olive\",\n        \"aqua\",\n        \"fuchsia\",\n        # Special\n        \"transparent\",\n    }\n\n    # Check if color (converted to lowercase) is in the named colors set\n    # Using .lower() makes the check case-insensitive\n    # This allows \"Red\", \"RED\", and \"red\" to all be valid\n    return color.lower() in named_colors\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_price_format_type","title":"validate_price_format_type","text":"<pre><code>validate_price_format_type(type_value: str) -&gt; str\n</code></pre> <p>Validate price format type string.</p> <p>This function validates that a price format type string is one of the supported types. Price format types determine how prices are displayed in the chart (as currency, percentage, volume, or custom format).</p> <p>Parameters:</p> Name Type Description Default <code>type_value</code> <code>str</code> <p>Type string to validate. Must be one of: \"price\", \"volume\", \"percent\", \"custom\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated type string (same as input if valid). Returning the input allows for method chaining and confirms validation success.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If type_value is not one of the valid types.</p> Example <p>Validate format types::</p> <pre><code>&gt;&gt;&gt; validate_price_format_type(\"price\")\n'price'\n\n&gt;&gt;&gt; validate_price_format_type(\"volume\")\n'volume'\n\n&gt;&gt;&gt; validate_price_format_type(\"percent\")\n'percent'\n\n&gt;&gt;&gt; validate_price_format_type(\"custom\")\n'custom'\n\n# Invalid type raises exception\n&gt;&gt;&gt; validate_price_format_type(\"invalid\")\nValueValidationError: type must be one of {...}, got 'invalid'\n</code></pre> Note <p>The validation is case-sensitive. \"Price\" and \"PRICE\" are not valid, only \"price\" (lowercase) is accepted. This ensures consistency with the frontend JavaScript code.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_price_format_type(type_value: str) -&gt; str:\n    \"\"\"Validate price format type string.\n\n    This function validates that a price format type string is one of the\n    supported types. Price format types determine how prices are displayed\n    in the chart (as currency, percentage, volume, or custom format).\n\n    Args:\n        type_value (str): Type string to validate. Must be one of:\n            \"price\", \"volume\", \"percent\", \"custom\"\n\n    Returns:\n        str: The validated type string (same as input if valid).\n            Returning the input allows for method chaining and confirms\n            validation success.\n\n    Raises:\n        ValueValidationError: If type_value is not one of the valid types.\n\n    Example:\n        Validate format types::\n\n            &gt;&gt;&gt; validate_price_format_type(\"price\")\n            'price'\n\n            &gt;&gt;&gt; validate_price_format_type(\"volume\")\n            'volume'\n\n            &gt;&gt;&gt; validate_price_format_type(\"percent\")\n            'percent'\n\n            &gt;&gt;&gt; validate_price_format_type(\"custom\")\n            'custom'\n\n            # Invalid type raises exception\n            &gt;&gt;&gt; validate_price_format_type(\"invalid\")\n            ValueValidationError: type must be one of {...}, got 'invalid'\n\n    Note:\n        The validation is case-sensitive. \"Price\" and \"PRICE\" are not valid,\n        only \"price\" (lowercase) is accepted. This ensures consistency with\n        the frontend JavaScript code.\n    \"\"\"\n    # Define set of valid price format types\n    # Using a set for O(1) lookup performance\n    # These correspond to formatting modes in the charting library\n    valid_types = {\"price\", \"volume\", \"percent\", \"custom\"}\n\n    # Check if provided type is in the valid set\n    if type_value not in valid_types:\n        # If invalid, raise descriptive error showing what's valid\n        # Using ValueValidationError for consistent error handling\n        raise ValueValidationError(\n            \"type\",\n            f\"must be one of {valid_types}, got {type_value!r}\",\n        )\n\n    # Return the validated value\n    # This allows for method chaining and confirms validation passed\n    return type_value\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_precision","title":"validate_precision","text":"<pre><code>validate_precision(precision: int) -&gt; int\n</code></pre> <p>Validate precision value for number formatting.</p> <p>This function validates that a precision value is appropriate for number formatting in charts. Precision determines the number of decimal places shown for price and volume values.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>int</code> <p>Precision value to validate. Must be: - An integer type (not float) - Non-negative (&gt;= 0)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The validated precision value (same as input if valid).</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If precision is negative or not an integer.</p> Example <p>Validate precision values::</p> <pre><code>&gt;&gt;&gt; validate_precision(0)\n0\n\n&gt;&gt;&gt; validate_precision(2)\n2\n\n&gt;&gt;&gt; validate_precision(5)\n5\n\n# Invalid: negative\n&gt;&gt;&gt; validate_precision(-1)\nValueValidationError: precision must be non-negative, got -1\n\n# Invalid: not an integer\n&gt;&gt;&gt; validate_precision(2.5)\nValueValidationError: precision must be non-negative integer, got 2.5\n</code></pre> Note <p>While the function accepts any non-negative integer, precision values typically range from 0 to 8 in financial charts. Very large precision values (&gt; 10) may cause display issues or performance problems in the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_precision(precision: int) -&gt; int:\n    \"\"\"Validate precision value for number formatting.\n\n    This function validates that a precision value is appropriate for\n    number formatting in charts. Precision determines the number of\n    decimal places shown for price and volume values.\n\n    Args:\n        precision (int): Precision value to validate. Must be:\n            - An integer type (not float)\n            - Non-negative (&gt;= 0)\n\n    Returns:\n        int: The validated precision value (same as input if valid).\n\n    Raises:\n        ValueValidationError: If precision is negative or not an integer.\n\n    Example:\n        Validate precision values::\n\n            &gt;&gt;&gt; validate_precision(0)\n            0\n\n            &gt;&gt;&gt; validate_precision(2)\n            2\n\n            &gt;&gt;&gt; validate_precision(5)\n            5\n\n            # Invalid: negative\n            &gt;&gt;&gt; validate_precision(-1)\n            ValueValidationError: precision must be non-negative, got -1\n\n            # Invalid: not an integer\n            &gt;&gt;&gt; validate_precision(2.5)\n            ValueValidationError: precision must be non-negative integer, got 2.5\n\n    Note:\n        While the function accepts any non-negative integer, precision\n        values typically range from 0 to 8 in financial charts. Very\n        large precision values (&gt; 10) may cause display issues or\n        performance problems in the frontend.\n    \"\"\"\n    # Check both type and value constraints\n    # Must be exactly int type (not bool, which is subclass of int)\n    # Must be non-negative (&gt;= 0)\n    if not isinstance(precision, int) or precision &lt; 0:\n        # Raise descriptive error if validation fails\n        # Shows both the constraint and the actual invalid value\n        raise ValueValidationError(\n            \"precision\",\n            f\"must be a non-negative integer, got {precision}\",\n        )\n\n    # Return validated value\n    # This confirms validation passed and allows method chaining\n    return precision\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_min_move","title":"validate_min_move","text":"<pre><code>validate_min_move(min_move: float) -&gt; float\n</code></pre> <p>Validate minimum move value for price changes.</p> <p>This function validates that a minimum move value is appropriate for chart configuration. Minimum move determines the smallest price change that will trigger a visual update in the chart. It's crucial for performance - smaller values mean more frequent updates.</p> <p>Parameters:</p> Name Type Description Default <code>min_move</code> <code>float</code> <p>Minimum move value to validate. Must be: - A numeric type (int or float) - Positive (&gt; 0)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The validated minimum move value, converted to float for consistency. Even integer inputs are returned as floats.</p> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If min_move is zero, negative, or not numeric.</p> Example <p>Validate minimum move values::</p> <pre><code>&gt;&gt;&gt; validate_min_move(0.001)\n0.001\n\n&gt;&gt;&gt; validate_min_move(1.0)\n1.0\n\n&gt;&gt;&gt; validate_min_move(100)\n100.0\n\n# Invalid: zero\n&gt;&gt;&gt; validate_min_move(0)\nValueValidationError: min_move must be positive, got 0\n\n# Invalid: negative\n&gt;&gt;&gt; validate_min_move(-0.1)\nValueValidationError: min_move must be positive, got -0.1\n</code></pre> Note <p>Minimum move values are typically very small positive numbers: - Stocks: 0.01 (penny) - Forex: 0.0001 (pip) - Crypto: varies widely</p> <p>The function accepts both int and float, converting to float for consistency. This allows flexible input while ensuring type safety.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_min_move(min_move: float) -&gt; float:\n    \"\"\"Validate minimum move value for price changes.\n\n    This function validates that a minimum move value is appropriate for\n    chart configuration. Minimum move determines the smallest price change\n    that will trigger a visual update in the chart. It's crucial for\n    performance - smaller values mean more frequent updates.\n\n    Args:\n        min_move (float): Minimum move value to validate. Must be:\n            - A numeric type (int or float)\n            - Positive (&gt; 0)\n\n    Returns:\n        float: The validated minimum move value, converted to float for\n            consistency. Even integer inputs are returned as floats.\n\n    Raises:\n        ValueValidationError: If min_move is zero, negative, or not numeric.\n\n    Example:\n        Validate minimum move values::\n\n            &gt;&gt;&gt; validate_min_move(0.001)\n            0.001\n\n            &gt;&gt;&gt; validate_min_move(1.0)\n            1.0\n\n            &gt;&gt;&gt; validate_min_move(100)\n            100.0\n\n            # Invalid: zero\n            &gt;&gt;&gt; validate_min_move(0)\n            ValueValidationError: min_move must be positive, got 0\n\n            # Invalid: negative\n            &gt;&gt;&gt; validate_min_move(-0.1)\n            ValueValidationError: min_move must be positive, got -0.1\n\n    Note:\n        Minimum move values are typically very small positive numbers:\n        - Stocks: 0.01 (penny)\n        - Forex: 0.0001 (pip)\n        - Crypto: varies widely\n\n        The function accepts both int and float, converting to float for\n        consistency. This allows flexible input while ensuring type safety.\n    \"\"\"\n    # Check type and value constraints\n    # Must be int or float (numeric type)\n    # Must be strictly positive (&gt; 0), not just non-negative\n    if not isinstance(min_move, (int, float)) or min_move &lt;= 0:\n        # Use helper method to create appropriate error\n        # positive_value() creates a standardized error message\n        raise ValueValidationError.positive_value(\"min_move\", min_move)\n\n    # Convert to float for consistency\n    # Even if input is int (e.g., 1), return float (1.0)\n    # This ensures consistent type in chart configuration\n    return float(min_move)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html","title":"streamlit_lightweight_charts_pro.utils.profiler","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler","title":"profiler","text":"<p>Performance profiling and monitoring utilities.</p> <p>This module provides comprehensive performance profiling tools for identifying bottlenecks and monitoring optimization effectiveness in the charting library. It includes advanced memory tracking, CPU monitoring, and automated performance analysis with intelligent recommendations.</p> The profiling system helps developers <ul> <li>Identify performance bottlenecks in chart operations</li> <li>Monitor memory usage and detect potential leaks</li> <li>Track CPU utilization across operations</li> <li>Generate actionable optimization recommendations</li> <li>Export detailed performance reports for analysis</li> </ul> Architecture <p>The module provides a multi-layered profiling approach:</p> <p>PerformanceProfile:     Data class storing metrics for a single operation execution.     Captures timing, memory, CPU, and optional metadata.</p> <p>PerformanceReport:     Aggregated analysis report with bottlenecks and recommendations.     Generated from multiple PerformanceProfile instances.</p> <p>PerformanceProfiler:     Main profiler class with context managers and decorators.     Provides thread-safe operation tracking and analysis.</p> <p>MemoryMonitor:     Specialized memory tracking with trend analysis.     Detects leaks and provides memory optimization suggestions.</p> Key Features <ul> <li>Real-time memory and CPU usage tracking</li> <li>Automatic bottleneck identification (95<sup>th</sup> percentile)</li> <li>Performance optimization recommendations</li> <li>Thread-safe operation profiling</li> <li>Export capabilities for detailed analysis</li> <li>Memory leak detection and trend analysis</li> <li>Global profiler instance for easy integration</li> <li>Decorator and context manager APIs</li> </ul> Example <p>Using the global profiler with decorators::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import (\n    profile_function\n)\n\n@profile_function(\"chart_rendering\", data_size=1000)\ndef render_chart(data):\n    '''Create and render a chart with the given data.'''\n    chart = Chart(data)\n    return chart.render()\n\n# Function is automatically profiled on each call\nresult = render_chart(my_data)\n</code></pre> <p>Using context manager for code blocks::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import (\n    profile_operation\n)\n\n# Profile a specific block of code\nwith profile_operation(\"data_processing\", data_size=5000):\n    # This entire block is profiled\n    processed_data = transform_data(raw_data)\n    validated_data = validate_data(processed_data)\n    cached_data = cache_data(validated_data)\n</code></pre> <p>Custom profiler instance::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import (\n    PerformanceProfiler\n)\n\n# Create custom profiler with specific settings\nprofiler = PerformanceProfiler(enable_memory_tracking=True)\n\n# Use as context manager\nwith profiler.measure_operation(\"complex_operation\"):\n    perform_complex_task()\n\n# Generate and export report\nreport = profiler.generate_report()\nprofiler.export_profiles(\"performance_report.json\")\n\nprint(f\"Total operations: {report.total_operations}\")\nprint(f\"Avg execution time: {report.average_execution_time:.3f}s\")\nprint(f\"Bottlenecks: {len(report.bottlenecks)}\")\n</code></pre> <p>Memory monitoring::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import (\n    get_memory_monitor\n)\n\nmonitor = get_memory_monitor()\n\n# Record snapshots before and after operations\nmonitor.record_memory_snapshot()\nperform_memory_intensive_operation()\nmonitor.record_memory_snapshot()\n\n# Analyze memory trends\ntrend = monitor.get_memory_trend()\nprint(f\"Memory trend: {trend['trend']}\")\nprint(f\"RSS change: {trend['rss_change'] / 1024 / 1024:.2f} MB\")\n\n# Get optimization suggestions\nsuggestions = monitor.suggest_optimizations()\nfor suggestion in suggestions:\n    print(f\"- {suggestion}\")\n</code></pre> <p>Performance summary::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import (\n    get_performance_summary\n)\n\n# Get quick summary of all profiled operations\nsummary = get_performance_summary()\nprint(f\"Total operations: {summary['operations']}\")\nprint(f\"Total time: {summary['total_time']:.2f}s\")\nprint(f\"Average time: {summary['avg_time']:.3f}s\")\nprint(f\"Memory trend: {summary['memory_trend']}\")\nprint(f\"Bottlenecks found: {summary['bottlenecks']}\")\n</code></pre> Note <p>The module provides a global profiler instance (_global_profiler) that can be accessed via convenience functions like profile_function(), profile_operation(), and get_profiler(). This allows for easy integration without managing profiler instances.</p> <p>Memory tracking uses Python's tracemalloc module, which has a small performance overhead but provides detailed memory usage information. You can disable it by passing enable_memory_tracking=False.</p> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfile","title":"PerformanceProfile  <code>dataclass</code>","text":"<p>Performance profile data for a single operation.</p> <p>This class stores comprehensive performance metrics for a single operation execution, including timing, memory usage, CPU utilization, and optional metadata. It serves as the basic unit of performance measurement in the profiling system.</p> <p>Each profile captures a complete snapshot of an operation's resource usage, enabling detailed analysis and comparison across multiple executions or different operations.</p> <p>Attributes:</p> Name Type Description <code>operation_name</code> <code>str</code> <p>Name identifier for the operation being profiled. Used to group and analyze similar operations.</p> <code>execution_time</code> <code>float</code> <p>Total execution time in seconds. Measured from operation start to completion.</p> <code>memory_peak</code> <code>int</code> <p>Peak memory usage during operation in bytes. The maximum memory allocated at any point during execution.</p> <code>memory_current</code> <code>int</code> <p>Current memory usage at operation end in bytes. The resident set size (RSS) when the operation completed.</p> <code>memory_delta</code> <code>int</code> <p>Change in memory usage (current - initial) in bytes. Positive values indicate memory allocation, negative indicate deallocation.</p> <code>cpu_percent</code> <code>float</code> <p>CPU utilization percentage during operation. Ranges from 0.0 to 100.0 * cpu_count (can exceed 100% on multi-core).</p> <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed (if applicable). Useful for analyzing performance scalability with input size.</p> <code>cache_hits</code> <code>int</code> <p>Number of cache hits during operation. Defaults to 0. Tracks cache effectiveness when caching is implemented.</p> <code>cache_misses</code> <code>int</code> <p>Number of cache misses during operation. Defaults to 0. Combined with hits, indicates cache efficiency.</p> <code>timestamp</code> <code>float</code> <p>Unix timestamp when operation completed. Auto-generated using time.time() at profile creation.</p> <code>thread_id</code> <code>int</code> <p>Thread ID where operation executed. Auto-generated using threading.get_ident() at profile creation. Useful for analyzing concurrent operations.</p> Example <p>Manual profile creation::</p> <pre><code>&gt;&gt;&gt; profile = PerformanceProfile(\n...     operation_name=\"chart_rendering\",\n...     execution_time=0.125,\n...     memory_peak=52428800,  # 50 MB\n...     memory_current=10485760,  # 10 MB\n...     memory_delta=4194304,  # 4 MB increase\n...     cpu_percent=15.5,\n...     data_size=1000,\n...     cache_hits=25,\n...     cache_misses=5\n... )\n&gt;&gt;&gt; print(f\"Operation: {profile.operation_name}\")\n&gt;&gt;&gt; print(f\"Time: {profile.execution_time:.3f}s\")\n&gt;&gt;&gt; print(f\"Memory delta: {profile.memory_delta / 1024 / 1024:.1f} MB\")\n</code></pre> <p>Profiles are typically created automatically by PerformanceProfiler::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; with profiler.measure_operation(\"data_transform\"):\n...     transform_data(dataset)\n&gt;&gt;&gt; # Profile automatically created and stored\n</code></pre> Note <p>The timestamp and thread_id fields are automatically populated using the current time and thread identifier when the profile is created. These are useful for:     - Temporal analysis of performance changes     - Identifying concurrent execution patterns     - Correlating profiles with system events</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@dataclass\nclass PerformanceProfile:\n    \"\"\"Performance profile data for a single operation.\n\n    This class stores comprehensive performance metrics for a single operation\n    execution, including timing, memory usage, CPU utilization, and optional\n    metadata. It serves as the basic unit of performance measurement in the\n    profiling system.\n\n    Each profile captures a complete snapshot of an operation's resource usage,\n    enabling detailed analysis and comparison across multiple executions or\n    different operations.\n\n    Attributes:\n        operation_name (str): Name identifier for the operation being profiled.\n            Used to group and analyze similar operations.\n        execution_time (float): Total execution time in seconds. Measured from\n            operation start to completion.\n        memory_peak (int): Peak memory usage during operation in bytes. The\n            maximum memory allocated at any point during execution.\n        memory_current (int): Current memory usage at operation end in bytes.\n            The resident set size (RSS) when the operation completed.\n        memory_delta (int): Change in memory usage (current - initial) in bytes.\n            Positive values indicate memory allocation, negative indicate\n            deallocation.\n        cpu_percent (float): CPU utilization percentage during operation. Ranges\n            from 0.0 to 100.0 * cpu_count (can exceed 100% on multi-core).\n        data_size (Optional[int]): Size of data being processed (if applicable).\n            Useful for analyzing performance scalability with input size.\n        cache_hits (int): Number of cache hits during operation. Defaults to 0.\n            Tracks cache effectiveness when caching is implemented.\n        cache_misses (int): Number of cache misses during operation. Defaults to 0.\n            Combined with hits, indicates cache efficiency.\n        timestamp (float): Unix timestamp when operation completed. Auto-generated\n            using time.time() at profile creation.\n        thread_id (int): Thread ID where operation executed. Auto-generated using\n            threading.get_ident() at profile creation. Useful for analyzing\n            concurrent operations.\n\n    Example:\n        Manual profile creation::\n\n            &gt;&gt;&gt; profile = PerformanceProfile(\n            ...     operation_name=\"chart_rendering\",\n            ...     execution_time=0.125,\n            ...     memory_peak=52428800,  # 50 MB\n            ...     memory_current=10485760,  # 10 MB\n            ...     memory_delta=4194304,  # 4 MB increase\n            ...     cpu_percent=15.5,\n            ...     data_size=1000,\n            ...     cache_hits=25,\n            ...     cache_misses=5\n            ... )\n            &gt;&gt;&gt; print(f\"Operation: {profile.operation_name}\")\n            &gt;&gt;&gt; print(f\"Time: {profile.execution_time:.3f}s\")\n            &gt;&gt;&gt; print(f\"Memory delta: {profile.memory_delta / 1024 / 1024:.1f} MB\")\n\n        Profiles are typically created automatically by PerformanceProfiler::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; with profiler.measure_operation(\"data_transform\"):\n            ...     transform_data(dataset)\n            &gt;&gt;&gt; # Profile automatically created and stored\n\n    Note:\n        The timestamp and thread_id fields are automatically populated\n        using the current time and thread identifier when the profile\n        is created. These are useful for:\n            - Temporal analysis of performance changes\n            - Identifying concurrent execution patterns\n            - Correlating profiles with system events\n    \"\"\"\n\n    operation_name: str\n    execution_time: float\n    memory_peak: int\n    memory_current: int\n    memory_delta: int\n    cpu_percent: float\n    data_size: Optional[int] = None\n    cache_hits: int = 0\n    cache_misses: int = 0\n    # Auto-generate current timestamp when profile is created\n    timestamp: float = field(default_factory=time.time)\n    # Auto-generate current thread ID when profile is created\n    thread_id: int = field(default_factory=threading.get_ident)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport","title":"PerformanceReport  <code>dataclass</code>","text":"<p>Comprehensive performance report with analysis and recommendations.</p> <p>This class aggregates performance data from multiple operations and provides comprehensive analysis including bottleneck identification and optimization recommendations. It serves as the main output of the profiling system.</p> <p>The report analyzes all collected profiles to identify patterns, bottlenecks, and opportunities for optimization. It's designed to provide actionable insights for performance improvement.</p> <p>Attributes:</p> Name Type Description <code>total_operations</code> <code>int</code> <p>Total number of operations profiled across all operation types.</p> <code>total_execution_time</code> <code>float</code> <p>Sum of all execution times in seconds. Represents the cumulative time spent in profiled operations.</p> <code>average_execution_time</code> <code>float</code> <p>Average execution time per operation in seconds. Calculated as total_execution_time / total_operations.</p> <code>memory_peak_total</code> <code>int</code> <p>Peak memory usage across all operations in bytes. The maximum memory used by any single operation.</p> <code>memory_current_total</code> <code>int</code> <p>Current memory usage at report generation in bytes. The memory in use when the report was created.</p> <code>operations</code> <code>List[PerformanceProfile]</code> <p>List of all individual operation profiles collected by the profiler. Provides detailed per-operation metrics.</p> <code>bottlenecks</code> <code>List[str]</code> <p>Identified performance bottlenecks with details. Operations that exceed the 95<sup>th</sup> percentile of execution times.</p> <code>recommendations</code> <code>List[str]</code> <p>Optimization recommendations based on analysis. Actionable suggestions for improving performance.</p> Example <p>Generate and analyze report::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; # ... perform profiled operations ...\n&gt;&gt;&gt; report = profiler.generate_report()\n&gt;&gt;&gt; print(f\"Total operations: {report.total_operations}\")\n&gt;&gt;&gt; print(f\"Total time: {report.total_execution_time:.2f}s\")\n&gt;&gt;&gt; print(f\"Average time: {report.average_execution_time:.3f}s\")\n&gt;&gt;&gt; print(f\"Peak memory: {report.memory_peak_total / 1024 / 1024:.1f} MB\")\n&gt;&gt;&gt; print(f\"\\nBottlenecks:\")\n&gt;&gt;&gt; for bottleneck in report.bottlenecks:\n...     print(f\"  - {bottleneck}\")\n&gt;&gt;&gt; print(f\"\\nRecommendations:\")\n&gt;&gt;&gt; for rec in report.recommendations:\n...     print(f\"  - {rec}\")\n</code></pre> <p>Export report to JSON::</p> <pre><code>&gt;&gt;&gt; report_dict = report.to_dict()\n&gt;&gt;&gt; with open(\"performance.json\", \"w\") as f:\n...     json.dump(report_dict, f, indent=2)\n</code></pre> Note <p>The report is generated by the PerformanceProfiler.generate_report() method and includes intelligent analysis of the collected performance data. The analysis includes:     - Bottleneck identification (95<sup>th</sup> percentile analysis)     - Memory usage patterns     - Large dataset detection     - Repeated operation detection     - CPU utilization analysis</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@dataclass\nclass PerformanceReport:\n    \"\"\"Comprehensive performance report with analysis and recommendations.\n\n    This class aggregates performance data from multiple operations and provides\n    comprehensive analysis including bottleneck identification and optimization\n    recommendations. It serves as the main output of the profiling system.\n\n    The report analyzes all collected profiles to identify patterns, bottlenecks,\n    and opportunities for optimization. It's designed to provide actionable\n    insights for performance improvement.\n\n    Attributes:\n        total_operations (int): Total number of operations profiled across\n            all operation types.\n        total_execution_time (float): Sum of all execution times in seconds.\n            Represents the cumulative time spent in profiled operations.\n        average_execution_time (float): Average execution time per operation\n            in seconds. Calculated as total_execution_time / total_operations.\n        memory_peak_total (int): Peak memory usage across all operations in bytes.\n            The maximum memory used by any single operation.\n        memory_current_total (int): Current memory usage at report generation\n            in bytes. The memory in use when the report was created.\n        operations (List[PerformanceProfile]): List of all individual operation\n            profiles collected by the profiler. Provides detailed per-operation\n            metrics.\n        bottlenecks (List[str]): Identified performance bottlenecks with details.\n            Operations that exceed the 95th percentile of execution times.\n        recommendations (List[str]): Optimization recommendations based on\n            analysis. Actionable suggestions for improving performance.\n\n    Example:\n        Generate and analyze report::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; # ... perform profiled operations ...\n            &gt;&gt;&gt; report = profiler.generate_report()\n            &gt;&gt;&gt; print(f\"Total operations: {report.total_operations}\")\n            &gt;&gt;&gt; print(f\"Total time: {report.total_execution_time:.2f}s\")\n            &gt;&gt;&gt; print(f\"Average time: {report.average_execution_time:.3f}s\")\n            &gt;&gt;&gt; print(f\"Peak memory: {report.memory_peak_total / 1024 / 1024:.1f} MB\")\n            &gt;&gt;&gt; print(f\"\\\\nBottlenecks:\")\n            &gt;&gt;&gt; for bottleneck in report.bottlenecks:\n            ...     print(f\"  - {bottleneck}\")\n            &gt;&gt;&gt; print(f\"\\\\nRecommendations:\")\n            &gt;&gt;&gt; for rec in report.recommendations:\n            ...     print(f\"  - {rec}\")\n\n        Export report to JSON::\n\n            &gt;&gt;&gt; report_dict = report.to_dict()\n            &gt;&gt;&gt; with open(\"performance.json\", \"w\") as f:\n            ...     json.dump(report_dict, f, indent=2)\n\n    Note:\n        The report is generated by the PerformanceProfiler.generate_report()\n        method and includes intelligent analysis of the collected performance\n        data. The analysis includes:\n            - Bottleneck identification (95th percentile analysis)\n            - Memory usage patterns\n            - Large dataset detection\n            - Repeated operation detection\n            - CPU utilization analysis\n    \"\"\"\n\n    total_operations: int\n    total_execution_time: float\n    average_execution_time: float\n    memory_peak_total: int\n    memory_current_total: int\n    operations: List[PerformanceProfile]\n    bottlenecks: List[str]\n    recommendations: List[str]\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert report to dictionary for serialization.\n\n        This method converts the performance report to a dictionary format\n        suitable for JSON serialization or other data exchange formats.\n        It includes all key metrics and analysis results but excludes the\n        detailed operation profiles for brevity.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the performance report\n                with all metrics and analysis results. Contains:\n                    - total_operations: Number of profiled operations\n                    - total_execution_time: Cumulative execution time\n                    - average_execution_time: Mean execution time\n                    - memory_peak_total: Maximum memory usage\n                    - memory_current_total: Current memory usage\n                    - operations_count: Count of operation profiles\n                    - bottlenecks: List of identified bottlenecks\n                    - recommendations: List of optimization suggestions\n\n        Example:\n            Export to JSON file::\n\n                &gt;&gt;&gt; report = profiler.generate_report()\n                &gt;&gt;&gt; report_dict = report.to_dict()\n                &gt;&gt;&gt; import json\n                &gt;&gt;&gt; with open(\"perf_report.json\", \"w\") as f:\n                ...     json.dump(report_dict, f, indent=2)\n\n            Use in API response::\n\n                &gt;&gt;&gt; @app.get(\"/performance\")\n                &gt;&gt;&gt; def get_performance():\n                ...     report = profiler.generate_report()\n                ...     return report.to_dict()\n\n        Note:\n            The detailed operations list is not included in the dictionary\n            to keep the output concise. Only the count is provided via\n            operations_count. If you need detailed operation data, access\n            the operations attribute directly.\n        \"\"\"\n        # Convert the performance report to a dictionary format\n        # This includes all key metrics and analysis results for serialization\n        return {\n            # Total number of operations profiled\n            \"total_operations\": self.total_operations,\n            # Sum of all execution times in seconds\n            \"total_execution_time\": self.total_execution_time,\n            # Average time per operation in seconds\n            \"average_execution_time\": self.average_execution_time,\n            # Peak memory usage across all operations in bytes\n            \"memory_peak_total\": self.memory_peak_total,\n            # Current memory usage at report generation in bytes\n            \"memory_current_total\": self.memory_current_total,\n            # Count of individual operation profiles\n            \"operations_count\": len(self.operations),\n            # List of identified performance bottlenecks\n            \"bottlenecks\": self.bottlenecks,\n            # List of optimization recommendations\n            \"recommendations\": self.recommendations,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert report to dictionary for serialization.</p> <p>This method converts the performance report to a dictionary format suitable for JSON serialization or other data exchange formats. It includes all key metrics and analysis results but excludes the detailed operation profiles for brevity.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the performance report with all metrics and analysis results. Contains:     - total_operations: Number of profiled operations     - total_execution_time: Cumulative execution time     - average_execution_time: Mean execution time     - memory_peak_total: Maximum memory usage     - memory_current_total: Current memory usage     - operations_count: Count of operation profiles     - bottlenecks: List of identified bottlenecks     - recommendations: List of optimization suggestions</p> Example <p>Export to JSON file::</p> <pre><code>&gt;&gt;&gt; report = profiler.generate_report()\n&gt;&gt;&gt; report_dict = report.to_dict()\n&gt;&gt;&gt; import json\n&gt;&gt;&gt; with open(\"perf_report.json\", \"w\") as f:\n...     json.dump(report_dict, f, indent=2)\n</code></pre> <p>Use in API response::</p> <pre><code>&gt;&gt;&gt; @app.get(\"/performance\")\n&gt;&gt;&gt; def get_performance():\n...     report = profiler.generate_report()\n...     return report.to_dict()\n</code></pre> Note <p>The detailed operations list is not included in the dictionary to keep the output concise. Only the count is provided via operations_count. If you need detailed operation data, access the operations attribute directly.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert report to dictionary for serialization.\n\n    This method converts the performance report to a dictionary format\n    suitable for JSON serialization or other data exchange formats.\n    It includes all key metrics and analysis results but excludes the\n    detailed operation profiles for brevity.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the performance report\n            with all metrics and analysis results. Contains:\n                - total_operations: Number of profiled operations\n                - total_execution_time: Cumulative execution time\n                - average_execution_time: Mean execution time\n                - memory_peak_total: Maximum memory usage\n                - memory_current_total: Current memory usage\n                - operations_count: Count of operation profiles\n                - bottlenecks: List of identified bottlenecks\n                - recommendations: List of optimization suggestions\n\n    Example:\n        Export to JSON file::\n\n            &gt;&gt;&gt; report = profiler.generate_report()\n            &gt;&gt;&gt; report_dict = report.to_dict()\n            &gt;&gt;&gt; import json\n            &gt;&gt;&gt; with open(\"perf_report.json\", \"w\") as f:\n            ...     json.dump(report_dict, f, indent=2)\n\n        Use in API response::\n\n            &gt;&gt;&gt; @app.get(\"/performance\")\n            &gt;&gt;&gt; def get_performance():\n            ...     report = profiler.generate_report()\n            ...     return report.to_dict()\n\n    Note:\n        The detailed operations list is not included in the dictionary\n        to keep the output concise. Only the count is provided via\n        operations_count. If you need detailed operation data, access\n        the operations attribute directly.\n    \"\"\"\n    # Convert the performance report to a dictionary format\n    # This includes all key metrics and analysis results for serialization\n    return {\n        # Total number of operations profiled\n        \"total_operations\": self.total_operations,\n        # Sum of all execution times in seconds\n        \"total_execution_time\": self.total_execution_time,\n        # Average time per operation in seconds\n        \"average_execution_time\": self.average_execution_time,\n        # Peak memory usage across all operations in bytes\n        \"memory_peak_total\": self.memory_peak_total,\n        # Current memory usage at report generation in bytes\n        \"memory_current_total\": self.memory_current_total,\n        # Count of individual operation profiles\n        \"operations_count\": len(self.operations),\n        # List of identified performance bottlenecks\n        \"bottlenecks\": self.bottlenecks,\n        # List of optimization recommendations\n        \"recommendations\": self.recommendations,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler","title":"PerformanceProfiler","text":"<p>Advanced performance profiler with memory and CPU monitoring.</p> <p>This class provides comprehensive performance profiling capabilities for tracking execution time, memory usage, and CPU utilization across operations. It supports both decorator and context manager APIs for flexible integration.</p> <p>The profiler is thread-safe and can track multiple concurrent operations. It automatically analyzes collected profiles to identify bottlenecks and generate optimization recommendations.</p> <p>Attributes:</p> Name Type Description <code>enable_memory_tracking</code> <code>bool</code> <p>Whether detailed memory tracking is enabled using tracemalloc. Has small performance overhead.</p> <code>profiles</code> <code>List[PerformanceProfile]</code> <p>List of all collected operation profiles for analysis.</p> <code>operation_times</code> <code>Dict[str, List[float]]</code> <p>Execution times grouped by operation name for statistical analysis.</p> <code>memory_snapshots</code> <code>List[Dict[str, int]]</code> <p>Historical memory usage snapshots for trend analysis.</p> Example <p>Basic usage with context manager::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; with profiler.measure_operation(\"chart_render\"):\n...     render_chart(data)\n&gt;&gt;&gt; report = profiler.generate_report()\n</code></pre> <p>Using as decorator::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; @profiler.profile_operation(\"data_transform\", data_size=1000)\n... def transform_data(df):\n...     return df.apply(transformation)\n</code></pre> <p>Generate and export reports::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; # ... perform operations ...\n&gt;&gt;&gt; report = profiler.generate_report()\n&gt;&gt;&gt; profiler.export_profiles(\"performance.json\")\n</code></pre> Note <p>For most use cases, use the global profiler instance via the convenience functions: profile_function(), profile_operation(), and get_profiler().</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>class PerformanceProfiler:\n    \"\"\"Advanced performance profiler with memory and CPU monitoring.\n\n    This class provides comprehensive performance profiling capabilities for\n    tracking execution time, memory usage, and CPU utilization across operations.\n    It supports both decorator and context manager APIs for flexible integration.\n\n    The profiler is thread-safe and can track multiple concurrent operations.\n    It automatically analyzes collected profiles to identify bottlenecks and\n    generate optimization recommendations.\n\n    Attributes:\n        enable_memory_tracking (bool): Whether detailed memory tracking is enabled\n            using tracemalloc. Has small performance overhead.\n        profiles (List[PerformanceProfile]): List of all collected operation\n            profiles for analysis.\n        operation_times (Dict[str, List[float]]): Execution times grouped by\n            operation name for statistical analysis.\n        memory_snapshots (List[Dict[str, int]]): Historical memory usage\n            snapshots for trend analysis.\n\n    Example:\n        Basic usage with context manager::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; with profiler.measure_operation(\"chart_render\"):\n            ...     render_chart(data)\n            &gt;&gt;&gt; report = profiler.generate_report()\n\n        Using as decorator::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; @profiler.profile_operation(\"data_transform\", data_size=1000)\n            ... def transform_data(df):\n            ...     return df.apply(transformation)\n\n        Generate and export reports::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; # ... perform operations ...\n            &gt;&gt;&gt; report = profiler.generate_report()\n            &gt;&gt;&gt; profiler.export_profiles(\"performance.json\")\n\n    Note:\n        For most use cases, use the global profiler instance via the\n        convenience functions: profile_function(), profile_operation(),\n        and get_profiler().\n    \"\"\"\n\n    def __init__(self, enable_memory_tracking: bool = True):\n        \"\"\"Initialize profiler with optional memory tracking.\n\n        This method sets up the performance profiler with the specified\n        memory tracking configuration. It initializes data structures\n        for storing performance profiles and starts memory tracking\n        if enabled.\n\n        Args:\n            enable_memory_tracking (bool, optional): Whether to enable detailed\n                memory tracking using tracemalloc. Defaults to True. When enabled,\n                provides accurate peak memory measurements but incurs a small\n                performance overhead (~5-10%).\n\n        Example:\n            Create profiler with memory tracking::\n\n                &gt;&gt;&gt; profiler = PerformanceProfiler(enable_memory_tracking=True)\n\n            Create lightweight profiler without memory tracking::\n\n                &gt;&gt;&gt; profiler = PerformanceProfiler(enable_memory_tracking=False)\n\n        Note:\n            Memory tracking uses Python's tracemalloc module which tracks\n            memory allocations at the Python level. It provides detailed\n            insights but has a small performance cost. Disable it for\n            minimal overhead in production environments.\n        \"\"\"\n        # Store memory tracking configuration for later use\n        self.enable_memory_tracking = enable_memory_tracking\n\n        # Initialize list to store all operation profiles\n        # Each profile contains metrics for a single operation execution\n        self.profiles: List[PerformanceProfile] = []\n\n        # Initialize dict to group execution times by operation name\n        # Used for calculating statistics per operation type\n        self.operation_times: Dict[str, List[float]] = defaultdict(list)\n\n        # Initialize list to store memory usage snapshots over time\n        # Used for trend analysis and leak detection\n        self.memory_snapshots: List[Dict[str, int]] = []\n\n        # Create thread lock for thread-safe operations\n        # Ensures concurrent profiling doesn't corrupt data structures\n        self._lock = threading.Lock()\n\n        # Start memory tracking if enabled\n        # tracemalloc tracks Python memory allocations for detailed analysis\n        if enable_memory_tracking:\n            # Start tracking memory allocations at the Python level\n            tracemalloc.start()\n\n    def profile_operation(\n        self, operation_name: str, data_size: Optional[int] = None\n    ):\n        \"\"\"Decorator to profile a function or method.\n\n        This decorator wraps a function to automatically profile its execution\n        time, memory usage, and CPU utilization. Each invocation of the\n        decorated function creates a new PerformanceProfile.\n\n        Args:\n            operation_name (str): Name identifier for the operation being\n                profiled. Used to group and analyze similar operations.\n            data_size (Optional[int], optional): Size of data being processed\n                (if applicable). Useful for analyzing scalability. Defaults to None.\n\n        Returns:\n            Callable: Decorator function that wraps the target function with\n                profiling instrumentation.\n\n        Example:\n            Profile a function::\n\n                &gt;&gt;&gt; profiler = PerformanceProfiler()\n                &gt;&gt;&gt; @profiler.profile_operation(\"chart_rendering\", data_size=1000)\n                ... def render_chart(data):\n                ...     return Chart(data).render()\n                &gt;&gt;&gt; # Function is automatically profiled on each call\n                &gt;&gt;&gt; result = render_chart(my_data)\n\n            Profile with dynamic data size::\n\n                &gt;&gt;&gt; @profiler.profile_operation(\"data_processing\")\n                ... def process_data(data):\n                ...     return transform(data)\n\n        Note:\n            The decorator preserves the original function's metadata using\n            functools.wraps, so docstrings, name, and other attributes are\n            maintained.\n        \"\"\"\n\n        # Define the decorator that will wrap the target function\n        def decorator(func: Callable) -&gt; Callable:\n            # Use functools.wraps to preserve function metadata\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                # Profile the function execution using measure_operation\n                with self.measure_operation(operation_name, data_size):\n                    # Call the original function and return its result\n                    return func(*args, **kwargs)\n\n            # Return the wrapped function\n            return wrapper\n\n        # Return the decorator\n        return decorator\n\n    @contextmanager\n    def measure_operation(\n        self, operation_name: str, data_size: Optional[int] = None\n    ):\n        \"\"\"Context manager to measure operation performance.\n\n        This context manager measures the performance of a code block by\n        tracking execution time, memory usage, and CPU utilization. It\n        automatically creates a PerformanceProfile and stores it for analysis.\n\n        The measurement process:\n            1. Record initial state (memory, CPU baseline)\n            2. Take memory snapshot if tracking is enabled\n            3. Execute the measured code block\n            4. Record final state (memory, CPU)\n            5. Calculate deltas and create profile\n            6. Store profile for analysis\n\n        Args:\n            operation_name (str): Name identifier for the operation being\n                measured. Used to group similar operations for analysis.\n            data_size (Optional[int], optional): Size of data being processed\n                (if applicable). Useful for analyzing performance scalability.\n                Defaults to None.\n\n        Yields:\n            None: The context manager yields control to the measured code block.\n\n        Example:\n            Profile a code block::\n\n                &gt;&gt;&gt; profiler = PerformanceProfiler()\n                &gt;&gt;&gt; with profiler.measure_operation(\"data_transform\", data_size=5000):\n                ...     transformed = transform_data(raw_data)\n                ...     validated = validate_data(transformed)\n\n            Nested profiling::\n\n                &gt;&gt;&gt; with profiler.measure_operation(\"complete_workflow\"):\n                ...     with profiler.measure_operation(\"data_load\"):\n                ...         data = load_data()\n                ...     with profiler.measure_operation(\"data_process\"):\n                ...         result = process_data(data)\n\n        Note:\n            The context manager always executes the finally block, ensuring\n            that profiles are recorded even if exceptions occur. The profile\n            will still capture execution time and resource usage up to the\n            point of failure.\n        \"\"\"\n        # Get the current process for memory and CPU monitoring\n        # psutil.Process() without arguments gets the current process\n        process = psutil.Process()\n\n        # Record initial memory state\n        # RSS (Resident Set Size) is the actual physical memory used\n        initial_memory = process.memory_info().rss\n\n        # Initialize CPU monitoring\n        # First call to cpu_percent() returns 0, subsequent calls return\n        # actual usage since last call. This primes the CPU counter.\n        process.cpu_percent()\n\n        # Take initial memory snapshot if detailed tracking is enabled\n        # This provides a baseline for memory usage analysis\n        if self.enable_memory_tracking:\n            # Create a snapshot of current memory allocations\n            tracemalloc.take_snapshot()\n\n        # Record start time for execution time measurement\n        # Uses time.time() for wall-clock time (includes I/O wait time)\n        start_time = time.time()\n\n        try:\n            # Yield control to the code block being measured\n            # This is where the actual operation executes\n            yield\n        finally:\n            # This finally block always executes, even if exceptions occur\n            # Ensures we capture performance data even for failed operations\n\n            # Record end time and calculate execution duration\n            end_time = time.time()\n            execution_time = end_time - start_time\n\n            # Get final memory state after operation completion\n            # RSS gives us the actual physical memory used by the process\n            final_memory = process.memory_info().rss\n\n            # Get CPU utilization during the operation\n            # Returns percentage of CPU time used since last cpu_percent() call\n            final_cpu = process.cpu_percent()\n\n            # Calculate memory delta (change in memory usage)\n            # Positive values indicate memory allocation\n            # Negative values indicate memory deallocation\n            memory_delta = final_memory - initial_memory\n\n            # Get peak memory usage if detailed tracking is enabled\n            # Use final memory as fallback if tracking is disabled\n            memory_peak = final_memory\n            if self.enable_memory_tracking:\n                # Take final snapshot to capture all allocations\n                snapshot = tracemalloc.take_snapshot()\n\n                # Calculate total memory used by summing all allocations\n                # Statistics grouped by line number for detailed tracking\n                memory_peak = sum(\n                    stat.size for stat in snapshot.statistics(\"lineno\")\n                )\n\n            # Create comprehensive performance profile for this operation\n            # This captures all metrics collected during the operation\n            profile = PerformanceProfile(\n                operation_name=operation_name,  # Operation identifier\n                execution_time=execution_time,  # Total execution time\n                memory_peak=memory_peak,  # Peak memory usage\n                memory_current=final_memory,  # Current memory usage\n                memory_delta=memory_delta,  # Change in memory usage\n                cpu_percent=final_cpu,  # CPU utilization percentage\n                data_size=data_size,  # Optional data size metadata\n            )\n\n            # Store the profile in thread-safe manner\n            # The lock ensures concurrent profiling doesn't corrupt data\n            with self._lock:\n                # Add profile to the list of all profiles\n                self.profiles.append(profile)\n\n                # Group execution time by operation name for statistics\n                self.operation_times[operation_name].append(execution_time)\n\n    def get_operation_stats(self, operation_name: str) -&gt; Dict[str, float]:\n        \"\"\"Get statistics for a specific operation.\n\n        This method calculates comprehensive statistics for all executions\n        of a specific operation type, including count, total time, average,\n        min, max, and median execution times.\n\n        Args:\n            operation_name (str): Name of the operation to analyze.\n\n        Returns:\n            Dict[str, float]: Dictionary containing operation statistics:\n                - count: Number of times operation was executed\n                - total_time: Sum of all execution times\n                - average_time: Mean execution time\n                - min_time: Fastest execution time\n                - max_time: Slowest execution time\n                - median_time: Median execution time\n\n                Returns empty dict if operation has no recorded executions.\n\n        Example:\n            Get statistics for specific operation::\n\n                &gt;&gt;&gt; stats = profiler.get_operation_stats(\"chart_rendering\")\n                &gt;&gt;&gt; print(f\"Executed {stats['count']} times\")\n                &gt;&gt;&gt; print(f\"Average time: {stats['average_time']:.3f}s\")\n                &gt;&gt;&gt; print(f\"Min time: {stats['min_time']:.3f}s\")\n                &gt;&gt;&gt; print(f\"Max time: {stats['max_time']:.3f}s\")\n                &gt;&gt;&gt; print(f\"Median time: {stats['median_time']:.3f}s\")\n\n            Check if operation exists::\n\n                &gt;&gt;&gt; stats = profiler.get_operation_stats(\"unknown_op\")\n                &gt;&gt;&gt; if not stats:\n                ...     print(\"Operation not profiled\")\n\n        Note:\n            The median calculation uses a simple approach that works well\n            for most cases. For even-length lists, it returns the lower\n            middle value rather than the average of the two middle values.\n        \"\"\"\n        # Get list of execution times for this operation\n        # Returns empty list if operation name not found\n        times = self.operation_times.get(operation_name, [])\n\n        # Return empty dict if no times recorded for this operation\n        if not times:\n            return {}\n\n        # Calculate and return comprehensive statistics\n        return {\n            # Count of executions\n            \"count\": len(times),\n            # Sum of all execution times\n            \"total_time\": sum(times),\n            # Mean execution time\n            \"average_time\": sum(times) / len(times),\n            # Fastest execution time\n            \"min_time\": min(times),\n            # Slowest execution time\n            \"max_time\": max(times),\n            # Median execution time (middle value of sorted list)\n            \"median_time\": sorted(times)[len(times) // 2],\n        }\n\n    def identify_bottlenecks(\n        self, threshold_percentile: float = 95.0\n    ) -&gt; List[str]:\n        \"\"\"Identify performance bottlenecks based on execution times.\n\n        This method analyzes all profiled operations to identify bottlenecks\n        using percentile analysis. Operations whose average execution time\n        exceeds the specified percentile threshold are flagged as bottlenecks.\n\n        The default 95th percentile means that operations in the slowest 5%\n        are considered bottlenecks.\n\n        Args:\n            threshold_percentile (float, optional): Percentile threshold for\n                identifying slow operations. Must be between 0 and 100.\n                Defaults to 95.0 (slowest 5% of operations).\n\n        Returns:\n            List[str]: List of bottleneck descriptions in the format\n                \"{operation_name}: {average_time:.4f}s average\".\n                Empty list if no operations are profiled.\n\n        Example:\n            Identify default bottlenecks (95th percentile)::\n\n                &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks()\n                &gt;&gt;&gt; for bottleneck in bottlenecks:\n                ...     print(f\"Bottleneck: {bottleneck}\")\n\n            Use stricter threshold (90th percentile)::\n\n                &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(90.0)\n\n            Use more lenient threshold (99th percentile)::\n\n                &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(99.0)\n\n        Note:\n            The method compares average execution times per operation,\n            not individual execution times. This helps identify consistently\n            slow operations rather than one-off outliers.\n        \"\"\"\n        # Return empty list if no profiles have been collected\n        if not self.profiles:\n            return []\n\n        # Step 1: Calculate threshold value using percentile analysis\n        # Collect all execution times from all profiles\n        all_times = [p.execution_time for p in self.profiles]\n\n        # Sort times and find value at the specified percentile\n        # This gives us the threshold above which operations are bottlenecks\n        threshold = sorted(all_times)[\n            int(len(all_times) * threshold_percentile / 100)\n        ]\n\n        # Step 2: Group execution times by operation name\n        # This allows us to calculate average time per operation type\n        operation_stats = defaultdict(list)\n        for profile in self.profiles:\n            operation_stats[profile.operation_name].append(profile.execution_time)\n\n        # Step 3: Identify operations with average time above threshold\n        slow_operations = []\n        for op_name, times in operation_stats.items():\n            # Calculate average execution time for this operation\n            avg_time = sum(times) / len(times)\n\n            # If average exceeds threshold, flag as bottleneck\n            if avg_time &gt; threshold:\n                # Format bottleneck description with operation name and time\n                slow_operations.append(f\"{op_name}: {avg_time:.4f}s average\")\n\n        # Return list of identified bottlenecks\n        return slow_operations\n\n    def generate_recommendations(self) -&gt; List[str]:\n        \"\"\"Generate performance optimization recommendations.\n\n        This method analyzes the collected performance profiles to generate\n        actionable optimization recommendations. It examines memory usage,\n        execution times, data sizes, and operation patterns to provide\n        targeted suggestions.\n\n        The recommendations cover:\n            - High memory usage detection\n            - Slow operation identification\n            - Large dataset handling\n            - Repeated operation optimization\n\n        Returns:\n            List[str]: List of optimization recommendations. Empty list if\n                no operations have been profiled. Each recommendation is\n                a complete sentence describing the issue and suggested fix.\n\n        Example:\n            Generate and display recommendations::\n\n                &gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n                &gt;&gt;&gt; print(f\"Found {len(recommendations)} recommendations:\")\n                &gt;&gt;&gt; for i, rec in enumerate(recommendations, 1):\n                ...     print(f\"{i}. {rec}\")\n\n            Check for specific recommendations::\n\n                &gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n                &gt;&gt;&gt; memory_recs = [r for r in recommendations if \"memory\" in r.lower()]\n                &gt;&gt;&gt; caching_recs = [r for r in recommendations if \"cach\" in r.lower()]\n\n        Note:\n            Recommendations are generated based on heuristics and thresholds\n            that work well for most applications. You may need to adjust your\n            interpretation based on your specific use case and performance\n            requirements.\n        \"\"\"\n        # Initialize list to store recommendations\n        recommendations: List[str] = []\n\n        # Return empty list if no profiles have been collected\n        if not self.profiles:\n            return recommendations\n\n        # Analysis 1: Check for high memory usage\n        # Filter profiles that increased memory (positive delta)\n        memory_profiles = [p for p in self.profiles if p.memory_delta &gt; 0]\n\n        if memory_profiles:\n            # Calculate average memory increase across operations\n            avg_memory_delta = sum(\n                p.memory_delta for p in memory_profiles\n            ) / len(memory_profiles)\n\n            # Flag if average memory increase exceeds 100 MB\n            if avg_memory_delta &gt; 100 * 1024 * 1024:  # 100MB threshold\n                recommendations.append(\n                    \"High memory usage detected. Consider using lazy loading \"\n                    \"or chunking.\"\n                )\n\n        # Analysis 2: Check for slow operations using 90th percentile\n        # More aggressive than the default 95th percentile for bottlenecks\n        slow_operations = self.identify_bottlenecks(90.0)\n\n        if slow_operations:\n            # Show up to 3 slowest operations to keep recommendation concise\n            top_slow = \", \".join(slow_operations[:3])\n            recommendations.append(\n                f\"Slow operations detected: {top_slow}. \"\n                \"Consider optimization or caching.\"\n            )\n\n        # Analysis 3: Check for large dataset processing\n        # Filter operations processing more than 10,000 items\n        large_data_ops = [\n            p for p in self.profiles if p.data_size and p.data_size &gt; 10000\n        ]\n\n        if large_data_ops:\n            recommendations.append(\n                \"Large datasets detected. Consider using vectorized processing \"\n                \"or memory-efficient data classes.\"\n            )\n\n        # Analysis 4: Check for repeated operations\n        # Count how many times each operation was executed\n        operation_counts: defaultdict[str, int] = defaultdict(int)\n        for profile in self.profiles:\n            operation_counts[profile.operation_name] += 1\n\n        # Flag operations executed more than 10 times\n        repeated_ops = [op for op, count in operation_counts.items() if count &gt; 10]\n\n        if repeated_ops:\n            # Show operation names that might benefit from caching\n            ops_list = \", \".join(repeated_ops)\n            recommendations.append(\n                f\"Frequent operations detected: {ops_list}. \"\n                \"Consider caching or batching.\"\n            )\n\n        # Return all generated recommendations\n        return recommendations\n\n    def generate_report(self) -&gt; PerformanceReport:\n        \"\"\"Generate comprehensive performance report.\n\n        This method aggregates all collected performance profiles and generates\n        a comprehensive report including total metrics, bottleneck analysis,\n        and optimization recommendations.\n\n        Returns:\n            PerformanceReport: Complete performance report with metrics,\n                bottlenecks, and recommendations. Returns a report with zero\n                values if no operations have been profiled.\n\n        Example:\n            Generate and analyze report::\n\n                &gt;&gt;&gt; report = profiler.generate_report()\n                &gt;&gt;&gt; print(f\"Operations profiled: {report.total_operations}\")\n                &gt;&gt;&gt; print(f\"Total time: {report.total_execution_time:.2f}s\")\n                &gt;&gt;&gt; print(f\"Average time: {report.average_execution_time:.3f}s\")\n                &gt;&gt;&gt; print(f\"Peak memory: {report.memory_peak_total / 1024 / 1024:.1f} MB\")\n                &gt;&gt;&gt; print(f\"\\\\nBottlenecks ({len(report.bottlenecks)}):\")\n                &gt;&gt;&gt; for bottleneck in report.bottlenecks:\n                ...     print(f\"  - {bottleneck}\")\n                &gt;&gt;&gt; print(f\"\\\\nRecommendations ({len(report.recommendations)}):\")\n                &gt;&gt;&gt; for rec in report.recommendations:\n                ...     print(f\"  - {rec}\")\n\n            Export report::\n\n                &gt;&gt;&gt; report = profiler.generate_report()\n                &gt;&gt;&gt; with open(\"report.json\", \"w\") as f:\n                ...     json.dump(report.to_dict(), f, indent=2)\n\n        Note:\n            The report provides a snapshot of performance at the time it's\n            generated. If you continue profiling operations after generating\n            a report, you'll need to call generate_report() again to get\n            updated metrics.\n        \"\"\"\n        # Handle case where no operations have been profiled\n        # Return empty report with zero values\n        if not self.profiles:\n            return PerformanceReport(\n                total_operations=0,\n                total_execution_time=0.0,\n                average_execution_time=0.0,\n                memory_peak_total=0,\n                memory_current_total=0,\n                operations=[],\n                bottlenecks=[],\n                recommendations=[],\n            )\n\n        # Calculate total execution time across all operations\n        total_time = sum(p.execution_time for p in self.profiles)\n\n        # Calculate average execution time per operation\n        avg_time = total_time / len(self.profiles)\n\n        # Find peak memory usage across all operations\n        # This is the maximum memory used by any single operation\n        memory_peak_total = max(p.memory_peak for p in self.profiles)\n\n        # Find current memory usage across all operations\n        # This is the maximum current memory at the end of any operation\n        memory_current_total = max(p.memory_current for p in self.profiles)\n\n        # Generate bottleneck analysis using default 95th percentile\n        bottlenecks = self.identify_bottlenecks()\n\n        # Generate optimization recommendations based on collected data\n        recommendations = self.generate_recommendations()\n\n        # Create and return comprehensive performance report\n        return PerformanceReport(\n            total_operations=len(self.profiles),\n            total_execution_time=total_time,\n            average_execution_time=avg_time,\n            memory_peak_total=memory_peak_total,\n            memory_current_total=memory_current_total,\n            operations=self.profiles.copy(),  # Copy to prevent external modification\n            bottlenecks=bottlenecks,\n            recommendations=recommendations,\n        )\n\n    def clear_profiles(self) -&gt; None:\n        \"\"\"Clear all stored profiles and reset the profiler.\n\n        This method removes all collected performance profiles and resets\n        internal data structures. If memory tracking is enabled, it also\n        restarts tracemalloc to clear memory tracking state.\n\n        Use this method when you want to start fresh profiling without\n        creating a new profiler instance, or to free memory occupied by\n        old profiles.\n\n        Example:\n            Clear profiles between test runs::\n\n                &gt;&gt;&gt; profiler = PerformanceProfiler()\n                &gt;&gt;&gt; # ... run first batch of operations ...\n                &gt;&gt;&gt; report1 = profiler.generate_report()\n                &gt;&gt;&gt; profiler.clear_profiles()  # Reset for next batch\n                &gt;&gt;&gt; # ... run second batch of operations ...\n                &gt;&gt;&gt; report2 = profiler.generate_report()\n\n            Free memory after exporting::\n\n                &gt;&gt;&gt; profiler.export_profiles(\"report.json\")\n                &gt;&gt;&gt; profiler.clear_profiles()  # Free memory\n\n        Note:\n            This operation is thread-safe and will wait for any ongoing\n            profiling operations to complete before clearing data.\n\n            After clearing, the profiler is ready to collect new profiles\n            immediately.\n        \"\"\"\n        # Use lock to ensure thread-safe clearing\n        # Prevents race conditions with concurrent profiling\n        with self._lock:\n            # Clear all stored operation profiles\n            self.profiles.clear()\n\n            # Clear grouped operation times for statistics\n            self.operation_times.clear()\n\n            # Clear memory usage snapshots\n            self.memory_snapshots.clear()\n\n        # Reset memory tracking if enabled\n        # This clears tracemalloc's internal state\n        if self.enable_memory_tracking:\n            # Stop current memory tracking\n            tracemalloc.stop()\n\n            # Restart memory tracking with clean state\n            tracemalloc.start()\n\n    def export_profiles(self, filename: str) -&gt; None:\n        \"\"\"Export profiles to a JSON file for analysis.\n\n        This method generates a performance report and exports it to a JSON\n        file. The exported data includes all metrics, bottlenecks, and\n        recommendations in a format suitable for further analysis or sharing.\n\n        Args:\n            filename (str): Path to the output JSON file. Can be relative\n                or absolute. Parent directories must exist.\n\n        Example:\n            Export to default location::\n\n                &gt;&gt;&gt; profiler.export_profiles(\"performance_report.json\")\n\n            Export to specific directory::\n\n                &gt;&gt;&gt; profiler.export_profiles(\"/tmp/reports/perf_20240101.json\")\n\n            Export with timestamp::\n\n                &gt;&gt;&gt; from datetime import datetime\n                &gt;&gt;&gt; timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                &gt;&gt;&gt; profiler.export_profiles(f\"perf_{timestamp}.json\")\n\n        Note:\n            The exported file contains:\n                - Total operations count\n                - Total and average execution times\n                - Peak and current memory usage\n                - Count of operations\n                - List of bottlenecks\n                - List of recommendations\n\n            The file is written with UTF-8 encoding and 2-space indentation\n            for readability.\n\n        Raises:\n            IOError: If the file cannot be written (e.g., permission denied,\n                disk full, parent directory doesn't exist).\n        \"\"\"\n        # Generate comprehensive performance report\n        report = self.generate_report()\n\n        # Open file for writing with UTF-8 encoding\n        # Using Path ensures cross-platform compatibility\n        with Path(filename).open(\"w\", encoding=\"utf-8\") as f:\n            # Convert report to dict and write as JSON\n            # indent=2 makes the output human-readable\n            json.dump(report.to_dict(), f, indent=2)\n\n        # Log successful export for debugging\n        logger.info(\"Performance profiles exported to %s\", filename)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.profile_operation","title":"profile_operation","text":"<pre><code>profile_operation(operation_name: str, data_size: Optional[int] = None)\n</code></pre> <p>Decorator to profile a function or method.</p> <p>This decorator wraps a function to automatically profile its execution time, memory usage, and CPU utilization. Each invocation of the decorated function creates a new PerformanceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name identifier for the operation being profiled. Used to group and analyze similar operations.</p> required <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed (if applicable). Useful for analyzing scalability. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <p>Decorator function that wraps the target function with profiling instrumentation.</p> Example <p>Profile a function::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; @profiler.profile_operation(\"chart_rendering\", data_size=1000)\n... def render_chart(data):\n...     return Chart(data).render()\n&gt;&gt;&gt; # Function is automatically profiled on each call\n&gt;&gt;&gt; result = render_chart(my_data)\n</code></pre> <p>Profile with dynamic data size::</p> <pre><code>&gt;&gt;&gt; @profiler.profile_operation(\"data_processing\")\n... def process_data(data):\n...     return transform(data)\n</code></pre> Note <p>The decorator preserves the original function's metadata using functools.wraps, so docstrings, name, and other attributes are maintained.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def profile_operation(\n    self, operation_name: str, data_size: Optional[int] = None\n):\n    \"\"\"Decorator to profile a function or method.\n\n    This decorator wraps a function to automatically profile its execution\n    time, memory usage, and CPU utilization. Each invocation of the\n    decorated function creates a new PerformanceProfile.\n\n    Args:\n        operation_name (str): Name identifier for the operation being\n            profiled. Used to group and analyze similar operations.\n        data_size (Optional[int], optional): Size of data being processed\n            (if applicable). Useful for analyzing scalability. Defaults to None.\n\n    Returns:\n        Callable: Decorator function that wraps the target function with\n            profiling instrumentation.\n\n    Example:\n        Profile a function::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; @profiler.profile_operation(\"chart_rendering\", data_size=1000)\n            ... def render_chart(data):\n            ...     return Chart(data).render()\n            &gt;&gt;&gt; # Function is automatically profiled on each call\n            &gt;&gt;&gt; result = render_chart(my_data)\n\n        Profile with dynamic data size::\n\n            &gt;&gt;&gt; @profiler.profile_operation(\"data_processing\")\n            ... def process_data(data):\n            ...     return transform(data)\n\n    Note:\n        The decorator preserves the original function's metadata using\n        functools.wraps, so docstrings, name, and other attributes are\n        maintained.\n    \"\"\"\n\n    # Define the decorator that will wrap the target function\n    def decorator(func: Callable) -&gt; Callable:\n        # Use functools.wraps to preserve function metadata\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # Profile the function execution using measure_operation\n            with self.measure_operation(operation_name, data_size):\n                # Call the original function and return its result\n                return func(*args, **kwargs)\n\n        # Return the wrapped function\n        return wrapper\n\n    # Return the decorator\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.measure_operation","title":"measure_operation","text":"<pre><code>measure_operation(operation_name: str, data_size: Optional[int] = None)\n</code></pre> <p>Context manager to measure operation performance.</p> <p>This context manager measures the performance of a code block by tracking execution time, memory usage, and CPU utilization. It automatically creates a PerformanceProfile and stores it for analysis.</p> The measurement process <ol> <li>Record initial state (memory, CPU baseline)</li> <li>Take memory snapshot if tracking is enabled</li> <li>Execute the measured code block</li> <li>Record final state (memory, CPU)</li> <li>Calculate deltas and create profile</li> <li>Store profile for analysis</li> </ol> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name identifier for the operation being measured. Used to group similar operations for analysis.</p> required <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed (if applicable). Useful for analyzing performance scalability. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>None</code> <p>The context manager yields control to the measured code block.</p> Example <p>Profile a code block::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; with profiler.measure_operation(\"data_transform\", data_size=5000):\n...     transformed = transform_data(raw_data)\n...     validated = validate_data(transformed)\n</code></pre> <p>Nested profiling::</p> <pre><code>&gt;&gt;&gt; with profiler.measure_operation(\"complete_workflow\"):\n...     with profiler.measure_operation(\"data_load\"):\n...         data = load_data()\n...     with profiler.measure_operation(\"data_process\"):\n...         result = process_data(data)\n</code></pre> Note <p>The context manager always executes the finally block, ensuring that profiles are recorded even if exceptions occur. The profile will still capture execution time and resource usage up to the point of failure.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@contextmanager\ndef measure_operation(\n    self, operation_name: str, data_size: Optional[int] = None\n):\n    \"\"\"Context manager to measure operation performance.\n\n    This context manager measures the performance of a code block by\n    tracking execution time, memory usage, and CPU utilization. It\n    automatically creates a PerformanceProfile and stores it for analysis.\n\n    The measurement process:\n        1. Record initial state (memory, CPU baseline)\n        2. Take memory snapshot if tracking is enabled\n        3. Execute the measured code block\n        4. Record final state (memory, CPU)\n        5. Calculate deltas and create profile\n        6. Store profile for analysis\n\n    Args:\n        operation_name (str): Name identifier for the operation being\n            measured. Used to group similar operations for analysis.\n        data_size (Optional[int], optional): Size of data being processed\n            (if applicable). Useful for analyzing performance scalability.\n            Defaults to None.\n\n    Yields:\n        None: The context manager yields control to the measured code block.\n\n    Example:\n        Profile a code block::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; with profiler.measure_operation(\"data_transform\", data_size=5000):\n            ...     transformed = transform_data(raw_data)\n            ...     validated = validate_data(transformed)\n\n        Nested profiling::\n\n            &gt;&gt;&gt; with profiler.measure_operation(\"complete_workflow\"):\n            ...     with profiler.measure_operation(\"data_load\"):\n            ...         data = load_data()\n            ...     with profiler.measure_operation(\"data_process\"):\n            ...         result = process_data(data)\n\n    Note:\n        The context manager always executes the finally block, ensuring\n        that profiles are recorded even if exceptions occur. The profile\n        will still capture execution time and resource usage up to the\n        point of failure.\n    \"\"\"\n    # Get the current process for memory and CPU monitoring\n    # psutil.Process() without arguments gets the current process\n    process = psutil.Process()\n\n    # Record initial memory state\n    # RSS (Resident Set Size) is the actual physical memory used\n    initial_memory = process.memory_info().rss\n\n    # Initialize CPU monitoring\n    # First call to cpu_percent() returns 0, subsequent calls return\n    # actual usage since last call. This primes the CPU counter.\n    process.cpu_percent()\n\n    # Take initial memory snapshot if detailed tracking is enabled\n    # This provides a baseline for memory usage analysis\n    if self.enable_memory_tracking:\n        # Create a snapshot of current memory allocations\n        tracemalloc.take_snapshot()\n\n    # Record start time for execution time measurement\n    # Uses time.time() for wall-clock time (includes I/O wait time)\n    start_time = time.time()\n\n    try:\n        # Yield control to the code block being measured\n        # This is where the actual operation executes\n        yield\n    finally:\n        # This finally block always executes, even if exceptions occur\n        # Ensures we capture performance data even for failed operations\n\n        # Record end time and calculate execution duration\n        end_time = time.time()\n        execution_time = end_time - start_time\n\n        # Get final memory state after operation completion\n        # RSS gives us the actual physical memory used by the process\n        final_memory = process.memory_info().rss\n\n        # Get CPU utilization during the operation\n        # Returns percentage of CPU time used since last cpu_percent() call\n        final_cpu = process.cpu_percent()\n\n        # Calculate memory delta (change in memory usage)\n        # Positive values indicate memory allocation\n        # Negative values indicate memory deallocation\n        memory_delta = final_memory - initial_memory\n\n        # Get peak memory usage if detailed tracking is enabled\n        # Use final memory as fallback if tracking is disabled\n        memory_peak = final_memory\n        if self.enable_memory_tracking:\n            # Take final snapshot to capture all allocations\n            snapshot = tracemalloc.take_snapshot()\n\n            # Calculate total memory used by summing all allocations\n            # Statistics grouped by line number for detailed tracking\n            memory_peak = sum(\n                stat.size for stat in snapshot.statistics(\"lineno\")\n            )\n\n        # Create comprehensive performance profile for this operation\n        # This captures all metrics collected during the operation\n        profile = PerformanceProfile(\n            operation_name=operation_name,  # Operation identifier\n            execution_time=execution_time,  # Total execution time\n            memory_peak=memory_peak,  # Peak memory usage\n            memory_current=final_memory,  # Current memory usage\n            memory_delta=memory_delta,  # Change in memory usage\n            cpu_percent=final_cpu,  # CPU utilization percentage\n            data_size=data_size,  # Optional data size metadata\n        )\n\n        # Store the profile in thread-safe manner\n        # The lock ensures concurrent profiling doesn't corrupt data\n        with self._lock:\n            # Add profile to the list of all profiles\n            self.profiles.append(profile)\n\n            # Group execution time by operation name for statistics\n            self.operation_times[operation_name].append(execution_time)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.get_operation_stats","title":"get_operation_stats","text":"<pre><code>get_operation_stats(operation_name: str) -&gt; Dict[str, float]\n</code></pre> <p>Get statistics for a specific operation.</p> <p>This method calculates comprehensive statistics for all executions of a specific operation type, including count, total time, average, min, max, and median execution times.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name of the operation to analyze.</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str, float]: Dictionary containing operation statistics: - count: Number of times operation was executed - total_time: Sum of all execution times - average_time: Mean execution time - min_time: Fastest execution time - max_time: Slowest execution time - median_time: Median execution time</p> <p>Returns empty dict if operation has no recorded executions.</p> Example <p>Get statistics for specific operation::</p> <pre><code>&gt;&gt;&gt; stats = profiler.get_operation_stats(\"chart_rendering\")\n&gt;&gt;&gt; print(f\"Executed {stats['count']} times\")\n&gt;&gt;&gt; print(f\"Average time: {stats['average_time']:.3f}s\")\n&gt;&gt;&gt; print(f\"Min time: {stats['min_time']:.3f}s\")\n&gt;&gt;&gt; print(f\"Max time: {stats['max_time']:.3f}s\")\n&gt;&gt;&gt; print(f\"Median time: {stats['median_time']:.3f}s\")\n</code></pre> <p>Check if operation exists::</p> <pre><code>&gt;&gt;&gt; stats = profiler.get_operation_stats(\"unknown_op\")\n&gt;&gt;&gt; if not stats:\n...     print(\"Operation not profiled\")\n</code></pre> Note <p>The median calculation uses a simple approach that works well for most cases. For even-length lists, it returns the lower middle value rather than the average of the two middle values.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_operation_stats(self, operation_name: str) -&gt; Dict[str, float]:\n    \"\"\"Get statistics for a specific operation.\n\n    This method calculates comprehensive statistics for all executions\n    of a specific operation type, including count, total time, average,\n    min, max, and median execution times.\n\n    Args:\n        operation_name (str): Name of the operation to analyze.\n\n    Returns:\n        Dict[str, float]: Dictionary containing operation statistics:\n            - count: Number of times operation was executed\n            - total_time: Sum of all execution times\n            - average_time: Mean execution time\n            - min_time: Fastest execution time\n            - max_time: Slowest execution time\n            - median_time: Median execution time\n\n            Returns empty dict if operation has no recorded executions.\n\n    Example:\n        Get statistics for specific operation::\n\n            &gt;&gt;&gt; stats = profiler.get_operation_stats(\"chart_rendering\")\n            &gt;&gt;&gt; print(f\"Executed {stats['count']} times\")\n            &gt;&gt;&gt; print(f\"Average time: {stats['average_time']:.3f}s\")\n            &gt;&gt;&gt; print(f\"Min time: {stats['min_time']:.3f}s\")\n            &gt;&gt;&gt; print(f\"Max time: {stats['max_time']:.3f}s\")\n            &gt;&gt;&gt; print(f\"Median time: {stats['median_time']:.3f}s\")\n\n        Check if operation exists::\n\n            &gt;&gt;&gt; stats = profiler.get_operation_stats(\"unknown_op\")\n            &gt;&gt;&gt; if not stats:\n            ...     print(\"Operation not profiled\")\n\n    Note:\n        The median calculation uses a simple approach that works well\n        for most cases. For even-length lists, it returns the lower\n        middle value rather than the average of the two middle values.\n    \"\"\"\n    # Get list of execution times for this operation\n    # Returns empty list if operation name not found\n    times = self.operation_times.get(operation_name, [])\n\n    # Return empty dict if no times recorded for this operation\n    if not times:\n        return {}\n\n    # Calculate and return comprehensive statistics\n    return {\n        # Count of executions\n        \"count\": len(times),\n        # Sum of all execution times\n        \"total_time\": sum(times),\n        # Mean execution time\n        \"average_time\": sum(times) / len(times),\n        # Fastest execution time\n        \"min_time\": min(times),\n        # Slowest execution time\n        \"max_time\": max(times),\n        # Median execution time (middle value of sorted list)\n        \"median_time\": sorted(times)[len(times) // 2],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.identify_bottlenecks","title":"identify_bottlenecks","text":"<pre><code>identify_bottlenecks(threshold_percentile: float = 95.0) -&gt; List[str]\n</code></pre> <p>Identify performance bottlenecks based on execution times.</p> <p>This method analyzes all profiled operations to identify bottlenecks using percentile analysis. Operations whose average execution time exceeds the specified percentile threshold are flagged as bottlenecks.</p> <p>The default 95<sup>th</sup> percentile means that operations in the slowest 5% are considered bottlenecks.</p> <p>Parameters:</p> Name Type Description Default <code>threshold_percentile</code> <code>float</code> <p>Percentile threshold for identifying slow operations. Must be between 0 and 100. Defaults to 95.0 (slowest 5% of operations).</p> <code>95.0</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of bottleneck descriptions in the format \"{operation_name}: {average_time:.4f}s average\". Empty list if no operations are profiled.</p> Example <p>Identify default bottlenecks (95<sup>th</sup> percentile)::</p> <pre><code>&gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks()\n&gt;&gt;&gt; for bottleneck in bottlenecks:\n...     print(f\"Bottleneck: {bottleneck}\")\n</code></pre> <p>Use stricter threshold (90<sup>th</sup> percentile)::</p> <pre><code>&gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(90.0)\n</code></pre> <p>Use more lenient threshold (99<sup>th</sup> percentile)::</p> <pre><code>&gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(99.0)\n</code></pre> Note <p>The method compares average execution times per operation, not individual execution times. This helps identify consistently slow operations rather than one-off outliers.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def identify_bottlenecks(\n    self, threshold_percentile: float = 95.0\n) -&gt; List[str]:\n    \"\"\"Identify performance bottlenecks based on execution times.\n\n    This method analyzes all profiled operations to identify bottlenecks\n    using percentile analysis. Operations whose average execution time\n    exceeds the specified percentile threshold are flagged as bottlenecks.\n\n    The default 95th percentile means that operations in the slowest 5%\n    are considered bottlenecks.\n\n    Args:\n        threshold_percentile (float, optional): Percentile threshold for\n            identifying slow operations. Must be between 0 and 100.\n            Defaults to 95.0 (slowest 5% of operations).\n\n    Returns:\n        List[str]: List of bottleneck descriptions in the format\n            \"{operation_name}: {average_time:.4f}s average\".\n            Empty list if no operations are profiled.\n\n    Example:\n        Identify default bottlenecks (95th percentile)::\n\n            &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks()\n            &gt;&gt;&gt; for bottleneck in bottlenecks:\n            ...     print(f\"Bottleneck: {bottleneck}\")\n\n        Use stricter threshold (90th percentile)::\n\n            &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(90.0)\n\n        Use more lenient threshold (99th percentile)::\n\n            &gt;&gt;&gt; bottlenecks = profiler.identify_bottlenecks(99.0)\n\n    Note:\n        The method compares average execution times per operation,\n        not individual execution times. This helps identify consistently\n        slow operations rather than one-off outliers.\n    \"\"\"\n    # Return empty list if no profiles have been collected\n    if not self.profiles:\n        return []\n\n    # Step 1: Calculate threshold value using percentile analysis\n    # Collect all execution times from all profiles\n    all_times = [p.execution_time for p in self.profiles]\n\n    # Sort times and find value at the specified percentile\n    # This gives us the threshold above which operations are bottlenecks\n    threshold = sorted(all_times)[\n        int(len(all_times) * threshold_percentile / 100)\n    ]\n\n    # Step 2: Group execution times by operation name\n    # This allows us to calculate average time per operation type\n    operation_stats = defaultdict(list)\n    for profile in self.profiles:\n        operation_stats[profile.operation_name].append(profile.execution_time)\n\n    # Step 3: Identify operations with average time above threshold\n    slow_operations = []\n    for op_name, times in operation_stats.items():\n        # Calculate average execution time for this operation\n        avg_time = sum(times) / len(times)\n\n        # If average exceeds threshold, flag as bottleneck\n        if avg_time &gt; threshold:\n            # Format bottleneck description with operation name and time\n            slow_operations.append(f\"{op_name}: {avg_time:.4f}s average\")\n\n    # Return list of identified bottlenecks\n    return slow_operations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.generate_recommendations","title":"generate_recommendations","text":"<pre><code>generate_recommendations() -&gt; List[str]\n</code></pre> <p>Generate performance optimization recommendations.</p> <p>This method analyzes the collected performance profiles to generate actionable optimization recommendations. It examines memory usage, execution times, data sizes, and operation patterns to provide targeted suggestions.</p> The recommendations cover <ul> <li>High memory usage detection</li> <li>Slow operation identification</li> <li>Large dataset handling</li> <li>Repeated operation optimization</li> </ul> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of optimization recommendations. Empty list if no operations have been profiled. Each recommendation is a complete sentence describing the issue and suggested fix.</p> Example <p>Generate and display recommendations::</p> <pre><code>&gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n&gt;&gt;&gt; print(f\"Found {len(recommendations)} recommendations:\")\n&gt;&gt;&gt; for i, rec in enumerate(recommendations, 1):\n...     print(f\"{i}. {rec}\")\n</code></pre> <p>Check for specific recommendations::</p> <pre><code>&gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n&gt;&gt;&gt; memory_recs = [r for r in recommendations if \"memory\" in r.lower()]\n&gt;&gt;&gt; caching_recs = [r for r in recommendations if \"cach\" in r.lower()]\n</code></pre> Note <p>Recommendations are generated based on heuristics and thresholds that work well for most applications. You may need to adjust your interpretation based on your specific use case and performance requirements.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def generate_recommendations(self) -&gt; List[str]:\n    \"\"\"Generate performance optimization recommendations.\n\n    This method analyzes the collected performance profiles to generate\n    actionable optimization recommendations. It examines memory usage,\n    execution times, data sizes, and operation patterns to provide\n    targeted suggestions.\n\n    The recommendations cover:\n        - High memory usage detection\n        - Slow operation identification\n        - Large dataset handling\n        - Repeated operation optimization\n\n    Returns:\n        List[str]: List of optimization recommendations. Empty list if\n            no operations have been profiled. Each recommendation is\n            a complete sentence describing the issue and suggested fix.\n\n    Example:\n        Generate and display recommendations::\n\n            &gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n            &gt;&gt;&gt; print(f\"Found {len(recommendations)} recommendations:\")\n            &gt;&gt;&gt; for i, rec in enumerate(recommendations, 1):\n            ...     print(f\"{i}. {rec}\")\n\n        Check for specific recommendations::\n\n            &gt;&gt;&gt; recommendations = profiler.generate_recommendations()\n            &gt;&gt;&gt; memory_recs = [r for r in recommendations if \"memory\" in r.lower()]\n            &gt;&gt;&gt; caching_recs = [r for r in recommendations if \"cach\" in r.lower()]\n\n    Note:\n        Recommendations are generated based on heuristics and thresholds\n        that work well for most applications. You may need to adjust your\n        interpretation based on your specific use case and performance\n        requirements.\n    \"\"\"\n    # Initialize list to store recommendations\n    recommendations: List[str] = []\n\n    # Return empty list if no profiles have been collected\n    if not self.profiles:\n        return recommendations\n\n    # Analysis 1: Check for high memory usage\n    # Filter profiles that increased memory (positive delta)\n    memory_profiles = [p for p in self.profiles if p.memory_delta &gt; 0]\n\n    if memory_profiles:\n        # Calculate average memory increase across operations\n        avg_memory_delta = sum(\n            p.memory_delta for p in memory_profiles\n        ) / len(memory_profiles)\n\n        # Flag if average memory increase exceeds 100 MB\n        if avg_memory_delta &gt; 100 * 1024 * 1024:  # 100MB threshold\n            recommendations.append(\n                \"High memory usage detected. Consider using lazy loading \"\n                \"or chunking.\"\n            )\n\n    # Analysis 2: Check for slow operations using 90th percentile\n    # More aggressive than the default 95th percentile for bottlenecks\n    slow_operations = self.identify_bottlenecks(90.0)\n\n    if slow_operations:\n        # Show up to 3 slowest operations to keep recommendation concise\n        top_slow = \", \".join(slow_operations[:3])\n        recommendations.append(\n            f\"Slow operations detected: {top_slow}. \"\n            \"Consider optimization or caching.\"\n        )\n\n    # Analysis 3: Check for large dataset processing\n    # Filter operations processing more than 10,000 items\n    large_data_ops = [\n        p for p in self.profiles if p.data_size and p.data_size &gt; 10000\n    ]\n\n    if large_data_ops:\n        recommendations.append(\n            \"Large datasets detected. Consider using vectorized processing \"\n            \"or memory-efficient data classes.\"\n        )\n\n    # Analysis 4: Check for repeated operations\n    # Count how many times each operation was executed\n    operation_counts: defaultdict[str, int] = defaultdict(int)\n    for profile in self.profiles:\n        operation_counts[profile.operation_name] += 1\n\n    # Flag operations executed more than 10 times\n    repeated_ops = [op for op, count in operation_counts.items() if count &gt; 10]\n\n    if repeated_ops:\n        # Show operation names that might benefit from caching\n        ops_list = \", \".join(repeated_ops)\n        recommendations.append(\n            f\"Frequent operations detected: {ops_list}. \"\n            \"Consider caching or batching.\"\n        )\n\n    # Return all generated recommendations\n    return recommendations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.generate_report","title":"generate_report","text":"<pre><code>generate_report() -&gt; PerformanceReport\n</code></pre> <p>Generate comprehensive performance report.</p> <p>This method aggregates all collected performance profiles and generates a comprehensive report including total metrics, bottleneck analysis, and optimization recommendations.</p> <p>Returns:</p> Name Type Description <code>PerformanceReport</code> <code>PerformanceReport</code> <p>Complete performance report with metrics, bottlenecks, and recommendations. Returns a report with zero values if no operations have been profiled.</p> Example <p>Generate and analyze report::</p> <pre><code>&gt;&gt;&gt; report = profiler.generate_report()\n&gt;&gt;&gt; print(f\"Operations profiled: {report.total_operations}\")\n&gt;&gt;&gt; print(f\"Total time: {report.total_execution_time:.2f}s\")\n&gt;&gt;&gt; print(f\"Average time: {report.average_execution_time:.3f}s\")\n&gt;&gt;&gt; print(f\"Peak memory: {report.memory_peak_total / 1024 / 1024:.1f} MB\")\n&gt;&gt;&gt; print(f\"\\nBottlenecks ({len(report.bottlenecks)}):\")\n&gt;&gt;&gt; for bottleneck in report.bottlenecks:\n...     print(f\"  - {bottleneck}\")\n&gt;&gt;&gt; print(f\"\\nRecommendations ({len(report.recommendations)}):\")\n&gt;&gt;&gt; for rec in report.recommendations:\n...     print(f\"  - {rec}\")\n</code></pre> <p>Export report::</p> <pre><code>&gt;&gt;&gt; report = profiler.generate_report()\n&gt;&gt;&gt; with open(\"report.json\", \"w\") as f:\n...     json.dump(report.to_dict(), f, indent=2)\n</code></pre> Note <p>The report provides a snapshot of performance at the time it's generated. If you continue profiling operations after generating a report, you'll need to call generate_report() again to get updated metrics.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def generate_report(self) -&gt; PerformanceReport:\n    \"\"\"Generate comprehensive performance report.\n\n    This method aggregates all collected performance profiles and generates\n    a comprehensive report including total metrics, bottleneck analysis,\n    and optimization recommendations.\n\n    Returns:\n        PerformanceReport: Complete performance report with metrics,\n            bottlenecks, and recommendations. Returns a report with zero\n            values if no operations have been profiled.\n\n    Example:\n        Generate and analyze report::\n\n            &gt;&gt;&gt; report = profiler.generate_report()\n            &gt;&gt;&gt; print(f\"Operations profiled: {report.total_operations}\")\n            &gt;&gt;&gt; print(f\"Total time: {report.total_execution_time:.2f}s\")\n            &gt;&gt;&gt; print(f\"Average time: {report.average_execution_time:.3f}s\")\n            &gt;&gt;&gt; print(f\"Peak memory: {report.memory_peak_total / 1024 / 1024:.1f} MB\")\n            &gt;&gt;&gt; print(f\"\\\\nBottlenecks ({len(report.bottlenecks)}):\")\n            &gt;&gt;&gt; for bottleneck in report.bottlenecks:\n            ...     print(f\"  - {bottleneck}\")\n            &gt;&gt;&gt; print(f\"\\\\nRecommendations ({len(report.recommendations)}):\")\n            &gt;&gt;&gt; for rec in report.recommendations:\n            ...     print(f\"  - {rec}\")\n\n        Export report::\n\n            &gt;&gt;&gt; report = profiler.generate_report()\n            &gt;&gt;&gt; with open(\"report.json\", \"w\") as f:\n            ...     json.dump(report.to_dict(), f, indent=2)\n\n    Note:\n        The report provides a snapshot of performance at the time it's\n        generated. If you continue profiling operations after generating\n        a report, you'll need to call generate_report() again to get\n        updated metrics.\n    \"\"\"\n    # Handle case where no operations have been profiled\n    # Return empty report with zero values\n    if not self.profiles:\n        return PerformanceReport(\n            total_operations=0,\n            total_execution_time=0.0,\n            average_execution_time=0.0,\n            memory_peak_total=0,\n            memory_current_total=0,\n            operations=[],\n            bottlenecks=[],\n            recommendations=[],\n        )\n\n    # Calculate total execution time across all operations\n    total_time = sum(p.execution_time for p in self.profiles)\n\n    # Calculate average execution time per operation\n    avg_time = total_time / len(self.profiles)\n\n    # Find peak memory usage across all operations\n    # This is the maximum memory used by any single operation\n    memory_peak_total = max(p.memory_peak for p in self.profiles)\n\n    # Find current memory usage across all operations\n    # This is the maximum current memory at the end of any operation\n    memory_current_total = max(p.memory_current for p in self.profiles)\n\n    # Generate bottleneck analysis using default 95th percentile\n    bottlenecks = self.identify_bottlenecks()\n\n    # Generate optimization recommendations based on collected data\n    recommendations = self.generate_recommendations()\n\n    # Create and return comprehensive performance report\n    return PerformanceReport(\n        total_operations=len(self.profiles),\n        total_execution_time=total_time,\n        average_execution_time=avg_time,\n        memory_peak_total=memory_peak_total,\n        memory_current_total=memory_current_total,\n        operations=self.profiles.copy(),  # Copy to prevent external modification\n        bottlenecks=bottlenecks,\n        recommendations=recommendations,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.clear_profiles","title":"clear_profiles","text":"<pre><code>clear_profiles() -&gt; None\n</code></pre> <p>Clear all stored profiles and reset the profiler.</p> <p>This method removes all collected performance profiles and resets internal data structures. If memory tracking is enabled, it also restarts tracemalloc to clear memory tracking state.</p> <p>Use this method when you want to start fresh profiling without creating a new profiler instance, or to free memory occupied by old profiles.</p> Example <p>Clear profiles between test runs::</p> <pre><code>&gt;&gt;&gt; profiler = PerformanceProfiler()\n&gt;&gt;&gt; # ... run first batch of operations ...\n&gt;&gt;&gt; report1 = profiler.generate_report()\n&gt;&gt;&gt; profiler.clear_profiles()  # Reset for next batch\n&gt;&gt;&gt; # ... run second batch of operations ...\n&gt;&gt;&gt; report2 = profiler.generate_report()\n</code></pre> <p>Free memory after exporting::</p> <pre><code>&gt;&gt;&gt; profiler.export_profiles(\"report.json\")\n&gt;&gt;&gt; profiler.clear_profiles()  # Free memory\n</code></pre> Note <p>This operation is thread-safe and will wait for any ongoing profiling operations to complete before clearing data.</p> <p>After clearing, the profiler is ready to collect new profiles immediately.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def clear_profiles(self) -&gt; None:\n    \"\"\"Clear all stored profiles and reset the profiler.\n\n    This method removes all collected performance profiles and resets\n    internal data structures. If memory tracking is enabled, it also\n    restarts tracemalloc to clear memory tracking state.\n\n    Use this method when you want to start fresh profiling without\n    creating a new profiler instance, or to free memory occupied by\n    old profiles.\n\n    Example:\n        Clear profiles between test runs::\n\n            &gt;&gt;&gt; profiler = PerformanceProfiler()\n            &gt;&gt;&gt; # ... run first batch of operations ...\n            &gt;&gt;&gt; report1 = profiler.generate_report()\n            &gt;&gt;&gt; profiler.clear_profiles()  # Reset for next batch\n            &gt;&gt;&gt; # ... run second batch of operations ...\n            &gt;&gt;&gt; report2 = profiler.generate_report()\n\n        Free memory after exporting::\n\n            &gt;&gt;&gt; profiler.export_profiles(\"report.json\")\n            &gt;&gt;&gt; profiler.clear_profiles()  # Free memory\n\n    Note:\n        This operation is thread-safe and will wait for any ongoing\n        profiling operations to complete before clearing data.\n\n        After clearing, the profiler is ready to collect new profiles\n        immediately.\n    \"\"\"\n    # Use lock to ensure thread-safe clearing\n    # Prevents race conditions with concurrent profiling\n    with self._lock:\n        # Clear all stored operation profiles\n        self.profiles.clear()\n\n        # Clear grouped operation times for statistics\n        self.operation_times.clear()\n\n        # Clear memory usage snapshots\n        self.memory_snapshots.clear()\n\n    # Reset memory tracking if enabled\n    # This clears tracemalloc's internal state\n    if self.enable_memory_tracking:\n        # Stop current memory tracking\n        tracemalloc.stop()\n\n        # Restart memory tracking with clean state\n        tracemalloc.start()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.export_profiles","title":"export_profiles","text":"<pre><code>export_profiles(filename: str) -&gt; None\n</code></pre> <p>Export profiles to a JSON file for analysis.</p> <p>This method generates a performance report and exports it to a JSON file. The exported data includes all metrics, bottlenecks, and recommendations in a format suitable for further analysis or sharing.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the output JSON file. Can be relative or absolute. Parent directories must exist.</p> required Example <p>Export to default location::</p> <pre><code>&gt;&gt;&gt; profiler.export_profiles(\"performance_report.json\")\n</code></pre> <p>Export to specific directory::</p> <pre><code>&gt;&gt;&gt; profiler.export_profiles(\"/tmp/reports/perf_20240101.json\")\n</code></pre> <p>Export with timestamp::</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n&gt;&gt;&gt; profiler.export_profiles(f\"perf_{timestamp}.json\")\n</code></pre> Note <p>The exported file contains:     - Total operations count     - Total and average execution times     - Peak and current memory usage     - Count of operations     - List of bottlenecks     - List of recommendations</p> <p>The file is written with UTF-8 encoding and 2-space indentation for readability.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written (e.g., permission denied, disk full, parent directory doesn't exist).</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def export_profiles(self, filename: str) -&gt; None:\n    \"\"\"Export profiles to a JSON file for analysis.\n\n    This method generates a performance report and exports it to a JSON\n    file. The exported data includes all metrics, bottlenecks, and\n    recommendations in a format suitable for further analysis or sharing.\n\n    Args:\n        filename (str): Path to the output JSON file. Can be relative\n            or absolute. Parent directories must exist.\n\n    Example:\n        Export to default location::\n\n            &gt;&gt;&gt; profiler.export_profiles(\"performance_report.json\")\n\n        Export to specific directory::\n\n            &gt;&gt;&gt; profiler.export_profiles(\"/tmp/reports/perf_20240101.json\")\n\n        Export with timestamp::\n\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            &gt;&gt;&gt; profiler.export_profiles(f\"perf_{timestamp}.json\")\n\n    Note:\n        The exported file contains:\n            - Total operations count\n            - Total and average execution times\n            - Peak and current memory usage\n            - Count of operations\n            - List of bottlenecks\n            - List of recommendations\n\n        The file is written with UTF-8 encoding and 2-space indentation\n        for readability.\n\n    Raises:\n        IOError: If the file cannot be written (e.g., permission denied,\n            disk full, parent directory doesn't exist).\n    \"\"\"\n    # Generate comprehensive performance report\n    report = self.generate_report()\n\n    # Open file for writing with UTF-8 encoding\n    # Using Path ensures cross-platform compatibility\n    with Path(filename).open(\"w\", encoding=\"utf-8\") as f:\n        # Convert report to dict and write as JSON\n        # indent=2 makes the output human-readable\n        json.dump(report.to_dict(), f, indent=2)\n\n    # Log successful export for debugging\n    logger.info(\"Performance profiles exported to %s\", filename)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor","title":"MemoryMonitor","text":"<p>Memory usage monitoring and optimization suggestions.</p> <p>This class provides memory tracking capabilities with trend analysis and optimization suggestions. It monitors memory usage over time to detect leaks, analyze trends, and provide actionable recommendations.</p> <p>The monitor tracks both RSS (Resident Set Size - actual physical memory) and VMS (Virtual Memory Size - total virtual memory) to provide a complete picture of memory usage.</p> <p>Attributes:</p> Name Type Description <code>memory_history</code> <code>List[Dict[str, float]]</code> <p>Historical snapshots of memory usage with timestamps for trend analysis.</p> <code>process</code> <code>Process</code> <p>Process handle for memory monitoring.</p> Example <p>Basic memory monitoring::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; monitor.record_memory_snapshot()\n&gt;&gt;&gt; perform_memory_intensive_operation()\n&gt;&gt;&gt; monitor.record_memory_snapshot()\n&gt;&gt;&gt; trend = monitor.get_memory_trend()\n&gt;&gt;&gt; print(f\"Memory trend: {trend['trend']}\")\n</code></pre> <p>Get optimization suggestions::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; # ... perform operations ...\n&gt;&gt;&gt; suggestions = monitor.suggest_optimizations()\n&gt;&gt;&gt; for suggestion in suggestions:\n...     print(f\"- {suggestion}\")\n</code></pre> Note <p>The monitor tracks the current process by default. For monitoring other processes, you would need to modify the implementation to accept a PID parameter.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>class MemoryMonitor:\n    \"\"\"Memory usage monitoring and optimization suggestions.\n\n    This class provides memory tracking capabilities with trend analysis\n    and optimization suggestions. It monitors memory usage over time to\n    detect leaks, analyze trends, and provide actionable recommendations.\n\n    The monitor tracks both RSS (Resident Set Size - actual physical memory)\n    and VMS (Virtual Memory Size - total virtual memory) to provide a\n    complete picture of memory usage.\n\n    Attributes:\n        memory_history (List[Dict[str, float]]): Historical snapshots of\n            memory usage with timestamps for trend analysis.\n        process (psutil.Process): Process handle for memory monitoring.\n\n    Example:\n        Basic memory monitoring::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()\n            &gt;&gt;&gt; perform_memory_intensive_operation()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()\n            &gt;&gt;&gt; trend = monitor.get_memory_trend()\n            &gt;&gt;&gt; print(f\"Memory trend: {trend['trend']}\")\n\n        Get optimization suggestions::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; # ... perform operations ...\n            &gt;&gt;&gt; suggestions = monitor.suggest_optimizations()\n            &gt;&gt;&gt; for suggestion in suggestions:\n            ...     print(f\"- {suggestion}\")\n\n    Note:\n        The monitor tracks the current process by default. For monitoring\n        other processes, you would need to modify the implementation to\n        accept a PID parameter.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize memory monitor.\n\n        Creates a new memory monitor instance that tracks the current process.\n        Initializes data structures for storing memory usage history.\n\n        Example:\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; usage = monitor.get_memory_usage()\n            &gt;&gt;&gt; print(f\"Current memory: {usage['rss'] / 1024 / 1024:.1f} MB\")\n        \"\"\"\n        # Initialize list to store memory usage history\n        # Each entry is a dict with memory metrics and timestamp\n        self.memory_history: List[Dict[str, float]] = []\n\n        # Get handle to current process for memory monitoring\n        # psutil.Process() without arguments gets current process\n        self.process = psutil.Process()\n\n    def get_memory_usage(self) -&gt; Dict[str, float]:\n        \"\"\"Get current memory usage information.\n\n        This method retrieves current memory usage metrics for the monitored\n        process, including RSS, VMS, and memory percentage.\n\n        Returns:\n            Dict[str, float]: Dictionary containing current memory metrics:\n                - rss: Resident Set Size in bytes (physical memory)\n                - vms: Virtual Memory Size in bytes (total virtual memory)\n                - percent: Memory usage as percentage of system total\n\n        Example:\n            Display current memory usage::\n\n                &gt;&gt;&gt; usage = monitor.get_memory_usage()\n                &gt;&gt;&gt; print(f\"Physical memory: {usage['rss'] / 1024 / 1024:.1f} MB\")\n                &gt;&gt;&gt; print(f\"Virtual memory: {usage['vms'] / 1024 / 1024:.1f} MB\")\n                &gt;&gt;&gt; print(f\"Memory percent: {usage['percent']:.1f}%\")\n\n        Note:\n            RSS (Resident Set Size) is the actual physical memory used by the\n            process. VMS (Virtual Memory Size) includes swapped memory and\n            memory-mapped files. Typically RSS is more relevant for performance\n            analysis.\n        \"\"\"\n        # Get memory info from process\n        memory_info = self.process.memory_info()\n\n        # Return dict with memory metrics\n        return {\n            # Resident Set Size - actual physical memory in bytes\n            \"rss\": float(memory_info.rss),\n            # Virtual Memory Size - total virtual memory in bytes\n            \"vms\": float(memory_info.vms),\n            # Memory usage as percentage of system total\n            \"percent\": self.process.memory_percent(),\n        }\n\n    def record_memory_snapshot(self) -&gt; None:\n        \"\"\"Record current memory usage snapshot.\n\n        This method captures the current memory state and adds it to the\n        history for trend analysis. Each snapshot includes RSS, VMS, memory\n        percentage, and a timestamp.\n\n        Example:\n            Track memory over time::\n\n                &gt;&gt;&gt; monitor = MemoryMonitor()\n                &gt;&gt;&gt; monitor.record_memory_snapshot()  # Before\n                &gt;&gt;&gt; process_large_dataset()\n                &gt;&gt;&gt; monitor.record_memory_snapshot()  # After\n                &gt;&gt;&gt; trend = monitor.get_memory_trend()\n\n            Track multiple operations::\n\n                &gt;&gt;&gt; monitor = MemoryMonitor()\n                &gt;&gt;&gt; for i in range(10):\n                ...     monitor.record_memory_snapshot()\n                ...     perform_operation(i)\n                &gt;&gt;&gt; # Analyze trend across all operations\n                &gt;&gt;&gt; trend = monitor.get_memory_trend()\n\n        Note:\n            Snapshots are stored in memory, so excessive snapshot recording\n            could itself consume memory. For long-running monitoring, consider\n            periodically clearing old snapshots.\n        \"\"\"\n        # Get current memory usage metrics\n        snapshot = self.get_memory_usage()\n\n        # Add timestamp to snapshot\n        # This allows temporal analysis of memory trends\n        snapshot[\"timestamp\"] = time.time()\n\n        # Append snapshot to history\n        self.memory_history.append(snapshot)\n\n    def get_memory_trend(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze memory usage trend.\n\n        This method analyzes the memory history to determine whether memory\n        usage is increasing, decreasing, or stable. It compares the most\n        recent snapshot with the oldest snapshot.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing trend analysis:\n                - trend: \"increasing\", \"decreasing\", \"stable\", or\n                  \"insufficient_data\"\n                - rss_change: Change in RSS (bytes). Only if data is sufficient.\n                - vms_change: Change in VMS (bytes). Only if data is sufficient.\n                - current_rss: Current RSS (bytes). Only if data is sufficient.\n                - current_vms: Current VMS (bytes). Only if data is sufficient.\n\n        Example:\n            Analyze memory trend::\n\n                &gt;&gt;&gt; monitor = MemoryMonitor()\n                &gt;&gt;&gt; # ... record snapshots over time ...\n                &gt;&gt;&gt; trend = monitor.get_memory_trend()\n                &gt;&gt;&gt; if trend['trend'] == 'increasing':\n                ...     mb_increase = trend['rss_change'] / 1024 / 1024\n                ...     print(f\"Memory increased by {mb_increase:.1f} MB\")\n                &gt;&gt;&gt; elif trend['trend'] == 'insufficient_data':\n                ...     print(\"Need more snapshots for trend analysis\")\n\n        Note:\n            Requires at least 2 snapshots for trend analysis. Returns\n            \"insufficient_data\" if fewer than 2 snapshots are recorded.\n\n            The trend is based on RSS (physical memory) rather than VMS,\n            as RSS is more directly related to actual memory consumption.\n        \"\"\"\n        # Check if we have enough data for trend analysis\n        # Need at least 2 snapshots to calculate a trend\n        if len(self.memory_history) &lt; 2:\n            return {\"trend\": \"insufficient_data\"}\n\n        # Get most recent and oldest snapshots for comparison\n        recent = self.memory_history[-1]\n        older = self.memory_history[0]\n\n        # Calculate change in memory usage\n        rss_change = recent[\"rss\"] - older[\"rss\"]\n        vms_change = recent[\"vms\"] - older[\"vms\"]\n\n        # Determine trend based on RSS change\n        # RSS is more meaningful than VMS for actual memory usage\n        if rss_change &gt; 0:\n            trend = \"increasing\"\n        elif rss_change &lt; 0:\n            trend = \"decreasing\"\n        else:\n            trend = \"stable\"\n\n        # Return comprehensive trend analysis\n        return {\n            \"trend\": trend,  # Overall trend direction\n            \"rss_change\": rss_change,  # Change in physical memory\n            \"vms_change\": vms_change,  # Change in virtual memory\n            \"current_rss\": recent[\"rss\"],  # Current physical memory\n            \"current_vms\": recent[\"vms\"],  # Current virtual memory\n        }\n\n    def suggest_optimizations(self) -&gt; List[str]:\n        \"\"\"Suggest memory optimizations based on usage patterns.\n\n        This method analyzes memory usage history to identify potential\n        issues and provide optimization recommendations. It checks for:\n            - High memory usage (&gt; 80% of system memory)\n            - Potential memory leaks (large increasing trend)\n            - Excessive virtual memory usage (&gt; 2GB)\n\n        Returns:\n            List[str]: List of optimization suggestions. Empty list if\n                no issues are detected or no history is available. Each\n                suggestion is a complete sentence describing the issue\n                and recommended action.\n\n        Example:\n            Get and display suggestions::\n\n                &gt;&gt;&gt; monitor = MemoryMonitor()\n                &gt;&gt;&gt; # ... record snapshots over time ...\n                &gt;&gt;&gt; suggestions = monitor.suggest_optimizations()\n                &gt;&gt;&gt; if suggestions:\n                ...     print(\"Memory optimization suggestions:\")\n                ...     for i, suggestion in enumerate(suggestions, 1):\n                ...         print(f\"{i}. {suggestion}\")\n                ... else:\n                ...     print(\"No memory issues detected\")\n\n        Note:\n            Suggestions are based on heuristics and thresholds that work\n            well for most applications:\n                - 80% memory usage threshold\n                - 100MB RSS increase for leak detection\n                - 2GB VMS threshold for virtual memory warning\n\n            You may need to adjust your interpretation based on your\n            specific application's memory requirements.\n        \"\"\"\n        # Initialize list to store suggestions\n        suggestions: List[str] = []\n\n        # Return empty list if no history is available\n        if not self.memory_history:\n            return suggestions\n\n        # Get most recent snapshot for current state analysis\n        current = self.memory_history[-1]\n\n        # Get trend analysis for leak detection\n        trend = self.get_memory_trend()\n\n        # Check 1: High memory usage detection\n        # Flag if process is using more than 80% of system memory\n        if current[\"percent\"] &gt; 80:\n            suggestions.append(\n                \"High memory usage detected. Consider using memory-efficient \"\n                \"data classes.\"\n            )\n\n        # Check 2: Memory leak detection\n        # Flag if memory is increasing AND increase is significant (&gt; 100MB)\n        if (\n            trend[\"trend\"] == \"increasing\"\n            and trend[\"rss_change\"] &gt; 100 * 1024 * 1024  # 100MB threshold\n        ):\n            suggestions.append(\n                \"Potential memory leak detected. Check for unclosed resources.\"\n            )\n\n        # Check 3: Excessive virtual memory usage\n        # Flag if virtual memory exceeds 2GB\n        if current[\"vms\"] &gt; 2 * 1024 * 1024 * 1024:  # 2GB threshold\n            suggestions.append(\n                \"Large virtual memory usage. Consider using chunked processing.\"\n            )\n\n        # Return all generated suggestions\n        return suggestions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.get_memory_usage","title":"get_memory_usage","text":"<pre><code>get_memory_usage() -&gt; Dict[str, float]\n</code></pre> <p>Get current memory usage information.</p> <p>This method retrieves current memory usage metrics for the monitored process, including RSS, VMS, and memory percentage.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str, float]: Dictionary containing current memory metrics: - rss: Resident Set Size in bytes (physical memory) - vms: Virtual Memory Size in bytes (total virtual memory) - percent: Memory usage as percentage of system total</p> Example <p>Display current memory usage::</p> <pre><code>&gt;&gt;&gt; usage = monitor.get_memory_usage()\n&gt;&gt;&gt; print(f\"Physical memory: {usage['rss'] / 1024 / 1024:.1f} MB\")\n&gt;&gt;&gt; print(f\"Virtual memory: {usage['vms'] / 1024 / 1024:.1f} MB\")\n&gt;&gt;&gt; print(f\"Memory percent: {usage['percent']:.1f}%\")\n</code></pre> Note <p>RSS (Resident Set Size) is the actual physical memory used by the process. VMS (Virtual Memory Size) includes swapped memory and memory-mapped files. Typically RSS is more relevant for performance analysis.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_usage(self) -&gt; Dict[str, float]:\n    \"\"\"Get current memory usage information.\n\n    This method retrieves current memory usage metrics for the monitored\n    process, including RSS, VMS, and memory percentage.\n\n    Returns:\n        Dict[str, float]: Dictionary containing current memory metrics:\n            - rss: Resident Set Size in bytes (physical memory)\n            - vms: Virtual Memory Size in bytes (total virtual memory)\n            - percent: Memory usage as percentage of system total\n\n    Example:\n        Display current memory usage::\n\n            &gt;&gt;&gt; usage = monitor.get_memory_usage()\n            &gt;&gt;&gt; print(f\"Physical memory: {usage['rss'] / 1024 / 1024:.1f} MB\")\n            &gt;&gt;&gt; print(f\"Virtual memory: {usage['vms'] / 1024 / 1024:.1f} MB\")\n            &gt;&gt;&gt; print(f\"Memory percent: {usage['percent']:.1f}%\")\n\n    Note:\n        RSS (Resident Set Size) is the actual physical memory used by the\n        process. VMS (Virtual Memory Size) includes swapped memory and\n        memory-mapped files. Typically RSS is more relevant for performance\n        analysis.\n    \"\"\"\n    # Get memory info from process\n    memory_info = self.process.memory_info()\n\n    # Return dict with memory metrics\n    return {\n        # Resident Set Size - actual physical memory in bytes\n        \"rss\": float(memory_info.rss),\n        # Virtual Memory Size - total virtual memory in bytes\n        \"vms\": float(memory_info.vms),\n        # Memory usage as percentage of system total\n        \"percent\": self.process.memory_percent(),\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.record_memory_snapshot","title":"record_memory_snapshot","text":"<pre><code>record_memory_snapshot() -&gt; None\n</code></pre> <p>Record current memory usage snapshot.</p> <p>This method captures the current memory state and adds it to the history for trend analysis. Each snapshot includes RSS, VMS, memory percentage, and a timestamp.</p> Example <p>Track memory over time::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; monitor.record_memory_snapshot()  # Before\n&gt;&gt;&gt; process_large_dataset()\n&gt;&gt;&gt; monitor.record_memory_snapshot()  # After\n&gt;&gt;&gt; trend = monitor.get_memory_trend()\n</code></pre> <p>Track multiple operations::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; for i in range(10):\n...     monitor.record_memory_snapshot()\n...     perform_operation(i)\n&gt;&gt;&gt; # Analyze trend across all operations\n&gt;&gt;&gt; trend = monitor.get_memory_trend()\n</code></pre> Note <p>Snapshots are stored in memory, so excessive snapshot recording could itself consume memory. For long-running monitoring, consider periodically clearing old snapshots.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def record_memory_snapshot(self) -&gt; None:\n    \"\"\"Record current memory usage snapshot.\n\n    This method captures the current memory state and adds it to the\n    history for trend analysis. Each snapshot includes RSS, VMS, memory\n    percentage, and a timestamp.\n\n    Example:\n        Track memory over time::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()  # Before\n            &gt;&gt;&gt; process_large_dataset()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()  # After\n            &gt;&gt;&gt; trend = monitor.get_memory_trend()\n\n        Track multiple operations::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; for i in range(10):\n            ...     monitor.record_memory_snapshot()\n            ...     perform_operation(i)\n            &gt;&gt;&gt; # Analyze trend across all operations\n            &gt;&gt;&gt; trend = monitor.get_memory_trend()\n\n    Note:\n        Snapshots are stored in memory, so excessive snapshot recording\n        could itself consume memory. For long-running monitoring, consider\n        periodically clearing old snapshots.\n    \"\"\"\n    # Get current memory usage metrics\n    snapshot = self.get_memory_usage()\n\n    # Add timestamp to snapshot\n    # This allows temporal analysis of memory trends\n    snapshot[\"timestamp\"] = time.time()\n\n    # Append snapshot to history\n    self.memory_history.append(snapshot)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.get_memory_trend","title":"get_memory_trend","text":"<pre><code>get_memory_trend() -&gt; Dict[str, Any]\n</code></pre> <p>Analyze memory usage trend.</p> <p>This method analyzes the memory history to determine whether memory usage is increasing, decreasing, or stable. It compares the most recent snapshot with the oldest snapshot.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing trend analysis: - trend: \"increasing\", \"decreasing\", \"stable\", or   \"insufficient_data\" - rss_change: Change in RSS (bytes). Only if data is sufficient. - vms_change: Change in VMS (bytes). Only if data is sufficient. - current_rss: Current RSS (bytes). Only if data is sufficient. - current_vms: Current VMS (bytes). Only if data is sufficient.</p> Example <p>Analyze memory trend::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; # ... record snapshots over time ...\n&gt;&gt;&gt; trend = monitor.get_memory_trend()\n&gt;&gt;&gt; if trend['trend'] == 'increasing':\n...     mb_increase = trend['rss_change'] / 1024 / 1024\n...     print(f\"Memory increased by {mb_increase:.1f} MB\")\n&gt;&gt;&gt; elif trend['trend'] == 'insufficient_data':\n...     print(\"Need more snapshots for trend analysis\")\n</code></pre> Note <p>Requires at least 2 snapshots for trend analysis. Returns \"insufficient_data\" if fewer than 2 snapshots are recorded.</p> <p>The trend is based on RSS (physical memory) rather than VMS, as RSS is more directly related to actual memory consumption.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_trend(self) -&gt; Dict[str, Any]:\n    \"\"\"Analyze memory usage trend.\n\n    This method analyzes the memory history to determine whether memory\n    usage is increasing, decreasing, or stable. It compares the most\n    recent snapshot with the oldest snapshot.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing trend analysis:\n            - trend: \"increasing\", \"decreasing\", \"stable\", or\n              \"insufficient_data\"\n            - rss_change: Change in RSS (bytes). Only if data is sufficient.\n            - vms_change: Change in VMS (bytes). Only if data is sufficient.\n            - current_rss: Current RSS (bytes). Only if data is sufficient.\n            - current_vms: Current VMS (bytes). Only if data is sufficient.\n\n    Example:\n        Analyze memory trend::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; # ... record snapshots over time ...\n            &gt;&gt;&gt; trend = monitor.get_memory_trend()\n            &gt;&gt;&gt; if trend['trend'] == 'increasing':\n            ...     mb_increase = trend['rss_change'] / 1024 / 1024\n            ...     print(f\"Memory increased by {mb_increase:.1f} MB\")\n            &gt;&gt;&gt; elif trend['trend'] == 'insufficient_data':\n            ...     print(\"Need more snapshots for trend analysis\")\n\n    Note:\n        Requires at least 2 snapshots for trend analysis. Returns\n        \"insufficient_data\" if fewer than 2 snapshots are recorded.\n\n        The trend is based on RSS (physical memory) rather than VMS,\n        as RSS is more directly related to actual memory consumption.\n    \"\"\"\n    # Check if we have enough data for trend analysis\n    # Need at least 2 snapshots to calculate a trend\n    if len(self.memory_history) &lt; 2:\n        return {\"trend\": \"insufficient_data\"}\n\n    # Get most recent and oldest snapshots for comparison\n    recent = self.memory_history[-1]\n    older = self.memory_history[0]\n\n    # Calculate change in memory usage\n    rss_change = recent[\"rss\"] - older[\"rss\"]\n    vms_change = recent[\"vms\"] - older[\"vms\"]\n\n    # Determine trend based on RSS change\n    # RSS is more meaningful than VMS for actual memory usage\n    if rss_change &gt; 0:\n        trend = \"increasing\"\n    elif rss_change &lt; 0:\n        trend = \"decreasing\"\n    else:\n        trend = \"stable\"\n\n    # Return comprehensive trend analysis\n    return {\n        \"trend\": trend,  # Overall trend direction\n        \"rss_change\": rss_change,  # Change in physical memory\n        \"vms_change\": vms_change,  # Change in virtual memory\n        \"current_rss\": recent[\"rss\"],  # Current physical memory\n        \"current_vms\": recent[\"vms\"],  # Current virtual memory\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.suggest_optimizations","title":"suggest_optimizations","text":"<pre><code>suggest_optimizations() -&gt; List[str]\n</code></pre> <p>Suggest memory optimizations based on usage patterns.</p> <p>This method analyzes memory usage history to identify potential issues and provide optimization recommendations. It checks for:     - High memory usage (&gt; 80% of system memory)     - Potential memory leaks (large increasing trend)     - Excessive virtual memory usage (&gt; 2GB)</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of optimization suggestions. Empty list if no issues are detected or no history is available. Each suggestion is a complete sentence describing the issue and recommended action.</p> Example <p>Get and display suggestions::</p> <pre><code>&gt;&gt;&gt; monitor = MemoryMonitor()\n&gt;&gt;&gt; # ... record snapshots over time ...\n&gt;&gt;&gt; suggestions = monitor.suggest_optimizations()\n&gt;&gt;&gt; if suggestions:\n...     print(\"Memory optimization suggestions:\")\n...     for i, suggestion in enumerate(suggestions, 1):\n...         print(f\"{i}. {suggestion}\")\n... else:\n...     print(\"No memory issues detected\")\n</code></pre> Note <p>Suggestions are based on heuristics and thresholds that work well for most applications:     - 80% memory usage threshold     - 100MB RSS increase for leak detection     - 2GB VMS threshold for virtual memory warning</p> <p>You may need to adjust your interpretation based on your specific application's memory requirements.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def suggest_optimizations(self) -&gt; List[str]:\n    \"\"\"Suggest memory optimizations based on usage patterns.\n\n    This method analyzes memory usage history to identify potential\n    issues and provide optimization recommendations. It checks for:\n        - High memory usage (&gt; 80% of system memory)\n        - Potential memory leaks (large increasing trend)\n        - Excessive virtual memory usage (&gt; 2GB)\n\n    Returns:\n        List[str]: List of optimization suggestions. Empty list if\n            no issues are detected or no history is available. Each\n            suggestion is a complete sentence describing the issue\n            and recommended action.\n\n    Example:\n        Get and display suggestions::\n\n            &gt;&gt;&gt; monitor = MemoryMonitor()\n            &gt;&gt;&gt; # ... record snapshots over time ...\n            &gt;&gt;&gt; suggestions = monitor.suggest_optimizations()\n            &gt;&gt;&gt; if suggestions:\n            ...     print(\"Memory optimization suggestions:\")\n            ...     for i, suggestion in enumerate(suggestions, 1):\n            ...         print(f\"{i}. {suggestion}\")\n            ... else:\n            ...     print(\"No memory issues detected\")\n\n    Note:\n        Suggestions are based on heuristics and thresholds that work\n        well for most applications:\n            - 80% memory usage threshold\n            - 100MB RSS increase for leak detection\n            - 2GB VMS threshold for virtual memory warning\n\n        You may need to adjust your interpretation based on your\n        specific application's memory requirements.\n    \"\"\"\n    # Initialize list to store suggestions\n    suggestions: List[str] = []\n\n    # Return empty list if no history is available\n    if not self.memory_history:\n        return suggestions\n\n    # Get most recent snapshot for current state analysis\n    current = self.memory_history[-1]\n\n    # Get trend analysis for leak detection\n    trend = self.get_memory_trend()\n\n    # Check 1: High memory usage detection\n    # Flag if process is using more than 80% of system memory\n    if current[\"percent\"] &gt; 80:\n        suggestions.append(\n            \"High memory usage detected. Consider using memory-efficient \"\n            \"data classes.\"\n        )\n\n    # Check 2: Memory leak detection\n    # Flag if memory is increasing AND increase is significant (&gt; 100MB)\n    if (\n        trend[\"trend\"] == \"increasing\"\n        and trend[\"rss_change\"] &gt; 100 * 1024 * 1024  # 100MB threshold\n    ):\n        suggestions.append(\n            \"Potential memory leak detected. Check for unclosed resources.\"\n        )\n\n    # Check 3: Excessive virtual memory usage\n    # Flag if virtual memory exceeds 2GB\n    if current[\"vms\"] &gt; 2 * 1024 * 1024 * 1024:  # 2GB threshold\n        suggestions.append(\n            \"Large virtual memory usage. Consider using chunked processing.\"\n        )\n\n    # Return all generated suggestions\n    return suggestions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_profiler","title":"get_profiler","text":"<pre><code>get_profiler() -&gt; PerformanceProfiler\n</code></pre> <p>Get the global profiler instance.</p> <p>Returns the singleton global profiler instance that can be used throughout the application for consistent profiling.</p> <p>Returns:</p> Name Type Description <code>PerformanceProfiler</code> <code>PerformanceProfiler</code> <p>The global profiler instance.</p> Example <p>Use global profiler::</p> <pre><code>&gt;&gt;&gt; profiler = get_profiler()\n&gt;&gt;&gt; with profiler.measure_operation(\"operation\"):\n...     perform_operation()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_profiler() -&gt; PerformanceProfiler:\n    \"\"\"Get the global profiler instance.\n\n    Returns the singleton global profiler instance that can be used\n    throughout the application for consistent profiling.\n\n    Returns:\n        PerformanceProfiler: The global profiler instance.\n\n    Example:\n        Use global profiler::\n\n            &gt;&gt;&gt; profiler = get_profiler()\n            &gt;&gt;&gt; with profiler.measure_operation(\"operation\"):\n            ...     perform_operation()\n    \"\"\"\n    return _global_profiler\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_memory_monitor","title":"get_memory_monitor","text":"<pre><code>get_memory_monitor() -&gt; MemoryMonitor\n</code></pre> <p>Get the global memory monitor instance.</p> <p>Returns the singleton global memory monitor instance that can be used throughout the application for consistent memory tracking.</p> <p>Returns:</p> Name Type Description <code>MemoryMonitor</code> <code>MemoryMonitor</code> <p>The global memory monitor instance.</p> Example <p>Use global monitor::</p> <pre><code>&gt;&gt;&gt; monitor = get_memory_monitor()\n&gt;&gt;&gt; monitor.record_memory_snapshot()\n&gt;&gt;&gt; perform_operation()\n&gt;&gt;&gt; monitor.record_memory_snapshot()\n&gt;&gt;&gt; trend = monitor.get_memory_trend()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_monitor() -&gt; MemoryMonitor:\n    \"\"\"Get the global memory monitor instance.\n\n    Returns the singleton global memory monitor instance that can be used\n    throughout the application for consistent memory tracking.\n\n    Returns:\n        MemoryMonitor: The global memory monitor instance.\n\n    Example:\n        Use global monitor::\n\n            &gt;&gt;&gt; monitor = get_memory_monitor()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()\n            &gt;&gt;&gt; perform_operation()\n            &gt;&gt;&gt; monitor.record_memory_snapshot()\n            &gt;&gt;&gt; trend = monitor.get_memory_trend()\n    \"\"\"\n    return _memory_monitor\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.profile_function","title":"profile_function","text":"<pre><code>profile_function(operation_name: str, data_size: Optional[int] = None)\n</code></pre> <p>Convenience decorator for profiling functions using global profiler.</p> <p>This is a convenience wrapper around the global profiler's profile_operation decorator. It allows for easy function profiling without explicitly accessing the global profiler.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name identifier for the operation.</p> required <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <p>Decorator function that profiles the decorated function.</p> Example <p>@profile_function(\"data_transform\", data_size=1000) ... def transform_data(data): ...     return data.apply(transformation)</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def profile_function(operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Convenience decorator for profiling functions using global profiler.\n\n    This is a convenience wrapper around the global profiler's\n    profile_operation decorator. It allows for easy function profiling\n    without explicitly accessing the global profiler.\n\n    Args:\n        operation_name (str): Name identifier for the operation.\n        data_size (Optional[int], optional): Size of data being processed.\n            Defaults to None.\n\n    Returns:\n        Callable: Decorator function that profiles the decorated function.\n\n    Example:\n        &gt;&gt;&gt; @profile_function(\"data_transform\", data_size=1000)\n        ... def transform_data(data):\n        ...     return data.apply(transformation)\n    \"\"\"\n    return _global_profiler.profile_operation(operation_name, data_size)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.profile_operation","title":"profile_operation","text":"<pre><code>profile_operation(operation_name: str, data_size: Optional[int] = None)\n</code></pre> <p>Convenience context manager for profiling using global profiler.</p> <p>This is a convenience wrapper around the global profiler's measure_operation context manager. It allows for easy code block profiling without explicitly accessing the global profiler.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name identifier for the operation.</p> required <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>None</code> <p>Yields control to the measured code block.</p> Example <p>with profile_operation(\"data_processing\", data_size=5000): ...     processed = process_data(raw_data)</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@contextmanager\ndef profile_operation(operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Convenience context manager for profiling using global profiler.\n\n    This is a convenience wrapper around the global profiler's\n    measure_operation context manager. It allows for easy code block\n    profiling without explicitly accessing the global profiler.\n\n    Args:\n        operation_name (str): Name identifier for the operation.\n        data_size (Optional[int], optional): Size of data being processed.\n            Defaults to None.\n\n    Yields:\n        None: Yields control to the measured code block.\n\n    Example:\n        &gt;&gt;&gt; with profile_operation(\"data_processing\", data_size=5000):\n        ...     processed = process_data(raw_data)\n    \"\"\"\n    with _global_profiler.measure_operation(operation_name, data_size):\n        yield\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_performance_summary","title":"get_performance_summary","text":"<pre><code>get_performance_summary() -&gt; Dict[str, Any]\n</code></pre> <p>Get a quick performance summary from global profiler and monitor.</p> <p>This convenience function generates a concise performance summary combining data from both the global profiler and memory monitor. It provides a quick overview of key metrics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing summary metrics: - operations: Total number of profiled operations - total_time: Cumulative execution time in seconds - avg_time: Average execution time per operation in seconds - memory_trend: Current memory usage trend (increasing/decreasing/stable) - current_memory_mb: Current memory usage in megabytes - bottlenecks: Number of identified bottlenecks - recommendations: Number of recommendations generated</p> Example <p>Display quick summary::</p> <pre><code>&gt;&gt;&gt; summary = get_performance_summary()\n&gt;&gt;&gt; print(f\"Operations: {summary['operations']}\")\n&gt;&gt;&gt; print(f\"Total time: {summary['total_time']:.2f}s\")\n&gt;&gt;&gt; print(f\"Average time: {summary['avg_time']:.3f}s\")\n&gt;&gt;&gt; print(f\"Memory: {summary['current_memory_mb']:.1f} MB\")\n&gt;&gt;&gt; print(f\"Trend: {summary['memory_trend']}\")\n&gt;&gt;&gt; print(f\"Bottlenecks: {summary['bottlenecks']}\")\n&gt;&gt;&gt; print(f\"Recommendations: {summary['recommendations']}\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_performance_summary() -&gt; Dict[str, Any]:\n    \"\"\"Get a quick performance summary from global profiler and monitor.\n\n    This convenience function generates a concise performance summary\n    combining data from both the global profiler and memory monitor.\n    It provides a quick overview of key metrics.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing summary metrics:\n            - operations: Total number of profiled operations\n            - total_time: Cumulative execution time in seconds\n            - avg_time: Average execution time per operation in seconds\n            - memory_trend: Current memory usage trend (increasing/decreasing/stable)\n            - current_memory_mb: Current memory usage in megabytes\n            - bottlenecks: Number of identified bottlenecks\n            - recommendations: Number of recommendations generated\n\n    Example:\n        Display quick summary::\n\n            &gt;&gt;&gt; summary = get_performance_summary()\n            &gt;&gt;&gt; print(f\"Operations: {summary['operations']}\")\n            &gt;&gt;&gt; print(f\"Total time: {summary['total_time']:.2f}s\")\n            &gt;&gt;&gt; print(f\"Average time: {summary['avg_time']:.3f}s\")\n            &gt;&gt;&gt; print(f\"Memory: {summary['current_memory_mb']:.1f} MB\")\n            &gt;&gt;&gt; print(f\"Trend: {summary['memory_trend']}\")\n            &gt;&gt;&gt; print(f\"Bottlenecks: {summary['bottlenecks']}\")\n            &gt;&gt;&gt; print(f\"Recommendations: {summary['recommendations']}\")\n    \"\"\"\n    # Generate performance report from global profiler\n    report = _global_profiler.generate_report()\n\n    # Get memory trend from global memory monitor\n    memory_trend = _memory_monitor.get_memory_trend()\n\n    # Compile and return summary metrics\n    return {\n        \"operations\": report.total_operations,\n        \"total_time\": report.total_execution_time,\n        \"avg_time\": report.average_execution_time,\n        \"memory_trend\": memory_trend[\"trend\"],\n        \"current_memory_mb\": memory_trend.get(\"current_rss\", 0) / (1024 * 1024),\n        \"bottlenecks\": len(report.bottlenecks),\n        \"recommendations\": len(report.recommendations),\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html","title":"streamlit_lightweight_charts_pro.utils.serialization","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization","title":"serialization","text":"<p>Serialization utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides base classes and utilities for consistent serialization of Python data structures to frontend-compatible JavaScript dictionary formats. It centralizes the logic for handling naming conventions, nested object serialization, and type-specific transformations required for chart rendering.</p> <p>The serialization system bridges the gap between Python's snake_case naming and JavaScript's camelCase conventions, while also handling type conversions that ensure data is JSON-serializable and frontend-compatible.</p> Key Features <ul> <li>Automatic snake_case to camelCase key conversion</li> <li>Recursive serialization of nested objects and collections</li> <li>Enum value extraction for JavaScript compatibility</li> <li>NaN to zero conversion for JSON compatibility</li> <li>NumPy type conversion to Python native types</li> <li>Configurable filtering of None/empty values</li> <li>Special field flattening for complex options</li> <li>Support for custom field name mappings</li> </ul> Architecture <p>The module provides a mixin-based approach to serialization:</p> <p>SerializableMixin:     The base mixin that provides full serialization capabilities.     Classes inherit this and implement their own asdict() method.</p> <p>SimpleSerializableMixin:     A simplified version with a default asdict() implementation     for classes that don't need customization.</p> <p>SerializationConfig:     Configuration class that controls serialization behavior,     allowing different classes to have different serialization rules.</p> Example <p>Basic serialization with default config::</p> <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import (\n    SerializableMixin\n)\n\n@dataclass\nclass ChartOptions(SerializableMixin):\n    title_text: str\n    is_visible: bool = True\n    background_color: str = \"#FFFFFF\"\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n\noptions = ChartOptions(title_text=\"My Chart\", is_visible=True)\nresult = options.asdict()\n# Returns: {\"titleText\": \"My Chart\", \"isVisible\": True,\n#           \"backgroundColor\": \"#FFFFFF\"}\n</code></pre> <p>Custom serialization config::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.serialization import (\n    SerializationConfig,\n    create_serializable_mixin\n)\n\n# Create custom config that keeps None values\ncustom_config = SerializationConfig(\n    skip_none=False,\n    convert_nan_to_zero=True\n)\n\n# Create a custom mixin with this config\nCustomMixin = create_serializable_mixin(custom_config)\n\n@dataclass\nclass MyData(CustomMixin):\n    value: Optional[int] = None\n\ndata = MyData()\nresult = data.asdict()\n# Returns: {\"value\": None}  # None is kept due to custom config\n</code></pre> <p>Nested object serialization::</p> <pre><code>@dataclass\nclass NestedOptions(SerializableMixin):\n    line_width: int = 2\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n\n@dataclass\nclass ChartConfig(SerializableMixin):\n    title: str\n    nested_options: NestedOptions\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n\nconfig = ChartConfig(\n    title=\"Chart\",\n    nested_options=NestedOptions(line_width=3)\n)\nresult = config.asdict()\n# Returns: {\"title\": \"Chart\", \"nestedOptions\": {\"lineWidth\": 3}}\n</code></pre> Note <p>This module was created to consolidate serialization logic previously scattered across:     - streamlit_lightweight_charts_pro/data/data.py     - streamlit_lightweight_charts_pro/charts/options/base_options.py     - Other classes with custom asdict() implementations</p> <p>By centralizing this logic, we ensure consistent serialization behavior across the entire codebase.</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SerializationConfig","title":"SerializationConfig","text":"<p>Configuration for serialization behavior.</p> <p>This class controls how objects are serialized to dictionaries for frontend consumption. It provides fine-grained control over which values are included, how they're transformed, and how special fields are handled.</p> <p>The configuration allows different classes to have different serialization rules without duplicating code. For example, some classes may want to keep None values while others skip them.</p> <p>Attributes:</p> Name Type Description <code>skip_none</code> <code>bool</code> <p>If True, fields with None values are omitted from serialized output. Reduces payload size for optional fields.</p> <code>skip_empty_strings</code> <code>bool</code> <p>If True, fields with empty string values (\"\") are omitted. Useful for preventing empty labels in charts.</p> <code>skip_empty_dicts</code> <code>bool</code> <p>If True, fields with empty dictionary values ({}) are omitted. Prevents unnecessary nested empty objects.</p> <code>convert_nan_to_zero</code> <code>bool</code> <p>If True, NaN float values are converted to 0.0. Required for JSON compatibility as JSON doesn't support NaN.</p> <code>convert_enums</code> <code>bool</code> <p>If True, Enum instances are converted to their underlying values. JavaScript doesn't understand Python enums.</p> <code>flatten_options_fields</code> <code>bool</code> <p>If True, fields ending in '_options' like 'background_options' have their contents merged into the parent dictionary instead of being nested.</p> Example <p>Create custom config for strict serialization::</p> <pre><code>&gt;&gt;&gt; config = SerializationConfig(\n...     skip_none=False,  # Keep None values\n...     skip_empty_strings=False,  # Keep empty strings\n...     convert_nan_to_zero=False  # Keep NaN as-is\n... )\n</code></pre> <p>Create config for minimal payload::</p> <pre><code>&gt;&gt;&gt; config = SerializationConfig(\n...     skip_none=True,\n...     skip_empty_strings=True,\n...     skip_empty_dicts=True\n... )\n</code></pre> Note <p>The DEFAULT_CONFIG instance uses sensible defaults for most use cases: skip None/empty values, convert NaN to zero, convert enums.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializationConfig:\n    \"\"\"Configuration for serialization behavior.\n\n    This class controls how objects are serialized to dictionaries for\n    frontend consumption. It provides fine-grained control over which\n    values are included, how they're transformed, and how special fields\n    are handled.\n\n    The configuration allows different classes to have different\n    serialization rules without duplicating code. For example, some\n    classes may want to keep None values while others skip them.\n\n    Attributes:\n        skip_none (bool): If True, fields with None values are omitted\n            from serialized output. Reduces payload size for optional fields.\n        skip_empty_strings (bool): If True, fields with empty string values\n            (\"\") are omitted. Useful for preventing empty labels in charts.\n        skip_empty_dicts (bool): If True, fields with empty dictionary values\n            ({}) are omitted. Prevents unnecessary nested empty objects.\n        convert_nan_to_zero (bool): If True, NaN float values are converted\n            to 0.0. Required for JSON compatibility as JSON doesn't support NaN.\n        convert_enums (bool): If True, Enum instances are converted to their\n            underlying values. JavaScript doesn't understand Python enums.\n        flatten_options_fields (bool): If True, fields ending in '_options'\n            like 'background_options' have their contents merged into the\n            parent dictionary instead of being nested.\n\n    Example:\n        Create custom config for strict serialization::\n\n            &gt;&gt;&gt; config = SerializationConfig(\n            ...     skip_none=False,  # Keep None values\n            ...     skip_empty_strings=False,  # Keep empty strings\n            ...     convert_nan_to_zero=False  # Keep NaN as-is\n            ... )\n\n        Create config for minimal payload::\n\n            &gt;&gt;&gt; config = SerializationConfig(\n            ...     skip_none=True,\n            ...     skip_empty_strings=True,\n            ...     skip_empty_dicts=True\n            ... )\n\n    Note:\n        The DEFAULT_CONFIG instance uses sensible defaults for most use\n        cases: skip None/empty values, convert NaN to zero, convert enums.\n    \"\"\"\n\n    def __init__(\n        self,\n        skip_none: bool = True,\n        skip_empty_strings: bool = True,\n        skip_empty_dicts: bool = True,\n        convert_nan_to_zero: bool = True,\n        convert_enums: bool = True,\n        flatten_options_fields: bool = True,\n    ):\n        \"\"\"Initialize serialization configuration.\n\n        Args:\n            skip_none (bool, optional): Whether to skip None values in\n                serialization. Defaults to True. When True, optional fields\n                set to None are omitted from output.\n            skip_empty_strings (bool, optional): Whether to skip empty string\n                values. Defaults to True. When True, fields with \"\" values\n                are omitted.\n            skip_empty_dicts (bool, optional): Whether to skip empty dictionary\n                values. Defaults to True. When True, fields with {} values\n                are omitted.\n            convert_nan_to_zero (bool, optional): Whether to convert NaN float\n                values to 0.0. Defaults to True. Required for JSON compatibility\n                since JSON spec doesn't support NaN.\n            convert_enums (bool, optional): Whether to convert Enum objects to\n                their values. Defaults to True. JavaScript can't understand\n                Python enum types directly.\n            flatten_options_fields (bool, optional): Whether to flatten fields\n                ending in '_options'. Defaults to True. When True, fields like\n                'background_options' have their dict contents merged into parent\n                instead of being nested.\n\n        Example:\n            Default configuration::\n\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; config.skip_none\n                True\n\n            Custom configuration::\n\n                &gt;&gt;&gt; config = SerializationConfig(\n                ...     skip_none=False,\n                ...     convert_nan_to_zero=False\n                ... )\n                &gt;&gt;&gt; config.skip_none\n                False\n        \"\"\"\n        # Store skip_none setting for filtering None values\n        self.skip_none = skip_none\n\n        # Store skip_empty_strings setting for filtering empty strings\n        self.skip_empty_strings = skip_empty_strings\n\n        # Store skip_empty_dicts setting for filtering empty dictionaries\n        self.skip_empty_dicts = skip_empty_dicts\n\n        # Store NaN conversion setting for JSON compatibility\n        self.convert_nan_to_zero = convert_nan_to_zero\n\n        # Store enum conversion setting for JavaScript compatibility\n        self.convert_enums = convert_enums\n\n        # Store field flattening setting for special options handling\n        self.flatten_options_fields = flatten_options_fields\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SerializableMixin","title":"SerializableMixin","text":"<p>Mixin class that provides standardized serialization capabilities.</p> <p>This mixin provides a consistent interface for serializing Python objects to frontend-compatible dictionaries. It handles common transformations including enum conversion, type normalization, and camelCase key conversion.</p> <p>Classes using this mixin should be dataclasses and implement asdict() by calling _serialize_to_dict() with optional custom configuration.</p> The mixin handles the complete serialization pipeline <ol> <li>Iterate through all dataclass fields</li> <li>Apply filtering based on configuration (skip None, empty, etc.)</li> <li>Convert field names (snake_case to camelCase)</li> <li>Transform values (enums to values, NaN to zero, etc.)</li> <li>Recursively serialize nested objects</li> <li>Handle special field flattening rules</li> </ol> Features <ul> <li>Automatic snake_case to camelCase conversion</li> <li>Enum value extraction for JavaScript compatibility</li> <li>NaN to zero conversion for JSON compatibility</li> <li>NumPy type conversion to Python native types</li> <li>Recursive serialization of nested objects</li> <li>Configurable filtering of None/empty values</li> <li>Support for special field names (like 'time' -&gt; ColumnNames.TIME)</li> <li>Field override support for custom transformations</li> </ul> Example <p>Basic usage::</p> <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import (\n    SerializableMixin\n)\n\n@dataclass\nclass ChartConfig(SerializableMixin):\n    title_text: str = \"My Chart\"\n    is_visible: bool = True\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n\nconfig = ChartConfig()\nresult = config.asdict()\n# Returns: {\"titleText\": \"My Chart\", \"isVisible\": True}\n</code></pre> <p>With custom config::</p> <pre><code>@dataclass\nclass StrictConfig(SerializableMixin):\n    value: Optional[int] = None\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        custom_config = SerializationConfig(skip_none=False)\n        return dict(self._serialize_to_dict(custom_config))\n\nconfig = StrictConfig()\nresult = config.asdict()\n# Returns: {\"value\": None}  # None kept due to custom config\n</code></pre> Note <p>This class is designed to work with dataclasses. It uses the dataclasses.fields() function to introspect the class structure. Non-dataclass usage may result in errors.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializableMixin:\n    \"\"\"Mixin class that provides standardized serialization capabilities.\n\n    This mixin provides a consistent interface for serializing Python objects\n    to frontend-compatible dictionaries. It handles common transformations\n    including enum conversion, type normalization, and camelCase key conversion.\n\n    Classes using this mixin should be dataclasses and implement asdict() by\n    calling _serialize_to_dict() with optional custom configuration.\n\n    The mixin handles the complete serialization pipeline:\n        1. Iterate through all dataclass fields\n        2. Apply filtering based on configuration (skip None, empty, etc.)\n        3. Convert field names (snake_case to camelCase)\n        4. Transform values (enums to values, NaN to zero, etc.)\n        5. Recursively serialize nested objects\n        6. Handle special field flattening rules\n\n    Features:\n        - Automatic snake_case to camelCase conversion\n        - Enum value extraction for JavaScript compatibility\n        - NaN to zero conversion for JSON compatibility\n        - NumPy type conversion to Python native types\n        - Recursive serialization of nested objects\n        - Configurable filtering of None/empty values\n        - Support for special field names (like 'time' -&gt; ColumnNames.TIME)\n        - Field override support for custom transformations\n\n    Example:\n        Basic usage::\n\n            from dataclasses import dataclass\n            from streamlit_lightweight_charts_pro.utils.serialization import (\n                SerializableMixin\n            )\n\n            @dataclass\n            class ChartConfig(SerializableMixin):\n                title_text: str = \"My Chart\"\n                is_visible: bool = True\n\n                def asdict(self) -&gt; Dict[str, Any]:\n                    return dict(self._serialize_to_dict())\n\n            config = ChartConfig()\n            result = config.asdict()\n            # Returns: {\"titleText\": \"My Chart\", \"isVisible\": True}\n\n        With custom config::\n\n            @dataclass\n            class StrictConfig(SerializableMixin):\n                value: Optional[int] = None\n\n                def asdict(self) -&gt; Dict[str, Any]:\n                    custom_config = SerializationConfig(skip_none=False)\n                    return dict(self._serialize_to_dict(custom_config))\n\n            config = StrictConfig()\n            result = config.asdict()\n            # Returns: {\"value\": None}  # None kept due to custom config\n\n    Note:\n        This class is designed to work with dataclasses. It uses the\n        dataclasses.fields() function to introspect the class structure.\n        Non-dataclass usage may result in errors.\n    \"\"\"\n\n    def _serialize_to_dict(\n        self,\n        config: SerializationConfig = DEFAULT_CONFIG,\n        override_fields: dict[str, Any] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize the object to a dictionary with camelCase keys.\n\n        This method provides the core serialization logic that handles\n        type conversion, key transformation, and field filtering. It's\n        designed to be called by subclasses' asdict() implementations.\n\n        The serialization process follows these steps:\n            1. Initialize result dictionary and process field overrides\n            2. Iterate through all dataclass fields\n            3. Get field value (from override dict or instance attribute)\n            4. Apply filtering based on config (skip None, empty, etc.)\n            5. Process value (convert types, serialize nested objects)\n            6. Process field name (snake_case to camelCase)\n            7. Handle special flattening for '_options' fields\n            8. Add processed key-value pair to result\n\n        Args:\n            config (SerializationConfig, optional): Configuration instance\n                controlling serialization behavior. Defaults to DEFAULT_CONFIG\n                which provides sensible defaults for most cases.\n            override_fields (dict[str, Any] | None, optional): Dictionary of\n                field overrides. Values in this dict replace computed values\n                during serialization. Useful for custom transformations on\n                specific fields. Defaults to None.\n\n        Returns:\n            dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption. The dictionary is fully JSON-serializable\n                and compatible with JavaScript naming conventions.\n\n        Example:\n            Basic serialization::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Document(SerializableMixin):\n                ...     title: str = \"Test\"\n                ...     page_count: int = 42\n                ...     notes: str = \"\"\n                ...\n                ...     def asdict(self) -&gt; Dict[str, Any]:\n                ...         return dict(self._serialize_to_dict())\n                &gt;&gt;&gt; data = Document()\n                &gt;&gt;&gt; result = data._serialize_to_dict()\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 42}  # notes skipped (empty)\n\n            Custom config::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_strings=False)\n                &gt;&gt;&gt; result = data._serialize_to_dict(config)\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 42, \"notes\": \"\"}\n\n            With field overrides::\n\n                &gt;&gt;&gt; overrides = {\"page_count\": 100}\n                &gt;&gt;&gt; result = data._serialize_to_dict(\n                ...     override_fields=overrides\n                ... )\n                &gt;&gt;&gt; print(result)\n                {\"title\": \"Test\", \"pageCount\": 100}\n\n        Note:\n            This method must be called on a dataclass instance. It uses\n            dataclasses.fields() to introspect the object structure.\n        \"\"\"\n        # Step 1: Initialize result dictionary that will hold serialized data\n        result: dict[str, Any] = {}\n\n        # Initialize override_fields to empty dict if not provided\n        # This allows us to use .get() without None checks\n        override_fields = override_fields or {}\n\n        # Step 2: Iterate through all dataclass fields\n        # fields() returns a tuple of Field objects representing each field\n        # Cast self to Any to satisfy mypy - SerializableMixin is always\n        # used with dataclasses but mypy can't infer this\n        for field in fields(self):  # type: ignore[arg-type]\n            # Extract the field name (e.g., \"title_text\", \"is_visible\")\n            field_name = field.name\n\n            # Step 3: Get field value (use override if provided, otherwise\n            # get from instance)\n            # Overrides allow callers to customize specific field values\n            # during serialization without modifying the object\n            value = override_fields.get(field_name, getattr(self, field_name))\n\n            # Step 4: Apply config-based filtering\n            # Check if this value should be included based on config rules\n            # (skip None, skip empty strings, skip empty dicts)\n            if not self._should_include_value(value, config):\n                # Value should be skipped, move to next field\n                continue\n\n            # Step 5: Process value for serialization\n            # This handles type conversions:\n            # - NaN -&gt; 0.0\n            # - Enum -&gt; enum.value\n            # - NumPy types -&gt; Python types\n            # - Nested objects -&gt; recursive serialization\n            processed_value = self._process_value_for_serialization(\n                value, config\n            )\n\n            # Step 6: Process field name for serialization\n            # Convert snake_case to camelCase and handle special fields\n            # like 'time' and 'value'\n            processed_field = self._process_field_name_for_serialization(\n                field_name, config\n            )\n\n            # Step 7: Handle special flattening rules\n            # Some fields like 'background_options' should have their\n            # contents merged into the parent dict instead of being nested\n            if (\n                config.flatten_options_fields\n                and field_name.endswith(\"_options\")\n                and isinstance(processed_value, dict)\n                and field_name == \"background_options\"  # Only flatten specific\n            ):\n                # Merge flattened fields directly into result dictionary\n                # This converts {\"background_options\": {\"color\": \"red\"}}\n                # to {\"color\": \"red\"} in the output\n                result.update(processed_value)\n            else:\n                # Normal field: add as key-value pair in result\n                result[processed_field] = processed_value\n\n        # Step 8: Return the fully processed dictionary\n        # This dictionary is ready for JSON serialization and frontend use\n        return result\n\n    def _should_include_value(\n        self, value: Any, config: SerializationConfig\n    ) -&gt; bool:\n        \"\"\"Determine if a value should be included in serialized output.\n\n        This method applies filtering rules based on the configuration to\n        decide whether a field value should be included in the serialized\n        dictionary. It helps reduce payload size by omitting unwanted values.\n\n        The checks are performed in order:\n            1. Check if value is None and should be skipped\n            2. Check if value is empty string and should be skipped\n            3. Check if value is empty dict and should be skipped\n\n        Args:\n            value (Any): The value to check. Can be any Python type.\n            config (SerializationConfig): Serialization configuration that\n                controls which values should be filtered out.\n\n        Returns:\n            bool: True if the value should be included in the serialized\n                output, False if it should be omitted.\n\n        Example:\n            Check None values::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_none=True)\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; mixin._should_include_value(None, config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value(\"text\", config)\n                True\n\n            Check empty strings::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_strings=True)\n                &gt;&gt;&gt; mixin._should_include_value(\"\", config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value(\"hello\", config)\n                True\n\n            Check empty dicts::\n\n                &gt;&gt;&gt; config = SerializationConfig(skip_empty_dicts=True)\n                &gt;&gt;&gt; mixin._should_include_value({}, config)\n                False\n                &gt;&gt;&gt; mixin._should_include_value({\"key\": \"value\"}, config)\n                True\n\n        Note:\n            This method doesn't check type validity or perform conversions.\n            It only determines inclusion based on the filtering rules.\n        \"\"\"\n        # Check 1: Skip None values if configured\n        # None values typically represent unset optional fields\n        # Omitting them reduces payload size without losing information\n        if value is None and config.skip_none:\n            return False\n\n        # Check 2: Skip empty strings if configured\n        # Empty strings can clutter the output and provide no value\n        # to the frontend\n        if value == \"\" and config.skip_empty_strings:\n            return False\n\n        # Check 3: Skip empty dictionaries if configured\n        # Returns True if value is not an empty dict, or if we should\n        # keep empty dicts\n        # Empty dicts create unnecessary nesting in the output\n        return not (value == {} and config.skip_empty_dicts)\n\n    def _process_value_for_serialization(\n        self,\n        value: Any,\n        config: SerializationConfig,\n    ) -&gt; Any:\n        \"\"\"Process a value during serialization with type-specific conversions.\n\n        This method handles all value transformations needed to make Python\n        objects compatible with JavaScript/JSON. It processes values\n        recursively, handling nested objects, collections, and special types.\n\n        The processing pipeline:\n            1. Convert NaN floats to zero for JSON compatibility\n            2. Convert NumPy scalar types to Python native types\n            3. Extract enum values for JavaScript compatibility\n            4. Recursively serialize nested SerializableMixin objects\n            5. Recursively process lists\n            6. Recursively process dictionaries with key conversion\n            7. Return processed value\n\n        Args:\n            value (Any): The value to process. Can be any Python type.\n            config (SerializationConfig): Configuration controlling the\n                conversion behavior.\n\n        Returns:\n            Any: The processed value ready for JSON serialization. The value\n                will be JSON-compatible and use JavaScript naming conventions.\n\n        Example:\n            NaN conversion::\n\n                &gt;&gt;&gt; import math\n                &gt;&gt;&gt; config = SerializationConfig(convert_nan_to_zero=True)\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; mixin._process_value_for_serialization(math.nan, config)\n                0.0\n\n            Enum conversion::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Color(Enum):\n                ...     RED = \"red\"\n                &gt;&gt;&gt; config = SerializationConfig(convert_enums=True)\n                &gt;&gt;&gt; mixin._process_value_for_serialization(Color.RED, config)\n                'red'\n\n            Nested object serialization::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Inner(SerializableMixin):\n                ...     value: int = 42\n                ...     def asdict(self):\n                ...         return {\"value\": self.value}\n                &gt;&gt;&gt; inner = Inner()\n                &gt;&gt;&gt; mixin._process_value_for_serialization(inner, config)\n                {'value': 42}\n\n        Note:\n            This method is recursive and will process deeply nested structures.\n            Circular references will cause infinite recursion.\n        \"\"\"\n        # Step 1: Handle NaN floats - convert to zero for JSON compatibility\n        # JSON spec doesn't support NaN, Infinity, or -Infinity\n        # JavaScript charts typically treat NaN as zero anyway\n        if (\n            isinstance(value, float)\n            and math.isnan(value)\n            and config.convert_nan_to_zero\n        ):\n            return 0.0\n\n        # Step 2: Convert NumPy scalar types to Python native types\n        # NumPy types like np.int64, np.float32 aren't JSON-serializable\n        # The .item() method extracts the Python scalar value\n        if hasattr(value, \"item\"):  # NumPy scalar types have .item() method\n            value = value.item()\n\n        # Step 3: Convert enums to their values\n        # JavaScript doesn't understand Python enum types\n        # Extract the underlying value (string, int, etc.)\n        if config.convert_enums and isinstance(value, Enum):\n            value = value.value\n\n        # Step 4: Handle nested serializable objects\n        # Objects with asdict() method are serialized recursively\n        # This enables deep serialization of complex object hierarchies\n        if hasattr(value, \"asdict\") and callable(value.asdict):\n            value = value.asdict()\n\n        # Step 5: Handle serializable lists recursively\n        # Lists may contain nested objects that also need serialization\n        elif isinstance(value, list):\n            return self._serialize_list_recursively(value, config)\n\n        # Step 6: Handle nested dictionaries recursively\n        # Dictionaries need key conversion (snake_case to camelCase)\n        # and recursive value processing\n        elif isinstance(value, dict):\n            return self._serialize_dict_recursively(value, config)\n\n        # Step 7: Return the processed value\n        # At this point, the value has been fully processed and is\n        # ready for JSON serialization\n        return value\n\n    def _serialize_list_recursively(\n        self,\n        items: list[Any],\n        config: SerializationConfig,\n    ) -&gt; list[Any]:\n        \"\"\"Serialize a list recursively.\n\n        This method processes each item in a list, applying the same\n        serialization logic as the parent object. It ensures that nested\n        objects, enums, and special types within lists are properly\n        converted for frontend consumption.\n\n        Args:\n            items (list[Any]): List of items to serialize. Items can be\n                any Python type including nested objects, primitives,\n                enums, dicts, or other lists.\n            config (SerializationConfig): Configuration controlling the\n                serialization behavior for each item.\n\n        Returns:\n            list[Any]: Recursively serialized list with all items processed\n                according to the configuration. The list is ready for JSON\n                serialization.\n\n        Example:\n            List of primitives::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; mixin._serialize_list_recursively([1, 2, 3], config)\n                [1, 2, 3]\n\n            List with enums::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Status(Enum):\n                ...     ACTIVE = \"active\"\n                ...     INACTIVE = \"inactive\"\n                &gt;&gt;&gt; items = [Status.ACTIVE, Status.INACTIVE]\n                &gt;&gt;&gt; mixin._serialize_list_recursively(items, config)\n                ['active', 'inactive']\n\n            List with nested objects::\n\n                &gt;&gt;&gt; @dataclass\n                ... class Point(SerializableMixin):\n                ...     x: int\n                ...     y: int\n                ...     def asdict(self):\n                ...         return {\"x\": self.x, \"y\": self.y}\n                &gt;&gt;&gt; items = [Point(1, 2), Point(3, 4)]\n                &gt;&gt;&gt; mixin._serialize_list_recursively(items, config)\n                [{'x': 1, 'y': 2}, {'x': 3, 'y': 4}]\n\n        Note:\n            This method is recursive and will process deeply nested lists.\n            Circular references will cause infinite recursion.\n        \"\"\"\n        # Initialize result list to hold processed items\n        processed_items = []\n\n        # Iterate through each item in the input list\n        for item in items:\n            # Process each item using the same serialization logic\n            # This ensures consistency between top-level and nested values\n            # Handles: enums, nested objects, dicts, other lists, etc.\n            processed_item = self._process_value_for_serialization(\n                item, config\n            )\n\n            # Add the processed item to result list\n            processed_items.append(processed_item)\n\n        # Return the fully processed list\n        return processed_items\n\n    def _serialize_dict_recursively(\n        self,\n        data: dict[str, Any],\n        config: SerializationConfig,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize a dictionary recursively with key conversion.\n\n        This method processes dictionaries by converting keys from snake_case\n        to camelCase and recursively serializing values. It ensures that\n        nested dictionaries follow JavaScript naming conventions.\n\n        Args:\n            data (dict[str, Any]): Dictionary to serialize. Keys should be\n                strings (typically in snake_case), values can be any type.\n            config (SerializationConfig): Configuration controlling the\n                serialization behavior for values.\n\n        Returns:\n            dict[str, Any]: Recursively processed dictionary with camelCase\n                keys and serialized values. Ready for JSON serialization.\n\n        Example:\n            Simple dict with snake_case keys::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; data = {\"first_name\": \"John\", \"last_name\": \"Doe\"}\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'firstName': 'John', 'lastName': 'Doe'}\n\n            Nested dict::\n\n                &gt;&gt;&gt; data = {\n                ...     \"user_info\": {\n                ...         \"first_name\": \"John\",\n                ...         \"age_years\": 30\n                ...     }\n                ... }\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'userInfo': {'firstName': 'John', 'ageYears': 30}}\n\n            Dict with enum values::\n\n                &gt;&gt;&gt; from enum import Enum\n                &gt;&gt;&gt; class Status(Enum):\n                ...     ACTIVE = \"active\"\n                &gt;&gt;&gt; data = {\"user_status\": Status.ACTIVE}\n                &gt;&gt;&gt; mixin._serialize_dict_recursively(data, config)\n                {'userStatus': 'active'}\n\n        Note:\n            Non-string keys are converted to strings before camelCase\n            conversion. This ensures consistent behavior with JavaScript\n            object keys which are always strings.\n        \"\"\"\n        # Initialize result dictionary to hold processed key-value pairs\n        result = {}\n\n        # Iterate through each key-value pair in the input dictionary\n        for key, value in data.items():\n            # Step 1: Convert key to camelCase for JavaScript compatibility\n            # JavaScript conventionally uses camelCase for object keys\n            # If key is not a string, convert it to string first\n            # (JavaScript object keys are always strings)\n            processed_key = (\n                snake_to_camel(key) if isinstance(key, str) else str(key)\n            )\n\n            # Step 2: Process value recursively\n            # Apply the full serialization pipeline to the value\n            # This handles nested objects, enums, lists, dicts, etc.\n            processed_value = self._process_value_for_serialization(\n                value, config\n            )\n\n            # Step 3: Add processed key-value pair to result dictionary\n            result[processed_key] = processed_value\n\n        # Return the fully processed dictionary\n        return result\n\n    def _process_field_name_for_serialization(\n        self,\n        field_name: str,\n        _config: SerializationConfig,\n    ) -&gt; str:\n        \"\"\"Process field name for serialization with special handling.\n\n        This method converts field names from Python's snake_case convention\n        to JavaScript's camelCase convention. It also handles special field\n        names that need to map to specific constants for frontend compatibility.\n\n        Special field handling:\n            - 'time' -&gt; Maps to ColumnNames.TIME enum value\n            - 'value' -&gt; Maps to ColumnNames.VALUE enum value\n            - All other fields -&gt; Standard snake_case to camelCase conversion\n\n        Args:\n            field_name (str): Original Python field name in snake_case\n                (e.g., \"title_text\", \"is_visible\").\n            _config (SerializationConfig): Serialization configuration\n                (currently unused but kept for interface consistency).\n\n        Returns:\n            str: Processed field name in camelCase or special constant value.\n                Ready for use as JavaScript object key.\n\n        Example:\n            Regular field conversion::\n\n                &gt;&gt;&gt; mixin = SerializableMixin()\n                &gt;&gt;&gt; config = SerializationConfig()\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\n                ...     \"title_text\", config\n                ... )\n                'titleText'\n\n            Special field handling::\n\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\"time\", config)\n                'time'  # Maps to ColumnNames.TIME.value\n\n                &gt;&gt;&gt; mixin._process_field_name_for_serialization(\"value\", config)\n                'value'  # Maps to ColumnNames.VALUE.value\n\n        Note:\n            The function imports ColumnNames dynamically to avoid circular\n            import issues. If the import fails, it falls back to standard\n            camelCase conversion.\n        \"\"\"\n        # Special handling for known column names to match frontend expectations\n        # These special cases ensure consistent naming with the JavaScript chart\n        # library which expects specific field names for time and value data\n\n        if field_name == \"time\":\n            # Case 1: \"time\" field - use ColumnNames enum for consistency\n            # The \"time\" field is critical for chart data and must match\n            # exactly what the JavaScript library expects\n            try:\n                # Import inside function to avoid circular import issues\n                # The enum module may depend on this serialization module\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                    ColumnNames,\n                )\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                # This ensures serialization still works even if enums\n                # module isn't available (e.g., during testing)\n                return snake_to_camel(field_name)\n            else:\n                # Return the canonical time field name from enum\n                return ColumnNames.TIME.value\n\n        elif field_name == \"value\":\n            # Case 2: \"value\" field - use ColumnNames enum for consistency\n            # The \"value\" field is used for chart data points and must\n            # match the JavaScript library's expectations\n            try:\n                # Import inside function to avoid circular import issues\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                    ColumnNames,\n                )\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                return snake_to_camel(field_name)\n            else:\n                # Return the canonical value field name from enum\n                return ColumnNames.VALUE.value\n\n        else:\n            # Case 3: Regular field - convert snake_case to camelCase\n            # This is the standard conversion for most fields\n            # Examples: title_text -&gt; titleText, is_visible -&gt; isVisible\n            return snake_to_camel(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin","title":"SimpleSerializableMixin","text":"<p>Simplified mixin for basic classes that need basic serialization.</p> <p>This variant provides a more straightforward serialization approach for simple data classes that don't need complex nested serialization or special field handling. It implements a default asdict() method that uses DEFAULT_CONFIG, saving boilerplate code in simple classes.</p> Use this when <ul> <li>Your class has simple fields (strings, ints, bools)</li> <li>You don't need custom serialization config</li> <li>You don't need special field transformations</li> <li>Default filtering rules (skip None, empty strings) are acceptable</li> </ul> Example <p>Simple data class::</p> <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import (\n    SimpleSerializableMixin\n)\n\n@dataclass\nclass ChartTitle(SimpleSerializableMixin):\n    text: str\n    font_size: int = 14\n    is_visible: bool = True\n\ntitle = ChartTitle(text=\"My Chart\")\nresult = title.asdict()\n# Returns: {\"text\": \"My Chart\", \"fontSize\": 14, \"isVisible\": True}\n</code></pre> Note <p>If you need custom serialization config or field overrides, inherit from SerializableMixin instead and implement your own asdict() method.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SimpleSerializableMixin(SerializableMixin):\n    \"\"\"Simplified mixin for basic classes that need basic serialization.\n\n    This variant provides a more straightforward serialization approach\n    for simple data classes that don't need complex nested serialization\n    or special field handling. It implements a default asdict() method\n    that uses DEFAULT_CONFIG, saving boilerplate code in simple classes.\n\n    Use this when:\n        - Your class has simple fields (strings, ints, bools)\n        - You don't need custom serialization config\n        - You don't need special field transformations\n        - Default filtering rules (skip None, empty strings) are acceptable\n\n    Example:\n        Simple data class::\n\n            from dataclasses import dataclass\n            from streamlit_lightweight_charts_pro.utils.serialization import (\n                SimpleSerializableMixin\n            )\n\n            @dataclass\n            class ChartTitle(SimpleSerializableMixin):\n                text: str\n                font_size: int = 14\n                is_visible: bool = True\n\n            title = ChartTitle(text=\"My Chart\")\n            result = title.asdict()\n            # Returns: {\"text\": \"My Chart\", \"fontSize\": 14, \"isVisible\": True}\n\n    Note:\n        If you need custom serialization config or field overrides,\n        inherit from SerializableMixin instead and implement your own\n        asdict() method.\n    \"\"\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n        This method provides a default implementation that uses the\n        DEFAULT_CONFIG for serialization. It's suitable for most simple\n        classes that don't need special handling.\n\n        Returns:\n            dict[str, Any]: Serialized representation with camelCase keys,\n                filtered according to DEFAULT_CONFIG rules (skip None,\n                empty strings, empty dicts).\n\n        Example:\n            &gt;&gt;&gt; @dataclass\n            ... class Point(SimpleSerializableMixin):\n            ...     x_coord: int\n            ...     y_coord: int\n            &gt;&gt;&gt; point = Point(x_coord=10, y_coord=20)\n            &gt;&gt;&gt; point.asdict()\n            {'xCoord': 10, 'yCoord': 20}\n        \"\"\"\n        # Use the base class _serialize_to_dict with DEFAULT_CONFIG\n        # This applies standard serialization rules without customization\n        return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[str, Any]\n</code></pre> <p>Serialize to dictionary with basic camelCase conversion.</p> <p>This method provides a default implementation that uses the DEFAULT_CONFIG for serialization. It's suitable for most simple classes that don't need special handling.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Serialized representation with camelCase keys, filtered according to DEFAULT_CONFIG rules (skip None, empty strings, empty dicts).</p> Example <p>@dataclass ... class Point(SimpleSerializableMixin): ...     x_coord: int ...     y_coord: int point = Point(x_coord=10, y_coord=20) point.asdict()</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n    This method provides a default implementation that uses the\n    DEFAULT_CONFIG for serialization. It's suitable for most simple\n    classes that don't need special handling.\n\n    Returns:\n        dict[str, Any]: Serialized representation with camelCase keys,\n            filtered according to DEFAULT_CONFIG rules (skip None,\n            empty strings, empty dicts).\n\n    Example:\n        &gt;&gt;&gt; @dataclass\n        ... class Point(SimpleSerializableMixin):\n        ...     x_coord: int\n        ...     y_coord: int\n        &gt;&gt;&gt; point = Point(x_coord=10, y_coord=20)\n        &gt;&gt;&gt; point.asdict()\n        {'xCoord': 10, 'yCoord': 20}\n    \"\"\"\n    # Use the base class _serialize_to_dict with DEFAULT_CONFIG\n    # This applies standard serialization rules without customization\n    return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.create_serializable_mixin","title":"create_serializable_mixin","text":"<pre><code>create_serializable_mixin(config_override: SerializationConfig | None = None) -&gt; type\n</code></pre> <p>Factory function to create a configurable SerializableMixin.</p> <p>This factory allows you to create custom mixin classes with specific serialization configurations. It's useful when different parts of your codebase need different serialization rules.</p> <p>Instead of passing config to every asdict() call, you can create a custom mixin class that encapsulates the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_override</code> <code>SerializationConfig | None</code> <p>Custom serialization configuration. If None, uses DEFAULT_CONFIG. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>type</code> <code>type</code> <p>A custom SerializableMixin class with the specified configuration. This class can be used as a base for dataclasses.</p> Example <p>Create mixin that keeps None values::</p> <pre><code>from streamlit_lightweight_charts_pro.utils.serialization import (\n    SerializationConfig,\n    create_serializable_mixin\n)\n\n# Create config that keeps None values\nstrict_config = SerializationConfig(skip_none=False)\n\n# Create custom mixin with this config\nStrictMixin = create_serializable_mixin(strict_config)\n\n# Use the custom mixin\n@dataclass\nclass MyData(StrictMixin):\n    value: Optional[int] = None\n\ndata = MyData()\nresult = data.asdict()\n# Returns: {\"value\": None}  # None is kept\n</code></pre> <p>Create mixin for minimal payloads::</p> <pre><code># Create config that aggressively filters\nminimal_config = SerializationConfig(\n    skip_none=True,\n    skip_empty_strings=True,\n    skip_empty_dicts=True\n)\n\nMinimalMixin = create_serializable_mixin(minimal_config)\n\n@dataclass\nclass ChartData(MinimalMixin):\n    title: str = \"\"\n    value: Optional[int] = None\n\ndata = ChartData()\nresult = data.asdict()\n# Returns: {}  # Both fields filtered out\n</code></pre> Note <p>The returned mixin class is a dynamic type created at runtime. It inherits from SerializableMixin and overrides the configuration behavior.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>def create_serializable_mixin(\n    config_override: SerializationConfig | None = None,\n) -&gt; type:\n    \"\"\"Factory function to create a configurable SerializableMixin.\n\n    This factory allows you to create custom mixin classes with specific\n    serialization configurations. It's useful when different parts of your\n    codebase need different serialization rules.\n\n    Instead of passing config to every asdict() call, you can create a\n    custom mixin class that encapsulates the configuration.\n\n    Args:\n        config_override (SerializationConfig | None, optional): Custom\n            serialization configuration. If None, uses DEFAULT_CONFIG.\n            Defaults to None.\n\n    Returns:\n        type: A custom SerializableMixin class with the specified\n            configuration. This class can be used as a base for dataclasses.\n\n    Example:\n        Create mixin that keeps None values::\n\n            from streamlit_lightweight_charts_pro.utils.serialization import (\n                SerializationConfig,\n                create_serializable_mixin\n            )\n\n            # Create config that keeps None values\n            strict_config = SerializationConfig(skip_none=False)\n\n            # Create custom mixin with this config\n            StrictMixin = create_serializable_mixin(strict_config)\n\n            # Use the custom mixin\n            @dataclass\n            class MyData(StrictMixin):\n                value: Optional[int] = None\n\n            data = MyData()\n            result = data.asdict()\n            # Returns: {\"value\": None}  # None is kept\n\n        Create mixin for minimal payloads::\n\n            # Create config that aggressively filters\n            minimal_config = SerializationConfig(\n                skip_none=True,\n                skip_empty_strings=True,\n                skip_empty_dicts=True\n            )\n\n            MinimalMixin = create_serializable_mixin(minimal_config)\n\n            @dataclass\n            class ChartData(MinimalMixin):\n                title: str = \"\"\n                value: Optional[int] = None\n\n            data = ChartData()\n            result = data.asdict()\n            # Returns: {}  # Both fields filtered out\n\n    Note:\n        The returned mixin class is a dynamic type created at runtime.\n        It inherits from SerializableMixin and overrides the configuration\n        behavior.\n    \"\"\"\n    # Use provided config or fall back to default configuration\n    # This allows None to mean \"use defaults\" rather than requiring\n    # explicit DEFAULT_CONFIG argument\n    config = config_override or DEFAULT_CONFIG\n\n    # Define a new mixin class that uses the specified configuration\n    class ConfigurableSerializableMixin(SerializableMixin):\n        \"\"\"Configurable serialization mixin with custom config.\n\n        This class provides a SerializableMixin variant with custom\n        serialization configuration. It's useful when different classes\n        need different serialization behaviors (e.g., some skip None,\n        others don't).\n\n        This class is dynamically created by create_serializable_mixin()\n        and encapsulates the provided configuration.\n\n        Attributes:\n            config: The SerializationConfig instance to use for this mixin.\n                This is captured from the factory function's closure.\n        \"\"\"\n\n        def _get_serialization_config(self) -&gt; SerializationConfig:\n            \"\"\"Get the serialization configuration for this mixin.\n\n            Returns:\n                SerializationConfig: The configuration instance captured\n                    from the factory function.\n            \"\"\"\n            # Return the config from the enclosing scope\n            # This provides access to the factory function's config parameter\n            return config\n\n        def asdict(self) -&gt; dict[str, Any]:\n            \"\"\"Serialize to dictionary using the custom configuration.\n\n            This method overrides the base implementation to use the\n            configuration specified when the mixin class was created.\n\n            Returns:\n                dict[str, Any]: Serialized representation with custom\n                    configuration applied.\n            \"\"\"\n            # Use the custom config from _get_serialization_config()\n            # This ensures all serialization uses the factory-specified rules\n            return self._serialize_to_dict(self._get_serialization_config())\n\n    # Return the dynamically created mixin class\n    # Callers can use this as a base class for their dataclasses\n    return ConfigurableSerializableMixin\n</code></pre>"},{"location":"examples/overview.html","title":"Examples","text":"<p>Explore various chart types and configurations with these examples.</p>"},{"location":"examples/overview.html#chart-types","title":"Chart Types","text":"<ul> <li>Line Charts - Basic line charts with customization</li> <li>Candlestick Charts - OHLC candlestick charts</li> <li>Area Charts - Filled area charts</li> <li>Histogram Charts - Volume and distribution charts</li> </ul>"},{"location":"examples/overview.html#advanced-features","title":"Advanced Features","text":"<ul> <li>Multi-Pane Charts - Multiple chart panes</li> <li>Custom Styling - Advanced styling options</li> <li>Real-time Data - Live data updates</li> </ul>"},{"location":"examples/overview.html#integration-examples","title":"Integration Examples","text":"<ul> <li>Pandas Integration - Working with DataFrames</li> <li>Streamlit Widgets - Interactive controls</li> <li>Performance Optimization - Large dataset handling</li> </ul>"},{"location":"getting-started/basic-usage.html","title":"Basic Usage","text":"<p>Learn how to create your first chart with Streamlit Lightweight Charts Pro.</p>"},{"location":"getting-started/basic-usage.html#simple-line-chart","title":"Simple Line Chart","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Sample data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 103),\n    SingleValueData(\"2024-01-04\", 108),\n]\n\n# Create chart\nchart = Chart(series=LineSeries(data))\nchart.render(key=\"line_chart\")\n</code></pre>"},{"location":"getting-started/basic-usage.html#candlestick-chart","title":"Candlestick Chart","text":"<pre><code>from streamlit_lightweight_charts_pro import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# OHLC data\ncandle_data = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 107),\n]\n\nchart = Chart(series=CandlestickSeries(candle_data))\nchart.render(key=\"candlestick_chart\")\n</code></pre>"},{"location":"getting-started/basic-usage.html#multiple-series","title":"Multiple Series","text":"<pre><code>from streamlit_lightweight_charts_pro import AreaSeries\n\n# Create multiple series\nline_series = LineSeries(data, color=\"#2196F3\")\narea_series = AreaSeries(data, color=\"#4CAF50\")\n\nchart = Chart(series=[line_series, area_series])\nchart.render(key=\"multi_series_chart\")\n</code></pre>"},{"location":"getting-started/installation.html","title":"Installation","text":"<p>Install Streamlit Lightweight Charts Pro using pip:</p> <pre><code>pip install streamlit-lightweight-charts-pro\n</code></pre>"},{"location":"getting-started/installation.html#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> <li>Streamlit 1.0+</li> <li>Node.js 16+ (for development)</li> </ul>"},{"location":"getting-started/installation.html#development-installation","title":"Development Installation","text":"<p>For development or to contribute:</p> <pre><code>git clone https://github.com/nandkapadia/streamlit-lightweight-charts-pro.git\ncd streamlit-lightweight-charts-pro\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation.html#verify-installation","title":"Verify Installation","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart\n\nst.write(\"Installation successful!\")\n</code></pre>"}]}