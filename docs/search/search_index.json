{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Streamlit Lightweight Charts Pro","text":"<p>Professional-grade financial charting library for Streamlit that wraps TradingView's lightweight-charts with a fluent Python API.</p>"},{"location":"index.html#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create sample data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 103),\n]\n\n# Create and render chart\nchart = Chart(series=LineSeries(data))\nchart.render(key=\"my_chart\")\n</code></pre>"},{"location":"index.html#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Getting Started - Installation and basic usage</li> <li>Examples - Code examples and tutorials</li> </ul>"},{"location":"index.html#features","title":"\u2728 Features","text":"<ul> <li>Professional Charts - Line, candlestick, area, histogram, and more</li> <li>Fluent API - Method chaining for easy configuration</li> <li>Type Safety - Full type hints and validation</li> <li>Performance - Optimized for large datasets</li> <li>Customizable - Extensive styling and behavior options</li> </ul>"},{"location":"index.html#links","title":"\ud83d\udd17 Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issues &amp; Support</li> </ul>"},{"location":"api/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>streamlit_lightweight_charts_pro<ul> <li>charts<ul> <li>chart</li> <li>chart_manager</li> <li>options<ul> <li>base_options</li> <li>chart_options</li> <li>interaction_options</li> <li>layout_options</li> <li>line_options</li> <li>localization_options</li> <li>price_format_options</li> <li>price_line_options</li> <li>price_scale_options</li> <li>sync_options</li> <li>time_scale_options</li> <li>trade_visualization_options</li> <li>ui_options</li> </ul> </li> <li>series<ul> <li>area</li> <li>band</li> <li>bar_series</li> <li>base</li> <li>baseline</li> <li>candlestick</li> <li>gradient_ribbon</li> <li>histogram</li> <li>line</li> <li>ribbon</li> <li>signal_series</li> <li>trend_fill</li> </ul> </li> <li>series_settings_api</li> </ul> </li> <li>cli</li> <li>component</li> <li>data<ul> <li>annotation</li> <li>area_data</li> <li>band</li> <li>bar_data</li> <li>baseline_data</li> <li>candlestick_data</li> <li>data</li> <li>gradient_ribbon</li> <li>histogram_data</li> <li>line_data</li> <li>marker</li> <li>ohlc_data</li> <li>ohlcv_data</li> <li>ribbon</li> <li>signal_data</li> <li>single_value_data</li> <li>tooltip</li> <li>trade</li> <li>trend_fill</li> </ul> </li> <li>exceptions</li> <li>logging_config</li> <li>type_definitions<ul> <li>colors</li> <li>enums</li> </ul> </li> <li>types<ul> <li>series_config_types</li> </ul> </li> <li>utils<ul> <li>chainable</li> <li>data_utils</li> <li>profiler</li> <li>serialization</li> </ul> </li> </ul> </li> </ul>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html","title":"streamlit_lightweight_charts_pro.cli","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli","title":"cli","text":"<p>Command-line interface for streamlit-lightweight-charts-pro.</p> <p>This module provides command-line utilities for managing the streamlit-lightweight-charts-pro package, including frontend building, dependency management, and development tools.</p> The CLI supports <ul> <li>Frontend build management and validation</li> <li>Dependency installation and updates</li> <li>Development environment setup</li> <li>Package validation and testing</li> </ul> Key Features <ul> <li>Automatic frontend build detection and building</li> <li>NPM dependency management with validation</li> <li>Development vs production mode handling</li> <li>Error handling with clear user messages</li> <li>Cross-platform compatibility</li> </ul> Example Usage <pre><code># Build frontend assets\npython -m streamlit_lightweight_charts_pro build-frontend\n\n# Check frontend build status\npython -m streamlit_lightweight_charts_pro check-frontend\n\n# Install development dependencies\npython -m streamlit_lightweight_charts_pro install-dev\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.check_frontend_build","title":"check_frontend_build","text":"<pre><code>check_frontend_build()\n</code></pre> <p>Check if frontend is built and provide instructions if not.</p> <p>This function validates that the frontend build directory exists and contains the required static assets. If the frontend is not built, it automatically triggers the build process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if frontend is built successfully, False otherwise.</p> Example <pre><code>if check_frontend_build():\n    print(\"Frontend is ready\")\nelse:\n    print(\"Frontend build failed\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def check_frontend_build():\n    \"\"\"Check if frontend is built and provide instructions if not.\n\n    This function validates that the frontend build directory exists and contains\n    the required static assets. If the frontend is not built, it automatically\n    triggers the build process.\n\n    Returns:\n        bool: True if frontend is built successfully, False otherwise.\n\n    Example:\n        ```python\n        if check_frontend_build():\n            print(\"Frontend is ready\")\n        else:\n            print(\"Frontend build failed\")\n        ```\n    \"\"\"\n    # Check if frontend build directory exists and contains required assets\n    frontend_dir = Path(__file__).parent / \"frontend\"\n    build_dir = frontend_dir / \"build\"\n\n    # Validate that build directory exists and contains static assets\n    if not build_dir.exists() or not (build_dir / \"static\").exists():\n        print(\"\u274c Frontend not built. Building now...\")\n        return build_frontend()\n    return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.build_frontend","title":"build_frontend","text":"<pre><code>build_frontend()\n</code></pre> <p>Build the frontend assets using NPM.</p> <p>This function handles the complete frontend build process including: - Installing NPM dependencies - Running the production build - Validating build output - Error handling and recovery</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if build succeeds, False otherwise.</p> <p>Raises:</p> Type Description <code>NpmNotFoundError</code> <p>If NPM is not installed or not found in PATH.</p> <code>CalledProcessError</code> <p>If the build process fails.</p> Example <pre><code>success = build_frontend()\nif success:\n    print(\"Frontend built successfully\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def build_frontend():\n    \"\"\"Build the frontend assets using NPM.\n\n    This function handles the complete frontend build process including:\n    - Installing NPM dependencies\n    - Running the production build\n    - Validating build output\n    - Error handling and recovery\n\n    Returns:\n        bool: True if build succeeds, False otherwise.\n\n    Raises:\n        NpmNotFoundError: If NPM is not installed or not found in PATH.\n        subprocess.CalledProcessError: If the build process fails.\n\n    Example:\n        ```python\n        success = build_frontend()\n        if success:\n            print(\"Frontend built successfully\")\n        ```\n    \"\"\"\n    # Get the frontend directory path relative to this module\n    frontend_dir = Path(__file__).parent / \"frontend\"\n\n    try:\n        # Store current directory for restoration after build\n        original_dir = Path.cwd()\n        # Change to frontend directory for NPM operations\n        os.chdir(frontend_dir)\n\n        # Install dependencies first to ensure all packages are available\n        print(\"\ud83d\udce6 Installing frontend dependencies...\")\n        npm_path = shutil.which(\"npm\")\n        if not npm_path:\n\n            def _raise_npm_not_found():\n                raise NpmNotFoundError()  # noqa: TRY301\n\n            _raise_npm_not_found()\n\n        # Validate npm_path to prevent command injection\n        def _raise_invalid_npm_path():\n            raise ValueError(\"Invalid npm path\")  # noqa: TRY301\n\n        if not npm_path or not Path(npm_path).exists():\n            _raise_invalid_npm_path()\n        subprocess.run([npm_path, \"install\"], check=True, shell=False)\n\n        # Build frontend\n        print(\"\ud83d\udd28 Building frontend...\")\n        subprocess.run([npm_path, \"run\", \"build\"], check=True, shell=False)\n\n        print(\"\u2705 Frontend build successful!\")\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\u274c Frontend build failed: {e}\")\n        return False\n    except Exception as e:\n        print(f\"\u274c Unexpected error during frontend build: {e}\")\n        return False\n    finally:\n        # Return to original directory\n        os.chdir(original_dir)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/cli.html#streamlit_lightweight_charts_pro.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Main CLI entry point.</p> Source code in <code>streamlit_lightweight_charts_pro/cli.py</code> <pre><code>def main():\n    \"\"\"Main CLI entry point.\"\"\"\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: streamlit-lightweight-charts-pro &lt;command&gt;\")\n        print(\"Commands:\")\n        print(\"  build-frontend  Build the frontend assets\")\n        print(\"  check          Check if frontend is built\")\n        print(\"  version        Show version information\")\n        return 1\n\n    command = sys.argv[1]\n\n    if command == \"build-frontend\":\n        success = build_frontend()\n        return 0 if success else 1\n\n    if command == \"check\":\n        success = check_frontend_build()\n        return 0 if success else 1\n\n    if command == \"version\":\n        print(f\"streamlit-lightweight-charts-pro version {__version__}\")\n        return 0\n\n    print(f\"Unknown command: {command}\")\n    return 1\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html","title":"streamlit_lightweight_charts_pro.component","text":""},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component","title":"component","text":"<p>Component initialization for streamlit-lightweight-charts.</p> <p>This module handles the initialization of the Streamlit component to avoid circular import issues. It manages the component function that renders charts in Streamlit applications.</p> The module supports both development and production modes <ul> <li>Development mode: Uses local development server for hot reloading</li> <li>Production mode: Uses built frontend files for deployment</li> </ul> <p>The component function is initialized once when the module is first imported and can be retrieved using get_component_func() for use throughout the application.</p> Example <pre><code>from streamlit_lightweight_charts_pro.component import get_component_func\n\ncomponent_func = get_component_func()\nif component_func:\n    component_func(config=chart_config, key=\"my_chart\")\n</code></pre> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Streamlit components module cannot be imported</p> <code>FileNotFoundError</code> <p>If frontend build directory is missing in production mode</p>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.get_component_func","title":"get_component_func","text":"<pre><code>get_component_func() -&gt; Optional[Callable[..., Any]]\n</code></pre> <p>Get the Streamlit component function for rendering charts.</p> <p>This function returns the initialized component function that can be used to render charts in Streamlit applications. The component function is initialized once when the module is first imported.</p> <p>The component function takes chart configuration and renders it using the React frontend component. It handles the communication between Python and the JavaScript frontend.</p> <p>Returns:</p> Type Description <code>Optional[Callable[..., Any]]</code> <p>Optional[Callable[..., Any]]: The component function if successfully initialized, None otherwise. The function signature is: component_func(config: Dict[str, Any], key: Optional[str] = None) -&gt; Any</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If component initialization fails (handled internally)</p> Example <pre><code>component_func = get_component_func()\nif component_func:\n    result = component_func(config=chart_config, key=\"my_chart\")\nelse:\n    logger.warning(\"Component function not available\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def get_component_func() -&gt; Optional[Callable[..., Any]]:\n    \"\"\"Get the Streamlit component function for rendering charts.\n\n    This function returns the initialized component function that can be used\n    to render charts in Streamlit applications. The component function is\n    initialized once when the module is first imported.\n\n    The component function takes chart configuration and renders it using\n    the React frontend component. It handles the communication between\n    Python and the JavaScript frontend.\n\n    Returns:\n        Optional[Callable[..., Any]]: The component function if successfully\n            initialized, None otherwise. The function signature is:\n            component_func(config: Dict[str, Any], key: Optional[str] = None) -&gt; Any\n\n    Raises:\n        RuntimeError: If component initialization fails (handled internally)\n\n    Example:\n        ```python\n        component_func = get_component_func()\n        if component_func:\n            result = component_func(config=chart_config, key=\"my_chart\")\n        else:\n            logger.warning(\"Component function not available\")\n        ```\n    \"\"\"\n    if _component_func is None:\n        logger.warning(\"Component function is not initialized. This may indicate a loading issue.\")\n    return _component_func\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.debug_component_status","title":"debug_component_status","text":"<pre><code>debug_component_status() -&gt; Dict[str, Any]\n</code></pre> <p>Debug function to check component initialization status.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Status information about the component</p> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def debug_component_status() -&gt; Dict[str, Any]:\n    \"\"\"Debug function to check component initialization status.\n\n    Returns:\n        Dict[str, Any]: Status information about the component\n    \"\"\"\n    status = {\n        \"component_initialized\": _component_func is not None,\n        \"release_mode\": _RELEASE,\n        \"frontend_dir_exists\": False,\n        \"component_type\": type(_component_func).__name__ if _component_func else None,\n    }\n\n    if _RELEASE:\n        frontend_dir = Path(__file__).parent / \"frontend\" / \"build\"\n        status[\"frontend_dir_exists\"] = frontend_dir.exists()\n        status[\"frontend_dir_path\"] = str(frontend_dir)\n\n        # Check if build files exist\n        if frontend_dir.exists():\n            static_dir = frontend_dir / \"static\"\n            js_dir = static_dir / \"js\" if static_dir.exists() else None\n            status[\"static_dir_exists\"] = static_dir.exists()\n            status[\"js_dir_exists\"] = js_dir.exists() if js_dir else False\n\n            if js_dir and js_dir.exists():\n                js_files = list(js_dir.glob(\"*.js\"))\n                status[\"js_files_count\"] = len(js_files)\n                status[\"js_files\"] = [f.name for f in js_files]\n\n    return status\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/component.html#streamlit_lightweight_charts_pro.component.reinitialize_component","title":"reinitialize_component","text":"<pre><code>reinitialize_component() -&gt; bool\n</code></pre> <p>Attempt to reinitialize the component if it failed to load initially.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if reinitialization was successful, False otherwise</p> Source code in <code>streamlit_lightweight_charts_pro/component.py</code> <pre><code>def reinitialize_component() -&gt; bool:\n    \"\"\"Attempt to reinitialize the component if it failed to load initially.\n\n    Returns:\n        bool: True if reinitialization was successful, False otherwise\n    \"\"\"\n    global _component_func  # pylint: disable=global-statement  # noqa: PLW0603\n\n    logger.info(\"Attempting to reinitialize component...\")\n\n    if _RELEASE:\n        frontend_dir = Path(__file__).parent / \"frontend\" / \"build\"\n        if frontend_dir.exists():\n            try:\n                _component_func = components.declare_component(\n                    \"streamlit_lightweight_charts_pro\",\n                    path=str(frontend_dir),\n                )\n                logger.info(\"Successfully reinitialized production component\")\n            except Exception:\n                logger.exception(\"Failed to reinitialize component\")\n                return False\n            else:\n                return True\n        else:\n            logger.error(\"Frontend build directory not found at %s\", frontend_dir)\n            return False\n    else:\n        try:\n            _component_func = components.declare_component(\n                \"streamlit_lightweight_charts_pro\",\n                url=\"http://localhost:3001\",\n            )\n            logger.info(\"Successfully reinitialized development component\")\n        except Exception:\n            logger.exception(\"Failed to reinitialize development component\")\n            return False\n        else:\n            return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html","title":"streamlit_lightweight_charts_pro.exceptions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions","title":"exceptions","text":"<p>Custom exceptions for streamlit-lightweight-charts-pro.</p> <p>This module provides a streamlined set of custom exceptions organized in a hierarchical structure that reduces redundancy while maintaining clarity and specific error handling.</p>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValidationError","title":"ValidationError","text":"<p>Base exception for all validation errors.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Base exception for all validation errors.\"\"\"\n\n    def __init__(self, message: str):\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ConfigurationError","title":"ConfigurationError","text":"<p>Base exception for configuration-related errors.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ConfigurationError(Exception):\n    \"\"\"Base exception for configuration-related errors.\"\"\"\n\n    def __init__(self, message: str):\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeValidationError","title":"TypeValidationError","text":"<p>Raised when type validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TypeValidationError(ValidationError):\n    \"\"\"Raised when type validation fails.\"\"\"\n\n    def __init__(self, field_name: str, expected_type: str, actual_type: Optional[str] = None):\n        if actual_type:\n            message = f\"{field_name} must be {expected_type}, got {actual_type}\"\n        else:\n            message = f\"{field_name} must be {expected_type}\"\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError","title":"ValueValidationError","text":"<p>Raised when value validation fails.</p> <p>This class provides helper methods for common validation patterns to reduce the need for overly specific exception classes.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ValueValidationError(ValidationError):\n    \"\"\"Raised when value validation fails.\n\n    This class provides helper methods for common validation patterns\n    to reduce the need for overly specific exception classes.\n    \"\"\"\n\n    def __init__(self, field_name: str, message: str):\n        super().__init__(f\"{field_name} {message}\")\n\n    @classmethod\n    def positive_value(cls, field_name: str, value: float | int) -&gt; \"ValueValidationError\":\n        \"\"\"Helper for positive value validation.\"\"\"\n        return cls(field_name, f\"must be positive, got {value}\")\n\n    @classmethod\n    def non_negative_value(\n        cls,\n        field_name: str,\n        value: float | int | None = None,\n    ) -&gt; \"ValueValidationError\":\n        \"\"\"Helper for non-negative value validation.\"\"\"\n        if value is not None:\n            return cls(field_name, f\"must be &gt;= 0, got {value}\")\n        return cls(field_name, \"must be non-negative\")\n\n    @classmethod\n    def in_range(\n        cls,\n        field_name: str,\n        min_val: float,\n        max_val: float,\n        value: float | int,\n    ) -&gt; \"ValueValidationError\":\n        \"\"\"Helper for range validation.\"\"\"\n        return cls(field_name, f\"must be between {min_val} and {max_val}, got {value}\")\n\n    @classmethod\n    def required_field(cls, field_name: str) -&gt; \"ValueValidationError\":\n        \"\"\"Helper for required field validation.\"\"\"\n        return cls(field_name, \"is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.positive_value","title":"positive_value  <code>classmethod</code>","text":"<pre><code>positive_value(\n    field_name: str, value: float | int\n) -&gt; ValueValidationError\n</code></pre> <p>Helper for positive value validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef positive_value(cls, field_name: str, value: float | int) -&gt; \"ValueValidationError\":\n    \"\"\"Helper for positive value validation.\"\"\"\n    return cls(field_name, f\"must be positive, got {value}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.non_negative_value","title":"non_negative_value  <code>classmethod</code>","text":"<pre><code>non_negative_value(\n    field_name: str, value: float | int | None = None\n) -&gt; ValueValidationError\n</code></pre> <p>Helper for non-negative value validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef non_negative_value(\n    cls,\n    field_name: str,\n    value: float | int | None = None,\n) -&gt; \"ValueValidationError\":\n    \"\"\"Helper for non-negative value validation.\"\"\"\n    if value is not None:\n        return cls(field_name, f\"must be &gt;= 0, got {value}\")\n    return cls(field_name, \"must be non-negative\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.in_range","title":"in_range  <code>classmethod</code>","text":"<pre><code>in_range(\n    field_name: str,\n    min_val: float,\n    max_val: float,\n    value: float | int,\n) -&gt; ValueValidationError\n</code></pre> <p>Helper for range validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef in_range(\n    cls,\n    field_name: str,\n    min_val: float,\n    max_val: float,\n    value: float | int,\n) -&gt; \"ValueValidationError\":\n    \"\"\"Helper for range validation.\"\"\"\n    return cls(field_name, f\"must be between {min_val} and {max_val}, got {value}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ValueValidationError.required_field","title":"required_field  <code>classmethod</code>","text":"<pre><code>required_field(field_name: str) -&gt; ValueValidationError\n</code></pre> <p>Helper for required field validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef required_field(cls, field_name: str) -&gt; \"ValueValidationError\":\n    \"\"\"Helper for required field validation.\"\"\"\n    return cls(field_name, \"is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RangeValidationError","title":"RangeValidationError","text":"<p>Raised when value is outside valid range.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class RangeValidationError(ValueValidationError):\n    \"\"\"Raised when value is outside valid range.\"\"\"\n\n    def __init__(\n        self,\n        field_name: str,\n        value: float | int,\n        min_value: Optional[float] = None,\n        max_value: Optional[float] = None,\n    ):\n        if min_value is not None and max_value is not None:\n            message = f\"must be between {min_value} and {max_value}, got {value}\"\n        elif min_value is not None:\n            message = f\"must be &gt;= {min_value}, got {value}\"\n        elif max_value is not None:\n            message = f\"must be &lt;= {max_value}, got {value}\"\n        else:\n            message = f\"invalid value: {value}\"\n\n        super().__init__(field_name, message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.RequiredFieldError","title":"RequiredFieldError","text":"<p>Raised when a required field is missing.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class RequiredFieldError(ValidationError):\n    \"\"\"Raised when a required field is missing.\"\"\"\n\n    def __init__(self, field_name: str):\n        super().__init__(f\"{field_name} is required\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DuplicateError","title":"DuplicateError","text":"<p>Raised when duplicate values are detected.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DuplicateError(ValidationError):\n    \"\"\"Raised when duplicate values are detected.\"\"\"\n\n    def __init__(self, field_name: str, value: Any):\n        super().__init__(f\"Duplicate {field_name}: {value}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ComponentNotAvailableError","title":"ComponentNotAvailableError","text":"<p>Raised when component function is not available.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ComponentNotAvailableError(ConfigurationError):\n    \"\"\"Raised when component function is not available.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"Component function not available. \"\n            \"Please check if the component is properly initialized.\",\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.AnnotationItemsTypeError","title":"AnnotationItemsTypeError","text":"<p>Raised when annotation items are not correct type.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class AnnotationItemsTypeError(TypeValidationError):\n    \"\"\"Raised when annotation items are not correct type.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"All items\", \"Annotation instances\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.SeriesItemsTypeError","title":"SeriesItemsTypeError","text":"<p>Raised when series items are not correct type.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class SeriesItemsTypeError(TypeValidationError):\n    \"\"\"Raised when series items are not correct type.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"All items\", \"Series instances\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleIdTypeError","title":"PriceScaleIdTypeError","text":"<p>Raised when price scale ID is not a string.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class PriceScaleIdTypeError(TypeValidationError):\n    \"\"\"Raised when price scale ID is not a string.\"\"\"\n\n    def __init__(self, scale_name: str, actual_type: type):\n        super().__init__(\n            f\"{scale_name}.price_scale_id\",\n            \"must be a string\",\n            actual_type.__name__,\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.PriceScaleOptionsTypeError","title":"PriceScaleOptionsTypeError","text":"<p>Raised when price scale options are invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class PriceScaleOptionsTypeError(TypeValidationError):\n    \"\"\"Raised when price scale options are invalid.\"\"\"\n\n    def __init__(self, scale_name: str, actual_type: type):\n        super().__init__(\n            scale_name,\n            \"must be a PriceScaleOptions object\",\n            actual_type.__name__,\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColorValidationError","title":"ColorValidationError","text":"<p>Raised when color format is invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ColorValidationError(ValidationError):\n    \"\"\"Raised when color format is invalid.\"\"\"\n\n    def __init__(self, property_name: str, color_value: str):\n        super().__init__(\n            f\"Invalid color format for {property_name}: {color_value!r}. Must be hex or rgba.\",\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError","title":"DataFrameValidationError","text":"<p>Raised when DataFrame validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DataFrameValidationError(ValidationError):\n    \"\"\"Raised when DataFrame validation fails.\"\"\"\n\n    @classmethod\n    def missing_column(cls, column: str) -&gt; \"DataFrameValidationError\":\n        \"\"\"Helper for missing column validation.\"\"\"\n        return cls(f\"DataFrame is missing required column: {column}\")\n\n    @classmethod\n    def invalid_data_type(cls, data_type: type) -&gt; \"DataFrameValidationError\":\n        \"\"\"Helper for invalid data type validation.\"\"\"\n        return cls(\n            f\"data must be a list of SingleValueData objects, DataFrame, or Series, got {data_type}\",\n        )\n\n    @classmethod\n    def missing_columns_mapping(\n        cls,\n        missing_columns: list[str],\n        required: list[str],\n        mapping: dict[str, str],\n    ) -&gt; \"DataFrameValidationError\":\n        \"\"\"Helper for missing columns mapping validation.\"\"\"\n        message = (\n            f\"Missing required columns in column_mapping: {missing_columns}\\n\"\n            f\"Required columns: {required}\\n\"\n            f\"Column mapping: {mapping}\"\n        )\n        return cls(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.missing_column","title":"missing_column  <code>classmethod</code>","text":"<pre><code>missing_column(column: str) -&gt; DataFrameValidationError\n</code></pre> <p>Helper for missing column validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef missing_column(cls, column: str) -&gt; \"DataFrameValidationError\":\n    \"\"\"Helper for missing column validation.\"\"\"\n    return cls(f\"DataFrame is missing required column: {column}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.invalid_data_type","title":"invalid_data_type  <code>classmethod</code>","text":"<pre><code>invalid_data_type(\n    data_type: type,\n) -&gt; DataFrameValidationError\n</code></pre> <p>Helper for invalid data type validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef invalid_data_type(cls, data_type: type) -&gt; \"DataFrameValidationError\":\n    \"\"\"Helper for invalid data type validation.\"\"\"\n    return cls(\n        f\"data must be a list of SingleValueData objects, DataFrame, or Series, got {data_type}\",\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataFrameValidationError.missing_columns_mapping","title":"missing_columns_mapping  <code>classmethod</code>","text":"<pre><code>missing_columns_mapping(\n    missing_columns: list[str],\n    required: list[str],\n    mapping: dict[str, str],\n) -&gt; DataFrameValidationError\n</code></pre> <p>Helper for missing columns mapping validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef missing_columns_mapping(\n    cls,\n    missing_columns: list[str],\n    required: list[str],\n    mapping: dict[str, str],\n) -&gt; \"DataFrameValidationError\":\n    \"\"\"Helper for missing columns mapping validation.\"\"\"\n    message = (\n        f\"Missing required columns in column_mapping: {missing_columns}\\n\"\n        f\"Required columns: {required}\\n\"\n        f\"Column mapping: {mapping}\"\n    )\n    return cls(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError","title":"TimeValidationError","text":"<p>Raised when time validation fails.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TimeValidationError(ValidationError):\n    \"\"\"Raised when time validation fails.\"\"\"\n\n    def __init__(self, message: str):\n        super().__init__(f\"Time validation failed: {message}\")\n\n    @classmethod\n    def invalid_time_string(cls, time_value: str) -&gt; \"TimeValidationError\":\n        \"\"\"Helper for invalid time string validation.\"\"\"\n        return cls(f\"Invalid time string: {time_value!r}\")\n\n    @classmethod\n    def unsupported_type(cls, time_type: type) -&gt; \"TimeValidationError\":\n        \"\"\"Helper for unsupported time type validation.\"\"\"\n        return cls(f\"Unsupported time type {time_type.__name__}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError.invalid_time_string","title":"invalid_time_string  <code>classmethod</code>","text":"<pre><code>invalid_time_string(time_value: str) -&gt; TimeValidationError\n</code></pre> <p>Helper for invalid time string validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef invalid_time_string(cls, time_value: str) -&gt; \"TimeValidationError\":\n    \"\"\"Helper for invalid time string validation.\"\"\"\n    return cls(f\"Invalid time string: {time_value!r}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TimeValidationError.unsupported_type","title":"unsupported_type  <code>classmethod</code>","text":"<pre><code>unsupported_type(time_type: type) -&gt; TimeValidationError\n</code></pre> <p>Helper for unsupported time type validation.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>@classmethod\ndef unsupported_type(cls, time_type: type) -&gt; \"TimeValidationError\":\n    \"\"\"Helper for unsupported time type validation.\"\"\"\n    return cls(f\"Unsupported time type {time_type.__name__}\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.UnsupportedTimeTypeError","title":"UnsupportedTimeTypeError","text":"<p>Raised when time type is unsupported.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class UnsupportedTimeTypeError(TypeValidationError):\n    \"\"\"Raised when time type is unsupported.\"\"\"\n\n    def __init__(self, time_type: type):\n        super().__init__(\"time\", \"unsupported type\", time_type.__name__)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InvalidMarkerPositionError","title":"InvalidMarkerPositionError","text":"<p>Raised when marker position is invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class InvalidMarkerPositionError(ValidationError):\n    \"\"\"Raised when marker position is invalid.\"\"\"\n\n    def __init__(self, position: str, marker_type: str):\n        super().__init__(\n            f\"Invalid position '{position}' for marker type {marker_type}\",\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ColumnMappingRequiredError","title":"ColumnMappingRequiredError","text":"<p>Raised when column mapping is required but not provided.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ColumnMappingRequiredError(RequiredFieldError):\n    \"\"\"Raised when column mapping is required but not provided.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"column_mapping is required when providing DataFrame or Series data\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.DataItemsTypeError","title":"DataItemsTypeError","text":"<p>Raised when data items are not correct type.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class DataItemsTypeError(TypeValidationError):\n    \"\"\"Raised when data items are not correct type.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"All items in data list\", \"instances of Data or its subclasses\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.ExitTimeAfterEntryTimeError","title":"ExitTimeAfterEntryTimeError","text":"<p>Raised when exit time must be after entry time.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class ExitTimeAfterEntryTimeError(ValueValidationError):\n    \"\"\"Raised when exit time must be after entry time.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"Exit time\", \"must be after entry time\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.InstanceTypeError","title":"InstanceTypeError","text":"<p>Raised when value must be an instance of a specific type.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class InstanceTypeError(TypeValidationError):\n    \"\"\"Raised when value must be an instance of a specific type.\"\"\"\n\n    def __init__(self, attr_name: str, value_type: type, allow_none: bool = False):\n        if allow_none:\n            message = f\"an instance of {value_type.__name__} or None\"\n        else:\n            message = f\"an instance of {value_type.__name__}\"\n        super().__init__(attr_name, message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TypeMismatchError","title":"TypeMismatchError","text":"<p>Raised when type mismatch occurs.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TypeMismatchError(TypeValidationError):\n    \"\"\"Raised when type mismatch occurs.\"\"\"\n\n    def __init__(self, attr_name: str, value_type: type, actual_type: type):\n        super().__init__(attr_name, f\"must be of type {value_type.__name__}\", actual_type.__name__)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.TrendDirectionIntegerError","title":"TrendDirectionIntegerError","text":"<p>Raised when trend direction is not an integer.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class TrendDirectionIntegerError(TypeValidationError):\n    \"\"\"Raised when trend direction is not an integer.\"\"\"\n\n    def __init__(self, field_name: str, expected_type: str, actual_type: str):\n        super().__init__(field_name, f\"must be {expected_type}\", actual_type)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.BaseValueFormatError","title":"BaseValueFormatError","text":"<p>Raised when base value format is invalid.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class BaseValueFormatError(ValidationError):\n    \"\"\"Raised when base value format is invalid.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"Base value must be a dict with 'type' and 'price' keys\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NotFoundError","title":"NotFoundError","text":"<p>Raised when a requested resource is not found.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class NotFoundError(ValidationError):\n    \"\"\"Raised when a requested resource is not found.\"\"\"\n\n    def __init__(self, resource_type: str, identifier: str):\n        super().__init__(f\"{resource_type} with identifier '{identifier}' not found\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/exceptions.html#streamlit_lightweight_charts_pro.exceptions.NpmNotFoundError","title":"NpmNotFoundError","text":"<p>Raised when NPM is not found in the system PATH.</p> Source code in <code>streamlit_lightweight_charts_pro/exceptions.py</code> <pre><code>class NpmNotFoundError(ConfigurationError):\n    \"\"\"Raised when NPM is not found in the system PATH.\"\"\"\n\n    def __init__(self):\n        message = (\n            \"NPM not found in system PATH. Please install Node.js and NPM to build frontend assets.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html","title":"streamlit_lightweight_charts_pro.logging_config","text":""},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config","title":"logging_config","text":"<p>Logging configuration for Streamlit Lightweight Charts Pro.</p> <p>This module provides centralized logging configuration for the package, including proper log levels, formatting, and handlers. It ensures consistent logging behavior across all components of the library.</p> The module provides two main functions <ul> <li>setup_logging(): Configures the root logger with custom settings</li> <li>get_logger(): Retrieves a logger instance with proper naming</li> </ul> Features <ul> <li>Centralized logging configuration</li> <li>Customizable log levels and formats</li> <li>Automatic handler management to prevent duplicates</li> <li>Consistent logger naming convention</li> <li>Default error-level logging for production use</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.logging_config import get_logger, setup_logging\n\n# Set up logging with custom level\nsetup_logging(level=logging.INFO)\n\n# Get a logger for a specific component\nlogger = get_logger(\"chart_rendering\")\nlogger.info(\"Chart rendered successfully\")\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    level: int = ERROR,\n    log_format: Optional[str] = None,\n    stream: Optional[StreamHandler] = None,\n) -&gt; Logger\n</code></pre> <p>Set up logging configuration for the package.</p> <p>This function configures the root logger for the package with the specified settings. It ensures that logging is properly initialized and prevents duplicate handlers from being added.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level to set for the root logger. Defaults to ERROR for production use. Common values: logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL.</p> <code>ERROR</code> <code>log_format</code> <code>Optional[str]</code> <p>Custom log format string. If None, uses a standard format that includes timestamp, logger name, level, and message.</p> <code>None</code> <code>stream</code> <code>Optional[StreamHandler]</code> <p>Custom stream handler. If None, creates a StreamHandler that writes to sys.stdout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The configured root logger instance for the package.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid logging level is provided.</p> Example <pre><code>import logging\nfrom streamlit_lightweight_charts_pro.logging_config import setup_logging\n\n# Set up logging with INFO level\nlogger = setup_logging(level=logging.INFO)\nlogger.info(\"Logging configured successfully\")\n\n# Set up logging with custom format\ncustom_format = \"%(asctime)s - %(levelname)s - %(message)s\"\nsetup_logging(level=logging.DEBUG, log_format=custom_format)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def setup_logging(\n    level: int = logging.ERROR,\n    log_format: Optional[str] = None,\n    stream: Optional[logging.StreamHandler] = None,\n) -&gt; logging.Logger:\n    \"\"\"Set up logging configuration for the package.\n\n    This function configures the root logger for the package with the specified\n    settings. It ensures that logging is properly initialized and prevents\n    duplicate handlers from being added.\n\n    Args:\n        level: Logging level to set for the root logger. Defaults to ERROR\n            for production use. Common values: logging.DEBUG, logging.INFO,\n            logging.WARNING, logging.ERROR, logging.CRITICAL.\n        log_format: Custom log format string. If None, uses a standard format\n            that includes timestamp, logger name, level, and message.\n        stream: Custom stream handler. If None, creates a StreamHandler\n            that writes to sys.stdout.\n\n    Returns:\n        logging.Logger: The configured root logger instance for the package.\n\n    Raises:\n        ValueError: If an invalid logging level is provided.\n\n    Example:\n        ```python\n        import logging\n        from streamlit_lightweight_charts_pro.logging_config import setup_logging\n\n        # Set up logging with INFO level\n        logger = setup_logging(level=logging.INFO)\n        logger.info(\"Logging configured successfully\")\n\n        # Set up logging with custom format\n        custom_format = \"%(asctime)s - %(levelname)s - %(message)s\"\n        setup_logging(level=logging.DEBUG, log_format=custom_format)\n        ```\n    \"\"\"\n    # Create logger\n    logger = logging.getLogger(\"streamlit_lightweight_charts_pro\")\n    logger.setLevel(level)\n\n    # Avoid adding handlers multiple times\n    if logger.handlers:\n        return logger\n\n    # Set default format if not provided\n    if log_format is None:\n        log_format = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n\n    # Create formatter\n    formatter = logging.Formatter(log_format)\n\n    # Create stream handler if not provided\n    if stream is None:\n        stream = logging.StreamHandler(sys.stdout)\n        stream.setLevel(level)\n        stream.setFormatter(formatter)\n\n    # Add handler to logger\n    logger.addHandler(stream)\n\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/logging_config.html#streamlit_lightweight_charts_pro.logging_config.get_logger","title":"get_logger","text":"<pre><code>get_logger(\n    name: Optional[str] = None, level: int = ERROR\n) -&gt; Logger\n</code></pre> <p>Get a logger instance for the package.</p> <p>This function creates or retrieves a logger instance with the proper naming convention. The logger name is automatically prefixed with the package name to ensure proper hierarchy and filtering.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Optional logger name that will be appended to the package name. If None, returns the root package logger. The full logger name will be \"streamlit_lightweight_charts_pro.{name}\".</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level for this specific logger. Defaults to ERROR for production use. This level is set on the logger instance and can be overridden by parent loggers.</p> <code>ERROR</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: A logger instance with the specified name and level.</p> Example <pre><code>from streamlit_lightweight_charts_pro.logging_config import get_logger\n\n# Get the root package logger\nroot_logger = get_logger()\nroot_logger.error(\"Critical error occurred\")\n\n# Get a logger for a specific component\nchart_logger = get_logger(\"chart_rendering\", level=logging.INFO)\nchart_logger.info(\"Chart component initialized\")\n\n# Get a logger for data processing\ndata_logger = get_logger(\"data_processing\")\ndata_logger.debug(\"Processing data batch\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/logging_config.py</code> <pre><code>def get_logger(name: Optional[str] = None, level: int = logging.ERROR) -&gt; logging.Logger:\n    \"\"\"Get a logger instance for the package.\n\n    This function creates or retrieves a logger instance with the proper naming\n    convention. The logger name is automatically prefixed with the package name\n    to ensure proper hierarchy and filtering.\n\n    Args:\n        name: Optional logger name that will be appended to the package name.\n            If None, returns the root package logger. The full logger name\n            will be \"streamlit_lightweight_charts_pro.{name}\".\n        level: Logging level for this specific logger. Defaults to ERROR\n            for production use. This level is set on the logger instance\n            and can be overridden by parent loggers.\n\n    Returns:\n        logging.Logger: A logger instance with the specified name and level.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.logging_config import get_logger\n\n        # Get the root package logger\n        root_logger = get_logger()\n        root_logger.error(\"Critical error occurred\")\n\n        # Get a logger for a specific component\n        chart_logger = get_logger(\"chart_rendering\", level=logging.INFO)\n        chart_logger.info(\"Chart component initialized\")\n\n        # Get a logger for data processing\n        data_logger = get_logger(\"data_processing\")\n        data_logger.debug(\"Processing data batch\")\n        ```\n    \"\"\"\n    logger = logging.getLogger(f\"streamlit_lightweight_charts_pro.{name}\")\n    logger.setLevel(level)\n    return logger\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html","title":"streamlit_lightweight_charts_pro.charts.chart","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart","title":"chart","text":"<p>Chart implementation for streamlit-lightweight-charts.</p> <p>This module provides the Chart class, which is the primary chart type for displaying financial data in a single pane. It supports multiple series types, annotations, and comprehensive customization options with a fluent API for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create data\ndata = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\n\n# Create chart with method chaining\nchart = (\n    Chart(series=LineSeries(data))\n    .update_options(height=400)\n    .add_annotation(create_text_annotation(\"2024-01-01\", 100, \"Start\"))\n)\n\n# Render in Streamlit\nchart.render(key=\"my_chart\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart","title":"Chart","text":"<p>Single pane chart for displaying financial data.</p> <p>This class represents a single pane chart that can display multiple series of financial data. It supports various chart types including candlestick, line, area, bar, and histogram series. The chart includes comprehensive annotation support, trade visualization, and method chaining for fluent API usage.</p> <p>Attributes:</p> Name Type Description <code>series</code> <code>List[Series]</code> <p>List of series objects to display in the chart.</p> <code>options</code> <code>ChartOptions</code> <p>Chart configuration options including layout, grid, etc.</p> <code>annotation_manager</code> <code>AnnotationManager</code> <p>Manager for chart annotations and layers.</p> Example <pre><code># Basic usage\nchart = Chart(series=LineSeries(data))\n\n# With method chaining\nchart = Chart(series=LineSeries(data)).update_options(height=400)\n                                      .add_annotation(text_annotation)\n\n# From DataFrame with price and volume\nchart = Chart.from_price_volume_dataframe(\n    df, column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"}\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>class Chart:\n    \"\"\"Single pane chart for displaying financial data.\n\n    This class represents a single pane chart that can display multiple\n    series of financial data. It supports various chart types including\n    candlestick, line, area, bar, and histogram series. The chart includes\n    comprehensive annotation support, trade visualization, and method chaining\n    for fluent API usage.\n\n    Attributes:\n        series (List[Series]): List of series objects to display in the chart.\n        options (ChartOptions): Chart configuration options including layout,\n            grid, etc.\n        annotation_manager (AnnotationManager): Manager for chart annotations\n            and layers.\n\n    Example:\n        ```python\n        # Basic usage\n        chart = Chart(series=LineSeries(data))\n\n        # With method chaining\n        chart = Chart(series=LineSeries(data)).update_options(height=400)\n                                              .add_annotation(text_annotation)\n\n        # From DataFrame with price and volume\n        chart = Chart.from_price_volume_dataframe(\n            df, column_mapping={\"time\": \"timestamp\", \"open\": \"o\", \"high\": \"h\"}\n        )\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        series: Optional[Union[Series, List[Series]]] = None,\n        options: Optional[ChartOptions] = None,\n        annotations: Optional[List[Annotation]] = None,\n        chart_group_id: int = 0,\n        chart_manager: Optional[Any] = None,\n    ):\n        \"\"\"Initialize a single pane chart.\n\n        Creates a new Chart instance with optional series, configuration options,\n        and annotations. The chart can be configured with multiple series types\n        and supports method chaining for fluent API usage.\n\n        Args:\n            series: Optional single series object or list of series objects to\n                display. Each series represents a different data visualization\n                (line, candlestick, area, etc.). If None, an empty chart is\n                created.\n            options: Optional chart configuration options. If not provided,\n                default options will be used.\n            annotations: Optional list of annotations to add to the chart.\n                Annotations can include text, arrows, shapes, etc.\n            chart_group_id: Group ID for synchronization. Charts with the same\n                group ID will be synchronized. Defaults to 0.\n            chart_manager: Reference to the ChartManager that owns this chart.\n                Used to access sync configuration when rendering individual charts.\n\n        Returns:\n            Chart: Initialized chart instance ready for configuration and rendering.\n\n        Raises:\n            SeriesItemsTypeError: If any item in the series list is not a Series\n                instance.\n            TypeValidationError: If series is not a Series instance or list, or if\n                annotations is not a list.\n            AnnotationItemsTypeError: If any item in annotations is not an Annotation\n                instance.\n\n        Example:\n            ```python\n            # Create empty chart\n            chart = Chart()\n\n            # Create chart with single series\n            chart = Chart(series=LineSeries(data))\n\n            # Create chart with multiple series\n            chart = Chart(series=[line_series, candlestick_series])\n\n            # Create chart with custom options\n            chart = Chart(series=line_series, options=ChartOptions(height=600, width=800))\n            ```\n        \"\"\"\n        # Handle series input - convert to list for uniform processing\n        # This allows the class to accept either a single Series or a list\n        if series is None:\n            # Case 1: No series provided - create empty chart\n            self.series = []\n        elif isinstance(series, Series):\n            # Case 2: Single Series object - wrap in list for consistent handling\n            self.series = [series]\n        elif isinstance(series, list):\n            # Case 3: List of series - validate each item is a Series instance\n            for item in series:\n                if not isinstance(item, Series):\n                    # Reject list items that are not Series objects\n                    raise SeriesItemsTypeError()\n            self.series = series\n        else:\n            # Case 4: Invalid input type - raise error with clear message\n            raise TypeValidationError(\"series\", \"Series instance or list\")\n\n        # Set up chart configuration\n        # Use provided options or default ChartOptions instance\n        self.options = options or ChartOptions()\n\n        # Initialize chart synchronization support\n        # Chart group ID enables multiple charts to sync their time ranges\n        self._chart_group_id = chart_group_id\n\n        # Store ChartManager reference for retrieving sync settings\n        # This allows the chart to access manager's configuration\n        self._chart_manager = chart_manager\n\n        # Set up annotation system that manages chart annotations\n        # AnnotationsManager handles layers, visibility, and annotations\n        self.annotation_manager = AnnotationManager()\n\n        # Initialize storage for trade data to be processed by frontend\n        # Trades include buy/sell markers and PnL calculations\n        self._trades = []\n\n        # Initialize tooltip manager for lazy loading\n        # Tooltips are only loaded if requested to improve performance\n        self._tooltip_manager = None\n\n        # Process initial annotations if provided\n        # This ensures annotations are added in correct order\n        if annotations is not None:\n            # Validate that annotations parameter is a list\n            if not isinstance(annotations, list):\n                # Fail fast on invalid annotation container\n                raise TypeValidationError(\"annotations\", \"list\")\n\n            # Add each annotation to the chart annotation system\n            for annotation in annotations:\n                if not isinstance(annotation, Annotation):\n                    # Reject annotation items that are not Annotation objects\n                    raise AnnotationItemsTypeError()\n                # Add annotation to the chart's annotation manager\n                self.add_annotation(annotation)\n\n    def add_series(self, series: Series) -&gt; \"Chart\":\n        \"\"\"Add a series to the chart.\n\n        Adds a new series object to the chart's series list. The series will be\n        displayed according to its type (line, candlestick, area, etc.) and\n        configuration options. Automatically handles price scale configuration\n        for custom price scale IDs.\n\n        Args:\n            series: Series object to add to the chart. Must be an instance of a\n                Series subclass (LineSeries, CandlestickSeries, etc.).\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Raises:\n            TypeValidationError: If the series parameter is not an instance of Series.\n\n        Example:\n            ```python\n            # Add a candlestick series\n            chart.add_series(CandlestickSeries(ohlc_data))\n\n            # Add a line series with custom options\n            chart.add_series(LineSeries(data, line_options=LineOptions(color=\"red\")))\n\n            # Method chaining\n            chart.add_series(line_series).add_series(candlestick_series)\n            ```\n        \"\"\"\n        # Validate input type to ensure it's a proper Series instance\n        if not isinstance(series, Series):\n            raise TypeValidationError(\"series\", \"Series instance\")\n\n        # Check for custom price scale configuration needs\n        # Extract price_scale_id from the series for validation\n        price_scale_id = series.price_scale_id\n\n        # Handle custom price scale setup\n        # Only process non-standard scale IDs (not default \"left\"/\"right\")\n        if (\n            price_scale_id\n            and price_scale_id not in [\"left\", \"right\", \"\"]\n            and price_scale_id not in self.options.overlay_price_scales\n        ):\n            # Log warning when series uses custom price scale without configuration\n            logger.warning(\n                \"Series with price_scale_id '%s' does not have a corresponding \"\n                \"overlay price scale configuration. Creating empty price scale object.\",\n                price_scale_id,\n            )\n            # Create basic price scale configuration for the custom ID\n            empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n            self.options.overlay_price_scales[price_scale_id] = empty_scale\n\n        # Add the validated series to the chart's series collection\n        self.series.append(series)\n\n        # Return self for method chaining\n        return self\n\n    def update_options(self, **kwargs) -&gt; \"Chart\":\n        \"\"\"Update chart options.\n\n        Updates the chart's configuration options using keyword arguments.\n        Only valid ChartOptions attributes will be updated; invalid attributes\n        are silently ignored to support method chaining.\n\n        Args:\n            **kwargs: Chart options to update. Valid options include:\n                - width (Optional[int]): Chart width in pixels\n                - height (int): Chart height in pixels\n                - auto_size (bool): Whether to auto-size the chart\n                - handle_scroll (bool): Whether to enable scroll interactions\n                - handle_scale (bool): Whether to enable scale interactions\n                - add_default_pane (bool): Whether to add a default pane\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Update basic options\n            chart.update_options(height=600, width=800, auto_size=True)\n\n            # Update interaction options\n            chart.update_options(handle_scroll=True, handle_scale=False)\n\n            # Method chaining\n            chart.update_options(height=500).update_options(width=1000)\n            ```\n        \"\"\"\n        # Process each keyword argument to update chart options\n        for key, value in kwargs.items():\n            # Check that the attribute exists on options and value is not None\n            if value is not None and hasattr(self.options, key):\n                # Get the current attribute value for type checking\n                current_value = getattr(self.options, key)\n                # Validate that the new value type matches current attribute type\n                if isinstance(value, type(current_value)) or (\n                    current_value is None and value is not None\n                ):\n                    # Update the attribute with the validated value\n                    setattr(self.options, key, value)\n            # Silently ignore None values to support method chaining\n        # Return self for method chaining\n        return self\n\n    def add_annotation(self, annotation: Annotation, layer_name: str = \"default\") -&gt; \"Chart\":\n        \"\"\"Add an annotation to the chart.\n\n        Adds a single annotation to the specified annotation layer. If the layer\n        doesn't exist, it will be created automatically. Annotations can include\n        text, arrows, shapes, and other visual elements.\n\n        Args:\n            annotation (Annotation): Annotation object to add to the chart.\n            layer_name (str, optional): Name of the annotation layer. Defaults to \"default\".\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Add text annotation\n            text_ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n            chart.add_annotation(text_ann)\n\n            # Add annotation to custom layer\n            chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n            # Method chaining\n            chart.add_annotation(text_ann).add_annotation(arrow_ann)\n            ```\n        \"\"\"\n        if annotation is None:\n            raise ValueValidationError(\"annotation\", \"cannot be None\")\n        if not isinstance(annotation, Annotation):\n            raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n        # Use default layer name if None is provided\n        if layer_name is None:\n            layer_name = \"default\"\n        elif not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        self.annotation_manager.add_annotation(annotation, layer_name)\n        return self\n\n    def add_annotations(\n        self,\n        annotations: List[Annotation],\n        layer_name: str = \"default\",\n    ) -&gt; \"Chart\":\n        \"\"\"Add multiple annotations to the chart.\n\n        Adds multiple annotation objects to the specified annotation layer. This\n        is more efficient than calling add_annotation multiple times as it\n        processes all annotations in a single operation.\n\n        Args:\n            annotations (List[Annotation]): List of annotation objects to add\n                to the chart.\n            layer_name (str, optional): Name of the annotation layer. Defaults to \"default\".\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Add multiple annotations at once\n            annotations = [\n                create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n                create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n                create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n            ]\n            chart.add_annotations(annotations)\n\n            # Add to custom layer\n            chart.add_annotations(annotations, layer_name=\"analysis\")\n            ```\n        \"\"\"\n        if annotations is None:\n            raise TypeValidationError(\"annotations\", \"list\")\n        if not isinstance(annotations, list):\n            raise TypeValidationError(\"annotations\", \"list\")\n        if not layer_name or not isinstance(layer_name, str):\n            raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n        for annotation in annotations:\n            if not isinstance(annotation, Annotation):\n                raise AnnotationItemsTypeError()\n            self.add_annotation(annotation, layer_name)\n        return self\n\n    def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new annotation layer with the specified name. Annotation layers\n        allow you to organize and manage groups of annotations independently.\n        Each layer can be shown, hidden, or cleared separately.\n\n        Args:\n            name (str): Name of the annotation layer to create.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Create custom layers for different types of annotations\n            chart.create_annotation_layer(\"signals\")\n            chart.create_annotation_layer(\"analysis\")\n            chart.create_annotation_layer(\"events\")\n\n            # Method chaining\n            chart.create_annotation_layer(\"layer1\").create_annotation_layer(\"layer2\")\n            ```\n        \"\"\"\n        if name is None:\n            raise TypeValidationError(\"name\", \"string\")\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n        self.annotation_manager.create_layer(name)\n        return self\n\n    def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Hide an annotation layer.\n\n        Hides the specified annotation layer, making all annotations in that\n        layer invisible on the chart. The layer and its annotations are preserved\n        and can be shown again using show_annotation_layer.\n\n        Args:\n            name (str): Name of the annotation layer to hide.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Hide specific layers\n            chart.hide_annotation_layer(\"analysis\")\n            chart.hide_annotation_layer(\"signals\")\n\n            # Method chaining\n            chart.hide_annotation_layer(\"layer1\").hide_annotation_layer(\"layer2\")\n            ```\n        \"\"\"\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n        self.annotation_manager.hide_layer(name)\n        return self\n\n    def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n        \"\"\"Show an annotation layer.\n\n        Makes the specified annotation layer visible on the chart. This will\n        display all annotations that were previously added to this layer.\n        If the layer doesn't exist, this method will have no effect.\n\n        Args:\n            name (str): Name of the annotation layer to show.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Show specific layers\n            chart.show_annotation_layer(\"analysis\")\n            chart.show_annotation_layer(\"signals\")\n\n            # Method chaining\n            chart.show_annotation_layer(\"layer1\").show_annotation_layer(\"layer2\")\n            ```\n        \"\"\"\n        if not name or not isinstance(name, str):\n            raise ValueValidationError(\"name\", \"must be a non-empty string\")\n        self.annotation_manager.show_layer(name)\n        return self\n\n    def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n        \"\"\"Clear annotations from the chart.\n\n        Removes all annotations from the specified layer or from all layers if\n        no layer name is provided. The layer itself is preserved and can be\n        reused for new annotations.\n\n        Args:\n            layer_name (Optional[str]): Name of the layer to clear. If None,\n                clears all layers. Defaults to None.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Clear specific layer\n            chart.clear_annotations(\"analysis\")\n\n            # Clear all layers\n            chart.clear_annotations()\n\n            # Method chaining\n            chart.clear_annotations(\"layer1\").add_annotation(new_annotation)\n            ```\n        \"\"\"\n        if layer_name is not None and (not layer_name or not isinstance(layer_name, str)):\n            raise ValueValidationError(\"layer_name\", \"must be None or a non-empty string\")\n        self.annotation_manager.clear_layer(layer_name)\n        return self\n\n    def add_overlay_price_scale(self, scale_id: str, options: \"PriceScaleOptions\") -&gt; \"Chart\":\n        \"\"\"Add or update a custom overlay price scale configuration.\n\n        Adds or updates an overlay price scale configuration for the chart.\n        Overlay price scales allow multiple series to share the same price axis\n        while maintaining independent scaling and positioning.\n\n        Args:\n            scale_id (str): The unique identifier for the custom price scale\n                (e.g., 'volume', 'indicator1', 'overlay').\n            options (PriceScaleOptions): A PriceScaleOptions instance containing\n                the configuration for the overlay price scale.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.charts.options.price_scale_options import (\n                PriceScaleOptions,\n            )\n\n            # Add volume overlay price scale\n            volume_scale = PriceScaleOptions(\n                visible=False,\n                scale_margin_top=0.8,\n                scale_margin_bottom=0,\n                overlay=True,\n                auto_scale=True\n            )\n            chart.add_overlay_price_scale('volume', volume_scale)\n\n            # Method chaining\n            chart.add_overlay_price_scale('indicator1', indicator_scale) \\\n                .add_series(indicator_series)\n            ```\n        \"\"\"\n        if not scale_id or not isinstance(scale_id, str):\n            raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n        if options is None:\n            raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n        if not isinstance(options, PriceScaleOptions):\n            raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n        # Check for duplicate scale_id\n        if scale_id in self.options.overlay_price_scales:\n            raise DuplicateError(\"Price scale\", scale_id)\n\n        self.options.overlay_price_scales[scale_id] = options\n        return self\n\n    def add_price_volume_series(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"Chart\":\n        \"\"\"Add price and volume series to the chart.\n\n        Creates and adds both price and volume series to the chart from OHLCV data.\n        The price series is displayed on the main price scale, while the volume\n        series is displayed on a separate overlay price scale.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Defaults to None.\n            price_type (str, optional): Type of price series ('candlestick' or 'line').\n                Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration. Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration. Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Add candlestick with volume\n            chart.add_price_volume_series(\n                ohlcv_data,\n                column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n                price_type=\"candlestick\",\n            )\n\n            # Add line chart with custom volume colors\n            chart.add_price_volume_series(\n                ohlcv_data,\n                price_type=\"line\",\n                volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n            )\n            ```\n        \"\"\"\n        # Validate inputs\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)) or (\n            isinstance(data, list) and len(data) == 0\n        ):\n            raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n        if column_mapping is None:\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n        if not isinstance(column_mapping, dict):\n            raise TypeValidationError(\"column_mapping\", \"dict\")\n\n        if pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n        price_kwargs = price_kwargs or {}\n        volume_kwargs = volume_kwargs or {}\n\n        # Price series (default price scale)\n        if price_type == \"candlestick\":\n            # Filter column mapping to only include OHLC fields for candlestick series\n            price_column_mapping = {\n                k: v\n                for k, v in column_mapping.items()\n                if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n            }\n            price_series = CandlestickSeries(\n                data=data,\n                column_mapping=price_column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n\n        elif price_type == \"line\":\n            price_series = LineSeries(\n                data=data,\n                column_mapping=column_mapping,\n                pane_id=pane_id,\n                price_scale_id=\"right\",\n                **price_kwargs,\n            )\n        else:\n            raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n        # Extract volume-specific kwargs\n        volume_up_color = volume_kwargs.get(\"up_color\", \"rgba(38,166,154,0.5)\")\n        volume_down_color = volume_kwargs.get(\"down_color\", \"rgba(239,83,80,0.5)\")\n        volume_base = volume_kwargs.get(\"base\", 0)\n\n        # Add overlay price scale\n        volume_price_scale = PriceScaleOptions(\n            visible=False,\n            auto_scale=True,\n            border_visible=False,\n            mode=PriceScaleMode.NORMAL,\n            scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n            price_scale_id=ColumnNames.VOLUME,\n        )\n        self.add_overlay_price_scale(ColumnNames.VOLUME, volume_price_scale)\n\n        # The volume series histogram expects a column called 'value'\n        if \"value\" not in column_mapping:\n            column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n        # Create histogram series\n        volume_series = HistogramSeries.create_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            up_color=volume_up_color,\n            down_color=volume_down_color,\n            pane_id=pane_id,\n            price_scale_id=ColumnNames.VOLUME,\n        )\n\n        # Set volume-specific properties\n        volume_series.base = volume_base\n        volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}\n\n        # Add both series to the chart\n        self.add_series(price_series)\n        self.add_series(volume_series)\n        return self\n\n    def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n        \"\"\"Add trade visualization to the chart.\n\n        Converts TradeData objects to visual elements and adds them to the chart for\n        visualization. Each trade will be displayed with entry and exit markers,\n        rectangles, lines, arrows, or zones based on the TradeVisualizationOptions.style\n        configuration. The visualization can include markers, rectangles, arrows, or\n        combinations depending on the style setting.\n\n        Args:\n            trades (List[TradeData]): List of TradeData objects to visualize on the chart.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.data import TradeData\n            from streamlit_lightweight_charts_pro.type_definitions.enums import TradeType\n\n            # Create TradeData objects\n            trades = [\n                TradeData(\n                    entry_time=\"2024-01-01 10:00:00\",\n                    entry_price=100.0,\n                    exit_time=\"2024-01-01 15:00:00\",\n                    exit_price=105.0,\n                    quantity=100,\n                    trade_type=TradeType.LONG,\n                )\n            ]\n\n            # Add trade visualization\n            chart.add_trade_visualization(trades)\n\n            # Method chaining\n            chart.add_trade_visualization(trades).update_options(height=600)\n            ```\n        \"\"\"\n        if trades is None:\n            raise TypeValidationError(\"trades\", \"list\")\n        if not isinstance(trades, list):\n            raise TypeValidationError(\"trades\", \"list\")\n\n        # Validate that all items are TradeData objects\n        for trade in trades:\n            if not isinstance(trade, TradeData):\n                raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n        # Store trades for frontend processing\n        self._trades = trades\n\n        # Check if we should add markers based on TradeVisualizationOptions style\n        # Note: Trade markers are now created in the frontend using templates\n        # The frontend createTradeMarkers() function handles marker generation\n        # based on TradeVisualizationOptions (entry_marker_template, exit_marker_template)\n        # This provides more flexibility and consistency with the template system\n\n        return self\n\n    def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n        \"\"\"Set the tooltip manager for the chart.\n\n        Args:\n            tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n        Returns:\n            Chart: Self for method chaining.\n        \"\"\"\n        if not isinstance(tooltip_manager, TooltipManager):\n            raise TypeValidationError(\"tooltip_manager\", \"TooltipManager instance\")\n\n        self._tooltip_manager = tooltip_manager\n        return self\n\n    def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n        \"\"\"Add a tooltip configuration to the chart.\n\n        Args:\n            name: Name for the tooltip configuration.\n            config: TooltipConfig instance.\n\n        Returns:\n            Chart: Self for method chaining.\n        \"\"\"\n        if not isinstance(config, TooltipConfig):\n            raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n        if self._tooltip_manager is None:\n            self._tooltip_manager = TooltipManager()\n\n        self._tooltip_manager.add_config(name, config)\n        return self\n\n    def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n        \"\"\"Set the chart group ID for synchronization.\n\n        Charts with the same group_id will be synchronized with each other.\n        This is different from sync_group which is used by ChartManager.\n\n        Args:\n            group_id (int): Group ID for synchronization.\n\n        Returns:\n            Chart: Self for method chaining.\n\n        Example:\n            ```python\n            # Set chart group ID\n            chart.set_chart_group_id(1)\n            ```\n        \"\"\"\n        self.chart_group_id = group_id\n        return self\n\n    @property\n    def chart_group_id(self) -&gt; int:\n        \"\"\"Get the chart group ID for synchronization.\n\n        Returns:\n            int: The chart group ID.\n\n        Example:\n            ```python\n            # Get chart group ID\n            group_id = chart.chart_group_id\n            ```\n        \"\"\"\n        return self._chart_group_id\n\n    @chart_group_id.setter\n    def chart_group_id(self, group_id: int) -&gt; None:\n        \"\"\"Set the chart group ID for synchronization.\n\n        Args:\n            group_id (int): Group ID for synchronization.\n\n        Example:\n            ```python\n            # Set chart group ID\n            chart.chart_group_id = 1\n            ```\n        \"\"\"\n        if not isinstance(group_id, int):\n            raise TypeValidationError(\"chart_group_id\", \"integer\")\n        self._chart_group_id = group_id\n\n    def _filter_range_switcher_by_data(self, chart_config: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Filter range switcher options based on available data timespan.\n\n        This method calculates the actual data timespan from all series and removes\n        range options that exceed the available data range. This provides a cleaner\n        user experience by only showing relevant time ranges.\n\n        Args:\n            chart_config: The chart configuration dictionary\n\n        Returns:\n            Dict[str, Any]: Modified chart configuration with filtered range options\n        \"\"\"\n        # Only process if range switcher is configured\n        if not (chart_config.get(\"rangeSwitcher\") and chart_config[\"rangeSwitcher\"].get(\"ranges\")):\n            return chart_config\n\n        # Calculate data timespan from all series\n        data_timespan_seconds = self._calculate_data_timespan()\n        if data_timespan_seconds is None:\n            return chart_config  # No data or unable to calculate, keep all ranges\n\n        # Filter ranges based on data timespan\n        original_ranges = chart_config[\"rangeSwitcher\"][\"ranges\"]\n        filtered_ranges = []\n\n        for range_config in original_ranges:\n            range_seconds = self._get_range_seconds(range_config)\n\n            # Keep range if:\n            # - It's \"All\" range (range_seconds is None)\n            # - It's within data timespan (with small buffer for edge cases)\n            if range_seconds is None or range_seconds &lt;= data_timespan_seconds * 1.1:\n                filtered_ranges.append(range_config)\n\n        # Update the chart config with filtered ranges\n        chart_config[\"rangeSwitcher\"][\"ranges\"] = filtered_ranges\n\n        return chart_config\n\n    def _calculate_data_timespan(self) -&gt; Optional[float]:\n        \"\"\"Calculate the timespan of data across all series in seconds.\"\"\"\n        min_time = None\n        max_time = None\n\n        for series in self.series:\n            if not hasattr(series, \"data\") or not series.data:\n                continue\n\n            for data_point in series.data:\n                time_value = None\n\n                # Extract time from various data formats\n                if hasattr(data_point, \"time\"):\n                    time_value = data_point.time\n                elif isinstance(data_point, dict) and \"time\" in data_point:\n                    time_value = data_point[\"time\"]\n\n                if time_value is None:\n                    continue\n\n                # Convert time to timestamp\n                timestamp = self._convert_time_to_timestamp(time_value)\n                if timestamp is None:\n                    continue\n\n                if min_time is None or timestamp &lt; min_time:\n                    min_time = timestamp\n                if max_time is None or timestamp &gt; max_time:\n                    max_time = timestamp\n\n        if min_time is None or max_time is None:\n            return None\n\n        return max_time - min_time\n\n    def _convert_time_to_timestamp(self, time_value) -&gt; Optional[float]:\n        \"\"\"Convert various time formats to timestamp.\"\"\"\n        if isinstance(time_value, (int, float)):\n            return float(time_value)\n        if isinstance(time_value, str):\n            try:\n                # Try parsing ISO format\n                dt = datetime.fromisoformat(time_value.replace(\"Z\", \"+00:00\"))\n                return dt.timestamp()\n            except (ValueError, AttributeError):\n                try:\n                    # Try parsing as date\n                    dt = datetime.strptime(time_value, \"%Y-%m-%d\")\n                    return dt.timestamp()\n                except ValueError:\n                    return None\n        elif hasattr(time_value, \"timestamp\"):\n            return time_value.timestamp()\n        return None\n\n    def _get_range_seconds(self, range_config: Dict[str, Any]) -&gt; Optional[float]:\n        \"\"\"Extract seconds from range configuration.\"\"\"\n        range_value = range_config.get(\"range\")\n\n        if range_value is None or range_value == \"ALL\":\n            return None\n\n        # Handle TimeRange enum values\n        range_seconds_map = {\n            \"FIVE_MINUTES\": 300,\n            \"FIFTEEN_MINUTES\": 900,\n            \"THIRTY_MINUTES\": 1800,\n            \"ONE_HOUR\": 3600,\n            \"FOUR_HOURS\": 14400,\n            \"ONE_DAY\": 86400,\n            \"ONE_WEEK\": 604800,\n            \"TWO_WEEKS\": 1209600,\n            \"ONE_MONTH\": 2592000,\n            \"THREE_MONTHS\": 7776000,\n            \"SIX_MONTHS\": 15552000,\n            \"ONE_YEAR\": 31536000,\n            \"TWO_YEARS\": 63072000,\n            \"FIVE_YEARS\": 157680000,\n        }\n\n        if isinstance(range_value, str) and range_value in range_seconds_map:\n            return range_seconds_map[range_value]\n        if isinstance(range_value, (int, float)):\n            return float(range_value)\n\n        return None\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert chart to frontend configuration dictionary.\n\n        Converts the chart and all its components (series, options, annotations)\n        to a dictionary format suitable for frontend consumption. This method\n        handles the serialization of all chart elements including series data,\n        chart options, price scales, and annotations.\n\n        Returns:\n            Dict[str, Any]: Complete chart configuration ready for frontend\n                rendering. The configuration includes:\n                - charts: List of chart objects with series and options\n                - syncConfig: Synchronization settings for multi-chart layouts\n\n        Note:\n            Series are automatically ordered by z-index within each pane to ensure\n            proper layering in the frontend. Series with lower z-index values\n            render behind series with higher z-index values.\n\n        Example:\n            ```python\n            # Get frontend configuration\n            config = chart.to_frontend_config()\n\n            # Access chart configuration\n            chart_config = config[\"charts\"][0]\n            series_config = chart_config[\"series\"]\n            options_config = chart_config[\"chart\"]\n            ```\n        \"\"\"\n        # Group series by pane_id and sort by z_index within each pane\n        # This ensures proper layering order in the frontend where:\n        # - Series are grouped by their pane_id first\n        # - Within each pane, series are sorted by z_index (ascending)\n        # - Lower z_index values render behind higher z_index values\n        # - Pane order is maintained in the final output\n        series_by_pane = {}\n        for series in self.series:\n            series_config = series.asdict()\n\n            # Handle case where asdict() returns invalid data\n            if not isinstance(series_config, dict):\n                logger.warning(\n                    \"Series %s returned invalid configuration from asdict(): %s. \"\n                    \"Skipping z-index ordering for this series.\",\n                    type(series).__name__,\n                    series_config,\n                )\n                # Add to default pane with default z-index\n                if 0 not in series_by_pane:\n                    series_by_pane[0] = []\n                series_by_pane[0].append(series_config)\n                continue\n\n            pane_id = series_config.get(\"paneId\", 0)  # Default to pane 0 if not specified\n\n            if pane_id not in series_by_pane:\n                series_by_pane[pane_id] = []\n\n            series_by_pane[pane_id].append(series_config)\n\n        # Sort series within each pane by z_index (lower values render first/behind)\n        for series_list in series_by_pane.values():\n            series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n        # Flatten sorted series back to a single list, maintaining pane order\n        series_configs = []\n        for pane_id in sorted(series_by_pane.keys()):\n            series_configs.extend(series_by_pane[pane_id])\n\n        chart_config = (\n            self.options.asdict() if self.options is not None else ChartOptions().asdict()\n        )\n        # Ensure rightPriceScale, PriceScaleOptions, PriceScaleOptionss are present and dicts\n        if self.options and self.options.right_price_scale is not None:\n            try:\n                chart_config[\"rightPriceScale\"] = self.options.right_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.options.right_price_scale.price_scale_id is not None and not isinstance(\n                    self.options.right_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"right_price_scale\",\n                        type(self.options.right_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.options.right_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"right_price_scale\",\n                        type(self.options.right_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.options.right_price_scale),\n                ) from e\n        if self.options and self.options.left_price_scale is not None:\n            try:\n                chart_config[\"leftPriceScale\"] = self.options.left_price_scale.asdict()\n                # Validate price scale ID is a string if provided\n                if self.options.left_price_scale.price_scale_id is not None and not isinstance(\n                    self.options.left_price_scale.price_scale_id,\n                    str,\n                ):\n                    raise PriceScaleIdTypeError(\n                        \"left_price_scale\",\n                        type(self.options.left_price_scale.price_scale_id),\n                    )\n            except AttributeError as e:\n                if isinstance(self.options.left_price_scale, bool):\n                    raise PriceScaleOptionsTypeError(\n                        \"left_price_scale\",\n                        type(self.options.left_price_scale),\n                    ) from e\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.options.left_price_scale),\n                ) from e\n\n        if self.options and self.options.overlay_price_scales is not None:\n            chart_config[\"overlayPriceScales\"] = {\n                k: v.asdict() if hasattr(v, \"asdict\") else v\n                for k, v in self.options.overlay_price_scales.items()\n            }\n\n        annotations_config = self.annotation_manager.asdict()\n\n        # Add trades to chart configuration if they exist\n        trades_config = None\n        if hasattr(self, \"_trades\") and self._trades:\n            trades_config = [trade.asdict() for trade in self._trades]\n\n        # Apply data-aware range filtering to remove ranges that exceed data timespan\n        chart_config = self._filter_range_switcher_by_data(chart_config)\n\n        chart_obj = {\n            \"chartId\": f\"chart-{id(self)}\",\n            \"chart\": chart_config,\n            \"series\": series_configs,\n            \"annotations\": annotations_config,\n        }\n\n        # Add trades to chart configuration if they exist\n        if trades_config:\n            chart_obj[\"trades\"] = trades_config\n\n            # Add trade visualization options if they exist\n            if self.options and self.options.trade_visualization:\n                chart_obj[\"tradeVisualizationOptions\"] = self.options.trade_visualization.asdict()\n\n        # Add tooltip configurations if they exist\n        if self._tooltip_manager:\n            tooltip_configs = {}\n            for name, config in self._tooltip_manager.configs.items():\n                tooltip_configs[name] = config.asdict()\n            chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n        # Add chart group ID for synchronization\n        chart_obj[\"chartGroupId\"] = self.chart_group_id\n\n        # Note: paneHeights is now accessed directly from chart.layout.paneHeights in frontend\n        config = {\n            \"charts\": [chart_obj],\n        }\n\n        # Add sync configuration if ChartManager reference is available\n        if self._chart_manager is not None:\n            # Get sync config directly from manager without calling to_frontend_config\n            # to avoid circular reference\n\n            # Check if this chart's group has sync enabled\n            chart_group_id = self.chart_group_id\n            group_sync_enabled = False\n            group_sync_config = None\n\n            if (\n                self._chart_manager.sync_groups\n                and str(chart_group_id) in self._chart_manager.sync_groups\n            ):\n                group_sync_config = self._chart_manager.sync_groups[str(chart_group_id)]\n                group_sync_enabled = group_sync_config.enabled\n\n            # Enable sync at top level if this chart's group has sync enabled\n            sync_enabled = self._chart_manager.default_sync.enabled or group_sync_enabled\n\n            sync_config = {\n                \"enabled\": sync_enabled,\n                \"crosshair\": self._chart_manager.default_sync.crosshair,\n                \"timeRange\": self._chart_manager.default_sync.time_range,\n            }\n\n            # Add group-specific sync configurations\n            if self._chart_manager.sync_groups:\n                sync_config[\"groups\"] = {}\n                for group_id, group_sync in self._chart_manager.sync_groups.items():\n                    sync_config[\"groups\"][str(group_id)] = {\n                        \"enabled\": group_sync.enabled,\n                        \"crosshair\": group_sync.crosshair,\n                        \"timeRange\": group_sync.time_range,\n                    }\n\n            config[\"syncConfig\"] = sync_config\n\n        return config\n\n    def render(self, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render the chart in Streamlit.\n\n        Converts the chart to frontend configuration and renders it using the\n        Streamlit component. This is the final step in the chart creation process\n        that displays the interactive chart in the Streamlit application.\n\n        Args:\n            key (Optional[str]): Optional unique key for the Streamlit component.\n                This key is used to identify the component instance and is useful\n                for debugging and component state management.\n\n        Returns:\n            Any: The rendered Streamlit component that displays the interactive chart.\n\n        Example:\n            ```python\n            # Basic rendering\n            chart.render()\n\n            # Rendering with custom key\n            chart.render(key=\"my_chart\")\n\n            # Method chaining with rendering\n            chart.add_series(line_series).update_options(height=600).render(key=\"chart1\")\n            ```\n        \"\"\"\n        # Generate a unique key if none provided or if it's empty/invalid\n        if key is None or not isinstance(key, str) or not key.strip():\n            # Generate a unique key using timestamp and UUID\n            unique_id = str(uuid.uuid4())[:8]\n            key = f\"chart_{int(time.time() * 1000)}_{unique_id}\"\n\n        # Store chart instance in session state to persist across reruns\n        session_key = f\"chart_instance_{key}\"\n        if session_key not in st.session_state:\n            st.session_state[session_key] = self\n        else:\n            # Update existing chart instance with current state\n            existing_chart = st.session_state[session_key]\n            existing_chart.series = self.series\n            existing_chart.options = self.options\n            existing_chart.annotation_manager = self.annotation_manager\n            existing_chart._trades = self._trades\n            existing_chart._tooltip_manager = self._tooltip_manager\n            existing_chart._chart_group_id = self._chart_group_id\n            existing_chart._chart_manager = self._chart_manager\n\n        # Use the persisted chart instance for rendering\n        chart_instance = st.session_state[session_key]\n        config = chart_instance.to_frontend_config()\n        component_func = get_component_func()\n\n        if component_func is None:\n            # Try to reinitialize the component\n\n            if reinitialize_component():\n                component_func = get_component_func()\n\n            if component_func is None:\n                raise ComponentNotAvailableError()\n\n        kwargs = {\"config\": config}\n\n        # Extract height and width from chart options and pass to frontend\n        if chart_instance.options:\n            if (\n                hasattr(chart_instance.options, \"height\")\n                and chart_instance.options.height is not None\n            ):\n                kwargs[\"height\"] = chart_instance.options.height\n            if (\n                hasattr(chart_instance.options, \"width\")\n                and chart_instance.options.width is not None\n            ):\n                kwargs[\"width\"] = chart_instance.options.width\n\n        kwargs[\"key\"] = key\n\n        # Initialize series settings API and register series\n        series_api = get_series_settings_api(key)\n\n        # Register all series with the API (assuming pane 0 for single-pane charts)\n        for _i, series in enumerate(chart_instance.series):\n            series_api.register_series(pane_id=0, series=series)\n\n        # Handle series settings API calls if they exist in the returned data\n        result = component_func(**kwargs)\n\n        if result and isinstance(result, dict):\n            chart_instance._handle_series_settings_response(result, series_api)\n\n        return result\n\n    def _handle_series_settings_response(self, response: dict, series_api) -&gt; None:\n        \"\"\"Handle series settings API responses from the frontend.\n\n        Args:\n            response: Response data from the frontend component\n            series_api: SeriesSettingsAPI instance for this chart\n        \"\"\"\n        try:\n            # Debug logging for all responses\n            logger.debug(\"Handling series settings response: %s\", response)\n\n            # Check for series settings API calls\n            if response.get(\"type\") == \"get_pane_state\":\n                pane_id = response.get(\"paneId\", 0)\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    pane_state = series_api.get_pane_state(pane_id)\n                    # Send response back to frontend via custom event\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": True, \"data\": pane_state})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n            elif response.get(\"type\") == \"update_series_settings\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                config = response.get(\"config\", {})\n                message_id = response.get(\"messageId\")\n\n                # Always update the settings\n                success = series_api.update_series_settings(pane_id, series_id, config)\n\n                # Only send response if messageId was provided\n                if message_id:\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n                # Log the update for debugging\n                elif success:\n                    logger.debug(\n                        \"Updated series settings for %s: %s\",\n                        series_id,\n                        config,\n                    )\n\n            elif response.get(\"type\") == \"reset_series_defaults\":\n                pane_id = response.get(\"paneId\", 0)\n                series_id = response.get(\"seriesId\", \"\")\n                message_id = response.get(\"messageId\")\n\n                if message_id:\n                    defaults = series_api.reset_series_to_defaults(pane_id, series_id)\n                    success = defaults is not None\n                    components.html(\n                        f\"\"\"\n                    &lt;script&gt;\n                    document.dispatchEvent(new CustomEvent('streamlit:apiResponse', {{\n                        detail: {{\n                            messageId: '{message_id}',\n                            response: {json.dumps({\"success\": success, \"data\": defaults or {}})}\n                        }}\n                    }}));\n                    &lt;/script&gt;\n                    \"\"\",\n                        height=0,\n                    )\n\n        except Exception as e:\n            logger.exception(\"Error handling series settings response\")\n\n    def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n        \"\"\"Get series information for the series settings dialog.\n\n        Args:\n            pane_id: The pane ID to get series info for (default: 0)\n\n        Returns:\n            List of series information dictionaries\n        \"\"\"\n        series_info = []\n\n        for i, series in enumerate(self.series):\n            # Get series ID\n            series_id = getattr(series, \"id\", f\"series_{i}\")\n\n            # Get display name\n            display_name = series_id\n            if hasattr(series, \"name\") and series.name:\n                display_name = series.name\n            elif hasattr(series, \"title\") and series.title:\n                display_name = series.title\n\n            # Get series type\n            series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n            series_info.append(\n                {\n                    \"id\": series_id,\n                    \"displayName\": display_name,\n                    \"type\": series_type,\n                },\n            )\n\n        return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.chart_group_id","title":"chart_group_id  <code>property</code> <code>writable</code>","text":"<pre><code>chart_group_id: int\n</code></pre> <p>Get the chart group ID for synchronization.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The chart group ID.</p> Example <pre><code># Get chart group ID\ngroup_id = chart.chart_group_id\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_series","title":"add_series","text":"<pre><code>add_series(series: Series) -&gt; Chart\n</code></pre> <p>Add a series to the chart.</p> <p>Adds a new series object to the chart's series list. The series will be displayed according to its type (line, candlestick, area, etc.) and configuration options. Automatically handles price scale configuration for custom price scale IDs.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series object to add to the chart. Must be an instance of a Series subclass (LineSeries, CandlestickSeries, etc.).</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>TypeValidationError</code> <p>If the series parameter is not an instance of Series.</p> Example <pre><code># Add a candlestick series\nchart.add_series(CandlestickSeries(ohlc_data))\n\n# Add a line series with custom options\nchart.add_series(LineSeries(data, line_options=LineOptions(color=\"red\")))\n\n# Method chaining\nchart.add_series(line_series).add_series(candlestick_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_series(self, series: Series) -&gt; \"Chart\":\n    \"\"\"Add a series to the chart.\n\n    Adds a new series object to the chart's series list. The series will be\n    displayed according to its type (line, candlestick, area, etc.) and\n    configuration options. Automatically handles price scale configuration\n    for custom price scale IDs.\n\n    Args:\n        series: Series object to add to the chart. Must be an instance of a\n            Series subclass (LineSeries, CandlestickSeries, etc.).\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Raises:\n        TypeValidationError: If the series parameter is not an instance of Series.\n\n    Example:\n        ```python\n        # Add a candlestick series\n        chart.add_series(CandlestickSeries(ohlc_data))\n\n        # Add a line series with custom options\n        chart.add_series(LineSeries(data, line_options=LineOptions(color=\"red\")))\n\n        # Method chaining\n        chart.add_series(line_series).add_series(candlestick_series)\n        ```\n    \"\"\"\n    # Validate input type to ensure it's a proper Series instance\n    if not isinstance(series, Series):\n        raise TypeValidationError(\"series\", \"Series instance\")\n\n    # Check for custom price scale configuration needs\n    # Extract price_scale_id from the series for validation\n    price_scale_id = series.price_scale_id\n\n    # Handle custom price scale setup\n    # Only process non-standard scale IDs (not default \"left\"/\"right\")\n    if (\n        price_scale_id\n        and price_scale_id not in [\"left\", \"right\", \"\"]\n        and price_scale_id not in self.options.overlay_price_scales\n    ):\n        # Log warning when series uses custom price scale without configuration\n        logger.warning(\n            \"Series with price_scale_id '%s' does not have a corresponding \"\n            \"overlay price scale configuration. Creating empty price scale object.\",\n            price_scale_id,\n        )\n        # Create basic price scale configuration for the custom ID\n        empty_scale = PriceScaleOptions(price_scale_id=price_scale_id)\n        self.options.overlay_price_scales[price_scale_id] = empty_scale\n\n    # Add the validated series to the chart's series collection\n    self.series.append(series)\n\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.update_options","title":"update_options","text":"<pre><code>update_options(**kwargs) -&gt; Chart\n</code></pre> <p>Update chart options.</p> <p>Updates the chart's configuration options using keyword arguments. Only valid ChartOptions attributes will be updated; invalid attributes are silently ignored to support method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Chart options to update. Valid options include: - width (Optional[int]): Chart width in pixels - height (int): Chart height in pixels - auto_size (bool): Whether to auto-size the chart - handle_scroll (bool): Whether to enable scroll interactions - handle_scale (bool): Whether to enable scale interactions - add_default_pane (bool): Whether to add a default pane</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Update basic options\nchart.update_options(height=600, width=800, auto_size=True)\n\n# Update interaction options\nchart.update_options(handle_scroll=True, handle_scale=False)\n\n# Method chaining\nchart.update_options(height=500).update_options(width=1000)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def update_options(self, **kwargs) -&gt; \"Chart\":\n    \"\"\"Update chart options.\n\n    Updates the chart's configuration options using keyword arguments.\n    Only valid ChartOptions attributes will be updated; invalid attributes\n    are silently ignored to support method chaining.\n\n    Args:\n        **kwargs: Chart options to update. Valid options include:\n            - width (Optional[int]): Chart width in pixels\n            - height (int): Chart height in pixels\n            - auto_size (bool): Whether to auto-size the chart\n            - handle_scroll (bool): Whether to enable scroll interactions\n            - handle_scale (bool): Whether to enable scale interactions\n            - add_default_pane (bool): Whether to add a default pane\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Update basic options\n        chart.update_options(height=600, width=800, auto_size=True)\n\n        # Update interaction options\n        chart.update_options(handle_scroll=True, handle_scale=False)\n\n        # Method chaining\n        chart.update_options(height=500).update_options(width=1000)\n        ```\n    \"\"\"\n    # Process each keyword argument to update chart options\n    for key, value in kwargs.items():\n        # Check that the attribute exists on options and value is not None\n        if value is not None and hasattr(self.options, key):\n            # Get the current attribute value for type checking\n            current_value = getattr(self.options, key)\n            # Validate that the new value type matches current attribute type\n            if isinstance(value, type(current_value)) or (\n                current_value is None and value is not None\n            ):\n                # Update the attribute with the validated value\n                setattr(self.options, key, value)\n        # Silently ignore None values to support method chaining\n    # Return self for method chaining\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(\n    annotation: Annotation, layer_name: str = \"default\"\n) -&gt; Chart\n</code></pre> <p>Add an annotation to the chart.</p> <p>Adds a single annotation to the specified annotation layer. If the layer doesn't exist, it will be created automatically. Annotations can include text, arrows, shapes, and other visual elements.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the chart.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\".</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Add text annotation\ntext_ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\nchart.add_annotation(text_ann)\n\n# Add annotation to custom layer\nchart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n# Method chaining\nchart.add_annotation(text_ann).add_annotation(arrow_ann)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotation(self, annotation: Annotation, layer_name: str = \"default\") -&gt; \"Chart\":\n    \"\"\"Add an annotation to the chart.\n\n    Adds a single annotation to the specified annotation layer. If the layer\n    doesn't exist, it will be created automatically. Annotations can include\n    text, arrows, shapes, and other visual elements.\n\n    Args:\n        annotation (Annotation): Annotation object to add to the chart.\n        layer_name (str, optional): Name of the annotation layer. Defaults to \"default\".\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Add text annotation\n        text_ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n        chart.add_annotation(text_ann)\n\n        # Add annotation to custom layer\n        chart.add_annotation(arrow_ann, layer_name=\"signals\")\n\n        # Method chaining\n        chart.add_annotation(text_ann).add_annotation(arrow_ann)\n        ```\n    \"\"\"\n    if annotation is None:\n        raise ValueValidationError(\"annotation\", \"cannot be None\")\n    if not isinstance(annotation, Annotation):\n        raise TypeValidationError(\"annotation\", \"Annotation instance\")\n\n    # Use default layer name if None is provided\n    if layer_name is None:\n        layer_name = \"default\"\n    elif not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    self.annotation_manager.add_annotation(annotation, layer_name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_annotations","title":"add_annotations","text":"<pre><code>add_annotations(\n    annotations: List[Annotation],\n    layer_name: str = \"default\",\n) -&gt; Chart\n</code></pre> <p>Add multiple annotations to the chart.</p> <p>Adds multiple annotation objects to the specified annotation layer. This is more efficient than calling add_annotation multiple times as it processes all annotations in a single operation.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects to add to the chart.</p> required <code>layer_name</code> <code>str</code> <p>Name of the annotation layer. Defaults to \"default\".</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Add multiple annotations at once\nannotations = [\n    create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n    create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n    create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n]\nchart.add_annotations(annotations)\n\n# Add to custom layer\nchart.add_annotations(annotations, layer_name=\"analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_annotations(\n    self,\n    annotations: List[Annotation],\n    layer_name: str = \"default\",\n) -&gt; \"Chart\":\n    \"\"\"Add multiple annotations to the chart.\n\n    Adds multiple annotation objects to the specified annotation layer. This\n    is more efficient than calling add_annotation multiple times as it\n    processes all annotations in a single operation.\n\n    Args:\n        annotations (List[Annotation]): List of annotation objects to add\n            to the chart.\n        layer_name (str, optional): Name of the annotation layer. Defaults to \"default\".\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Add multiple annotations at once\n        annotations = [\n            create_text_annotation(\"2024-01-01\", 100, \"Start\"),\n            create_arrow_annotation(\"2024-01-02\", 105, \"Trend\"),\n            create_shape_annotation(\"2024-01-03\", 110, \"rectangle\"),\n        ]\n        chart.add_annotations(annotations)\n\n        # Add to custom layer\n        chart.add_annotations(annotations, layer_name=\"analysis\")\n        ```\n    \"\"\"\n    if annotations is None:\n        raise TypeValidationError(\"annotations\", \"list\")\n    if not isinstance(annotations, list):\n        raise TypeValidationError(\"annotations\", \"list\")\n    if not layer_name or not isinstance(layer_name, str):\n        raise ValueValidationError(\"layer_name\", \"must be a non-empty string\")\n\n    for annotation in annotations:\n        if not isinstance(annotation, Annotation):\n            raise AnnotationItemsTypeError()\n        self.add_annotation(annotation, layer_name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.create_annotation_layer","title":"create_annotation_layer","text":"<pre><code>create_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new annotation layer with the specified name. Annotation layers allow you to organize and manage groups of annotations independently. Each layer can be shown, hidden, or cleared separately.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to create.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Create custom layers for different types of annotations\nchart.create_annotation_layer(\"signals\")\nchart.create_annotation_layer(\"analysis\")\nchart.create_annotation_layer(\"events\")\n\n# Method chaining\nchart.create_annotation_layer(\"layer1\").create_annotation_layer(\"layer2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def create_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new annotation layer with the specified name. Annotation layers\n    allow you to organize and manage groups of annotations independently.\n    Each layer can be shown, hidden, or cleared separately.\n\n    Args:\n        name (str): Name of the annotation layer to create.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Create custom layers for different types of annotations\n        chart.create_annotation_layer(\"signals\")\n        chart.create_annotation_layer(\"analysis\")\n        chart.create_annotation_layer(\"events\")\n\n        # Method chaining\n        chart.create_annotation_layer(\"layer1\").create_annotation_layer(\"layer2\")\n        ```\n    \"\"\"\n    if name is None:\n        raise TypeValidationError(\"name\", \"string\")\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n    self.annotation_manager.create_layer(name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.hide_annotation_layer","title":"hide_annotation_layer","text":"<pre><code>hide_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Hide an annotation layer.</p> <p>Hides the specified annotation layer, making all annotations in that layer invisible on the chart. The layer and its annotations are preserved and can be shown again using show_annotation_layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to hide.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Hide specific layers\nchart.hide_annotation_layer(\"analysis\")\nchart.hide_annotation_layer(\"signals\")\n\n# Method chaining\nchart.hide_annotation_layer(\"layer1\").hide_annotation_layer(\"layer2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def hide_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Hide an annotation layer.\n\n    Hides the specified annotation layer, making all annotations in that\n    layer invisible on the chart. The layer and its annotations are preserved\n    and can be shown again using show_annotation_layer.\n\n    Args:\n        name (str): Name of the annotation layer to hide.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Hide specific layers\n        chart.hide_annotation_layer(\"analysis\")\n        chart.hide_annotation_layer(\"signals\")\n\n        # Method chaining\n        chart.hide_annotation_layer(\"layer1\").hide_annotation_layer(\"layer2\")\n        ```\n    \"\"\"\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n    self.annotation_manager.hide_layer(name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.show_annotation_layer","title":"show_annotation_layer","text":"<pre><code>show_annotation_layer(name: str) -&gt; Chart\n</code></pre> <p>Show an annotation layer.</p> <p>Makes the specified annotation layer visible on the chart. This will display all annotations that were previously added to this layer. If the layer doesn't exist, this method will have no effect.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the annotation layer to show.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Show specific layers\nchart.show_annotation_layer(\"analysis\")\nchart.show_annotation_layer(\"signals\")\n\n# Method chaining\nchart.show_annotation_layer(\"layer1\").show_annotation_layer(\"layer2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def show_annotation_layer(self, name: str) -&gt; \"Chart\":\n    \"\"\"Show an annotation layer.\n\n    Makes the specified annotation layer visible on the chart. This will\n    display all annotations that were previously added to this layer.\n    If the layer doesn't exist, this method will have no effect.\n\n    Args:\n        name (str): Name of the annotation layer to show.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Show specific layers\n        chart.show_annotation_layer(\"analysis\")\n        chart.show_annotation_layer(\"signals\")\n\n        # Method chaining\n        chart.show_annotation_layer(\"layer1\").show_annotation_layer(\"layer2\")\n        ```\n    \"\"\"\n    if not name or not isinstance(name, str):\n        raise ValueValidationError(\"name\", \"must be a non-empty string\")\n    self.annotation_manager.show_layer(name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations(\n    layer_name: Optional[str] = None,\n) -&gt; Chart\n</code></pre> <p>Clear annotations from the chart.</p> <p>Removes all annotations from the specified layer or from all layers if no layer name is provided. The layer itself is preserved and can be reused for new annotations.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>Optional[str]</code> <p>Name of the layer to clear. If None, clears all layers. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Clear specific layer\nchart.clear_annotations(\"analysis\")\n\n# Clear all layers\nchart.clear_annotations()\n\n# Method chaining\nchart.clear_annotations(\"layer1\").add_annotation(new_annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def clear_annotations(self, layer_name: Optional[str] = None) -&gt; \"Chart\":\n    \"\"\"Clear annotations from the chart.\n\n    Removes all annotations from the specified layer or from all layers if\n    no layer name is provided. The layer itself is preserved and can be\n    reused for new annotations.\n\n    Args:\n        layer_name (Optional[str]): Name of the layer to clear. If None,\n            clears all layers. Defaults to None.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Clear specific layer\n        chart.clear_annotations(\"analysis\")\n\n        # Clear all layers\n        chart.clear_annotations()\n\n        # Method chaining\n        chart.clear_annotations(\"layer1\").add_annotation(new_annotation)\n        ```\n    \"\"\"\n    if layer_name is not None and (not layer_name or not isinstance(layer_name, str)):\n        raise ValueValidationError(\"layer_name\", \"must be None or a non-empty string\")\n    self.annotation_manager.clear_layer(layer_name)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_overlay_price_scale","title":"add_overlay_price_scale","text":"<pre><code>add_overlay_price_scale(\n    scale_id: str, options: PriceScaleOptions\n) -&gt; Chart\n</code></pre> <p>Add or update a custom overlay price scale configuration.</p> <p>Adds or updates an overlay price scale configuration for the chart. Overlay price scales allow multiple series to share the same price axis while maintaining independent scaling and positioning.</p> <p>Parameters:</p> Name Type Description Default <code>scale_id</code> <code>str</code> <p>The unique identifier for the custom price scale (e.g., 'volume', 'indicator1', 'overlay').</p> required <code>options</code> <code>PriceScaleOptions</code> <p>A PriceScaleOptions instance containing the configuration for the overlay price scale.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options.price_scale_options import (\n    PriceScaleOptions,\n)\n\n# Add volume overlay price scale\nvolume_scale = PriceScaleOptions(\n    visible=False,\n    scale_margin_top=0.8,\n    scale_margin_bottom=0,\n    overlay=True,\n    auto_scale=True\n)\nchart.add_overlay_price_scale('volume', volume_scale)\n\n# Method chaining\nchart.add_overlay_price_scale('indicator1', indicator_scale)                 .add_series(indicator_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_overlay_price_scale(self, scale_id: str, options: \"PriceScaleOptions\") -&gt; \"Chart\":\n    \"\"\"Add or update a custom overlay price scale configuration.\n\n    Adds or updates an overlay price scale configuration for the chart.\n    Overlay price scales allow multiple series to share the same price axis\n    while maintaining independent scaling and positioning.\n\n    Args:\n        scale_id (str): The unique identifier for the custom price scale\n            (e.g., 'volume', 'indicator1', 'overlay').\n        options (PriceScaleOptions): A PriceScaleOptions instance containing\n            the configuration for the overlay price scale.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options.price_scale_options import (\n            PriceScaleOptions,\n        )\n\n        # Add volume overlay price scale\n        volume_scale = PriceScaleOptions(\n            visible=False,\n            scale_margin_top=0.8,\n            scale_margin_bottom=0,\n            overlay=True,\n            auto_scale=True\n        )\n        chart.add_overlay_price_scale('volume', volume_scale)\n\n        # Method chaining\n        chart.add_overlay_price_scale('indicator1', indicator_scale) \\\n            .add_series(indicator_series)\n        ```\n    \"\"\"\n    if not scale_id or not isinstance(scale_id, str):\n        raise ValueValidationError(\"scale_id\", \"must be a non-empty string\")\n    if options is None:\n        raise TypeValidationError(\"options\", \"PriceScaleOptions\")\n    if not isinstance(options, PriceScaleOptions):\n        raise ValueValidationError(\"options\", \"must be a PriceScaleOptions instance\")\n\n    # Check for duplicate scale_id\n    if scale_id in self.options.overlay_price_scales:\n        raise DuplicateError(\"Price scale\", scale_id)\n\n    self.options.overlay_price_scales[scale_id] = options\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_price_volume_series","title":"add_price_volume_series","text":"<pre><code>add_price_volume_series(\n    data: Union[Sequence[OhlcvData], DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; Chart\n</code></pre> <p>Add price and volume series to the chart.</p> <p>Creates and adds both price and volume series to the chart from OHLCV data. The price series is displayed on the main price scale, while the volume series is displayed on a separate overlay price scale.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Defaults to None.</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line'). Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration. Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration. Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Add candlestick with volume\nchart.add_price_volume_series(\n    ohlcv_data,\n    column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n    price_type=\"candlestick\",\n)\n\n# Add line chart with custom volume colors\nchart.add_price_volume_series(\n    ohlcv_data,\n    price_type=\"line\",\n    volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_price_volume_series(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"Chart\":\n    \"\"\"Add price and volume series to the chart.\n\n    Creates and adds both price and volume series to the chart from OHLCV data.\n    The price series is displayed on the main price scale, while the volume\n    series is displayed on a separate overlay price scale.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Defaults to None.\n        price_type (str, optional): Type of price series ('candlestick' or 'line').\n            Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration. Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration. Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Add candlestick with volume\n        chart.add_price_volume_series(\n            ohlcv_data,\n            column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"},\n            price_type=\"candlestick\",\n        )\n\n        # Add line chart with custom volume colors\n        chart.add_price_volume_series(\n            ohlcv_data,\n            price_type=\"line\",\n            volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n        )\n        ```\n    \"\"\"\n    # Validate inputs\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)) or (\n        isinstance(data, list) and len(data) == 0\n    ):\n        raise ValueValidationError(\"data\", \"must be a non-empty list or DataFrame\")\n\n    if column_mapping is None:\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n    if not isinstance(column_mapping, dict):\n        raise TypeValidationError(\"column_mapping\", \"dict\")\n\n    if pane_id &lt; 0:\n        raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n\n    price_kwargs = price_kwargs or {}\n    volume_kwargs = volume_kwargs or {}\n\n    # Price series (default price scale)\n    if price_type == \"candlestick\":\n        # Filter column mapping to only include OHLC fields for candlestick series\n        price_column_mapping = {\n            k: v\n            for k, v in column_mapping.items()\n            if k in [\"time\", \"open\", \"high\", \"low\", \"close\"]\n        }\n        price_series = CandlestickSeries(\n            data=data,\n            column_mapping=price_column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n\n    elif price_type == \"line\":\n        price_series = LineSeries(\n            data=data,\n            column_mapping=column_mapping,\n            pane_id=pane_id,\n            price_scale_id=\"right\",\n            **price_kwargs,\n        )\n    else:\n        raise ValueValidationError(\"price_type\", \"must be 'candlestick' or 'line'\")\n\n    # Extract volume-specific kwargs\n    volume_up_color = volume_kwargs.get(\"up_color\", \"rgba(38,166,154,0.5)\")\n    volume_down_color = volume_kwargs.get(\"down_color\", \"rgba(239,83,80,0.5)\")\n    volume_base = volume_kwargs.get(\"base\", 0)\n\n    # Add overlay price scale\n    volume_price_scale = PriceScaleOptions(\n        visible=False,\n        auto_scale=True,\n        border_visible=False,\n        mode=PriceScaleMode.NORMAL,\n        scale_margins=PriceScaleMargins(top=0.8, bottom=0.0),\n        price_scale_id=ColumnNames.VOLUME,\n    )\n    self.add_overlay_price_scale(ColumnNames.VOLUME, volume_price_scale)\n\n    # The volume series histogram expects a column called 'value'\n    if \"value\" not in column_mapping:\n        column_mapping[\"value\"] = column_mapping[\"volume\"]\n\n    # Create histogram series\n    volume_series = HistogramSeries.create_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        up_color=volume_up_color,\n        down_color=volume_down_color,\n        pane_id=pane_id,\n        price_scale_id=ColumnNames.VOLUME,\n    )\n\n    # Set volume-specific properties\n    volume_series.base = volume_base\n    volume_series.price_format = {\"type\": \"volume\", \"precision\": 0}\n\n    # Add both series to the chart\n    self.add_series(price_series)\n    self.add_series(volume_series)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_trades","title":"add_trades","text":"<pre><code>add_trades(trades: List[TradeData]) -&gt; Chart\n</code></pre> <p>Add trade visualization to the chart.</p> <p>Converts TradeData objects to visual elements and adds them to the chart for visualization. Each trade will be displayed with entry and exit markers, rectangles, lines, arrows, or zones based on the TradeVisualizationOptions.style configuration. The visualization can include markers, rectangles, arrows, or combinations depending on the style setting.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>List[TradeData]</code> <p>List of TradeData objects to visualize on the chart.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import TradeData\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import TradeType\n\n# Create TradeData objects\ntrades = [\n    TradeData(\n        entry_time=\"2024-01-01 10:00:00\",\n        entry_price=100.0,\n        exit_time=\"2024-01-01 15:00:00\",\n        exit_price=105.0,\n        quantity=100,\n        trade_type=TradeType.LONG,\n    )\n]\n\n# Add trade visualization\nchart.add_trade_visualization(trades)\n\n# Method chaining\nchart.add_trade_visualization(trades).update_options(height=600)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_trades(self, trades: List[TradeData]) -&gt; \"Chart\":\n    \"\"\"Add trade visualization to the chart.\n\n    Converts TradeData objects to visual elements and adds them to the chart for\n    visualization. Each trade will be displayed with entry and exit markers,\n    rectangles, lines, arrows, or zones based on the TradeVisualizationOptions.style\n    configuration. The visualization can include markers, rectangles, arrows, or\n    combinations depending on the style setting.\n\n    Args:\n        trades (List[TradeData]): List of TradeData objects to visualize on the chart.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import TradeData\n        from streamlit_lightweight_charts_pro.type_definitions.enums import TradeType\n\n        # Create TradeData objects\n        trades = [\n            TradeData(\n                entry_time=\"2024-01-01 10:00:00\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01 15:00:00\",\n                exit_price=105.0,\n                quantity=100,\n                trade_type=TradeType.LONG,\n            )\n        ]\n\n        # Add trade visualization\n        chart.add_trade_visualization(trades)\n\n        # Method chaining\n        chart.add_trade_visualization(trades).update_options(height=600)\n        ```\n    \"\"\"\n    if trades is None:\n        raise TypeValidationError(\"trades\", \"list\")\n    if not isinstance(trades, list):\n        raise TypeValidationError(\"trades\", \"list\")\n\n    # Validate that all items are TradeData objects\n    for trade in trades:\n        if not isinstance(trade, TradeData):\n            raise ValueValidationError(\"trades\", \"all items must be TradeData objects\")\n\n    # Store trades for frontend processing\n    self._trades = trades\n\n    # Check if we should add markers based on TradeVisualizationOptions style\n    # Note: Trade markers are now created in the frontend using templates\n    # The frontend createTradeMarkers() function handles marker generation\n    # based on TradeVisualizationOptions (entry_marker_template, exit_marker_template)\n    # This provides more flexibility and consistency with the template system\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.set_tooltip_manager","title":"set_tooltip_manager","text":"<pre><code>set_tooltip_manager(tooltip_manager) -&gt; Chart\n</code></pre> <p>Set the tooltip manager for the chart.</p> <p>Parameters:</p> Name Type Description Default <code>tooltip_manager</code> <p>TooltipManager instance to handle tooltip functionality.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_tooltip_manager(self, tooltip_manager) -&gt; \"Chart\":\n    \"\"\"Set the tooltip manager for the chart.\n\n    Args:\n        tooltip_manager: TooltipManager instance to handle tooltip functionality.\n\n    Returns:\n        Chart: Self for method chaining.\n    \"\"\"\n    if not isinstance(tooltip_manager, TooltipManager):\n        raise TypeValidationError(\"tooltip_manager\", \"TooltipManager instance\")\n\n    self._tooltip_manager = tooltip_manager\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.add_tooltip_config","title":"add_tooltip_config","text":"<pre><code>add_tooltip_config(name: str, config) -&gt; Chart\n</code></pre> <p>Add a tooltip configuration to the chart.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the tooltip configuration.</p> required <code>config</code> <p>TooltipConfig instance.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def add_tooltip_config(self, name: str, config) -&gt; \"Chart\":\n    \"\"\"Add a tooltip configuration to the chart.\n\n    Args:\n        name: Name for the tooltip configuration.\n        config: TooltipConfig instance.\n\n    Returns:\n        Chart: Self for method chaining.\n    \"\"\"\n    if not isinstance(config, TooltipConfig):\n        raise TypeValidationError(\"config\", \"TooltipConfig instance\")\n\n    if self._tooltip_manager is None:\n        self._tooltip_manager = TooltipManager()\n\n    self._tooltip_manager.add_config(name, config)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.set_chart_group_id","title":"set_chart_group_id","text":"<pre><code>set_chart_group_id(group_id: int) -&gt; Chart\n</code></pre> <p>Set the chart group ID for synchronization.</p> <p>Charts with the same group_id will be synchronized with each other. This is different from sync_group which is used by ChartManager.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>int</code> <p>Group ID for synchronization.</p> required <p>Returns:</p> Name Type Description <code>Chart</code> <code>Chart</code> <p>Self for method chaining.</p> Example <pre><code># Set chart group ID\nchart.set_chart_group_id(1)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def set_chart_group_id(self, group_id: int) -&gt; \"Chart\":\n    \"\"\"Set the chart group ID for synchronization.\n\n    Charts with the same group_id will be synchronized with each other.\n    This is different from sync_group which is used by ChartManager.\n\n    Args:\n        group_id (int): Group ID for synchronization.\n\n    Returns:\n        Chart: Self for method chaining.\n\n    Example:\n        ```python\n        # Set chart group ID\n        chart.set_chart_group_id(1)\n        ```\n    \"\"\"\n    self.chart_group_id = group_id\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert chart to frontend configuration dictionary.</p> <p>Converts the chart and all its components (series, options, annotations) to a dictionary format suitable for frontend consumption. This method handles the serialization of all chart elements including series data, chart options, price scales, and annotations.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Complete chart configuration ready for frontend rendering. The configuration includes: - charts: List of chart objects with series and options - syncConfig: Synchronization settings for multi-chart layouts</p> Note <p>Series are automatically ordered by z-index within each pane to ensure proper layering in the frontend. Series with lower z-index values render behind series with higher z-index values.</p> Example <pre><code># Get frontend configuration\nconfig = chart.to_frontend_config()\n\n# Access chart configuration\nchart_config = config[\"charts\"][0]\nseries_config = chart_config[\"series\"]\noptions_config = chart_config[\"chart\"]\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert chart to frontend configuration dictionary.\n\n    Converts the chart and all its components (series, options, annotations)\n    to a dictionary format suitable for frontend consumption. This method\n    handles the serialization of all chart elements including series data,\n    chart options, price scales, and annotations.\n\n    Returns:\n        Dict[str, Any]: Complete chart configuration ready for frontend\n            rendering. The configuration includes:\n            - charts: List of chart objects with series and options\n            - syncConfig: Synchronization settings for multi-chart layouts\n\n    Note:\n        Series are automatically ordered by z-index within each pane to ensure\n        proper layering in the frontend. Series with lower z-index values\n        render behind series with higher z-index values.\n\n    Example:\n        ```python\n        # Get frontend configuration\n        config = chart.to_frontend_config()\n\n        # Access chart configuration\n        chart_config = config[\"charts\"][0]\n        series_config = chart_config[\"series\"]\n        options_config = chart_config[\"chart\"]\n        ```\n    \"\"\"\n    # Group series by pane_id and sort by z_index within each pane\n    # This ensures proper layering order in the frontend where:\n    # - Series are grouped by their pane_id first\n    # - Within each pane, series are sorted by z_index (ascending)\n    # - Lower z_index values render behind higher z_index values\n    # - Pane order is maintained in the final output\n    series_by_pane = {}\n    for series in self.series:\n        series_config = series.asdict()\n\n        # Handle case where asdict() returns invalid data\n        if not isinstance(series_config, dict):\n            logger.warning(\n                \"Series %s returned invalid configuration from asdict(): %s. \"\n                \"Skipping z-index ordering for this series.\",\n                type(series).__name__,\n                series_config,\n            )\n            # Add to default pane with default z-index\n            if 0 not in series_by_pane:\n                series_by_pane[0] = []\n            series_by_pane[0].append(series_config)\n            continue\n\n        pane_id = series_config.get(\"paneId\", 0)  # Default to pane 0 if not specified\n\n        if pane_id not in series_by_pane:\n            series_by_pane[pane_id] = []\n\n        series_by_pane[pane_id].append(series_config)\n\n    # Sort series within each pane by z_index (lower values render first/behind)\n    for series_list in series_by_pane.values():\n        series_list.sort(key=lambda x: x.get(\"zIndex\", 0) if isinstance(x, dict) else 0)\n\n    # Flatten sorted series back to a single list, maintaining pane order\n    series_configs = []\n    for pane_id in sorted(series_by_pane.keys()):\n        series_configs.extend(series_by_pane[pane_id])\n\n    chart_config = (\n        self.options.asdict() if self.options is not None else ChartOptions().asdict()\n    )\n    # Ensure rightPriceScale, PriceScaleOptions, PriceScaleOptionss are present and dicts\n    if self.options and self.options.right_price_scale is not None:\n        try:\n            chart_config[\"rightPriceScale\"] = self.options.right_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.options.right_price_scale.price_scale_id is not None and not isinstance(\n                self.options.right_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"right_price_scale\",\n                    type(self.options.right_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.options.right_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.options.right_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"right_price_scale\",\n                type(self.options.right_price_scale),\n            ) from e\n    if self.options and self.options.left_price_scale is not None:\n        try:\n            chart_config[\"leftPriceScale\"] = self.options.left_price_scale.asdict()\n            # Validate price scale ID is a string if provided\n            if self.options.left_price_scale.price_scale_id is not None and not isinstance(\n                self.options.left_price_scale.price_scale_id,\n                str,\n            ):\n                raise PriceScaleIdTypeError(\n                    \"left_price_scale\",\n                    type(self.options.left_price_scale.price_scale_id),\n                )\n        except AttributeError as e:\n            if isinstance(self.options.left_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.options.left_price_scale),\n                ) from e\n            raise PriceScaleOptionsTypeError(\n                \"left_price_scale\",\n                type(self.options.left_price_scale),\n            ) from e\n\n    if self.options and self.options.overlay_price_scales is not None:\n        chart_config[\"overlayPriceScales\"] = {\n            k: v.asdict() if hasattr(v, \"asdict\") else v\n            for k, v in self.options.overlay_price_scales.items()\n        }\n\n    annotations_config = self.annotation_manager.asdict()\n\n    # Add trades to chart configuration if they exist\n    trades_config = None\n    if hasattr(self, \"_trades\") and self._trades:\n        trades_config = [trade.asdict() for trade in self._trades]\n\n    # Apply data-aware range filtering to remove ranges that exceed data timespan\n    chart_config = self._filter_range_switcher_by_data(chart_config)\n\n    chart_obj = {\n        \"chartId\": f\"chart-{id(self)}\",\n        \"chart\": chart_config,\n        \"series\": series_configs,\n        \"annotations\": annotations_config,\n    }\n\n    # Add trades to chart configuration if they exist\n    if trades_config:\n        chart_obj[\"trades\"] = trades_config\n\n        # Add trade visualization options if they exist\n        if self.options and self.options.trade_visualization:\n            chart_obj[\"tradeVisualizationOptions\"] = self.options.trade_visualization.asdict()\n\n    # Add tooltip configurations if they exist\n    if self._tooltip_manager:\n        tooltip_configs = {}\n        for name, config in self._tooltip_manager.configs.items():\n            tooltip_configs[name] = config.asdict()\n        chart_obj[\"tooltipConfigs\"] = tooltip_configs\n\n    # Add chart group ID for synchronization\n    chart_obj[\"chartGroupId\"] = self.chart_group_id\n\n    # Note: paneHeights is now accessed directly from chart.layout.paneHeights in frontend\n    config = {\n        \"charts\": [chart_obj],\n    }\n\n    # Add sync configuration if ChartManager reference is available\n    if self._chart_manager is not None:\n        # Get sync config directly from manager without calling to_frontend_config\n        # to avoid circular reference\n\n        # Check if this chart's group has sync enabled\n        chart_group_id = self.chart_group_id\n        group_sync_enabled = False\n        group_sync_config = None\n\n        if (\n            self._chart_manager.sync_groups\n            and str(chart_group_id) in self._chart_manager.sync_groups\n        ):\n            group_sync_config = self._chart_manager.sync_groups[str(chart_group_id)]\n            group_sync_enabled = group_sync_config.enabled\n\n        # Enable sync at top level if this chart's group has sync enabled\n        sync_enabled = self._chart_manager.default_sync.enabled or group_sync_enabled\n\n        sync_config = {\n            \"enabled\": sync_enabled,\n            \"crosshair\": self._chart_manager.default_sync.crosshair,\n            \"timeRange\": self._chart_manager.default_sync.time_range,\n        }\n\n        # Add group-specific sync configurations\n        if self._chart_manager.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self._chart_manager.sync_groups.items():\n                sync_config[\"groups\"][str(group_id)] = {\n                    \"enabled\": group_sync.enabled,\n                    \"crosshair\": group_sync.crosshair,\n                    \"timeRange\": group_sync.time_range,\n                }\n\n        config[\"syncConfig\"] = sync_config\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.render","title":"render","text":"<pre><code>render(key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart in Streamlit.</p> <p>Converts the chart to frontend configuration and renders it using the Streamlit component. This is the final step in the chart creation process that displays the interactive chart in the Streamlit application.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional unique key for the Streamlit component. This key is used to identify the component instance and is useful for debugging and component state management.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The rendered Streamlit component that displays the interactive chart.</p> Example <pre><code># Basic rendering\nchart.render()\n\n# Rendering with custom key\nchart.render(key=\"my_chart\")\n\n# Method chaining with rendering\nchart.add_series(line_series).update_options(height=600).render(key=\"chart1\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def render(self, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render the chart in Streamlit.\n\n    Converts the chart to frontend configuration and renders it using the\n    Streamlit component. This is the final step in the chart creation process\n    that displays the interactive chart in the Streamlit application.\n\n    Args:\n        key (Optional[str]): Optional unique key for the Streamlit component.\n            This key is used to identify the component instance and is useful\n            for debugging and component state management.\n\n    Returns:\n        Any: The rendered Streamlit component that displays the interactive chart.\n\n    Example:\n        ```python\n        # Basic rendering\n        chart.render()\n\n        # Rendering with custom key\n        chart.render(key=\"my_chart\")\n\n        # Method chaining with rendering\n        chart.add_series(line_series).update_options(height=600).render(key=\"chart1\")\n        ```\n    \"\"\"\n    # Generate a unique key if none provided or if it's empty/invalid\n    if key is None or not isinstance(key, str) or not key.strip():\n        # Generate a unique key using timestamp and UUID\n        unique_id = str(uuid.uuid4())[:8]\n        key = f\"chart_{int(time.time() * 1000)}_{unique_id}\"\n\n    # Store chart instance in session state to persist across reruns\n    session_key = f\"chart_instance_{key}\"\n    if session_key not in st.session_state:\n        st.session_state[session_key] = self\n    else:\n        # Update existing chart instance with current state\n        existing_chart = st.session_state[session_key]\n        existing_chart.series = self.series\n        existing_chart.options = self.options\n        existing_chart.annotation_manager = self.annotation_manager\n        existing_chart._trades = self._trades\n        existing_chart._tooltip_manager = self._tooltip_manager\n        existing_chart._chart_group_id = self._chart_group_id\n        existing_chart._chart_manager = self._chart_manager\n\n    # Use the persisted chart instance for rendering\n    chart_instance = st.session_state[session_key]\n    config = chart_instance.to_frontend_config()\n    component_func = get_component_func()\n\n    if component_func is None:\n        # Try to reinitialize the component\n\n        if reinitialize_component():\n            component_func = get_component_func()\n\n        if component_func is None:\n            raise ComponentNotAvailableError()\n\n    kwargs = {\"config\": config}\n\n    # Extract height and width from chart options and pass to frontend\n    if chart_instance.options:\n        if (\n            hasattr(chart_instance.options, \"height\")\n            and chart_instance.options.height is not None\n        ):\n            kwargs[\"height\"] = chart_instance.options.height\n        if (\n            hasattr(chart_instance.options, \"width\")\n            and chart_instance.options.width is not None\n        ):\n            kwargs[\"width\"] = chart_instance.options.width\n\n    kwargs[\"key\"] = key\n\n    # Initialize series settings API and register series\n    series_api = get_series_settings_api(key)\n\n    # Register all series with the API (assuming pane 0 for single-pane charts)\n    for _i, series in enumerate(chart_instance.series):\n        series_api.register_series(pane_id=0, series=series)\n\n    # Handle series settings API calls if they exist in the returned data\n    result = component_func(**kwargs)\n\n    if result and isinstance(result, dict):\n        chart_instance._handle_series_settings_response(result, series_api)\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart.Chart.get_series_info_for_pane","title":"get_series_info_for_pane","text":"<pre><code>get_series_info_for_pane(_pane_id: int = 0) -&gt; List[dict]\n</code></pre> <p>Get series information for the series settings dialog.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <p>The pane ID to get series info for (default: 0)</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of series information dictionaries</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart.py</code> <pre><code>def get_series_info_for_pane(self, _pane_id: int = 0) -&gt; List[dict]:\n    \"\"\"Get series information for the series settings dialog.\n\n    Args:\n        pane_id: The pane ID to get series info for (default: 0)\n\n    Returns:\n        List of series information dictionaries\n    \"\"\"\n    series_info = []\n\n    for i, series in enumerate(self.series):\n        # Get series ID\n        series_id = getattr(series, \"id\", f\"series_{i}\")\n\n        # Get display name\n        display_name = series_id\n        if hasattr(series, \"name\") and series.name:\n            display_name = series.name\n        elif hasattr(series, \"title\") and series.title:\n            display_name = series.title\n\n        # Get series type\n        series_type = series.__class__.__name__.lower().replace(\"series\", \"\")\n\n        series_info.append(\n            {\n                \"id\": series_id,\n                \"displayName\": display_name,\n                \"type\": series_type,\n            },\n        )\n\n    return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart.html#streamlit_lightweight_charts_pro.charts.chart-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html","title":"streamlit_lightweight_charts_pro.charts.chart_manager","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager","title":"chart_manager","text":"<p>Chart Manager Module for managing multiple synchronized charts.</p> <p>This module provides the ChartManager class for managing multiple Chart instances with synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> The module includes <ul> <li>ChartManager: Main class for managing multiple charts</li> <li>Chart synchronization and group management</li> <li>Batch rendering and configuration capabilities</li> <li>Cross-chart communication and state management</li> </ul> Key Features <ul> <li>Multiple chart management with unique identifiers</li> <li>Synchronization groups for coordinated chart behavior</li> <li>Crosshair and time range synchronization</li> <li>Batch rendering with consistent configuration</li> <li>Chart lifecycle management (add, remove, update)</li> <li>Automatic sync group assignment and management</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager and add charts\nmanager = ChartManager()\n\n# Create data for multiple charts\ndata1 = [SingleValueData(\"2024-01-01\", 100), SingleValueData(\"2024-01-02\", 105)]\ndata2 = [SingleValueData(\"2024-01-01\", 200), SingleValueData(\"2024-01-02\", 195)]\n\n# Add charts to manager\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render synchronized charts\nmanager.render_all_charts()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager","title":"ChartManager","text":"<p>Manager for multiple synchronized charts.</p> <p>This class provides comprehensive functionality to manage multiple Chart instances with advanced synchronization capabilities. It enables coordinated display of multiple charts with shared time ranges, crosshair synchronization, and group-based configuration management.</p> <p>The ChartManager maintains a registry of charts with unique identifiers and manages synchronization groups that allow charts to share crosshair position, time ranges, and other interactive states. This is particularly useful for creating multi-pane financial dashboards with coordinated chart behavior.</p> <p>Attributes:</p> Name Type Description <code>charts</code> <code>Dict[str, Chart]</code> <p>Dictionary mapping chart IDs to Chart instances.</p> <code>sync_groups</code> <code>Dict[str, SyncOptions]</code> <p>Dictionary mapping chart IDs to their synchronization group options.</p> <code>default_sync</code> <code>SyncOptions</code> <p>Default synchronization options applied to new charts when no specific group is assigned.</p> Example <pre><code>from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create manager\nmanager = ChartManager()\n\n# Add charts with unique IDs\nmanager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\nmanager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n# Configure synchronization groups\nmanager.set_sync_group(\"price_chart\", \"main_group\")\nmanager.set_sync_group(\"volume_chart\", \"main_group\")\n\n# Render all charts with synchronization\nmanager.render_all_charts()\n</code></pre> Note <ul> <li>Charts must have unique IDs within the manager</li> <li>Synchronization groups allow coordinated behavior between charts</li> <li>Individual charts can be rendered or all charts can be rendered together</li> <li>The manager handles component lifecycle and state management</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>class ChartManager:\n    \"\"\"Manager for multiple synchronized charts.\n\n    This class provides comprehensive functionality to manage multiple Chart instances\n    with advanced synchronization capabilities. It enables coordinated display of\n    multiple charts with shared time ranges, crosshair synchronization, and group-based\n    configuration management.\n\n    The ChartManager maintains a registry of charts with unique identifiers and\n    manages synchronization groups that allow charts to share crosshair position,\n    time ranges, and other interactive states. This is particularly useful for\n    creating multi-pane financial dashboards with coordinated chart behavior.\n\n    Attributes:\n        charts (Dict[str, Chart]): Dictionary mapping chart IDs to Chart instances.\n        sync_groups (Dict[str, SyncOptions]): Dictionary mapping chart IDs to their\n            synchronization group options.\n        default_sync (SyncOptions): Default synchronization options applied to\n            new charts when no specific group is assigned.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import ChartManager, Chart, LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create manager\n        manager = ChartManager()\n\n        # Add charts with unique IDs\n        manager.add_chart(Chart(series=LineSeries(data1)), \"price_chart\")\n        manager.add_chart(Chart(series=LineSeries(data2)), \"volume_chart\")\n\n        # Configure synchronization groups\n        manager.set_sync_group(\"price_chart\", \"main_group\")\n        manager.set_sync_group(\"volume_chart\", \"main_group\")\n\n        # Render all charts with synchronization\n        manager.render_all_charts()\n        ```\n\n    Note:\n        - Charts must have unique IDs within the manager\n        - Synchronization groups allow coordinated behavior between charts\n        - Individual charts can be rendered or all charts can be rendered together\n        - The manager handles component lifecycle and state management\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the ChartManager.\n\n        Creates a new ChartManager with empty chart registry and default\n        synchronization settings. The manager starts with no charts and uses\n        default sync options for new charts.\n        \"\"\"\n        # Initialize chart registry - maps chart IDs to Chart instances\n        self.charts: Dict[str, Chart] = {}\n\n        # Initialize sync groups - maps chart IDs to their sync configuration\n        self.sync_groups: Dict[str, SyncOptions] = {}\n\n        # Set default sync options for new charts without specific group assignment\n        self.default_sync: SyncOptions = SyncOptions()\n\n    def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n        \"\"\"Add a chart to the manager.\n\n        Adds a Chart instance to the manager with a unique identifier. The chart\n        is registered in the manager's chart registry and can participate in\n        synchronization groups. If no chart ID is provided, one is automatically\n        generated.\n\n        Args:\n            chart (Chart): The Chart instance to add to the manager.\n            chart_id (Optional[str]): Optional unique identifier for the chart.\n                If not provided, an auto-generated ID in the format \"chart_N\"\n                will be assigned.\n\n        Returns:\n            ChartManager: Self for method chaining.\n\n        Raises:\n            DuplicateError: If a chart with the specified ID already exists.\n\n        Example:\n            ```python\n            manager = ChartManager()\n            chart = Chart(series=LineSeries(data))\n\n            # Add chart with auto-generated ID\n            manager.add_chart(chart)\n\n            # Add chart with custom ID\n            manager.add_chart(chart, \"price_chart\")\n            ```\n        \"\"\"\n        # Generate unique chart ID if not provided\n        if chart_id is None:\n            chart_id = f\"chart_{len(self.charts) + 1}\"\n\n        # Validate that chart ID is unique within the manager\n        if chart_id in self.charts:\n            raise DuplicateError(\"Chart\", chart_id)\n\n        # Set the ChartManager reference on the chart for bidirectional communication\n        # This allows the chart to access manager configuration and sync settings\n        chart._chart_manager = self\n\n        # Add chart to the registry with its unique identifier\n        self.charts[chart_id] = chart\n        return self\n\n    def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n        \"\"\"Remove a chart from the manager.\n\n        Args:\n            chart_id: ID of the chart to remove\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        del self.charts[chart_id]\n        return self\n\n    def get_chart(self, chart_id: str) -&gt; Chart:\n        \"\"\"Get a chart by ID.\n\n        Args:\n            chart_id: ID of the chart to retrieve\n\n        Returns:\n            The Chart instance\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        return self.charts[chart_id]\n\n    def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n        This method renders a single chart while preserving the ChartManager's\n        sync configuration and group settings. This ensures that individual\n        charts can still participate in group synchronization.\n\n        Args:\n            chart_id: The ID of the chart to render\n            key: Optional key for the Streamlit component\n\n        Returns:\n            The rendered component\n\n        Raises:\n            ValueError: If chart_id is not found\n\n        Example:\n            ```python\n            manager = ChartManager()\n            manager.add_chart(chart1, \"chart1\")\n            manager.add_chart(chart2, \"chart2\")\n\n            col1, col2 = st.columns(2)\n            with col1:\n                manager.render_chart(\"chart1\")\n            with col2:\n                manager.render_chart(\"chart2\")\n            ```\n        \"\"\"\n        if chart_id not in self.charts:\n            raise NotFoundError(\"Chart\", chart_id)\n\n        # Get the chart and render it (sync config is automatically included)\n        chart = self.charts[chart_id]\n        return chart.render(key=key)\n\n    def get_chart_ids(self) -&gt; List[str]:\n        \"\"\"Get all chart IDs.\n\n        Returns:\n            List of chart IDs\n        \"\"\"\n        return list(self.charts.keys())\n\n    def clear_charts(self) -&gt; \"ChartManager\":\n        \"\"\"Remove all charts from the manager.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self.charts.clear()\n        return self\n\n    def set_sync_group_config(\n        self,\n        group_id: Union[int, str],\n        sync_options: SyncOptions,\n    ) -&gt; \"ChartManager\":\n        \"\"\"Set synchronization configuration for a specific group.\n\n        Args:\n            group_id: The sync group ID (int or str)\n            sync_options: The sync configuration for this group\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self.sync_groups[str(group_id)] = sync_options\n        return self\n\n    def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n        \"\"\"Get synchronization configuration for a specific group.\n\n        Args:\n            group_id: The sync group ID (int or str)\n\n        Returns:\n            The sync configuration for the group, or None if not found\n        \"\"\"\n        return self.sync_groups.get(str(group_id))\n\n    def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable crosshair synchronization.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_crosshair()\n        else:\n            self.default_sync.enable_crosshair()\n        return self\n\n    def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable crosshair synchronization.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_crosshair()\n        else:\n            self.default_sync.disable_crosshair()\n        return self\n\n    def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable time range synchronization.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_time_range()\n        else:\n            self.default_sync.enable_time_range()\n        return self\n\n    def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable time range synchronization.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_time_range()\n        else:\n            self.default_sync.disable_time_range()\n        return self\n\n    def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Enable all synchronization features.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key not in self.sync_groups:\n                self.sync_groups[group_key] = SyncOptions()\n            self.sync_groups[group_key].enable_all()\n        else:\n            self.default_sync.enable_all()\n        return self\n\n    def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n        \"\"\"Disable all synchronization features.\n\n        Args:\n            group_id: Optional group ID. If None, applies to default sync\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if group_id:\n            group_key = str(group_id)\n            if group_key in self.sync_groups:\n                self.sync_groups[group_key].disable_all()\n        else:\n            self.default_sync.disable_all()\n        return self\n\n    def from_price_volume_dataframe(\n        self,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: Optional[dict] = None,\n        price_type: str = \"candlestick\",\n        chart_id: str = \"main_chart\",\n        price_kwargs=None,\n        volume_kwargs=None,\n        pane_id: int = 0,\n    ) -&gt; \"ChartManager\":\n        \"\"\"Create a chart from OHLCV data with price and volume series.\n\n        Factory method that creates a new Chart instance with both price and volume\n        series from OHLCV data. This is a convenient way to create a complete\n        price-volume chart in a single operation.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n                price and volume information.\n            column_mapping (dict, optional): Mapping of column names for DataFrame\n                conversion. Defaults to None.\n            price_type (str, optional): Type of price series ('candlestick' or 'line').\n                Defaults to \"candlestick\".\n            price_kwargs (dict, optional): Additional arguments for price series\n                configuration. Defaults to None.\n            volume_kwargs (dict, optional): Additional arguments for volume series\n                configuration. Defaults to None.\n            pane_id (int, optional): Pane ID for both price and volume series.\n                Defaults to 0.\n\n        Returns:\n            Chart: A new Chart instance with price and volume series.\n\n        Example:\n            ```python\n            # Create chart from DataFrame\n            chart = Chart.from_price_volume_dataframe(\n                df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n            )\n\n            # Create chart from OHLCV data\n            chart = Chart.from_price_volume_dataframe(\n                ohlcv_data,\n                price_type=\"line\",\n                volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n            )\n            ```\n        \"\"\"\n        if data is None:\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n        if not isinstance(data, (list, pd.DataFrame)):\n            raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n        chart = Chart()\n        chart.add_price_volume_series(\n            data=data,\n            column_mapping=column_mapping,\n            price_type=price_type,\n            price_kwargs=price_kwargs,\n            volume_kwargs=volume_kwargs,\n            pane_id=pane_id,\n        )\n\n        # Set the ChartManager reference on the chart\n        chart._chart_manager = self\n\n        # Add the chart to the manager with an ID\n        self.add_chart(chart, chart_id=chart_id)\n\n        return chart\n\n    def to_frontend_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the chart manager to frontend configuration.\n\n        Returns:\n            Dictionary containing the frontend configuration\n        \"\"\"\n        if not self.charts:\n            return {\n                \"charts\": [],\n                \"syncConfig\": self.default_sync.asdict(),\n            }\n\n        chart_configs = []\n        for chart_id, chart in self.charts.items():\n            chart_config = chart.to_frontend_config()\n            if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n                chart_obj = chart_config[\"charts\"][0]\n                chart_obj[\"chartId\"] = chart_id\n                chart_configs.append(chart_obj)\n            else:\n                # Skip charts with invalid configuration\n                continue\n\n        # Build sync configuration\n        sync_config = self.default_sync.asdict()\n\n        # Add group-specific sync configurations\n        if self.sync_groups:\n            sync_config[\"groups\"] = {}\n            for group_id, group_sync in self.sync_groups.items():\n                sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n        return {\n            \"charts\": chart_configs,\n            \"syncConfig\": sync_config,\n        }\n\n    def render(self, key: Optional[str] = None) -&gt; Any:\n        \"\"\"Render the chart manager.\n\n        Args:\n            key: Optional key for the Streamlit component\n\n        Returns:\n            The rendered component\n        \"\"\"\n        if not self.charts:\n            raise RuntimeError()\n\n        config = self.to_frontend_config()\n        component_func = get_component_func()\n\n        if component_func is None:\n            if reinitialize_component():\n                component_func = get_component_func()\n            if component_func is None:\n                raise ComponentNotAvailableError()\n\n        kwargs = {\"config\": config}\n        if key is None or not isinstance(key, str) or not key.strip():\n            unique_id = str(uuid.uuid4())[:8]\n            key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n        kwargs[\"key\"] = key\n        return component_func(**kwargs)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of charts in the manager.\"\"\"\n        return len(self.charts)\n\n    def __contains__(self, chart_id: str) -&gt; bool:\n        \"\"\"Check if a chart ID exists in the manager.\"\"\"\n        return chart_id in self.charts\n\n    def __iter__(self):\n        \"\"\"Iterate over chart IDs in the manager.\"\"\"\n        return iter(self.charts.keys())\n\n    def keys(self):\n        \"\"\"Return chart IDs in the manager.\"\"\"\n        return self.charts.keys()\n\n    def values(self):\n        \"\"\"Return chart instances in the manager.\"\"\"\n        return self.charts.values()\n\n    def items(self):\n        \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n        return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.add_chart","title":"add_chart","text":"<pre><code>add_chart(\n    chart: Chart, chart_id: Optional[str] = None\n) -&gt; ChartManager\n</code></pre> <p>Add a chart to the manager.</p> <p>Adds a Chart instance to the manager with a unique identifier. The chart is registered in the manager's chart registry and can participate in synchronization groups. If no chart ID is provided, one is automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>Chart</code> <p>The Chart instance to add to the manager.</p> required <code>chart_id</code> <code>Optional[str]</code> <p>Optional unique identifier for the chart. If not provided, an auto-generated ID in the format \"chart_N\" will be assigned.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ChartManager</code> <code>ChartManager</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>DuplicateError</code> <p>If a chart with the specified ID already exists.</p> Example <pre><code>manager = ChartManager()\nchart = Chart(series=LineSeries(data))\n\n# Add chart with auto-generated ID\nmanager.add_chart(chart)\n\n# Add chart with custom ID\nmanager.add_chart(chart, \"price_chart\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def add_chart(self, chart: Chart, chart_id: Optional[str] = None) -&gt; \"ChartManager\":\n    \"\"\"Add a chart to the manager.\n\n    Adds a Chart instance to the manager with a unique identifier. The chart\n    is registered in the manager's chart registry and can participate in\n    synchronization groups. If no chart ID is provided, one is automatically\n    generated.\n\n    Args:\n        chart (Chart): The Chart instance to add to the manager.\n        chart_id (Optional[str]): Optional unique identifier for the chart.\n            If not provided, an auto-generated ID in the format \"chart_N\"\n            will be assigned.\n\n    Returns:\n        ChartManager: Self for method chaining.\n\n    Raises:\n        DuplicateError: If a chart with the specified ID already exists.\n\n    Example:\n        ```python\n        manager = ChartManager()\n        chart = Chart(series=LineSeries(data))\n\n        # Add chart with auto-generated ID\n        manager.add_chart(chart)\n\n        # Add chart with custom ID\n        manager.add_chart(chart, \"price_chart\")\n        ```\n    \"\"\"\n    # Generate unique chart ID if not provided\n    if chart_id is None:\n        chart_id = f\"chart_{len(self.charts) + 1}\"\n\n    # Validate that chart ID is unique within the manager\n    if chart_id in self.charts:\n        raise DuplicateError(\"Chart\", chart_id)\n\n    # Set the ChartManager reference on the chart for bidirectional communication\n    # This allows the chart to access manager configuration and sync settings\n    chart._chart_manager = self\n\n    # Add chart to the registry with its unique identifier\n    self.charts[chart_id] = chart\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.remove_chart","title":"remove_chart","text":"<pre><code>remove_chart(chart_id: str) -&gt; ChartManager\n</code></pre> <p>Remove a chart from the manager.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to remove</p> required <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def remove_chart(self, chart_id: str) -&gt; \"ChartManager\":\n    \"\"\"Remove a chart from the manager.\n\n    Args:\n        chart_id: ID of the chart to remove\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    del self.charts[chart_id]\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_chart","title":"get_chart","text":"<pre><code>get_chart(chart_id: str) -&gt; Chart\n</code></pre> <p>Get a chart by ID.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>ID of the chart to retrieve</p> required <p>Returns:</p> Type Description <code>Chart</code> <p>The Chart instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart(self, chart_id: str) -&gt; Chart:\n    \"\"\"Get a chart by ID.\n\n    Args:\n        chart_id: ID of the chart to retrieve\n\n    Returns:\n        The Chart instance\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    return self.charts[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.render_chart","title":"render_chart","text":"<pre><code>render_chart(\n    chart_id: str, key: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Render a specific chart from the manager with proper sync configuration.</p> <p>This method renders a single chart while preserving the ChartManager's sync configuration and group settings. This ensures that individual charts can still participate in group synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>The ID of the chart to render</p> required <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chart_id is not found</p> Example <pre><code>manager = ChartManager()\nmanager.add_chart(chart1, \"chart1\")\nmanager.add_chart(chart2, \"chart2\")\n\ncol1, col2 = st.columns(2)\nwith col1:\n    manager.render_chart(\"chart1\")\nwith col2:\n    manager.render_chart(\"chart2\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render_chart(self, chart_id: str, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render a specific chart from the manager with proper sync configuration.\n\n    This method renders a single chart while preserving the ChartManager's\n    sync configuration and group settings. This ensures that individual\n    charts can still participate in group synchronization.\n\n    Args:\n        chart_id: The ID of the chart to render\n        key: Optional key for the Streamlit component\n\n    Returns:\n        The rendered component\n\n    Raises:\n        ValueError: If chart_id is not found\n\n    Example:\n        ```python\n        manager = ChartManager()\n        manager.add_chart(chart1, \"chart1\")\n        manager.add_chart(chart2, \"chart2\")\n\n        col1, col2 = st.columns(2)\n        with col1:\n            manager.render_chart(\"chart1\")\n        with col2:\n            manager.render_chart(\"chart2\")\n        ```\n    \"\"\"\n    if chart_id not in self.charts:\n        raise NotFoundError(\"Chart\", chart_id)\n\n    # Get the chart and render it (sync config is automatically included)\n    chart = self.charts[chart_id]\n    return chart.render(key=key)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_chart_ids","title":"get_chart_ids","text":"<pre><code>get_chart_ids() -&gt; List[str]\n</code></pre> <p>Get all chart IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of chart IDs</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_chart_ids(self) -&gt; List[str]:\n    \"\"\"Get all chart IDs.\n\n    Returns:\n        List of chart IDs\n    \"\"\"\n    return list(self.charts.keys())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.clear_charts","title":"clear_charts","text":"<pre><code>clear_charts() -&gt; ChartManager\n</code></pre> <p>Remove all charts from the manager.</p> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def clear_charts(self) -&gt; \"ChartManager\":\n    \"\"\"Remove all charts from the manager.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.charts.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.set_sync_group_config","title":"set_sync_group_config","text":"<pre><code>set_sync_group_config(\n    group_id: Union[int, str], sync_options: SyncOptions\n) -&gt; ChartManager\n</code></pre> <p>Set synchronization configuration for a specific group.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str)</p> required <code>sync_options</code> <code>SyncOptions</code> <p>The sync configuration for this group</p> required <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def set_sync_group_config(\n    self,\n    group_id: Union[int, str],\n    sync_options: SyncOptions,\n) -&gt; \"ChartManager\":\n    \"\"\"Set synchronization configuration for a specific group.\n\n    Args:\n        group_id: The sync group ID (int or str)\n        sync_options: The sync configuration for this group\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.sync_groups[str(group_id)] = sync_options\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.get_sync_group_config","title":"get_sync_group_config","text":"<pre><code>get_sync_group_config(\n    group_id: Union[int, str],\n) -&gt; Optional[SyncOptions]\n</code></pre> <p>Get synchronization configuration for a specific group.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Union[int, str]</code> <p>The sync group ID (int or str)</p> required <p>Returns:</p> Type Description <code>Optional[SyncOptions]</code> <p>The sync configuration for the group, or None if not found</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def get_sync_group_config(self, group_id: Union[int, str]) -&gt; Optional[SyncOptions]:\n    \"\"\"Get synchronization configuration for a specific group.\n\n    Args:\n        group_id: The sync group ID (int or str)\n\n    Returns:\n        The sync configuration for the group, or None if not found\n    \"\"\"\n    return self.sync_groups.get(str(group_id))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_crosshair_sync","title":"enable_crosshair_sync","text":"<pre><code>enable_crosshair_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Enable crosshair synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable crosshair synchronization.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_crosshair()\n    else:\n        self.default_sync.enable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_crosshair_sync","title":"disable_crosshair_sync","text":"<pre><code>disable_crosshair_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Disable crosshair synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_crosshair_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable crosshair synchronization.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_crosshair()\n    else:\n        self.default_sync.disable_crosshair()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_time_range_sync","title":"enable_time_range_sync","text":"<pre><code>enable_time_range_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Enable time range synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable time range synchronization.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_time_range()\n    else:\n        self.default_sync.enable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_time_range_sync","title":"disable_time_range_sync","text":"<pre><code>disable_time_range_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Disable time range synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_time_range_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable time range synchronization.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_time_range()\n    else:\n        self.default_sync.disable_time_range()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.enable_all_sync","title":"enable_all_sync","text":"<pre><code>enable_all_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Enable all synchronization features.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def enable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Enable all synchronization features.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key not in self.sync_groups:\n            self.sync_groups[group_key] = SyncOptions()\n        self.sync_groups[group_key].enable_all()\n    else:\n        self.default_sync.enable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.disable_all_sync","title":"disable_all_sync","text":"<pre><code>disable_all_sync(\n    group_id: Optional[Union[int, str]] = None,\n) -&gt; ChartManager\n</code></pre> <p>Disable all synchronization features.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>Optional[Union[int, str]]</code> <p>Optional group ID. If None, applies to default sync</p> <code>None</code> <p>Returns:</p> Type Description <code>ChartManager</code> <p>Self for method chaining</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def disable_all_sync(self, group_id: Optional[Union[int, str]] = None) -&gt; \"ChartManager\":\n    \"\"\"Disable all synchronization features.\n\n    Args:\n        group_id: Optional group ID. If None, applies to default sync\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if group_id:\n        group_key = str(group_id)\n        if group_key in self.sync_groups:\n            self.sync_groups[group_key].disable_all()\n    else:\n        self.default_sync.disable_all()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.from_price_volume_dataframe","title":"from_price_volume_dataframe","text":"<pre><code>from_price_volume_dataframe(\n    data: Union[Sequence[OhlcvData], DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    chart_id: str = \"main_chart\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; ChartManager\n</code></pre> <p>Create a chart from OHLCV data with price and volume series.</p> <p>Factory method that creates a new Chart instance with both price and volume series from OHLCV data. This is a convenient way to create a complete price-volume chart in a single operation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of column names for DataFrame conversion. Defaults to None.</p> <code>None</code> <code>price_type</code> <code>str</code> <p>Type of price series ('candlestick' or 'line'). Defaults to \"candlestick\".</p> <code>'candlestick'</code> <code>price_kwargs</code> <code>dict</code> <p>Additional arguments for price series configuration. Defaults to None.</p> <code>None</code> <code>volume_kwargs</code> <code>dict</code> <p>Additional arguments for volume series configuration. Defaults to None.</p> <code>None</code> <code>pane_id</code> <code>int</code> <p>Pane ID for both price and volume series. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Chart</code> <code>ChartManager</code> <p>A new Chart instance with price and volume series.</p> Example <pre><code># Create chart from DataFrame\nchart = Chart.from_price_volume_dataframe(\n    df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n)\n\n# Create chart from OHLCV data\nchart = Chart.from_price_volume_dataframe(\n    ohlcv_data,\n    price_type=\"line\",\n    volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def from_price_volume_dataframe(\n    self,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: Optional[dict] = None,\n    price_type: str = \"candlestick\",\n    chart_id: str = \"main_chart\",\n    price_kwargs=None,\n    volume_kwargs=None,\n    pane_id: int = 0,\n) -&gt; \"ChartManager\":\n    \"\"\"Create a chart from OHLCV data with price and volume series.\n\n    Factory method that creates a new Chart instance with both price and volume\n    series from OHLCV data. This is a convenient way to create a complete\n    price-volume chart in a single operation.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data containing\n            price and volume information.\n        column_mapping (dict, optional): Mapping of column names for DataFrame\n            conversion. Defaults to None.\n        price_type (str, optional): Type of price series ('candlestick' or 'line').\n            Defaults to \"candlestick\".\n        price_kwargs (dict, optional): Additional arguments for price series\n            configuration. Defaults to None.\n        volume_kwargs (dict, optional): Additional arguments for volume series\n            configuration. Defaults to None.\n        pane_id (int, optional): Pane ID for both price and volume series.\n            Defaults to 0.\n\n    Returns:\n        Chart: A new Chart instance with price and volume series.\n\n    Example:\n        ```python\n        # Create chart from DataFrame\n        chart = Chart.from_price_volume_dataframe(\n            df, column_mapping={\"time\": \"timestamp\", \"volume\": \"vol\"}, price_type=\"candlestick\"\n        )\n\n        # Create chart from OHLCV data\n        chart = Chart.from_price_volume_dataframe(\n            ohlcv_data,\n            price_type=\"line\",\n            volume_kwargs={\"up_color\": \"green\", \"down_color\": \"red\"},\n        )\n        ```\n    \"\"\"\n    if data is None:\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n    if not isinstance(data, (list, pd.DataFrame)):\n        raise TypeValidationError(\"data\", \"list or DataFrame\")\n\n    chart = Chart()\n    chart.add_price_volume_series(\n        data=data,\n        column_mapping=column_mapping,\n        price_type=price_type,\n        price_kwargs=price_kwargs,\n        volume_kwargs=volume_kwargs,\n        pane_id=pane_id,\n    )\n\n    # Set the ChartManager reference on the chart\n    chart._chart_manager = self\n\n    # Add the chart to the manager with an ID\n    self.add_chart(chart, chart_id=chart_id)\n\n    return chart\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.to_frontend_config","title":"to_frontend_config","text":"<pre><code>to_frontend_config() -&gt; Dict[str, Any]\n</code></pre> <p>Convert the chart manager to frontend configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing the frontend configuration</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def to_frontend_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the chart manager to frontend configuration.\n\n    Returns:\n        Dictionary containing the frontend configuration\n    \"\"\"\n    if not self.charts:\n        return {\n            \"charts\": [],\n            \"syncConfig\": self.default_sync.asdict(),\n        }\n\n    chart_configs = []\n    for chart_id, chart in self.charts.items():\n        chart_config = chart.to_frontend_config()\n        if \"charts\" in chart_config and len(chart_config[\"charts\"]) &gt; 0:\n            chart_obj = chart_config[\"charts\"][0]\n            chart_obj[\"chartId\"] = chart_id\n            chart_configs.append(chart_obj)\n        else:\n            # Skip charts with invalid configuration\n            continue\n\n    # Build sync configuration\n    sync_config = self.default_sync.asdict()\n\n    # Add group-specific sync configurations\n    if self.sync_groups:\n        sync_config[\"groups\"] = {}\n        for group_id, group_sync in self.sync_groups.items():\n            sync_config[\"groups\"][group_id] = group_sync.asdict()\n\n    return {\n        \"charts\": chart_configs,\n        \"syncConfig\": sync_config,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.render","title":"render","text":"<pre><code>render(key: Optional[str] = None) -&gt; Any\n</code></pre> <p>Render the chart manager.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>Optional key for the Streamlit component</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The rendered component</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def render(self, key: Optional[str] = None) -&gt; Any:\n    \"\"\"Render the chart manager.\n\n    Args:\n        key: Optional key for the Streamlit component\n\n    Returns:\n        The rendered component\n    \"\"\"\n    if not self.charts:\n        raise RuntimeError()\n\n    config = self.to_frontend_config()\n    component_func = get_component_func()\n\n    if component_func is None:\n        if reinitialize_component():\n            component_func = get_component_func()\n        if component_func is None:\n            raise ComponentNotAvailableError()\n\n    kwargs = {\"config\": config}\n    if key is None or not isinstance(key, str) or not key.strip():\n        unique_id = str(uuid.uuid4())[:8]\n        key = f\"chart_manager_{int(time.time() * 1000)}_{unique_id}\"\n    kwargs[\"key\"] = key\n    return component_func(**kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return chart IDs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def keys(self):\n    \"\"\"Return chart IDs in the manager.\"\"\"\n    return self.charts.keys()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return chart instances in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def values(self):\n    \"\"\"Return chart instances in the manager.\"\"\"\n    return self.charts.values()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager.ChartManager.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return chart ID and instance pairs in the manager.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/chart_manager.py</code> <pre><code>def items(self):\n    \"\"\"Return chart ID and instance pairs in the manager.\"\"\"\n    return self.charts.items()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/chart_manager.html#streamlit_lightweight_charts_pro.charts.chart_manager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html","title":"streamlit_lightweight_charts_pro.charts.series_settings_api","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api","title":"series_settings_api","text":"<p>Series Settings API for Streamlit Backend Integration.</p> <p>This module provides the backend API for handling series settings requests from the React frontend. It manages persistence of series configurations in Streamlit session state and provides methods for: - Getting current pane/series state - Updating series settings with patches - Resetting series to defaults - Batch operations for multiple settings changes</p> <p>The API integrates with the existing Chart and Series classes and maintains compatibility with the series configuration system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI","title":"SeriesSettingsAPI","text":"<p>Backend API for handling series settings from the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>class SeriesSettingsAPI:\n    \"\"\"Backend API for handling series settings from the frontend.\"\"\"\n\n    def __init__(self, chart_id: str = \"default\"):\n        \"\"\"Initialize the API with a chart ID.\n\n        Args:\n            chart_id: Unique identifier for the chart instance\n        \"\"\"\n        self.chart_id = chart_id\n        self._session_key = f\"chart_model_{chart_id}\"\n        self._ensure_session_state()\n\n    def _ensure_session_state(self) -&gt; None:\n        \"\"\"Ensure session state is initialized for this chart.\"\"\"\n        if self._session_key not in st.session_state:\n            st.session_state[self._session_key] = {\n                \"panes\": {},  # {pane_id: {series_id: SeriesConfigState}}\n                \"series_refs\": {},  # {series_id: Series instance}\n                \"last_update\": time.time(),\n            }\n\n    def _get_chart_state(self) -&gt; Dict[str, Any]:\n        \"\"\"Get the current chart state from session.\"\"\"\n        # Initialize state if it doesn't exist\n        if self._session_key not in st.session_state:\n            self._ensure_session_state()\n        return st.session_state[self._session_key]\n\n    def _update_last_modified(self) -&gt; None:\n        \"\"\"Update the last modified timestamp.\"\"\"\n        st.session_state[self._session_key][\"last_update\"] = time.time()\n\n    def register_series(self, pane_id: int, series: Series) -&gt; None:\n        \"\"\"Register a series instance with the API.\n\n        Args:\n            pane_id: The pane ID where the series belongs\n            series: The series instance to register\n        \"\"\"\n        chart_state = self._get_chart_state()\n\n        # Initialize pane if it doesn't exist\n        if str(pane_id) not in chart_state[\"panes\"]:\n            chart_state[\"panes\"][str(pane_id)] = {}\n\n        # Store series reference\n        series_id = getattr(series, \"id\", f\"series_{len(chart_state['series_refs'])}\")\n        chart_state[\"series_refs\"][series_id] = series\n\n        # Initialize series config if it doesn't exist\n        if series_id not in chart_state[\"panes\"][str(pane_id)]:\n            chart_state[\"panes\"][str(pane_id)][series_id] = SeriesConfigState(\n                config=series.asdict() if hasattr(series, \"asdict\") else {},\n                series_type=series.__class__.__name__.lower(),\n                last_modified=int(time.time()),\n            )\n\n        self._update_last_modified()\n        logger.debug(\"Registered series %s in pane %s\", series_id, pane_id)\n\n    def get_pane_state(self, pane_id: int) -&gt; Dict[str, Any]:\n        \"\"\"Get current state for a specific pane.\n\n        Args:\n            pane_id: The pane ID to get state for\n\n        Returns:\n            Dictionary containing pane state with series configurations\n        \"\"\"\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n\n        if pane_key not in chart_state[\"panes\"]:\n            return {\"paneId\": pane_id, \"series\": {}}\n\n        # Convert SeriesConfigState objects to dicts\n        pane_series = {}\n        for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n            if isinstance(config_state, SeriesConfigState):\n                pane_series[series_id] = config_state.asdict()\n            else:\n                pane_series[series_id] = config_state\n\n        return {\n            \"paneId\": pane_id,\n            \"series\": pane_series,\n        }\n\n    def update_series_settings(\n        self,\n        pane_id: int,\n        series_id: str,\n        config_patch: Dict[str, Any],\n    ) -&gt; bool:\n        \"\"\"Update series settings with a configuration patch.\n\n        Args:\n            pane_id: The pane ID containing the series\n            series_id: The series ID to update\n            config_patch: Dictionary containing configuration updates\n\n        Returns:\n            True if update was successful, False otherwise\n        \"\"\"\n        try:\n            chart_state = self._get_chart_state()\n            pane_key = str(pane_id)\n\n            # Ensure pane exists\n            if pane_key not in chart_state[\"panes\"]:\n                chart_state[\"panes\"][pane_key] = {}\n\n            # Ensure series config exists\n            if series_id not in chart_state[\"panes\"][pane_key]:\n                chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                    config={},\n                    series_type=\"unknown\",\n                    last_modified=int(time.time()),\n                )\n\n            # Get current config\n            current_state = chart_state[\"panes\"][pane_key][series_id]\n            if isinstance(current_state, SeriesConfigState):\n                current_config = current_state.config.copy()\n            else:\n                current_config = current_state.get(\"config\", {}).copy()\n\n            # Apply patch\n            current_config.update(config_patch)\n\n            # Update the stored configuration\n            chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                config=current_config,\n                series_type=(\n                    current_state.series_type\n                    if isinstance(current_state, SeriesConfigState)\n                    else \"unknown\"\n                ),\n                last_modified=int(time.time()),\n            )\n\n            # Update the actual series object if available\n            if series_id in chart_state[\"series_refs\"]:\n                series_instance = chart_state[\"series_refs\"][series_id]\n                try:\n                    # Use fromdict if available to update series\n                    if hasattr(series_instance, \"fromdict\"):\n                        series_instance.fromdict(config_patch)\n                    else:\n                        # Fallback to setting attributes directly\n                        for key, value in config_patch.items():\n                            if hasattr(series_instance, key):\n                                setattr(series_instance, key, value)\n\n                    logger.debug(\"Updated series %s with config: %s\", series_id, config_patch)\n                except Exception as e:\n                    logger.warning(\"Failed to update series instance %s: %s\", series_id, e)\n\n            self._update_last_modified()\n        except Exception as e:\n            logger.exception(\"Failed to update series settings\")\n            return False\n        else:\n            return True\n\n    def reset_series_to_defaults(\n        self,\n        pane_id: int,\n        series_id: str,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Reset a series to its default configuration.\n\n        Args:\n            pane_id: The pane ID containing the series\n            series_id: The series ID to reset\n\n        Returns:\n            Dictionary containing the default configuration, or None if failed\n        \"\"\"\n        try:\n            chart_state = self._get_chart_state()\n\n            # Get the series instance to determine defaults\n            if series_id in chart_state[\"series_refs\"]:\n                series_instance = chart_state[\"series_refs\"][series_id]\n\n                # Get default configuration based on series type\n                default_config = self._get_series_defaults(series_instance)\n\n                # Update the stored configuration\n                pane_key = str(pane_id)\n                if pane_key in chart_state[\"panes\"] and series_id in chart_state[\"panes\"][pane_key]:\n                    chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                        config=default_config,\n                        series_type=series_instance.__class__.__name__.lower(),\n                        last_modified=int(time.time()),\n                    )\n\n                    # Update the series instance\n                    if hasattr(series_instance, \"fromdict\"):\n                        series_instance.fromdict(default_config)\n\n                    self._update_last_modified()\n                    return default_config\n            else:\n                return None\n\n        except Exception as e:\n            logger.exception(\"Failed to reset series to defaults\")\n            return None\n\n    def _get_series_defaults(self, series_instance: Series) -&gt; Dict[str, Any]:\n        \"\"\"Get default configuration for a series type.\n\n        Args:\n            series_instance: The series instance to get defaults for\n\n        Returns:\n            Dictionary containing default configuration\n        \"\"\"\n        series_type = series_instance.__class__.__name__.lower()\n\n        # Common defaults for all series types\n        defaults = {\n            \"visible\": True,\n            \"markers\": False,\n            \"last_value_visible\": True,\n            \"price_line\": True,\n        }\n\n        # Series-specific defaults\n        if \"ribbon\" in series_type:\n            defaults.update(\n                {\n                    \"upper_line\": {\n                        \"color\": \"#4CAF50\",\n                        \"line_style\": \"solid\",\n                        \"line_width\": 2,\n                    },\n                    \"lower_line\": {\n                        \"color\": \"#F44336\",\n                        \"line_style\": \"solid\",\n                        \"line_width\": 2,\n                    },\n                    \"fill\": True,\n                    \"fill_color\": \"#2196F3\",\n                    \"fill_opacity\": 20,\n                },\n            )\n        elif \"line\" in series_type:\n            defaults.update(\n                {\n                    \"color\": \"#2196F3\",\n                    \"line_style\": \"solid\",\n                    \"line_width\": 1,\n                },\n            )\n        elif \"candlestick\" in series_type:\n            defaults.update(\n                {\n                    \"upColor\": \"#4CAF50\",\n                    \"downColor\": \"#F44336\",\n                    \"wickUpColor\": \"#4CAF50\",\n                    \"wickDownColor\": \"#F44336\",\n                },\n            )\n        elif \"area\" in series_type:\n            defaults.update(\n                {\n                    \"topColor\": \"#2196F3\",\n                    \"bottomColor\": \"rgba(33, 150, 243, 0.1)\",\n                    \"lineColor\": \"#2196F3\",\n                    \"lineWidth\": 2,\n                },\n            )\n\n        return defaults\n\n    def update_multiple_settings(\n        self,\n        patches: List[Dict[str, Any]],\n    ) -&gt; bool:\n        \"\"\"Update multiple series settings in a batch operation.\n\n        Args:\n            patches: List of setting patches, each containing paneId, seriesId, and config\n\n        Returns:\n            True if all updates were successful, False otherwise\n        \"\"\"\n        try:\n            success = True\n            for patch in patches:\n                pane_id = patch.get(\"paneId\", 0)\n                series_id = patch.get(\"seriesId\", \"\")\n                config = patch.get(\"config\", {})\n\n                if not self.update_series_settings(pane_id, series_id, config):\n                    success = False\n                    logger.warning(\"Failed to update series %s in pane %s\", series_id, pane_id)\n                else:\n                    return success\n\n        except Exception as e:\n            logger.exception(\"Failed to update multiple settings\")\n            return False\n\n    def get_all_series_info(self, pane_id: int) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get information about all series in a pane.\n\n        Args:\n            pane_id: The pane ID to get series info for\n\n        Returns:\n            List of dictionaries containing series information\n        \"\"\"\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n        series_info = []\n\n        if pane_key in chart_state[\"panes\"]:\n            for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n                # Get series instance for display name\n                series_instance = chart_state[\"series_refs\"].get(series_id)\n                display_name = series_id\n\n                if series_instance:\n                    # Try to get a more user-friendly name\n                    if hasattr(series_instance, \"name\") and series_instance.name:\n                        display_name = series_instance.name\n                    elif hasattr(series_instance, \"title\") and series_instance.title:\n                        display_name = series_instance.title\n\n                series_type = (\n                    config_state.series_type\n                    if isinstance(config_state, SeriesConfigState)\n                    else \"unknown\"\n                )\n\n                series_info.append(\n                    {\n                        \"id\": series_id,\n                        \"displayName\": display_name,\n                        \"type\": series_type,\n                    },\n                )\n\n        return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.register_series","title":"register_series","text":"<pre><code>register_series(pane_id: int, series: Series) -&gt; None\n</code></pre> <p>Register a series instance with the API.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID where the series belongs</p> required <code>series</code> <code>Series</code> <p>The series instance to register</p> required Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def register_series(self, pane_id: int, series: Series) -&gt; None:\n    \"\"\"Register a series instance with the API.\n\n    Args:\n        pane_id: The pane ID where the series belongs\n        series: The series instance to register\n    \"\"\"\n    chart_state = self._get_chart_state()\n\n    # Initialize pane if it doesn't exist\n    if str(pane_id) not in chart_state[\"panes\"]:\n        chart_state[\"panes\"][str(pane_id)] = {}\n\n    # Store series reference\n    series_id = getattr(series, \"id\", f\"series_{len(chart_state['series_refs'])}\")\n    chart_state[\"series_refs\"][series_id] = series\n\n    # Initialize series config if it doesn't exist\n    if series_id not in chart_state[\"panes\"][str(pane_id)]:\n        chart_state[\"panes\"][str(pane_id)][series_id] = SeriesConfigState(\n            config=series.asdict() if hasattr(series, \"asdict\") else {},\n            series_type=series.__class__.__name__.lower(),\n            last_modified=int(time.time()),\n        )\n\n    self._update_last_modified()\n    logger.debug(\"Registered series %s in pane %s\", series_id, pane_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.get_pane_state","title":"get_pane_state","text":"<pre><code>get_pane_state(pane_id: int) -&gt; Dict[str, Any]\n</code></pre> <p>Get current state for a specific pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to get state for</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing pane state with series configurations</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_pane_state(self, pane_id: int) -&gt; Dict[str, Any]:\n    \"\"\"Get current state for a specific pane.\n\n    Args:\n        pane_id: The pane ID to get state for\n\n    Returns:\n        Dictionary containing pane state with series configurations\n    \"\"\"\n    chart_state = self._get_chart_state()\n    pane_key = str(pane_id)\n\n    if pane_key not in chart_state[\"panes\"]:\n        return {\"paneId\": pane_id, \"series\": {}}\n\n    # Convert SeriesConfigState objects to dicts\n    pane_series = {}\n    for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n        if isinstance(config_state, SeriesConfigState):\n            pane_series[series_id] = config_state.asdict()\n        else:\n            pane_series[series_id] = config_state\n\n    return {\n        \"paneId\": pane_id,\n        \"series\": pane_series,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.update_series_settings","title":"update_series_settings","text":"<pre><code>update_series_settings(\n    pane_id: int,\n    series_id: str,\n    config_patch: Dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Update series settings with a configuration patch.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID containing the series</p> required <code>series_id</code> <code>str</code> <p>The series ID to update</p> required <code>config_patch</code> <code>Dict[str, Any]</code> <p>Dictionary containing configuration updates</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if update was successful, False otherwise</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def update_series_settings(\n    self,\n    pane_id: int,\n    series_id: str,\n    config_patch: Dict[str, Any],\n) -&gt; bool:\n    \"\"\"Update series settings with a configuration patch.\n\n    Args:\n        pane_id: The pane ID containing the series\n        series_id: The series ID to update\n        config_patch: Dictionary containing configuration updates\n\n    Returns:\n        True if update was successful, False otherwise\n    \"\"\"\n    try:\n        chart_state = self._get_chart_state()\n        pane_key = str(pane_id)\n\n        # Ensure pane exists\n        if pane_key not in chart_state[\"panes\"]:\n            chart_state[\"panes\"][pane_key] = {}\n\n        # Ensure series config exists\n        if series_id not in chart_state[\"panes\"][pane_key]:\n            chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                config={},\n                series_type=\"unknown\",\n                last_modified=int(time.time()),\n            )\n\n        # Get current config\n        current_state = chart_state[\"panes\"][pane_key][series_id]\n        if isinstance(current_state, SeriesConfigState):\n            current_config = current_state.config.copy()\n        else:\n            current_config = current_state.get(\"config\", {}).copy()\n\n        # Apply patch\n        current_config.update(config_patch)\n\n        # Update the stored configuration\n        chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n            config=current_config,\n            series_type=(\n                current_state.series_type\n                if isinstance(current_state, SeriesConfigState)\n                else \"unknown\"\n            ),\n            last_modified=int(time.time()),\n        )\n\n        # Update the actual series object if available\n        if series_id in chart_state[\"series_refs\"]:\n            series_instance = chart_state[\"series_refs\"][series_id]\n            try:\n                # Use fromdict if available to update series\n                if hasattr(series_instance, \"fromdict\"):\n                    series_instance.fromdict(config_patch)\n                else:\n                    # Fallback to setting attributes directly\n                    for key, value in config_patch.items():\n                        if hasattr(series_instance, key):\n                            setattr(series_instance, key, value)\n\n                logger.debug(\"Updated series %s with config: %s\", series_id, config_patch)\n            except Exception as e:\n                logger.warning(\"Failed to update series instance %s: %s\", series_id, e)\n\n        self._update_last_modified()\n    except Exception as e:\n        logger.exception(\"Failed to update series settings\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.reset_series_to_defaults","title":"reset_series_to_defaults","text":"<pre><code>reset_series_to_defaults(\n    pane_id: int, series_id: str\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Reset a series to its default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID containing the series</p> required <code>series_id</code> <code>str</code> <p>The series ID to reset</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary containing the default configuration, or None if failed</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def reset_series_to_defaults(\n    self,\n    pane_id: int,\n    series_id: str,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Reset a series to its default configuration.\n\n    Args:\n        pane_id: The pane ID containing the series\n        series_id: The series ID to reset\n\n    Returns:\n        Dictionary containing the default configuration, or None if failed\n    \"\"\"\n    try:\n        chart_state = self._get_chart_state()\n\n        # Get the series instance to determine defaults\n        if series_id in chart_state[\"series_refs\"]:\n            series_instance = chart_state[\"series_refs\"][series_id]\n\n            # Get default configuration based on series type\n            default_config = self._get_series_defaults(series_instance)\n\n            # Update the stored configuration\n            pane_key = str(pane_id)\n            if pane_key in chart_state[\"panes\"] and series_id in chart_state[\"panes\"][pane_key]:\n                chart_state[\"panes\"][pane_key][series_id] = SeriesConfigState(\n                    config=default_config,\n                    series_type=series_instance.__class__.__name__.lower(),\n                    last_modified=int(time.time()),\n                )\n\n                # Update the series instance\n                if hasattr(series_instance, \"fromdict\"):\n                    series_instance.fromdict(default_config)\n\n                self._update_last_modified()\n                return default_config\n        else:\n            return None\n\n    except Exception as e:\n        logger.exception(\"Failed to reset series to defaults\")\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.update_multiple_settings","title":"update_multiple_settings","text":"<pre><code>update_multiple_settings(\n    patches: List[Dict[str, Any]],\n) -&gt; bool\n</code></pre> <p>Update multiple series settings in a batch operation.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>List[Dict[str, Any]]</code> <p>List of setting patches, each containing paneId, seriesId, and config</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all updates were successful, False otherwise</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def update_multiple_settings(\n    self,\n    patches: List[Dict[str, Any]],\n) -&gt; bool:\n    \"\"\"Update multiple series settings in a batch operation.\n\n    Args:\n        patches: List of setting patches, each containing paneId, seriesId, and config\n\n    Returns:\n        True if all updates were successful, False otherwise\n    \"\"\"\n    try:\n        success = True\n        for patch in patches:\n            pane_id = patch.get(\"paneId\", 0)\n            series_id = patch.get(\"seriesId\", \"\")\n            config = patch.get(\"config\", {})\n\n            if not self.update_series_settings(pane_id, series_id, config):\n                success = False\n                logger.warning(\"Failed to update series %s in pane %s\", series_id, pane_id)\n            else:\n                return success\n\n    except Exception as e:\n        logger.exception(\"Failed to update multiple settings\")\n        return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.SeriesSettingsAPI.get_all_series_info","title":"get_all_series_info","text":"<pre><code>get_all_series_info(pane_id: int) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get information about all series in a pane.</p> <p>Parameters:</p> Name Type Description Default <code>pane_id</code> <code>int</code> <p>The pane ID to get series info for</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries containing series information</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_all_series_info(self, pane_id: int) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get information about all series in a pane.\n\n    Args:\n        pane_id: The pane ID to get series info for\n\n    Returns:\n        List of dictionaries containing series information\n    \"\"\"\n    chart_state = self._get_chart_state()\n    pane_key = str(pane_id)\n    series_info = []\n\n    if pane_key in chart_state[\"panes\"]:\n        for series_id, config_state in chart_state[\"panes\"][pane_key].items():\n            # Get series instance for display name\n            series_instance = chart_state[\"series_refs\"].get(series_id)\n            display_name = series_id\n\n            if series_instance:\n                # Try to get a more user-friendly name\n                if hasattr(series_instance, \"name\") and series_instance.name:\n                    display_name = series_instance.name\n                elif hasattr(series_instance, \"title\") and series_instance.title:\n                    display_name = series_instance.title\n\n            series_type = (\n                config_state.series_type\n                if isinstance(config_state, SeriesConfigState)\n                else \"unknown\"\n            )\n\n            series_info.append(\n                {\n                    \"id\": series_id,\n                    \"displayName\": display_name,\n                    \"type\": series_type,\n                },\n            )\n\n    return series_info\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.create_series_settings_api","title":"create_series_settings_api","text":"<pre><code>create_series_settings_api(\n    chart_id: str = \"default\",\n) -&gt; SeriesSettingsAPI\n</code></pre> <p>Create a SeriesSettingsAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart</p> <code>'default'</code> <p>Returns:</p> Type Description <code>SeriesSettingsAPI</code> <p>SeriesSettingsAPI instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def create_series_settings_api(chart_id: str = \"default\") -&gt; SeriesSettingsAPI:\n    \"\"\"Create a SeriesSettingsAPI instance.\n\n    Args:\n        chart_id: Unique identifier for the chart\n\n    Returns:\n        SeriesSettingsAPI instance\n    \"\"\"\n    return SeriesSettingsAPI(chart_id)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series_settings_api.html#streamlit_lightweight_charts_pro.charts.series_settings_api.get_series_settings_api","title":"get_series_settings_api","text":"<pre><code>get_series_settings_api(\n    chart_id: str = \"default\",\n) -&gt; SeriesSettingsAPI\n</code></pre> <p>Get or create a SeriesSettingsAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>chart_id</code> <code>str</code> <p>Unique identifier for the chart</p> <code>'default'</code> <p>Returns:</p> Type Description <code>SeriesSettingsAPI</code> <p>SeriesSettingsAPI instance</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series_settings_api.py</code> <pre><code>def get_series_settings_api(chart_id: str = \"default\") -&gt; SeriesSettingsAPI:\n    \"\"\"Get or create a SeriesSettingsAPI instance.\n\n    Args:\n        chart_id: Unique identifier for the chart\n\n    Returns:\n        SeriesSettingsAPI instance\n    \"\"\"\n    if chart_id not in _api_instances:\n        _api_instances[chart_id] = SeriesSettingsAPI(chart_id)\n    return _api_instances[chart_id]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html","title":"streamlit_lightweight_charts_pro.charts.options.base_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options","title":"base_options","text":"<p>Base options class for streamlit-lightweight-charts.</p> <p>This module provides the base Options class that all option classes should inherit from. It provides common functionality for serialization, validation, and frontend communication through standardized dictionary conversion with camelCase key formatting.</p> <p>The Options class serves as the foundation for all configuration classes in the library, ensuring consistent behavior across different option types and providing a unified interface for frontend serialization and validation.</p> Key Features <ul> <li>Automatic snake_case to camelCase key conversion for frontend compatibility</li> <li>Enum value extraction and conversion for proper serialization</li> <li>Nested option object serialization with recursive handling</li> <li>Dictionary and list serialization with type-aware processing</li> <li>Special handling for _options fields with flattening logic</li> <li>Flexible update mechanism with dictionary-based configuration</li> <li>Comprehensive validation and error handling</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options.base_options import Options\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass MyOptions(Options):\n    background_color: str = \"#ffffff\"\n    text_color: str = \"#000000\"\n    is_visible: bool = True\n\n\n# Create and serialize options\noptions = MyOptions()\nserialized = options.asdict()\n# Returns: {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options","title":"Options  <code>dataclass</code>","text":"<p>Abstract base class for all option classes in financial chart configuration.</p> <p>This class provides common functionality for option classes including automatic camelCase key conversion for frontend serialization, enum value conversion, and standardized validation patterns. All option classes in the library should inherit from this base class to ensure consistent behavior and frontend compatibility.</p> <p>The class implements a sophisticated serialization system that handles: - Automatic snake_case to camelCase key conversion for JavaScript compatibility - Enum value extraction and conversion for proper frontend rendering - Nested option object serialization with recursive processing - List serialization with recursive option handling - Dictionary serialization with recursive Options object detection - Special handling for _options fields with flattening logic - Flexible update mechanism with dictionary-based configuration</p> Key Features <ul> <li>Frontend-compatible serialization with camelCase keys</li> <li>Type-safe validation and error handling</li> <li>Recursive nested object processing</li> <li>Enum value extraction and conversion</li> <li>Method chaining support for fluent API usage</li> <li>Comprehensive logging for debugging</li> </ul> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n@dataclass\nclass MyOptions(Options):\n    background_color: str = \"#ffffff\"\n    text_color: str = \"#000000\"\n    is_visible: bool = True\n\n\n@dataclass\nclass NestedOptions(Options):\n    color: str = \"#ff0000\"\n    width: int = 2\n\n\n@dataclass\nclass ContainerOptions(Options):\n    main_options: MyOptions = None\n    nested_dict: Dict[str, NestedOptions] = None\n\n\n# Create and serialize options\noptions = ContainerOptions(\n    main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n)\nresult = options.asdict()\n# Returns: {\n#     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n#     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n# }\n</code></pre> See also <p>chainable_field: Decorator for creating chainable option properties. snake_to_camel: Utility function for key conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>@dataclass\nclass Options(SerializableMixin, ABC):\n    \"\"\"Abstract base class for all option classes in financial chart configuration.\n\n    This class provides common functionality for option classes including automatic\n    camelCase key conversion for frontend serialization, enum value conversion,\n    and standardized validation patterns. All option classes in the library should\n    inherit from this base class to ensure consistent behavior and frontend compatibility.\n\n    The class implements a sophisticated serialization system that handles:\n    - Automatic snake_case to camelCase key conversion for JavaScript compatibility\n    - Enum value extraction and conversion for proper frontend rendering\n    - Nested option object serialization with recursive processing\n    - List serialization with recursive option handling\n    - Dictionary serialization with recursive Options object detection\n    - Special handling for _options fields with flattening logic\n    - Flexible update mechanism with dictionary-based configuration\n\n    Key Features:\n        - Frontend-compatible serialization with camelCase keys\n        - Type-safe validation and error handling\n        - Recursive nested object processing\n        - Enum value extraction and conversion\n        - Method chaining support for fluent API usage\n        - Comprehensive logging for debugging\n\n    Attributes:\n        Inherited by subclasses with specific option attributes. Each subclass\n        defines its own configuration properties with appropriate default values.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.charts.options.base_options import Options\n\n\n        @dataclass\n        class MyOptions(Options):\n            background_color: str = \"#ffffff\"\n            text_color: str = \"#000000\"\n            is_visible: bool = True\n\n\n        @dataclass\n        class NestedOptions(Options):\n            color: str = \"#ff0000\"\n            width: int = 2\n\n\n        @dataclass\n        class ContainerOptions(Options):\n            main_options: MyOptions = None\n            nested_dict: Dict[str, NestedOptions] = None\n\n\n        # Create and serialize options\n        options = ContainerOptions(\n            main_options=MyOptions(), nested_dict={\"line\": NestedOptions(), \"area\": NestedOptions()}\n        )\n        result = options.asdict()\n        # Returns: {\n        #     \"mainOptions\": {\"backgroundColor\": \"#ffffff\", \"textColor\": \"#000000\", \"isVisible\": True},\n        #     \"nestedDict\": {\"line\": {\"color\": \"#ff0000\", \"width\": 2}, \"area\": {\"color\": \"#ff0000\", \"width\": 2}}\n        # }\n        ```\n\n    See also:\n        chainable_field: Decorator for creating chainable option properties.\n        snake_to_camel: Utility function for key conversion.\n    \"\"\"\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n        \"\"\"Update options with a dictionary of values.\n\n        This method provides a flexible way to update option properties using a dictionary.\n        It handles both simple properties and nested objects, automatically creating\n        nested Options instances when needed.\n\n        Args:\n            updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n                Values can be simple types or dictionaries for nested objects.\n\n        Returns:\n            Options: Self for method chaining.\n\n        Raises:\n            ValueError: If an update key doesn't correspond to a valid field.\n            TypeError: If a value type is incompatible with the field type.\n\n        Example:\n            ```python\n            options = MyOptions()\n\n            # Update simple properties\n            options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n            # Update nested objects\n            options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n            # Method chaining\n            options.update({\"color\": \"red\"}).update({\"width\": 100})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            # Convert camelCase to snake_case for field lookup\n            field_name = self._camel_to_snake(key)\n\n            # Check if field exists\n            if not hasattr(self, field_name):\n                # Try the original key in case it's already snake_case\n                if hasattr(self, key):\n                    field_name = key\n                else:\n                    # Ignore invalid fields instead of raising an error\n\n                    continue\n\n            # Get field info for type checking\n            field_info = None\n            for field in fields(self):\n                if field.name == field_name:\n                    field_info = field\n                    break\n\n            if field_info is None:\n                # Ignore fields not found in dataclass fields\n\n                continue\n\n            # Handle nested Options objects and complex type annotations\n            contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n                field_info.type,\n            )\n\n            if contains_options and isinstance(value, dict):\n                if options_class is not None and not is_dict_type:\n                    # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                    current_value = getattr(self, field_name)\n                    if current_value is None:\n                        current_value = options_class()\n                    current_value.update(value)\n                    setattr(self, field_name, current_value)\n                else:\n                    # Handle Dict[str, Options] or similar complex types\n                    # The value is a dict that should contain Options objects\n                    # We'll process it recursively during asdict() call\n                    setattr(self, field_name, value)\n            else:\n                # Simple value assignment - set the field directly to bypass validation\n                # This is what we want for the update method\n                setattr(self, field_name, value)\n\n        return self\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n        \"\"\"\n        import re  # pylint: disable=import-outside-toplevel\n\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n\n    def _process_dict_recursively(self, data: Any) -&gt; Any:\n        \"\"\"Recursively process data structures to handle Options objects.\n\n        This method traverses through nested data structures (dicts, lists) and\n        converts any Options objects to dictionaries using their asdict() method.\n        It also converts dictionary keys from snake_case to camelCase.\n\n        Args:\n            data: The data to process. Can be any type, but the method specifically\n                handles dict, list, and Options types.\n\n        Returns:\n            The processed data with all Options objects converted to dictionaries\n            and keys converted to camelCase.\n        \"\"\"\n        if isinstance(data, Options):\n            return data.asdict()\n        if isinstance(data, dict):\n            return {\n                snake_to_camel(str(k)): self._process_dict_recursively(v) for k, v in data.items()\n            }\n        if isinstance(data, list):\n            return [self._process_dict_recursively(item) for item in data]\n        return data\n\n    def _analyze_type_for_options(self, field_type: Any) -&gt; tuple[bool, type | None, bool]:\n        \"\"\"Analyze a type annotation to determine if it contains Options objects.\n\n        Args:\n            field_type: The type annotation to analyze.\n\n        Returns:\n            Tuple of (contains_options, options_class, is_dict_type) where:\n            - contains_options: True if the type contains Options objects\n            - options_class: The Options class if found, None otherwise\n            - is_dict_type: True if the type is a Dict type (including Optional[Dict])\n        \"\"\"\n        # Direct Options type\n        if isinstance(field_type, type) and issubclass(field_type, Options):\n            return True, field_type, False\n\n        # Check if it's a generic type with origin\n        if not hasattr(field_type, \"__origin__\") or field_type.__origin__ is None:\n            return False, None, False\n\n        origin = field_type.__origin__\n        args = getattr(field_type, \"__args__\", ())\n\n        # Dict type\n        if origin is dict and len(args) &gt;= 2:\n            contains_options, options_class, _ = self._analyze_type_for_options(args[1])\n            if contains_options:\n                return True, options_class, True\n\n        # List type\n        elif origin is list and args:\n            contains_options, options_class, _ = self._analyze_type_for_options(args[0])\n            if contains_options:\n                return True, options_class, False\n\n        # Union type (Optional)\n        elif origin is not None:  # Union types\n            # Check if any non-None arg is a Dict type\n            is_dict_type = any(\n                hasattr(arg, \"__origin__\") and arg.__origin__ is dict\n                for arg in args\n                if arg is not type(None)\n            )\n\n            # Check each non-None argument\n            for arg in args:\n                if arg is type(None):\n                    continue\n                contains_options, options_class, _ = self._analyze_type_for_options(arg)\n                if contains_options:\n                    return True, options_class, is_dict_type\n\n        return False, None, False\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n        This method provides comprehensive serialization of option objects for\n        frontend communication. It handles complex nested structures, enum values,\n        and special field flattening patterns.\n\n        The serialization process:\n        1. Iterates through all dataclass fields\n        2. Skips None values, empty strings, and empty dictionaries\n        3. Converts enum values to their .value property\n        4. Recursively serializes nested Options objects\n        5. Handles lists of Options objects\n        6. Recursively processes dictionaries that may contain Options objects at any level\n        7. Converts field names from snake_case to camelCase\n        8. Applies special flattening logic for _options fields\n\n        Returns:\n            Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n                consumption. All nested structures are properly serialized and\n                enum values are converted to their primitive representations.\n\n        Note:\n            - Empty dictionaries and None values are omitted from output\n            - Enum values are automatically converted to their .value property\n            - Nested Options objects are recursively serialized\n            - Lists containing Options objects are handled recursively\n            - Dictionaries containing Options objects at any nesting level are processed recursively\n            - background_options fields are flattened into the parent result\n        \"\"\"\n        # Use the inherited serialization from SerializableMixin\n        return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Options\n</code></pre> <p>Update options with a dictionary of values.</p> <p>This method provides a flexible way to update option properties using a dictionary. It handles both simple properties and nested objects, automatically creating nested Options instances when needed.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types or dictionaries for nested objects.</p> required <p>Returns:</p> Name Type Description <code>Options</code> <code>Options</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an update key doesn't correspond to a valid field.</p> <code>TypeError</code> <p>If a value type is incompatible with the field type.</p> Example <pre><code>options = MyOptions()\n\n# Update simple properties\noptions.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n# Update nested objects\noptions.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n# Method chaining\noptions.update({\"color\": \"red\"}).update({\"width\": 100})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Options\":\n    \"\"\"Update options with a dictionary of values.\n\n    This method provides a flexible way to update option properties using a dictionary.\n    It handles both simple properties and nested objects, automatically creating\n    nested Options instances when needed.\n\n    Args:\n        updates: Dictionary of updates to apply. Keys can be in snake_case or camelCase.\n            Values can be simple types or dictionaries for nested objects.\n\n    Returns:\n        Options: Self for method chaining.\n\n    Raises:\n        ValueError: If an update key doesn't correspond to a valid field.\n        TypeError: If a value type is incompatible with the field type.\n\n    Example:\n        ```python\n        options = MyOptions()\n\n        # Update simple properties\n        options.update({\"background_color\": \"#ff0000\", \"is_visible\": False})\n\n        # Update nested objects\n        options.update({\"line_options\": {\"color\": \"#00ff00\", \"line_width\": 3}})\n\n        # Method chaining\n        options.update({\"color\": \"red\"}).update({\"width\": 100})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        # Convert camelCase to snake_case for field lookup\n        field_name = self._camel_to_snake(key)\n\n        # Check if field exists\n        if not hasattr(self, field_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                field_name = key\n            else:\n                # Ignore invalid fields instead of raising an error\n\n                continue\n\n        # Get field info for type checking\n        field_info = None\n        for field in fields(self):\n            if field.name == field_name:\n                field_info = field\n                break\n\n        if field_info is None:\n            # Ignore fields not found in dataclass fields\n\n            continue\n\n        # Handle nested Options objects and complex type annotations\n        contains_options, options_class, is_dict_type = self._analyze_type_for_options(\n            field_info.type,\n        )\n\n        if contains_options and isinstance(value, dict):\n            if options_class is not None and not is_dict_type:\n                # Handle direct Options types (e.g., MyOptions, Optional[MyOptions])\n                current_value = getattr(self, field_name)\n                if current_value is None:\n                    current_value = options_class()\n                current_value.update(value)\n                setattr(self, field_name, current_value)\n            else:\n                # Handle Dict[str, Options] or similar complex types\n                # The value is a dict that should contain Options objects\n                # We'll process it recursively during asdict() call\n                setattr(self, field_name, value)\n        else:\n            # Simple value assignment - set the field directly to bypass validation\n            # This is what we want for the update method\n            setattr(self, field_name, value)\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options.Options.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert options to dictionary with camelCase keys for frontend.</p> <p>This method provides comprehensive serialization of option objects for frontend communication. It handles complex nested structures, enum values, and special field flattening patterns.</p> <p>The serialization process: 1. Iterates through all dataclass fields 2. Skips None values, empty strings, and empty dictionaries 3. Converts enum values to their .value property 4. Recursively serializes nested Options objects 5. Handles lists of Options objects 6. Recursively processes dictionaries that may contain Options objects at any level 7. Converts field names from snake_case to camelCase 8. Applies special flattening logic for _options fields</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary with camelCase keys ready for frontend consumption. All nested structures are properly serialized and enum values are converted to their primitive representations.</p> Note <ul> <li>Empty dictionaries and None values are omitted from output</li> <li>Enum values are automatically converted to their .value property</li> <li>Nested Options objects are recursively serialized</li> <li>Lists containing Options objects are handled recursively</li> <li>Dictionaries containing Options objects at any nesting level are processed recursively</li> <li>background_options fields are flattened into the parent result</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/charts/options/base_options.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert options to dictionary with camelCase keys for frontend.\n\n    This method provides comprehensive serialization of option objects for\n    frontend communication. It handles complex nested structures, enum values,\n    and special field flattening patterns.\n\n    The serialization process:\n    1. Iterates through all dataclass fields\n    2. Skips None values, empty strings, and empty dictionaries\n    3. Converts enum values to their .value property\n    4. Recursively serializes nested Options objects\n    5. Handles lists of Options objects\n    6. Recursively processes dictionaries that may contain Options objects at any level\n    7. Converts field names from snake_case to camelCase\n    8. Applies special flattening logic for _options fields\n\n    Returns:\n        Dict[str, Any]: Dictionary with camelCase keys ready for frontend\n            consumption. All nested structures are properly serialized and\n            enum values are converted to their primitive representations.\n\n    Note:\n        - Empty dictionaries and None values are omitted from output\n        - Enum values are automatically converted to their .value property\n        - Nested Options objects are recursively serialized\n        - Lists containing Options objects are handled recursively\n        - Dictionaries containing Options objects at any nesting level are processed recursively\n        - background_options fields are flattened into the parent result\n    \"\"\"\n    # Use the inherited serialization from SerializableMixin\n    return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/base_options.html#streamlit_lightweight_charts_pro.charts.options.base_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html","title":"streamlit_lightweight_charts_pro.charts.options.chart_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options","title":"chart_options","text":"<p>Chart options configuration for streamlit-lightweight-charts.</p> <p>This module provides the main ChartOptions class for configuring chart display, behavior, and appearance. ChartOptions serves as the central configuration container for all chart-related settings including layout, interaction, localization, and trade visualization features.</p> Key Features <ul> <li>Comprehensive chart configuration management</li> <li>Layout and sizing options for responsive design</li> <li>Price scale configuration for multi-scale charts</li> <li>Time scale customization for different timeframes</li> <li>Interactive features like crosshair and tracking modes</li> <li>Grid and visual styling options</li> <li>Localization support for international markets</li> <li>Trade visualization and range switching capabilities</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800, height=400, auto_size=True, layout=LayoutOptions(text_color=\"#000000\")\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options.ChartOptions","title":"ChartOptions  <code>dataclass</code>","text":"<p>Configuration options for chart display and behavior in financial visualization.</p> <p>This class encapsulates all the configuration options that control how a chart is displayed, including its size, layout, grid settings, and various interactive features. It provides a comprehensive interface for customizing chart appearance and behavior across different chart types and use cases.</p> <p>The ChartOptions class serves as the central configuration container that combines layout, interaction, localization, and visualization settings into a unified configuration object that can be passed to chart instances.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Optional[int]</code> <p>Chart width in pixels. If None, uses 100% of container width. Defaults to None for automatic sizing.</p> <code>height</code> <code>int</code> <p>Chart height in pixels. Defaults to 400.</p> <code>auto_size</code> <code>bool</code> <p>Whether to automatically size the chart to fit its container. Defaults to False.</p> <code>layout</code> <code>LayoutOptions</code> <p>Chart layout configuration including background colors, text styling, and visual appearance settings.</p> <code>left_price_scale</code> <code>Optional[PriceScaleOptions]</code> <p>Left price scale configuration. If None, left price scale is disabled.</p> <code>right_price_scale</code> <code>PriceScaleOptions</code> <p>Right price scale configuration. Defaults to standard right price scale settings.</p> <code>overlay_price_scales</code> <code>Dict[str, PriceScaleOptions]</code> <p>Overlay price scale configurations for multiple price scales on the same chart.</p> <code>time_scale</code> <code>TimeScaleOptions</code> <p>Time scale configuration including axis settings, time formatting, and time range controls.</p> <code>crosshair</code> <code>CrosshairOptions</code> <p>Crosshair configuration for mouse interactions and data point highlighting.</p> <code>grid</code> <code>GridOptions</code> <p>Grid configuration for horizontal and vertical grid lines.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to enable scroll interactions for time navigation. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to enable scale interactions for zooming. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to enable double-click interactions. Defaults to True.</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to False.</p> <code>kinetic_scroll</code> <code>Optional[KineticScrollOptions]</code> <p>Kinetic scroll options for momentum-based scrolling behavior.</p> <code>tracking_mode</code> <code>Optional[TrackingModeOptions]</code> <p>Mouse tracking mode for crosshair and tooltips. Controls how the chart responds to mouse movement.</p> <code>localization</code> <code>Optional[LocalizationOptions]</code> <p>Localization settings for date/time formatting and locale-specific display options.</p> <code>add_default_pane</code> <code>bool</code> <p>Whether to add a default pane to the chart. Defaults to True.</p> <code>trade_visualization</code> <code>Optional[TradeVisualizationOptions]</code> <p>Trade visualization configuration options for displaying trade markers and annotations.</p> <code>range_switcher</code> <code>Optional[RangeSwitcherOptions]</code> <p>Range switcher configuration for time range selection buttons and presets.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any attribute is assigned an invalid type during initialization.</p> <code>PriceScaleIdTypeError</code> <p>If price scale ID is not a string.</p> <code>PriceScaleOptionsTypeError</code> <p>If price scale options are not of correct type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import ChartOptions\nfrom streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n# Create custom chart options\noptions = ChartOptions(\n    width=800,\n    height=600,\n    layout=LayoutOptions(background_color=\"#ffffff\"),\n    handle_scroll=True,\n    handle_scale=True,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/chart_options.py</code> <pre><code>@dataclass\n@chainable_field(\"width\", int)\n@chainable_field(\"height\", int)\n@chainable_field(\"auto_size\", bool)\n@chainable_field(\"layout\", LayoutOptions)\n@chainable_field(\"left_price_scale\", PriceScaleOptions)\n@chainable_field(\"right_price_scale\", PriceScaleOptions)\n@chainable_field(\"overlay_price_scales\", dict)\n@chainable_field(\"time_scale\", TimeScaleOptions)\n@chainable_field(\"crosshair\", CrosshairOptions)\n@chainable_field(\"grid\", GridOptions)\n@chainable_field(\"handle_scroll\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"kinetic_scroll\", KineticScrollOptions)\n@chainable_field(\"tracking_mode\", TrackingModeOptions)\n@chainable_field(\"localization\", LocalizationOptions)\n@chainable_field(\"add_default_pane\", bool)\n@chainable_field(\"trade_visualization\", TradeVisualizationOptions)\n@chainable_field(\"range_switcher\", RangeSwitcherOptions)\nclass ChartOptions(Options):\n    \"\"\"Configuration options for chart display and behavior in financial visualization.\n\n    This class encapsulates all the configuration options that control how a chart\n    is displayed, including its size, layout, grid settings, and various interactive\n    features. It provides a comprehensive interface for customizing chart appearance\n    and behavior across different chart types and use cases.\n\n    The ChartOptions class serves as the central configuration container that combines\n    layout, interaction, localization, and visualization settings into a unified\n    configuration object that can be passed to chart instances.\n\n    Attributes:\n        width (Optional[int]): Chart width in pixels. If None, uses 100% of container width.\n            Defaults to None for automatic sizing.\n        height (int): Chart height in pixels. Defaults to 400.\n        auto_size (bool): Whether to automatically size the chart to fit its container.\n            Defaults to False.\n        layout (LayoutOptions): Chart layout configuration including background colors,\n            text styling, and visual appearance settings.\n        left_price_scale (Optional[PriceScaleOptions]): Left price scale configuration.\n            If None, left price scale is disabled.\n        right_price_scale (PriceScaleOptions): Right price scale configuration.\n            Defaults to standard right price scale settings.\n        overlay_price_scales (Dict[str, PriceScaleOptions]): Overlay price scale\n            configurations for multiple price scales on the same chart.\n        time_scale (TimeScaleOptions): Time scale configuration including axis settings,\n            time formatting, and time range controls.\n        crosshair (CrosshairOptions): Crosshair configuration for mouse interactions\n            and data point highlighting.\n        grid (GridOptions): Grid configuration for horizontal and vertical grid lines.\n        handle_scroll (bool): Whether to enable scroll interactions for time navigation.\n            Defaults to True.\n        handle_scale (bool): Whether to enable scale interactions for zooming.\n            Defaults to True.\n        handle_double_click (bool): Whether to enable double-click interactions.\n            Defaults to True.\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to False.\n        kinetic_scroll (Optional[KineticScrollOptions]): Kinetic scroll options for\n            momentum-based scrolling behavior.\n        tracking_mode (Optional[TrackingModeOptions]): Mouse tracking mode for crosshair\n            and tooltips. Controls how the chart responds to mouse movement.\n        localization (Optional[LocalizationOptions]): Localization settings for date/time\n            formatting and locale-specific display options.\n        add_default_pane (bool): Whether to add a default pane to the chart.\n            Defaults to True.\n        trade_visualization (Optional[TradeVisualizationOptions]): Trade visualization\n            configuration options for displaying trade markers and annotations.\n        range_switcher (Optional[RangeSwitcherOptions]): Range switcher configuration\n            for time range selection buttons and presets.\n\n    Raises:\n        TypeError: If any attribute is assigned an invalid type during initialization.\n        PriceScaleIdTypeError: If price scale ID is not a string.\n        PriceScaleOptionsTypeError: If price scale options are not of correct type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import ChartOptions\n        from streamlit_lightweight_charts_pro.charts.options.layout_options import LayoutOptions\n\n        # Create custom chart options\n        options = ChartOptions(\n            width=800,\n            height=600,\n            layout=LayoutOptions(background_color=\"#ffffff\"),\n            handle_scroll=True,\n            handle_scale=True,\n        )\n        ```\n    \"\"\"\n\n    # Size and layout options\n    width: Optional[int] = None\n    height: int = 400\n    auto_size: bool = True\n\n    # Layout and appearance\n    layout: LayoutOptions = field(default_factory=LayoutOptions)\n    left_price_scale: Optional[PriceScaleOptions] = None\n    right_price_scale: PriceScaleOptions = field(default_factory=PriceScaleOptions)\n    overlay_price_scales: Dict[str, PriceScaleOptions] = field(default_factory=dict)\n    time_scale: TimeScaleOptions = field(default_factory=TimeScaleOptions)\n\n    # Interaction options\n    crosshair: CrosshairOptions = field(default_factory=CrosshairOptions)\n    grid: GridOptions = field(default_factory=GridOptions)\n    handle_scroll: bool = True\n    handle_scale: bool = True\n    handle_double_click: bool = True\n    fit_content_on_load: bool = True\n    kinetic_scroll: Optional[KineticScrollOptions] = None\n    tracking_mode: Optional[TrackingModeOptions] = None\n\n    # Localization and UI\n    localization: Optional[LocalizationOptions] = None\n    add_default_pane: bool = True\n\n    # Trade visualization options\n    trade_visualization: Optional[TradeVisualizationOptions] = None\n\n    # UI options\n    range_switcher: Optional[RangeSwitcherOptions] = None\n\n    # Synchronization options\n\n    def __post_init__(self):\n        \"\"\"Validate chart options after initialization.\"\"\"\n        # Validate price scale options\n        if self.right_price_scale is not None and not isinstance(\n            self.right_price_scale,\n            PriceScaleOptions,\n        ):\n            if isinstance(self.right_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"right_price_scale\",\n                    type(self.right_price_scale),\n                )\n            raise PriceScaleOptionsTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale),\n            )\n\n        if self.left_price_scale is not None and not isinstance(\n            self.left_price_scale,\n            PriceScaleOptions,\n        ):\n            if isinstance(self.left_price_scale, bool):\n                raise PriceScaleOptionsTypeError(\n                    \"left_price_scale\",\n                    type(self.left_price_scale),\n                )\n            raise PriceScaleOptionsTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale),\n            )\n\n        # Validate price scale IDs are strings\n        if (\n            self.right_price_scale is not None\n            and self.right_price_scale.price_scale_id is not None\n            and not isinstance(self.right_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"right_price_scale\",\n                type(self.right_price_scale.price_scale_id),\n            )\n\n        if (\n            self.left_price_scale is not None\n            and self.left_price_scale.price_scale_id is not None\n            and not isinstance(self.left_price_scale.price_scale_id, str)\n        ):\n            raise PriceScaleIdTypeError(\n                \"left_price_scale\",\n                type(self.left_price_scale.price_scale_id),\n            )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/chart_options.html#streamlit_lightweight_charts_pro.charts.options.chart_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html","title":"streamlit_lightweight_charts_pro.charts.options.interaction_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options","title":"interaction_options","text":"<p>Interaction options configuration for streamlit-lightweight-charts.</p> <p>This module provides interaction-related option classes for configuring crosshair behavior, kinetic scrolling, and tracking modes.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairLineOptions","title":"CrosshairLineOptions  <code>dataclass</code>","text":"<p>Crosshair line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"label_visible\", bool)\nclass CrosshairLineOptions(Options):\n    \"\"\"Crosshair line configuration.\"\"\"\n\n    color: str = \"#758696\"\n    width: int = 1\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = True\n    label_visible: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairSyncOptions","title":"CrosshairSyncOptions  <code>dataclass</code>","text":"<p>Crosshair synchronization configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"group_id\", int)\n@chainable_field(\"suppress_series_animations\", bool)\nclass CrosshairSyncOptions(Options):\n    \"\"\"Crosshair synchronization configuration.\"\"\"\n\n    group_id: int = 1\n    suppress_series_animations: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.CrosshairOptions","title":"CrosshairOptions  <code>dataclass</code>","text":"<p>Crosshair configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"mode\", CrosshairMode)\n@chainable_field(\"vert_line\", CrosshairLineOptions)\n@chainable_field(\"horz_line\", CrosshairLineOptions)\nclass CrosshairOptions(Options):\n    \"\"\"Crosshair configuration for chart.\"\"\"\n\n    mode: CrosshairMode = CrosshairMode.NORMAL\n    vert_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n    horz_line: CrosshairLineOptions = field(default_factory=CrosshairLineOptions)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.KineticScrollOptions","title":"KineticScrollOptions  <code>dataclass</code>","text":"<p>Kinetic scroll configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"touch\", bool)\n@chainable_field(\"mouse\", bool)\nclass KineticScrollOptions(Options):\n    \"\"\"Kinetic scroll configuration for chart.\"\"\"\n\n    touch: bool = True\n    mouse: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options.TrackingModeOptions","title":"TrackingModeOptions  <code>dataclass</code>","text":"<p>Tracking mode configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/interaction_options.py</code> <pre><code>@dataclass\n@chainable_field(\"exit_on_escape\", bool)\nclass TrackingModeOptions(Options):\n    \"\"\"Tracking mode configuration for chart.\"\"\"\n\n    exit_on_escape: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/interaction_options.html#streamlit_lightweight_charts_pro.charts.options.interaction_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html","title":"streamlit_lightweight_charts_pro.charts.options.layout_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options","title":"layout_options","text":"<p>Layout options configuration for streamlit-lightweight-charts.</p> <p>This module provides layout-related option classes for configuring chart appearance, grid settings, panes, and watermarks.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.GridLineOptions","title":"GridLineOptions  <code>dataclass</code>","text":"<p>Grid line configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"style\", LineStyle)\n@chainable_field(\"visible\", bool)\nclass GridLineOptions(Options):\n    \"\"\"Grid line configuration.\"\"\"\n\n    color: str = \"#e1e3e6\"\n    style: LineStyle = LineStyle.SOLID\n    visible: bool = False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.GridOptions","title":"GridOptions  <code>dataclass</code>","text":"<p>Grid configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"vert_lines\", GridLineOptions)\n@chainable_field(\"horz_lines\", GridLineOptions)\nclass GridOptions(Options):\n    \"\"\"Grid configuration for chart.\"\"\"\n\n    vert_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=False))\n    horz_lines: GridLineOptions = field(default_factory=lambda: GridLineOptions(visible=True))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.PaneOptions","title":"PaneOptions  <code>dataclass</code>","text":"<p>Pane configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"separator_color\", str, validator=\"color\")\n@chainable_field(\"separator_hover_color\", str, validator=\"color\")\n@chainable_field(\"enable_resize\", bool)\nclass PaneOptions(Options):\n    \"\"\"Pane configuration for chart.\"\"\"\n\n    separator_color: str = \"#e1e3ea\"\n    separator_hover_color: str = \"#ffffff\"\n    enable_resize: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.PaneHeightOptions","title":"PaneHeightOptions  <code>dataclass</code>","text":"<p>Pane height configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"factor\", float)\nclass PaneHeightOptions(Options):\n    \"\"\"Pane height configuration for chart.\"\"\"\n\n    factor: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate factor value.\"\"\"\n        if self.factor &lt;= 0:\n            raise ValueValidationError.positive_value(\"Pane height factor\", self.factor)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.LayoutOptions","title":"LayoutOptions  <code>dataclass</code>","text":"<p>Layout configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"background_options\", (BackgroundSolid, BackgroundGradient))\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"font_size\", int)\n@chainable_field(\"font_family\", str)\n@chainable_field(\"pane_options\", PaneOptions)\n@chainable_field(\"pane_heights\", Dict[int, PaneHeightOptions])\n@chainable_field(\"attribution_logo\", bool)\nclass LayoutOptions(Options):\n    \"\"\"Layout configuration for chart.\"\"\"\n\n    background_options: BackgroundSolid = field(\n        default_factory=lambda: BackgroundSolid(color=\"#ffffff\"),\n    )\n    text_color: str = \"#131722\"\n    font_size: int = 11\n    font_family: str = \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\"\n    pane_options: Optional[PaneOptions] = None\n    pane_heights: Optional[Dict[int, PaneHeightOptions]] = None\n    attribution_logo: bool = False\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ValueValidationError(property_name, \"Invalid color format\")\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options.WatermarkOptions","title":"WatermarkOptions  <code>dataclass</code>","text":"<p>Watermark configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/layout_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"text\", str)\n@chainable_field(\"font_size\", int)\n@chainable_field(\"horz_align\", HorzAlign)\n@chainable_field(\"vert_align\", VertAlign)\n@chainable_field(\"color\", str, validator=\"color\")\nclass WatermarkOptions(Options):\n    \"\"\"Watermark configuration.\"\"\"\n\n    visible: bool = True\n    text: str = \"\"\n    font_size: int = 96\n    horz_align: HorzAlign = HorzAlign.CENTER\n    vert_align: VertAlign = VertAlign.CENTER\n    color: str = \"rgba(255, 255, 255, 0.1)\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/layout_options.html#streamlit_lightweight_charts_pro.charts.options.layout_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html","title":"streamlit_lightweight_charts_pro.charts.options.line_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options","title":"line_options","text":"<p>Line options configuration for streamlit-lightweight-charts.</p> <p>This module provides line styling option classes for configuring the appearance of line series on charts. It includes comprehensive styling options for line visualization including colors, styles, markers, and animation effects.</p> Key Features <ul> <li>Line color, style, and width customization</li> <li>Point marker configuration for data points</li> <li>Crosshair marker styling for interaction</li> <li>Animation effects for price updates</li> <li>Line type options (simple, curved, stepped)</li> <li>Visibility controls for different line elements</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import LineOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import LineStyle, LineType\n\n# Create line options with custom styling\nline_opts = LineOptions(\n    color=\"#2196F3\", line_style=LineStyle.SOLID, line_width=2, point_markers_visible=True\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options.LineOptions","title":"LineOptions  <code>dataclass</code>","text":"<p>Comprehensive styling options for line series in financial chart visualization.</p> <p>This class encapsulates all the styling options that control how a line series appears on a chart. It mirrors TradingView's LineStyleOptions interface and provides extensive customization capabilities for line visualization.</p> <p>The LineOptions class supports various line styles, marker configurations, animation effects, and visual customization options to create professional-looking line charts for financial data visualization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Line color in hex or rgba format. Defaults to \"#2196f3\" (blue). Must be a valid color format for proper rendering.</p> <code>line_style</code> <code>LineStyle</code> <p>Line style for the series line. Options include SOLID, DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.</p> <code>line_width</code> <code>int</code> <p>Line width in pixels. Defaults to 3. Higher values create thicker lines for better visibility.</p> <code>line_type</code> <code>LineType</code> <p>Line type for connecting data points. Options include SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.</p> <code>line_visible</code> <code>bool</code> <p>Whether to show the series line. Defaults to True. Set to False to show only markers.</p> <code>point_markers_visible</code> <code>bool</code> <p>Whether to show circle markers on each data point. Defaults to False. Useful for highlighting individual data points.</p> <code>point_markers_radius</code> <code>Optional[int]</code> <p>Radius of point markers in pixels. Defaults to None (uses default radius). Only used when point_markers_visible is True.</p> <code>crosshair_marker_visible</code> <code>bool</code> <p>Whether to show the crosshair marker during mouse interactions. Defaults to False. Provides visual feedback during hovering.</p> <code>crosshair_marker_radius</code> <code>int</code> <p>Radius of crosshair marker in pixels. Defaults to 4. Controls the size of the interaction marker.</p> <code>crosshair_marker_border_color</code> <code>str</code> <p>Border color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_background_color</code> <code>str</code> <p>Background color for crosshair marker. Defaults to empty string (uses default color). Must be valid color format.</p> <code>crosshair_marker_border_width</code> <code>int</code> <p>Border width for crosshair marker in pixels. Defaults to 2. Controls the thickness of the marker border.</p> <code>last_price_animation</code> <code>LastPriceAnimationMode</code> <p>Animation mode for last price updates. Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.</p> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If color values are not in valid hex or rgba format.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import LineOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import (\n    LineStyle,\n    LineType,\n    LastPriceAnimationMode,\n)\n\n# Create line options with custom styling\nline_opts = LineOptions(\n    color=\"#FF5722\",\n    line_style=LineStyle.SOLID,\n    line_width=2,\n    line_type=LineType.CURVED,\n    point_markers_visible=True,\n    crosshair_marker_visible=True,\n    last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n)\n\n# Use with line series\nseries = LineSeries(data=data, line_options=line_opts)\n</code></pre> See also <p>TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_type\", LineType)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"point_markers_visible\", bool)\n@chainable_field(\"point_markers_radius\", int)\n@chainable_field(\"crosshair_marker_visible\", bool)\n@chainable_field(\"crosshair_marker_radius\", int)\n@chainable_field(\"crosshair_marker_border_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_background_color\", str, validator=\"color\")\n@chainable_field(\"crosshair_marker_border_width\", int)\n@chainable_field(\"last_price_animation\", LastPriceAnimationMode)\nclass LineOptions(Options):\n    \"\"\"Comprehensive styling options for line series in financial chart visualization.\n\n    This class encapsulates all the styling options that control how a line series\n    appears on a chart. It mirrors TradingView's LineStyleOptions interface and\n    provides extensive customization capabilities for line visualization.\n\n    The LineOptions class supports various line styles, marker configurations,\n    animation effects, and visual customization options to create professional-looking\n    line charts for financial data visualization.\n\n    Attributes:\n        color (str): Line color in hex or rgba format. Defaults to \"#2196f3\" (blue).\n            Must be a valid color format for proper rendering.\n        line_style (LineStyle): Line style for the series line. Options include SOLID,\n            DOTTED, DASHED, LARGE_DASHED, SPARSE_DOTTED. Defaults to LineStyle.SOLID.\n        line_width (int): Line width in pixels. Defaults to 3. Higher values create\n            thicker lines for better visibility.\n        line_type (LineType): Line type for connecting data points. Options include\n            SIMPLE, CURVED, STEPPED. Defaults to LineType.SIMPLE for straight connections.\n        line_visible (bool): Whether to show the series line. Defaults to True.\n            Set to False to show only markers.\n        point_markers_visible (bool): Whether to show circle markers on each data point.\n            Defaults to False. Useful for highlighting individual data points.\n        point_markers_radius (Optional[int]): Radius of point markers in pixels.\n            Defaults to None (uses default radius). Only used when point_markers_visible is True.\n        crosshair_marker_visible (bool): Whether to show the crosshair marker during\n            mouse interactions. Defaults to False. Provides visual feedback during hovering.\n        crosshair_marker_radius (int): Radius of crosshair marker in pixels.\n            Defaults to 4. Controls the size of the interaction marker.\n        crosshair_marker_border_color (str): Border color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_background_color (str): Background color for crosshair marker.\n            Defaults to empty string (uses default color). Must be valid color format.\n        crosshair_marker_border_width (int): Border width for crosshair marker in pixels.\n            Defaults to 2. Controls the thickness of the marker border.\n        last_price_animation (LastPriceAnimationMode): Animation mode for last price updates.\n            Options include DISABLED, CONTINUOUS, ON_DATA_UPDATE. Defaults to DISABLED.\n\n    Raises:\n        ColorValidationError: If color values are not in valid hex or rgba format.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import LineOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import (\n            LineStyle,\n            LineType,\n            LastPriceAnimationMode,\n        )\n\n        # Create line options with custom styling\n        line_opts = LineOptions(\n            color=\"#FF5722\",\n            line_style=LineStyle.SOLID,\n            line_width=2,\n            line_type=LineType.CURVED,\n            point_markers_visible=True,\n            crosshair_marker_visible=True,\n            last_price_animation=LastPriceAnimationMode.CONTINUOUS,\n        )\n\n        # Use with line series\n        series = LineSeries(data=data, line_options=line_opts)\n        ```\n\n    See also:\n        TradingView LineStyleOptions: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/LineStyleOptions\n    \"\"\"\n\n    color: str = \"#2196f3\"\n    line_style: LineStyle = LineStyle.SOLID\n    line_width: int = 3\n    line_type: LineType = LineType.SIMPLE\n    line_visible: bool = True\n    point_markers_visible: bool = False\n    point_markers_radius: Optional[int] = None\n    crosshair_marker_visible: bool = False\n    crosshair_marker_radius: int = 4\n    crosshair_marker_border_color: str = \"\"\n    crosshair_marker_background_color: str = \"\"\n    crosshair_marker_border_width: int = 2\n    last_price_animation: LastPriceAnimationMode = LastPriceAnimationMode.DISABLED\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\n\n        Validates that the provided color string is in a valid format (hex or rgba)\n        and raises an appropriate error if validation fails. This method is used\n        by the chainable_field decorator for color validation.\n\n        Args:\n            color (str): Color string to validate in hex or rgba format.\n            property_name (str): Name of the property being validated for error messages.\n\n        Returns:\n            str: The validated color string if valid.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n\n        Example:\n            ```python\n            # Valid colors\n            valid_color = LineOptions._validate_color_static(\"#FF0000\", \"color\")\n            valid_rgba = LineOptions._validate_color_static(\"rgba(255,0,0,0.5)\", \"color\")\n\n            # Invalid color (will raise ColorValidationError)\n            try:\n                invalid_color = LineOptions._validate_color_static(\"invalid\", \"color\")\n            except ColorValidationError as e:\n                print(f\"Invalid color: {e}\")\n            ```\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/line_options.html#streamlit_lightweight_charts_pro.charts.options.line_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html","title":"streamlit_lightweight_charts_pro.charts.options.localization_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options","title":"localization_options","text":"<p>Localization option classes for streamlit-lightweight-charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options.LocalizationOptions","title":"LocalizationOptions  <code>dataclass</code>","text":"<p>Localization configuration for chart.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/localization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"locale\", str)\n@chainable_field(\"date_format\", str)\n@chainable_field(\"time_format\", str)\n@chainable_field(\"price_formatter\", Callable)\n@chainable_field(\"percentage_formatter\", Callable)\nclass LocalizationOptions(Options):\n    \"\"\"Localization configuration for chart.\"\"\"\n\n    locale: str = \"en-US\"\n    date_format: str = \"yyyy-MM-dd\"\n    time_format: str = \"HH:mm:ss\"\n    price_formatter: Optional[Callable] = None\n    percentage_formatter: Optional[Callable] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/localization_options.html#streamlit_lightweight_charts_pro.charts.options.localization_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_format_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options","title":"price_format_options","text":"<p>Price format options configuration for streamlit-lightweight-charts.</p> <p>This module provides price formatting option classes for configuring how price values are displayed on charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options.PriceFormatOptions","title":"PriceFormatOptions  <code>dataclass</code>","text":"<p>Encapsulates price formatting options for a series, matching TradingView's API.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Format type (\"price\", \"volume\", \"percent\", \"custom\").</p> <code>precision</code> <code>int</code> <p>Number of decimal places.</p> <code>min_move</code> <code>float</code> <p>Minimum price movement.</p> <code>formatter</code> <code>Optional[str]</code> <p>Optional custom formatter (string name or function reference).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_format_options.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str, validator=\"price_format_type\")\n@chainable_field(\"precision\", int, validator=\"precision\")\n@chainable_field(\"min_move\", (int, float), validator=\"min_move\")\n@chainable_field(\"formatter\", str)\nclass PriceFormatOptions(Options):\n    \"\"\"Encapsulates price formatting options for a series, matching TradingView's API.\n\n    Attributes:\n        type (str): Format type (\"price\", \"volume\", \"percent\", \"custom\").\n        precision (int): Number of decimal places.\n        min_move (float): Minimum price movement.\n        formatter (Optional[str]): Optional custom formatter (string name or function reference).\n    \"\"\"\n\n    type: str = \"price\"\n    precision: int = 2\n    min_move: float = 0.01\n    formatter: Optional[str] = None\n\n    @staticmethod\n    def _validate_type_static(type_value: str) -&gt; str:\n        \"\"\"Static version of type validator for decorator use.\"\"\"\n        if type_value not in {\"price\", \"volume\", \"percent\", \"custom\"}:\n            raise ValueValidationError(\n                \"type\",\n                f\"must be one of 'price', 'volume', 'percent', 'custom', got {type_value!r}\",\n            )\n        return type_value\n\n    @staticmethod\n    def _validate_precision_static(precision: int) -&gt; int:\n        \"\"\"Static version of precision validator for decorator use.\"\"\"\n        if not isinstance(precision, int) or precision &lt; 0:\n            raise ValueValidationError(\"precision\", \"must be a non-negative integer\")\n        return precision\n\n    @staticmethod\n    def _validate_min_move_static(min_move: float) -&gt; float:\n        \"\"\"Static version of min_move validator for decorator use.\"\"\"\n        if not isinstance(min_move, (int, float)) or min_move &lt;= 0:\n            raise ValueValidationError(\"min_move\", \"must be a positive number\")\n        return min_move\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_format_options.html#streamlit_lightweight_charts_pro.charts.options.price_format_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_line_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options","title":"price_line_options","text":"<p>Price line options configuration for streamlit-lightweight-charts.</p> <p>This module provides price line option classes for configuring horizontal price lines on charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options.PriceLineOptions","title":"PriceLineOptions  <code>dataclass</code>","text":"<p>Encapsulates style and configuration options for a price line.</p> <p>Matching TradingView's PriceLineOptions.</p> <p>See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[str]</code> <p>Optional ID of the price line.</p> <code>price</code> <code>float</code> <p>Price line's value.</p> <code>color</code> <code>str</code> <p>Price line's color (hex or rgba).</p> <code>line_width</code> <code>int</code> <p>Price line's width in pixels.</p> <code>line_style</code> <code>LineStyle</code> <p>Price line's style.</p> <code>line_visible</code> <code>bool</code> <p>Whether the line is displayed.</p> <code>axis_label_visible</code> <code>bool</code> <p>Whether the price value is shown on the price scale.</p> <code>title</code> <code>str</code> <p>Title for the price line on the chart pane.</p> <code>axis_label_color</code> <code>Optional[str]</code> <p>Background color for the axis label.</p> <code>axis_label_text_color</code> <code>Optional[str]</code> <p>Text color for the axis label.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_line_options.py</code> <pre><code>@dataclass\n@chainable_field(\"id\", str)\n@chainable_field(\"price\", (int, float))\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", LineStyle)\n@chainable_field(\"line_visible\", bool)\n@chainable_field(\"axis_label_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"axis_label_color\", str, validator=\"color\")\n@chainable_field(\"axis_label_text_color\", str, validator=\"color\")\nclass PriceLineOptions(Options):\n    \"\"\"Encapsulates style and configuration options for a price line.\n\n    Matching TradingView's PriceLineOptions.\n\n    See: https://tradingview.github.io/lightweight-charts/docs/api/interfaces/PriceLineOptions\n\n    Attributes:\n        id (Optional[str]): Optional ID of the price line.\n        price (float): Price line's value.\n        color (str): Price line's color (hex or rgba).\n        line_width (int): Price line's width in pixels.\n        line_style (LineStyle): Price line's style.\n        line_visible (bool): Whether the line is displayed.\n        axis_label_visible (bool): Whether the price value is shown on the price scale.\n        title (str): Title for the price line on the chart pane.\n        axis_label_color (Optional[str]): Background color for the axis label.\n        axis_label_text_color (Optional[str]): Text color for the axis label.\n    \"\"\"\n\n    id: Optional[str] = None\n    price: float = 0.0\n    color: str = \"\"\n    line_width: int = 1\n    line_style: LineStyle = LineStyle.SOLID\n    line_visible: bool = True\n    axis_label_visible: bool = True\n    title: str = \"\"\n    axis_label_color: Optional[str] = None\n    axis_label_text_color: Optional[str] = None\n\n    @staticmethod\n    def _validate_color_static(color: str, property_name: str) -&gt; str:\n        \"\"\"Static version of color validator for decorator use.\"\"\"\n        if color and not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_line_options.html#streamlit_lightweight_charts_pro.charts.options.price_line_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html","title":"streamlit_lightweight_charts_pro.charts.options.price_scale_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options","title":"price_scale_options","text":"<p>Price scale option classes for streamlit-lightweight-charts.</p> <p>This module provides comprehensive configuration options for price scales in financial charts. Price scales control how price values are displayed, formatted, and positioned on the chart, including both left and right price scales as well as overlay scales.</p> Key Features <ul> <li>Price scale visibility and behavior configuration</li> <li>Auto-scaling and manual scale control options</li> <li>Visual appearance customization (colors, borders, text)</li> <li>Tick marks and label positioning options</li> <li>Scale margins and minimum width settings</li> <li>Price scale identification and management</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n# Create price scale options\nprice_scale = PriceScaleOptions(\n    visible=True,\n    auto_scale=True,\n    mode=PriceScaleMode.NORMAL,\n    border_color=\"#e0e0e0\",\n    text_color=\"#333333\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options.PriceScaleMargins","title":"PriceScaleMargins  <code>dataclass</code>","text":"<p>Configuration for price scale margins in financial charts.</p> <p>This class defines the margin settings for price scales, controlling the spacing between the chart content and the price scale boundaries. Margins are specified as percentages of the visible price range.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space above the chart.</p> <code>bottom</code> <code>float</code> <p>Bottom margin as a percentage of the visible price range. Defaults to 0.1 (10%). Higher values create more space below the chart.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n# Create margins with custom spacing\nmargins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n# Use with price scale options\nprice_scale = PriceScaleOptions(scale_margins=margins)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"top\", (int, float))\n@chainable_field(\"bottom\", (int, float))\nclass PriceScaleMargins(Options):\n    \"\"\"Configuration for price scale margins in financial charts.\n\n    This class defines the margin settings for price scales, controlling the\n    spacing between the chart content and the price scale boundaries. Margins\n    are specified as percentages of the visible price range.\n\n    Attributes:\n        top (float): Top margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space above the chart.\n        bottom (float): Bottom margin as a percentage of the visible price range.\n            Defaults to 0.1 (10%). Higher values create more space below the chart.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleMargins\n\n        # Create margins with custom spacing\n        margins = PriceScaleMargins(top=0.05, bottom=0.05)  # 5% margins\n\n        # Use with price scale options\n        price_scale = PriceScaleOptions(scale_margins=margins)\n        ```\n    \"\"\"\n\n    top: float = 0.1  # Top margin as percentage of visible price range\n    bottom: float = 0.1  # Bottom margin as percentage of visible price range\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options.PriceScaleOptions","title":"PriceScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for price scales in financial charts.</p> <p>This class provides extensive configuration options for price scales, controlling how price values are displayed, formatted, and positioned on the chart. It supports both left and right price scales as well as overlay scales with full customization of appearance, behavior, and interaction.</p> <p>Attributes:</p> Name Type Description <code>visible</code> <code>bool</code> <p>Whether the price scale is visible. Defaults to True.</p> <code>auto_scale</code> <code>bool</code> <p>Whether to automatically scale the price range based on data. Defaults to True. Set to False for manual scale control.</p> <code>mode</code> <code>PriceScaleMode</code> <p>Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE). Defaults to PriceScaleMode.NORMAL for linear scaling.</p> <code>invert_scale</code> <code>bool</code> <p>Whether to invert the price scale (high to low). Defaults to False for normal orientation.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the price scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the price scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>text_color</code> <code>str</code> <p>Color of price scale text and labels. Defaults to dark gray. Must be valid color format (hex or rgba).</p> <code>ticks_visible</code> <code>bool</code> <p>Whether to show tick marks on the price scale. Defaults to True.</p> <code>ensure_edge_tick_marks_visible</code> <code>bool</code> <p>Whether to ensure edge tick marks are always visible. Defaults to False.</p> <code>align_labels</code> <code>bool</code> <p>Whether to align price labels. Defaults to True.</p> <code>entire_text_only</code> <code>bool</code> <p>Whether to show only complete text labels. Defaults to False.</p> <code>minimum_width</code> <code>int</code> <p>Minimum width of the price scale in pixels. Defaults to 72 pixels.</p> <code>scale_margins</code> <code>PriceScaleMargins</code> <p>Margin configuration for the price scale. Defaults to 10% margins on top and bottom.</p> <code>price_scale_id</code> <code>str</code> <p>Unique identifier for the price scale. Defaults to \"\".</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n# Create left price scale with custom styling\nleft_scale = PriceScaleOptions(\n    visible=True,\n    auto_scale=True,\n    mode=PriceScaleMode.NORMAL,\n    border_color=\"#e0e0e0\",\n    text_color=\"#333333\",\n    minimum_width=100,\n)\n\n# Create right price scale for overlay series\nright_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n</code></pre> See also <p>PriceScaleMargins: Configuration class for price scale margins. PriceScaleMode: Enum for different price scale modes.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/price_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"auto_scale\", bool)\n@chainable_field(\"mode\", PriceScaleMode)\n@chainable_field(\"invert_scale\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"text_color\", str, validator=\"color\")\n@chainable_field(\"ticks_visible\", bool)\n@chainable_field(\"ensure_edge_tick_marks_visible\", bool)\n@chainable_field(\"align_labels\", bool)\n@chainable_field(\"entire_text_only\", bool)\n@chainable_field(\"minimum_width\", int)\n@chainable_field(\"scale_margins\", PriceScaleMargins)\n@chainable_field(\"price_scale_id\", str)\nclass PriceScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for price scales in financial charts.\n\n    This class provides extensive configuration options for price scales, controlling\n    how price values are displayed, formatted, and positioned on the chart. It supports\n    both left and right price scales as well as overlay scales with full customization\n    of appearance, behavior, and interaction.\n\n    Attributes:\n        visible (bool): Whether the price scale is visible. Defaults to True.\n        auto_scale (bool): Whether to automatically scale the price range based on data.\n            Defaults to True. Set to False for manual scale control.\n        mode (PriceScaleMode): Price scale mode (NORMAL, LOGARITHMIC, PERCENTAGE).\n            Defaults to PriceScaleMode.NORMAL for linear scaling.\n        invert_scale (bool): Whether to invert the price scale (high to low).\n            Defaults to False for normal orientation.\n        border_visible (bool): Whether to show the price scale border. Defaults to True.\n        border_color (str): Color of the price scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        text_color (str): Color of price scale text and labels. Defaults to dark gray.\n            Must be valid color format (hex or rgba).\n        ticks_visible (bool): Whether to show tick marks on the price scale.\n            Defaults to True.\n        ensure_edge_tick_marks_visible (bool): Whether to ensure edge tick marks\n            are always visible. Defaults to False.\n        align_labels (bool): Whether to align price labels. Defaults to True.\n        entire_text_only (bool): Whether to show only complete text labels.\n            Defaults to False.\n        minimum_width (int): Minimum width of the price scale in pixels.\n            Defaults to 72 pixels.\n        scale_margins (PriceScaleMargins): Margin configuration for the price scale.\n            Defaults to 10% margins on top and bottom.\n        price_scale_id (str): Unique identifier for the price scale. Defaults to \"\".\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import PriceScaleOptions\n        from streamlit_lightweight_charts_pro.type_definitions.enums import PriceScaleMode\n\n        # Create left price scale with custom styling\n        left_scale = PriceScaleOptions(\n            visible=True,\n            auto_scale=True,\n            mode=PriceScaleMode.NORMAL,\n            border_color=\"#e0e0e0\",\n            text_color=\"#333333\",\n            minimum_width=100,\n        )\n\n        # Create right price scale for overlay series\n        right_scale = PriceScaleOptions(visible=True, auto_scale=False, price_scale_id=\"overlay_scale\")\n        ```\n\n    See also:\n        PriceScaleMargins: Configuration class for price scale margins.\n        PriceScaleMode: Enum for different price scale modes.\n    \"\"\"\n\n    # Core visibility and behavior settings\n    visible: bool = True  # Whether the price scale is visible\n    auto_scale: bool = True  # Whether to automatically scale based on data\n    mode: PriceScaleMode = PriceScaleMode.NORMAL  # Price scale mode (linear/log/percentage)\n    invert_scale: bool = False  # Whether to invert the scale orientation\n\n    # Visual appearance configuration\n    border_visible: bool = True  # Whether to show the price scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n    text_color: str = \"#131722\"  # Text color (TradingView dark gray)\n\n    # Tick marks and label configuration\n    ticks_visible: bool = True  # Whether to show tick marks\n    ensure_edge_tick_marks_visible: bool = False  # Force edge tick marks to be visible\n    align_labels: bool = True  # Whether to align price labels\n    entire_text_only: bool = False  # Whether to show only complete text labels\n\n    # Size and positioning settings\n    minimum_width: int = 72  # Minimum width in pixels\n    scale_margins: PriceScaleMargins = field(\n        default_factory=PriceScaleMargins,\n    )  # Margin configuration\n\n    # Price scale identification\n    price_scale_id: str = \"\"  # Unique identifier for the price scale\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/price_scale_options.html#streamlit_lightweight_charts_pro.charts.options.price_scale_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html","title":"streamlit_lightweight_charts_pro.charts.options.sync_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options","title":"sync_options","text":"<p>Synchronization options for linked charts.</p> <p>This module provides synchronization configuration options for managing multiple linked charts. These options control how charts interact with each other when they are part of a linked chart system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions","title":"SyncOptions  <code>dataclass</code>","text":"<p>Synchronization options for linked charts.</p> <pre><code>    This class provides configuration options for synchronizing multiple\n        charts in a linked chart system. It controls crosshair and time range\n                                        synchronization behavior across linked charts.\n\n                                        Attributes:\n    enabled (bool): Whether synchronization is enabled. When True,\n    enables all synchronization features. When False, disables\n                                                all synchronization. Defaults to False.\n        crosshair (bool): Whether to synchronize crosshair position across\n        linked charts. When enabled, moving the crosshair on one chart\nwill update the crosshair position on all linked charts.\n                                                Defaults to False.\n        time_range (bool): Whether to synchronize time range across linked\n        charts. When enabled, zooming or panning the time range on one\n        chart will update the visible time range on all linked charts.\n                                                Defaults to False.\n    group_id (Optional[str]): Optional group identifier for chart\nsynchronization. Charts with the same group_id will be\nsynchronized with each other. If None, all charts in the\n        same LinkedChartManager will be synchronized. Defaults to None.\n\n                                        Example:\n                                            ```python\n            from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n                                            # Enable all synchronization\n                sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n                                            # Enable only crosshair synchronization\n                sync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n                                            # Use with group synchronization\n</code></pre> <p>sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True, group_id=\"price_charts\")                                                 ```</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"crosshair\", bool)\n@chainable_field(\"time_range\", bool)\n@chainable_field(\"group_id\", str)\nclass SyncOptions(Options):\n    \"\"\"Synchronization options for linked charts.\n\n            This class provides configuration options for synchronizing multiple\n                charts in a linked chart system. It controls crosshair and time range\n                                                synchronization behavior across linked charts.\n\n                                                Attributes:\n            enabled (bool): Whether synchronization is enabled. When True,\n            enables all synchronization features. When False, disables\n                                                        all synchronization. Defaults to False.\n                crosshair (bool): Whether to synchronize crosshair position across\n                linked charts. When enabled, moving the crosshair on one chart\n        will update the crosshair position on all linked charts.\n                                                        Defaults to False.\n                time_range (bool): Whether to synchronize time range across linked\n                charts. When enabled, zooming or panning the time range on one\n                chart will update the visible time range on all linked charts.\n                                                        Defaults to False.\n            group_id (Optional[str]): Optional group identifier for chart\n        synchronization. Charts with the same group_id will be\n        synchronized with each other. If None, all charts in the\n                same LinkedChartManager will be synchronized. Defaults to None.\n\n                                                Example:\n                                                    ```python\n                    from streamlit_lightweight_charts_pro.charts.options import SyncOptions\n\n                                                    # Enable all synchronization\n                        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True)\n\n                                                    # Enable only crosshair synchronization\n                        sync_options = SyncOptions(enabled=True, crosshair=True, time_range=False)\n\n                                                    # Use with group synchronization\n    sync_options = SyncOptions(enabled=True, crosshair=True, time_range=True, group_id=\"price_charts\")\n                                                    ```\n    \"\"\"\n\n    enabled: bool = False\n    crosshair: bool = False\n    time_range: bool = False\n    group_id: Optional[str] = None\n\n    def enable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = True\n        self.crosshair = True\n        self.time_range = True\n        return self\n\n    def disable_all(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable all synchronization features.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.enabled = False\n        self.crosshair = False\n        self.time_range = False\n        return self\n\n    def enable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = True\n        self.enabled = True\n        return self\n\n    def disable_crosshair(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable crosshair synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.crosshair = False\n        if not self.time_range:\n            self.enabled = False\n        return self\n\n    def enable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Enable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = True\n        self.enabled = True\n        return self\n\n    def disable_time_range(self) -&gt; \"SyncOptions\":\n        \"\"\"Disable time range synchronization.\n\n        Returns:\n            SyncOptions: Self for method chaining.\n        \"\"\"\n        self.time_range = False\n        if not self.crosshair:\n            self.enabled = False\n        return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_all","title":"enable_all","text":"<pre><code>enable_all() -&gt; SyncOptions\n</code></pre> <p>Enable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = True\n    self.crosshair = True\n    self.time_range = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_all","title":"disable_all","text":"<pre><code>disable_all() -&gt; SyncOptions\n</code></pre> <p>Disable all synchronization features.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_all(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable all synchronization features.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.enabled = False\n    self.crosshair = False\n    self.time_range = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_crosshair","title":"enable_crosshair","text":"<pre><code>enable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Enable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_crosshair","title":"disable_crosshair","text":"<pre><code>disable_crosshair() -&gt; SyncOptions\n</code></pre> <p>Disable crosshair synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_crosshair(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable crosshair synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.crosshair = False\n    if not self.time_range:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.enable_time_range","title":"enable_time_range","text":"<pre><code>enable_time_range() -&gt; SyncOptions\n</code></pre> <p>Enable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def enable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Enable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = True\n    self.enabled = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options.SyncOptions.disable_time_range","title":"disable_time_range","text":"<pre><code>disable_time_range() -&gt; SyncOptions\n</code></pre> <p>Disable time range synchronization.</p> <p>Returns:</p> Name Type Description <code>SyncOptions</code> <code>SyncOptions</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/sync_options.py</code> <pre><code>def disable_time_range(self) -&gt; \"SyncOptions\":\n    \"\"\"Disable time range synchronization.\n\n    Returns:\n        SyncOptions: Self for method chaining.\n    \"\"\"\n    self.time_range = False\n    if not self.crosshair:\n        self.enabled = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/sync_options.html#streamlit_lightweight_charts_pro.charts.options.sync_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html","title":"streamlit_lightweight_charts_pro.charts.options.time_scale_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options","title":"time_scale_options","text":"<p>Time scale option classes for streamlit-lightweight-charts.</p> <p>This module provides comprehensive configuration options for time scales in financial charts. Time scales control how time values are displayed, formatted, and positioned on the horizontal axis of the chart, including spacing, visibility, and interaction settings.</p> Key Features <ul> <li>Time axis spacing and positioning configuration</li> <li>Time visibility and formatting options</li> <li>Border and visual appearance customization</li> <li>Interactive behavior and scrolling controls</li> <li>Bar spacing and offset settings</li> <li>Time range locking and edge fixing options</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n# Create time scale options\ntime_scale = TimeScaleOptions(\n    visible=True, time_visible=True, border_visible=True, bar_spacing=6, right_offset=10\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options.TimeScaleOptions","title":"TimeScaleOptions  <code>dataclass</code>","text":"<p>Comprehensive configuration options for time scales in financial charts.</p> <p>This class provides extensive configuration options for time scales, controlling how time values are displayed, formatted, and positioned on the horizontal axis of the chart. It includes spacing, visibility, interaction, and formatting settings for professional time-based chart visualization.</p> <p>Attributes:</p> Name Type Description <code>right_offset</code> <code>int</code> <p>Right offset in pixels from the chart edge. Defaults to 0.</p> <code>left_offset</code> <code>int</code> <p>Left offset in pixels from the chart edge. Defaults to 0.</p> <code>bar_spacing</code> <code>int</code> <p>Spacing between bars in pixels. Defaults to 6.</p> <code>min_bar_spacing</code> <code>float</code> <p>Minimum spacing between bars in pixels. Defaults to 0.001.</p> <code>visible</code> <code>bool</code> <p>Whether the time scale is visible. Defaults to True.</p> <code>time_visible</code> <code>bool</code> <p>Whether to show time labels on the scale. Defaults to True.</p> <code>seconds_visible</code> <code>bool</code> <p>Whether to show seconds in time labels. Defaults to False.</p> <code>border_visible</code> <code>bool</code> <p>Whether to show the time scale border. Defaults to True.</p> <code>border_color</code> <code>str</code> <p>Color of the time scale border. Defaults to light gray. Must be valid color format (hex or rgba).</p> <code>fix_left_edge</code> <code>bool</code> <p>Whether to fix the left edge of the time range. Defaults to False.</p> <code>fix_right_edge</code> <code>bool</code> <p>Whether to fix the right edge of the time range. Defaults to False.</p> <code>lock_visible_time_range_on_resize</code> <code>bool</code> <p>Whether to lock the visible time range when resizing the chart. Defaults to False.</p> <code>right_bar_stays_on_scroll</code> <code>bool</code> <p>Whether the rightmost bar stays visible during scroll. Defaults to False.</p> <code>shift_visible_range_on_new_bar</code> <code>bool</code> <p>Whether to shift the visible range when a new bar is added. Defaults to False.</p> <code>allow_shift_visible_range_on_whitespace_access</code> <code>bool</code> <p>Whether to allow shifting the visible range when accessing whitespace. Defaults to False.</p> <code>tick_mark_formatter</code> <code>Optional[Callable]</code> <p>Custom formatter function for tick marks. Defaults to None (uses default formatting).</p> <code>fit_content_on_load</code> <code>bool</code> <p>Whether to fit content to visible area on initial load. Defaults to True.</p> <code>handle_double_click</code> <code>bool</code> <p>Whether to handle double-click interactions. Defaults to True.</p> <code>handle_scale</code> <code>bool</code> <p>Whether to handle scale interactions. Defaults to True.</p> <code>handle_scroll</code> <code>bool</code> <p>Whether to handle scroll interactions. Defaults to True.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n# Create time scale with custom spacing and visibility\ntime_scale = TimeScaleOptions(\n    visible=True,\n    time_visible=True,\n    seconds_visible=False,\n    border_visible=True,\n    bar_spacing=8,\n    right_offset=20,\n    left_offset=10,\n)\n\n# Create time scale with locked edges\nlocked_time_scale = TimeScaleOptions(\n    fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n)\n</code></pre> See also <p>Options: Base class providing common option functionality.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/time_scale_options.py</code> <pre><code>@dataclass\n@chainable_field(\"right_offset\", int)\n@chainable_field(\"left_offset\", int)\n@chainable_field(\"bar_spacing\", int)\n@chainable_field(\"min_bar_spacing\", float)\n@chainable_field(\"visible\", bool)\n@chainable_field(\"time_visible\", bool)\n@chainable_field(\"seconds_visible\", bool)\n@chainable_field(\"border_visible\", bool)\n@chainable_field(\"border_color\", str, validator=\"color\")\n@chainable_field(\"fix_left_edge\", bool)\n@chainable_field(\"fix_right_edge\", bool)\n@chainable_field(\"lock_visible_time_range_on_resize\", bool)\n@chainable_field(\"right_bar_stays_on_scroll\", bool)\n@chainable_field(\"shift_visible_range_on_new_bar\", bool)\n@chainable_field(\"allow_shift_visible_range_on_whitespace_access\", bool)\n@chainable_field(\"tick_mark_formatter\", Callable)\n@chainable_field(\"fit_content_on_load\", bool)\n@chainable_field(\"handle_double_click\", bool)\n@chainable_field(\"handle_scale\", bool)\n@chainable_field(\"handle_scroll\", bool)\nclass TimeScaleOptions(Options):\n    \"\"\"Comprehensive configuration options for time scales in financial charts.\n\n    This class provides extensive configuration options for time scales, controlling\n    how time values are displayed, formatted, and positioned on the horizontal axis\n    of the chart. It includes spacing, visibility, interaction, and formatting\n    settings for professional time-based chart visualization.\n\n    Attributes:\n        right_offset (int): Right offset in pixels from the chart edge. Defaults to 0.\n        left_offset (int): Left offset in pixels from the chart edge. Defaults to 0.\n        bar_spacing (int): Spacing between bars in pixels. Defaults to 6.\n        min_bar_spacing (float): Minimum spacing between bars in pixels. Defaults to 0.001.\n        visible (bool): Whether the time scale is visible. Defaults to True.\n        time_visible (bool): Whether to show time labels on the scale. Defaults to True.\n        seconds_visible (bool): Whether to show seconds in time labels. Defaults to False.\n        border_visible (bool): Whether to show the time scale border. Defaults to True.\n        border_color (str): Color of the time scale border. Defaults to light gray.\n            Must be valid color format (hex or rgba).\n        fix_left_edge (bool): Whether to fix the left edge of the time range. Defaults to False.\n        fix_right_edge (bool): Whether to fix the right edge of the time range. Defaults to False.\n        lock_visible_time_range_on_resize (bool): Whether to lock the visible time range\n            when resizing the chart. Defaults to False.\n        right_bar_stays_on_scroll (bool): Whether the rightmost bar stays visible during scroll.\n            Defaults to False.\n        shift_visible_range_on_new_bar (bool): Whether to shift the visible range when\n            a new bar is added. Defaults to False.\n        allow_shift_visible_range_on_whitespace_access (bool): Whether to allow shifting\n            the visible range when accessing whitespace. Defaults to False.\n        tick_mark_formatter (Optional[Callable]): Custom formatter function for tick marks.\n            Defaults to None (uses default formatting).\n        fit_content_on_load (bool): Whether to fit content to visible area on initial load.\n            Defaults to True.\n        handle_double_click (bool): Whether to handle double-click interactions.\n            Defaults to True.\n        handle_scale (bool): Whether to handle scale interactions. Defaults to True.\n        handle_scroll (bool): Whether to handle scroll interactions. Defaults to True.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.options import TimeScaleOptions\n\n        # Create time scale with custom spacing and visibility\n        time_scale = TimeScaleOptions(\n            visible=True,\n            time_visible=True,\n            seconds_visible=False,\n            border_visible=True,\n            bar_spacing=8,\n            right_offset=20,\n            left_offset=10,\n        )\n\n        # Create time scale with locked edges\n        locked_time_scale = TimeScaleOptions(\n            fix_left_edge=True, fix_right_edge=False, lock_visible_time_range_on_resize=True\n        )\n        ```\n\n    See also:\n        Options: Base class providing common option functionality.\n    \"\"\"\n\n    # Offset and spacing configuration\n    right_offset: int = 0  # Right offset in pixels from chart edge\n    left_offset: int = 0  # Left offset in pixels from chart edge\n    bar_spacing: int = 6  # Spacing between bars in pixels\n    min_bar_spacing: float = 0.001  # Minimum spacing between bars in pixels\n\n    # Visibility and appearance settings\n    visible: bool = True  # Whether the time scale is visible\n    time_visible: bool = True  # Whether to show time labels\n    seconds_visible: bool = False  # Whether to show seconds in time labels\n    border_visible: bool = True  # Whether to show the time scale border\n    border_color: str = \"rgba(197, 203, 206, 0.8)\"  # Border color with transparency\n\n    # Time range and scrolling behavior\n    fix_left_edge: bool = False  # Whether to fix the left edge of the time range\n    fix_right_edge: bool = False  # Whether to fix the right edge of the time range\n    lock_visible_time_range_on_resize: bool = False  # Lock visible range on resize\n    right_bar_stays_on_scroll: bool = False  # Keep rightmost bar visible during scroll\n    shift_visible_range_on_new_bar: bool = False  # Shift range when new bar is added\n    allow_shift_visible_range_on_whitespace_access: bool = False  # Allow shifting on whitespace\n\n    # Formatting and interaction settings\n    tick_mark_formatter: Optional[Callable] = None  # Custom formatter for tick marks\n    fit_content_on_load: bool = True  # Fit content to visible area on load\n    handle_double_click: bool = True  # Handle double-click interactions\n    handle_scale: bool = True  # Handle scale interactions\n    handle_scroll: bool = True  # Handle scroll interactions\n\n    def __getitem__(self, key):\n        \"\"\"Get option value by key for dictionary-like access.\n\n        Allows accessing option values using dictionary-style syntax, which\n        is useful for dynamic configuration and testing.\n\n        Args:\n            key (str): The option key to retrieve.\n\n        Returns:\n            Any: The value of the specified option key.\n\n        Example:\n            ```python\n            time_scale = TimeScaleOptions()\n            spacing = time_scale[\"bar_spacing\"]  # Returns 6\n            visible = time_scale[\"visible\"]  # Returns True\n            ```\n        \"\"\"\n        return self.asdict()[key]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/time_scale_options.html#streamlit_lightweight_charts_pro.charts.options.time_scale_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html","title":"streamlit_lightweight_charts_pro.charts.options.trade_visualization_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options","title":"trade_visualization_options","text":"<p>Trade visualization options for streamlit-lightweight-charts.</p> <p>This module provides the TradeVisualizationOptions class for configuring how trades are visualized on charts, including markers, rectangles, lines, arrows, and zones.</p> The module supports multiple visualization styles <ul> <li>Markers: Entry/exit markers at trade points</li> <li>Rectangles: Filled rectangles spanning trade duration</li> <li>Lines: Connecting lines between entry and exit</li> <li>Arrows: Directional arrows indicating trade flow</li> <li>Zones: Highlighted zones around trade areas</li> </ul> Key Features <ul> <li>Template-based tooltips and markers with HTML/placeholders</li> <li>Flexible color customization for profit/loss visualization</li> <li>Chainable API for fluent configuration</li> <li>Automatic validation of shapes, positions, and styles</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.options import TradeVisualizationOptions\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import TradeVisualization\n\n# Create options with method chaining\noptions = (TradeVisualizationOptions()\n          .set_style(TradeVisualization.BOTH)\n          .set_rectangle_color_profit(\"#00FF00\")\n          .set_marker_size(1)\n          .set_tooltip_template(\"&lt;div&gt;$$trade_type$$: $$pnl$$&lt;/div&gt;\"))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options.TradeVisualizationOptions","title":"TradeVisualizationOptions  <code>dataclass</code>","text":"<p>Options for trade visualization.</p> <p>This class provides comprehensive configuration options for how trades are displayed on charts, including various visual styles and customization options for markers, rectangles, lines, arrows, and zones.</p> <p>Attributes:</p> Name Type Description <code>style</code> <code>TradeVisualization</code> <p>The visualization style to use (markers, rectangles, both, etc.)</p> <code>entry_marker_color_long</code> <code>str</code> <p>Color for long entry markers</p> <code>entry_marker_color_short</code> <code>str</code> <p>Color for short entry markers</p> <code>exit_marker_color_profit</code> <code>str</code> <p>Color for profitable exit markers</p> <code>exit_marker_color_loss</code> <code>str</code> <p>Color for loss exit markers</p> <code>marker_size</code> <code>int</code> <p>Size of markers in pixels</p> <code>show_pnl_in_markers</code> <code>bool</code> <p>Whether to show P&amp;L in marker text</p> <code>rectangle_fill_opacity</code> <code>float</code> <p>Opacity for rectangle fill (0.0 to 1.0)</p> <code>rectangle_border_width</code> <code>int</code> <p>Width of rectangle borders</p> <code>rectangle_color_profit</code> <code>str</code> <p>Color for profitable trade rectangles</p> <code>rectangle_color_loss</code> <code>str</code> <p>Color for loss trade rectangles</p> <code>rectangle_fill_color_profit</code> <code>str</code> <p>Fill color for profitable trade rectangles</p> <code>rectangle_border_color_profit</code> <code>str</code> <p>Border color for profitable trade rectangles</p> <code>rectangle_border_color_loss</code> <code>str</code> <p>Border color for loss trade rectangles</p> <code>line_width</code> <code>int</code> <p>Width of connecting lines</p> <code>line_style</code> <code>str</code> <p>Style of connecting lines (solid, dashed, etc.)</p> <code>line_color_profit</code> <code>str</code> <p>Color for profitable trade lines</p> <code>line_color_loss</code> <code>str</code> <p>Color for loss trade lines</p> <code>arrow_size</code> <code>int</code> <p>Size of arrows in pixels</p> <code>arrow_color_profit</code> <code>str</code> <p>Color for profitable trade arrows</p> <code>arrow_color_loss</code> <code>str</code> <p>Color for loss trade arrows</p> <code>zone_opacity</code> <code>float</code> <p>Opacity for zone fills (0.0 to 1.0)</p> <code>zone_color_long</code> <code>str</code> <p>Color for long trade zones</p> <code>zone_color_short</code> <code>str</code> <p>Color for short trade zones</p> <code>zone_extend_bars</code> <code>int</code> <p>Number of bars to extend zones</p> <code>show_trade_id</code> <code>bool</code> <p>Whether to show trade ID in annotations</p> <code>show_quantity</code> <code>bool</code> <p>Whether to show quantity in annotations</p> <code>show_trade_type</code> <code>bool</code> <p>Whether to show trade type in annotations</p> <code>annotation_font_size</code> <code>int</code> <p>Font size for annotations</p> <code>annotation_background</code> <code>str</code> <p>Background color for annotations</p> <code>rectangle_show_text</code> <code>bool</code> <p>Whether to show text on rectangles</p> <code>rectangle_text_position</code> <code>str</code> <p>Position of text on rectangles (inside, above, below)</p> <code>rectangle_text_font_size</code> <code>int</code> <p>Font size for rectangle text</p> <code>rectangle_text_color</code> <code>str</code> <p>Color for rectangle text</p> <code>rectangle_text_background</code> <code>str</code> <p>Background color for rectangle text</p> <code>tooltip_template</code> <code>str</code> <p>Custom HTML template for tooltips with placeholders</p> <code>marker_template</code> <code>str</code> <p>Deprecated - use entry_marker_template and exit_marker_template</p> <code>entry_marker_template</code> <code>str</code> <p>Custom HTML template for entry marker text</p> <code>exit_marker_template</code> <code>str</code> <p>Custom HTML template for exit marker text</p> <code>entry_marker_shape</code> <code>str</code> <p>Shape for entry markers (arrow_up, arrow_down, circle, square)</p> <code>exit_marker_shape</code> <code>str</code> <p>Shape for exit markers (arrow_up, arrow_down, circle, square)</p> <code>entry_marker_position</code> <code>str</code> <p>Position for entry markers (above, below)</p> <code>exit_marker_position</code> <code>str</code> <p>Position for exit markers (above, below)</p> <code>show_marker_text</code> <code>bool</code> <p>Whether to show text on markers</p> Template Placeholders <p>For tooltips and markers, you can use these placeholders in your HTML templates. All fields from TradeData.additional_data are also available: - \\(\\(id\\)\\): Trade ID - \\(\\(entry_price\\)\\): Entry price value - \\(\\(exit_price\\)\\): Exit price value - \\(\\(is_profitable\\)\\): Boolean profitability flag - \\(\\(pnl\\)\\): Profit/Loss amount - \\(\\(pnl_percentage\\)\\): Profit/Loss percentage - \\(\\(trade_type\\)\\): LONG or SHORT (from additional_data) - \\(\\(quantity\\)\\): Trade quantity (from additional_data) - \\(\\(notes\\)\\): Trade notes (from additional_data) - Any custom field from additional_data: \\(\\(strategy\\)\\), \\(\\(risk_level\\)\\), etc.</p> Example templates <p>tooltip_template: \"\\(\\(trade_type\\)\\)Entry: \\(\\(entry_price\\)\\)Exit: \\(\\(exit_price\\)\\)P&amp;L: \\(\\(pnl\\)\\) (\\(\\(pnl_percentage\\)\\)%)\" entry_marker_template: \"\u2191 \\(\\(trade_type\\)\\)\\((\\(entry_price\\)\\)\" exit_marker_template: \"\u2193 ((\\(exit_price\\)\\)&lt;br/&gt;(\\)\\)pnl_percentage$$%)\"</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", TradeVisualization)\n@chainable_field(\"entry_marker_color_long\", str, validator=\"color\")\n@chainable_field(\"entry_marker_color_short\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_profit\", str, validator=\"color\")\n@chainable_field(\"exit_marker_color_loss\", str, validator=\"color\")\n@chainable_field(\"marker_size\", int)\n@chainable_field(\"show_pnl_in_markers\", bool)\n@chainable_field(\"rectangle_fill_opacity\", float)\n@chainable_field(\"rectangle_border_width\", int)\n@chainable_field(\"rectangle_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_color_loss\", str, validator=\"color\")\n@chainable_field(\"rectangle_fill_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_profit\", str, validator=\"color\")\n@chainable_field(\"rectangle_border_color_loss\", str, validator=\"color\")\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"line_color_profit\", str, validator=\"color\")\n@chainable_field(\"line_color_loss\", str, validator=\"color\")\n@chainable_field(\"arrow_size\", int)\n@chainable_field(\"arrow_color_profit\", str, validator=\"color\")\n@chainable_field(\"arrow_color_loss\", str, validator=\"color\")\n@chainable_field(\"zone_opacity\", float)\n@chainable_field(\"zone_color_long\", str, validator=\"color\")\n@chainable_field(\"zone_color_short\", str, validator=\"color\")\n@chainable_field(\"zone_extend_bars\", int)\n@chainable_field(\"show_trade_id\", bool)\n@chainable_field(\"show_quantity\", bool)\n@chainable_field(\"show_trade_type\", bool)\n@chainable_field(\"annotation_font_size\", int)\n@chainable_field(\"annotation_background\", str, validator=\"color\")\n@chainable_field(\"rectangle_show_text\", bool)\n@chainable_field(\"rectangle_text_position\", str)\n@chainable_field(\"rectangle_text_font_size\", int)\n@chainable_field(\"rectangle_text_color\", str, validator=\"color\")\n@chainable_field(\"rectangle_text_background\", str, validator=\"color\")\n@chainable_field(\"tooltip_template\", str)\n@chainable_field(\"marker_template\", str)\n@chainable_field(\"entry_marker_template\", str)\n@chainable_field(\"exit_marker_template\", str)\n@chainable_field(\"entry_marker_shape\", str)\n@chainable_field(\"exit_marker_shape\", str)\n@chainable_field(\"entry_marker_position\", str)\n@chainable_field(\"exit_marker_position\", str)\n@chainable_field(\"show_marker_text\", bool)\nclass TradeVisualizationOptions(Options):\n    \"\"\"Options for trade visualization.\n\n    This class provides comprehensive configuration options for how trades\n    are displayed on charts, including various visual styles and customization\n    options for markers, rectangles, lines, arrows, and zones.\n\n    Attributes:\n        style: The visualization style to use (markers, rectangles, both, etc.)\n        entry_marker_color_long: Color for long entry markers\n        entry_marker_color_short: Color for short entry markers\n        exit_marker_color_profit: Color for profitable exit markers\n        exit_marker_color_loss: Color for loss exit markers\n        marker_size: Size of markers in pixels\n        show_pnl_in_markers: Whether to show P&amp;L in marker text\n        rectangle_fill_opacity: Opacity for rectangle fill (0.0 to 1.0)\n        rectangle_border_width: Width of rectangle borders\n        rectangle_color_profit: Color for profitable trade rectangles\n        rectangle_color_loss: Color for loss trade rectangles\n        rectangle_fill_color_profit: Fill color for profitable trade rectangles\n        rectangle_border_color_profit: Border color for profitable trade rectangles\n        rectangle_border_color_loss: Border color for loss trade rectangles\n        line_width: Width of connecting lines\n        line_style: Style of connecting lines (solid, dashed, etc.)\n        line_color_profit: Color for profitable trade lines\n        line_color_loss: Color for loss trade lines\n        arrow_size: Size of arrows in pixels\n        arrow_color_profit: Color for profitable trade arrows\n        arrow_color_loss: Color for loss trade arrows\n        zone_opacity: Opacity for zone fills (0.0 to 1.0)\n        zone_color_long: Color for long trade zones\n        zone_color_short: Color for short trade zones\n        zone_extend_bars: Number of bars to extend zones\n        show_trade_id: Whether to show trade ID in annotations\n        show_quantity: Whether to show quantity in annotations\n        show_trade_type: Whether to show trade type in annotations\n        annotation_font_size: Font size for annotations\n        annotation_background: Background color for annotations\n        rectangle_show_text: Whether to show text on rectangles\n        rectangle_text_position: Position of text on rectangles (inside, above, below)\n        rectangle_text_font_size: Font size for rectangle text\n        rectangle_text_color: Color for rectangle text\n        rectangle_text_background: Background color for rectangle text\n        tooltip_template: Custom HTML template for tooltips with placeholders\n        marker_template: Deprecated - use entry_marker_template and exit_marker_template\n        entry_marker_template: Custom HTML template for entry marker text\n        exit_marker_template: Custom HTML template for exit marker text\n        entry_marker_shape: Shape for entry markers (arrow_up, arrow_down, circle, square)\n        exit_marker_shape: Shape for exit markers (arrow_up, arrow_down, circle, square)\n        entry_marker_position: Position for entry markers (above, below)\n        exit_marker_position: Position for exit markers (above, below)\n        show_marker_text: Whether to show text on markers\n\n    Template Placeholders:\n        For tooltips and markers, you can use these placeholders in your HTML templates.\n        All fields from TradeData.additional_data are also available:\n        - $$id$$: Trade ID\n        - $$entry_price$$: Entry price value\n        - $$exit_price$$: Exit price value\n        - $$is_profitable$$: Boolean profitability flag\n        - $$pnl$$: Profit/Loss amount\n        - $$pnl_percentage$$: Profit/Loss percentage\n        - $$trade_type$$: LONG or SHORT (from additional_data)\n        - $$quantity$$: Trade quantity (from additional_data)\n        - $$notes$$: Trade notes (from additional_data)\n        - Any custom field from additional_data: $$strategy$$, $$risk_level$$, etc.\n\n    Example templates:\n        tooltip_template: \"&lt;div&gt;&lt;strong&gt;$$trade_type$$&lt;/strong&gt;&lt;br/&gt;Entry: $$entry_price$$&lt;br/&gt;Exit: $$exit_price$$&lt;br/&gt;P&amp;L: $$pnl$$ ($$pnl_percentage$$%)&lt;/div&gt;\"\n        entry_marker_template: \"\u2191 $$trade_type$$&lt;br/&gt;$$$entry_price$$\"\n        exit_marker_template: \"\u2193 $$$exit_price$$&lt;br/&gt;($$pnl_percentage$$%)\"\n    \"\"\"\n\n    style: TradeVisualization = TradeVisualization.RECTANGLES\n\n    # Marker options\n    entry_marker_color_long: str = \"#2196F3\"\n    entry_marker_color_short: str = \"#FF9800\"\n    exit_marker_color_profit: str = \"#4CAF50\"\n    exit_marker_color_loss: str = \"#F44336\"\n    marker_size: int = 5\n    show_pnl_in_markers: bool = False\n\n    # Rectangle options\n    rectangle_fill_opacity: float = 0.1\n    rectangle_border_width: int = 1\n    rectangle_color_profit: str = \"#4CAF50\"\n    rectangle_color_loss: str = \"#F44336\"\n    rectangle_fill_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_profit: str = \"#4CAF50\"\n    rectangle_border_color_loss: str = \"#F44336\"\n\n    # Line options\n    line_width: int = 2\n    line_style: str = \"dashed\"\n    line_color_profit: str = \"#4CAF50\"\n    line_color_loss: str = \"#F44336\"\n\n    # Arrow options\n    arrow_size: int = 10\n    arrow_color_profit: str = \"#4CAF50\"\n    arrow_color_loss: str = \"#F44336\"\n\n    # Zone options\n    zone_opacity: float = 0.1\n    zone_color_long: str = \"#2196F3\"\n    zone_color_short: str = \"#FF9800\"\n    zone_extend_bars: int = 2  # Extend zone by this many bars\n\n    # Annotation options\n    show_trade_id: bool = False\n    show_quantity: bool = True\n    show_trade_type: bool = True\n    annotation_font_size: int = 12\n    annotation_background: str = \"rgba(255, 255, 255, 0.8)\"\n\n    # Rectangle text options\n    rectangle_show_text: bool = False\n    rectangle_text_position: str = \"inside\"  # inside, above, below\n    rectangle_text_font_size: int = 10\n    rectangle_text_color: str = \"#FFFFFF\"\n    rectangle_text_background: str = \"rgba(0, 0, 0, 0.7)\"\n\n    # Template options\n    tooltip_template: str = \"\"  # Custom HTML template for tooltips\n    marker_template: str = \"\"  # Deprecated - use entry/exit templates\n    entry_marker_template: str = \"\"  # Custom HTML template for entry markers\n    exit_marker_template: str = \"\"  # Custom HTML template for exit markers\n\n    # Marker shape and position options\n    entry_marker_shape: str = \"arrowUp\"  # arrowUp, arrowDown, circle, square\n    exit_marker_shape: str = \"arrowDown\"  # arrowUp, arrowDown, circle, square\n    entry_marker_position: str = \"belowBar\"  # belowBar, aboveBar\n    exit_marker_position: str = \"aboveBar\"  # belowBar, aboveBar\n    show_marker_text: bool = True  # Whether to show text on markers\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize options.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates all configuration values and sets defaults for invalid values.\n\n        Raises:\n            ValueError: If the style string cannot be converted to TradeVisualization enum.\n        \"\"\"\n        # Step 1: Convert style to enum if it's a string\n        # Allows users to pass \"rectangles\" instead of TradeVisualization.RECTANGLES\n        if isinstance(self.style, str):\n            self.style = TradeVisualization(self.style.lower())\n\n        # Step 2: Validate rectangle text position\n        # Ensures only valid positions are used (inside, above, below)\n        valid_positions = [\"inside\", \"above\", \"below\"]\n        if self.rectangle_text_position.lower() not in valid_positions:\n            # Default to \"inside\" if invalid position provided\n            self.rectangle_text_position = \"inside\"\n\n        # Step 3: Validate marker shapes\n        # Ensures only TradingView-supported shapes are used\n        valid_shapes = [\"arrowUp\", \"arrowDown\", \"circle\", \"square\"]\n        if self.entry_marker_shape not in valid_shapes:\n            # Default to arrowUp for entry if invalid shape provided\n            self.entry_marker_shape = \"arrowUp\"\n        if self.exit_marker_shape not in valid_shapes:\n            # Default to arrowDown for exit if invalid shape provided\n            self.exit_marker_shape = \"arrowDown\"\n\n        # Step 4: Validate marker positions\n        # Ensures only valid positions are used (belowBar, aboveBar)\n        valid_marker_positions = [\"belowBar\", \"aboveBar\"]\n        if self.entry_marker_position not in valid_marker_positions:\n            # Default to belowBar for entry (typical for long trades)\n            self.entry_marker_position = \"belowBar\"\n        if self.exit_marker_position not in valid_marker_positions:\n            # Default to aboveBar for exit (typical for long trades)\n            self.exit_marker_position = \"aboveBar\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/trade_visualization_options.html#streamlit_lightweight_charts_pro.charts.options.trade_visualization_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html","title":"streamlit_lightweight_charts_pro.charts.options.ui_options","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options","title":"ui_options","text":"<p>UI option classes for streamlit-lightweight-charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.TimeRange","title":"TimeRange","text":"<p>Time range constants in seconds for range switcher.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>class TimeRange(Enum):\n    \"\"\"Time range constants in seconds for range switcher.\"\"\"\n\n    FIVE_MINUTES = 300\n    FIFTEEN_MINUTES = 900\n    ONE_HOUR = 3600\n    FOUR_HOURS = 14400\n    ONE_DAY = 86400\n    ONE_WEEK = 604800\n    ONE_MONTH = 2592000\n    THREE_MONTHS = 7776000\n    SIX_MONTHS = 15552000\n    ONE_YEAR = 31536000\n    FIVE_YEARS = 157680000\n    ALL = None  # Special value for \"all data\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig","title":"RangeConfig  <code>dataclass</code>","text":"<p>Range configuration for range switcher.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"text\", str)\n@chainable_field(\"tooltip\", str)\n@chainable_field(\"range\", TimeRange)\nclass RangeConfig(Options):\n    \"\"\"Range configuration for range switcher.\"\"\"\n\n    text: str = \"\"\n    tooltip: str = \"\"\n    range: TimeRange = TimeRange.ONE_DAY\n\n    @property\n    def seconds(self) -&gt; int | None:\n        \"\"\"Get the time range in seconds.\"\"\"\n        return self.range.value if self.range else None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeConfig.seconds","title":"seconds  <code>property</code>","text":"<pre><code>seconds: int | None\n</code></pre> <p>Get the time range in seconds.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.RangeSwitcherOptions","title":"RangeSwitcherOptions  <code>dataclass</code>","text":"<p>Range switcher configuration.</p> <p>Range switcher supports only corner positions: top-left, top-right, bottom-left, bottom-right. Center positions are not supported.</p> <p>Range buttons are automatically hidden when they exceed the available data timespan, providing a better user experience.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"ranges\", list)\n@chainable_field(\"position\", str)\nclass RangeSwitcherOptions(Options):\n    \"\"\"Range switcher configuration.\n\n    Range switcher supports only corner positions: top-left, top-right,\n    bottom-left, bottom-right. Center positions are not supported.\n\n    Range buttons are automatically hidden when they exceed the available\n    data timespan, providing a better user experience.\n    \"\"\"\n\n    visible: bool = True\n    ranges: List[RangeConfig] = field(default_factory=list)\n    position: Literal[\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"] = \"bottom-right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options.LegendOptions","title":"LegendOptions  <code>dataclass</code>","text":"<p>Legend configuration with support for custom HTML templates and dynamic value display.</p> <p>The text supports a single placeholder that will be replaced by the frontend: - \\(\\(value\\)\\): Current value of the series at crosshair position</p> <p>Note: Title and color should be handled directly in your HTML template using the series title and color from your series configuration. This avoids conflicts with Python's f-string syntax and other templating systems.</p> <p>Dynamic Value Display: When show_values=True, the legend will automatically display current values at the crosshair position without needing to specify a custom template.</p> <p>Example templates: - \"MA20: \\(\\(value\\)\\)\" - \"PriceValue: \\(\\(value\\)\\)\" - \"RSI: \\(\\(value\\)\\)\"</p> <p>Example with dynamic values: LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/options/ui_options.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"position\", str)\n@chainable_field(\"symbol_name\", str)\n@chainable_field(\"background_color\", str)\n@chainable_field(\"border_color\", str)\n@chainable_field(\"border_width\", int)\n@chainable_field(\"border_radius\", int)\n@chainable_field(\"padding\", int)\n@chainable_field(\"margin\", int)\n@chainable_field(\"z_index\", int)\n@chainable_field(\"price_format\", str)\n@chainable_field(\"text\", str)\n@chainable_field(\"show_values\", bool)\n@chainable_field(\"value_format\", str)\n@chainable_field(\"update_on_crosshair\", bool)\nclass LegendOptions(Options):\n    \"\"\"Legend configuration with support for custom HTML templates and dynamic value display.\n\n    The text supports a single placeholder that will be replaced by the frontend:\n    - $$value$$: Current value of the series at crosshair position\n\n    Note: Title and color should be handled directly in your HTML template using\n    the series title and color from your series configuration. This avoids\n    conflicts with Python's f-string syntax and other templating systems.\n\n    Dynamic Value Display:\n    When show_values=True, the legend will automatically display current values\n    at the crosshair position without needing to specify a custom template.\n\n    Example templates:\n    - \"&lt;span style='color: #2196f3'&gt;MA20: $$value$$&lt;/span&gt;\"\n    - \"&lt;div&gt;&lt;strong&gt;Price&lt;/strong&gt;&lt;br/&gt;Value: $$value$$&lt;/div&gt;\"\n    - \"&lt;span class='legend-item'&gt;RSI: $$value$$&lt;/span&gt;\"\n\n    Example with dynamic values:\n    LegendOptions(show_values=True, value_format=\".2f\", update_on_crosshair=True)\n    \"\"\"\n\n    visible: bool = True\n    position: str = \"top-left\"\n    symbol_name: str = \"\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    margin: int = 0  # No margin - spacing handled by layout manager\n    z_index: int = 1000\n    price_format: str = \".2f\"\n    text: str = \"\"\n    show_values: bool = True\n    value_format: str = \".2f\"\n    update_on_crosshair: bool = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/options/ui_options.html#streamlit_lightweight_charts_pro.charts.options.ui_options-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html","title":"streamlit_lightweight_charts_pro.charts.series.area","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area","title":"area","text":"<p>Area series for streamlit-lightweight-charts.</p> <p>This module provides the AreaSeries class for creating area charts that display continuous data points with filled areas under the line. Area series are commonly used for price charts, indicators, and trend analysis in financial visualization.</p> <p>The AreaSeries class supports various styling options including area color, line color, width, style, and animation effects. It also supports markers and price line configurations for comprehensive chart customization.</p> Key Features <ul> <li>Filled area visualization with customizable colors</li> <li>Line styling through LineOptions integration</li> <li>Gradient effects and area inversion options</li> <li>Marker and price line support for annotations</li> <li>DataFrame integration with automatic column mapping</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries","title":"AreaSeries","text":"<p>Area series for creating filled area charts in financial visualization.</p> <p>This class represents an area series that displays continuous data points with filled areas under the line. It's commonly used for price charts, technical indicators, and trend analysis where the area under the curve provides visual emphasis and context.</p> <p>The AreaSeries supports various styling options including area colors, line styling via LineOptions, and gradient effects for enhanced visual appeal and data interpretation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[AreaData], DataFrame, Series]</code> <p>Data points for the area series. Can be a list of AreaData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <code>LineOptions</code> <p>LineOptions instance for line styling. Provides comprehensive line customization including color, width, style, and animation effects.</p> <code>top_color</code> <code>str</code> <p>Color of the top part of the area fill. Defaults to \"#2196F3\" (blue). Can be hex or rgba format.</p> <code>bottom_color</code> <code>str</code> <p>Color of the bottom part of the area fill. Defaults to \"rgba(33, 150, 243, 0.0)\" (transparent blue).</p> <code>relative_gradient</code> <code>bool</code> <p>Whether gradient is relative to base value. Defaults to False for absolute gradient positioning.</p> <code>invert_filled_area</code> <code>bool</code> <p>Whether to invert the filled area direction. Defaults to False for normal area filling.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (AreaData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import AreaSeries\nfrom streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data with line colors\ndata = [\n    AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n    AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n]\n\n# Create area series with gradient styling\nseries = AreaSeries(\n    data=data,\n    top_color=\"rgba(33, 150, 243, 0.4)\",\n    bottom_color=\"rgba(33, 150, 243, 0.0)\",\n    relative_gradient=False,\n    invert_filled_area=False,\n)\n\n# Configure line options\nseries.line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre> See also <p>Series: Base class providing common series functionality. LineOptions: Configuration class for line styling options. AreaData: Data class for area chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/area.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"top_color\", str, validator=\"color\")\n@chainable_property(\"bottom_color\", str, validator=\"color\")\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"invert_filled_area\", bool)\nclass AreaSeries(Series):\n    \"\"\"Area series for creating filled area charts in financial visualization.\n\n    This class represents an area series that displays continuous data points\n    with filled areas under the line. It's commonly used for price charts,\n    technical indicators, and trend analysis where the area under the curve\n    provides visual emphasis and context.\n\n    The AreaSeries supports various styling options including area colors,\n    line styling via LineOptions, and gradient effects for enhanced\n    visual appeal and data interpretation.\n\n    Attributes:\n        data (Union[List[AreaData], pd.DataFrame, pd.Series]): Data points for\n            the area series. Can be a list of AreaData objects, a pandas\n            DataFrame, or a pandas Series.\n        line_options (LineOptions): LineOptions instance for line styling.\n            Provides comprehensive line customization including color, width,\n            style, and animation effects.\n        top_color (str): Color of the top part of the area fill. Defaults to\n            \"#2196F3\" (blue). Can be hex or rgba format.\n        bottom_color (str): Color of the bottom part of the area fill. Defaults\n            to \"rgba(33, 150, 243, 0.0)\" (transparent blue).\n        relative_gradient (bool): Whether gradient is relative to base value.\n            Defaults to False for absolute gradient positioning.\n        invert_filled_area (bool): Whether to invert the filled area direction.\n            Defaults to False for normal area filling.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (AreaData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import AreaSeries\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data with line colors\n        data = [\n            AreaData(\"2024-01-01\", 100, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-02\", 105, line_color=\"#2196F3\"),\n            AreaData(\"2024-01-03\", 102, line_color=\"#2196F3\"),\n        ]\n\n        # Create area series with gradient styling\n        series = AreaSeries(\n            data=data,\n            top_color=\"rgba(33, 150, 243, 0.4)\",\n            bottom_color=\"rgba(33, 150, 243, 0.0)\",\n            relative_gradient=False,\n            invert_filled_area=False,\n        )\n\n        # Configure line options\n        series.line_options.set_color(\"#2196F3\").set_width(2)\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        LineOptions: Configuration class for line styling options.\n        AreaData: Data class for area chart data points.\n    \"\"\"\n\n    DATA_CLASS = AreaData\n\n    def __init__(\n        self,\n        data: Union[List[AreaData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize AreaSeries with data and configuration options.\n\n        Creates a new area series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes area-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[AreaData], pd.DataFrame, pd.Series]): Area data as a list\n                of AreaData objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of AreaData objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of AreaData or its subclasses.\n\n        Example:\n            ```python\n            # Basic area series with list of data objects\n            data = [AreaData(\"2024-01-01\", 100)]\n            series = AreaSeries(data=data)\n\n            # Area series with DataFrame\n            series = AreaSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Area series with custom configuration\n            series = AreaSeries(data=data, visible=True, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize area-specific properties with default values\n        self._line_options = LineOptions()  # Line styling configuration\n        self._top_color = \"#2196F3\"  # Top area color (blue)\n        self._bottom_color = \"rgba(33, 150, 243, 0.0)\"  # Bottom area color (transparent)\n        self._relative_gradient = False  # Absolute gradient positioning\n        self._invert_filled_area = False  # Normal area filling direction\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as an area chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The area chart type identifier.\n\n        Example:\n            ```python\n            series = AreaSeries(data=data)\n            chart_type = series.chart_type  # ChartType.AREA\n            ```\n        \"\"\"\n        return ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area.AreaSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as an area chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The area chart type identifier.</p> Example <pre><code>series = AreaSeries(data=data)\nchart_type = series.chart_type  # ChartType.AREA\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/area.html#streamlit_lightweight_charts_pro.charts.series.area-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html","title":"streamlit_lightweight_charts_pro.charts.series.band","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band","title":"band","text":"<p>Band series for streamlit-lightweight-charts.</p> <p>This module provides the BandSeries class for creating band charts (e.g., Bollinger Bands) that display upper, middle, and lower bands. Band series are commonly used for technical indicators and volatility analysis.</p> <p>The BandSeries class supports various styling options for each band, fill colors, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BandSeries from streamlit_lightweight_charts_pro.data import BandData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band--create-band-data","title":"Create band data","text":"<p>data = [     BandData(\"2024-01-01\", upper=110, middle=105, lower=100),     BandData(\"2024-01-02\", upper=112, middle=107, lower=102) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band--create-band-series-with-styling","title":"Create band series with styling","text":"<p>series = BandSeries(data=data) series.upper_line.color = \"#4CAF50\" series.lower_line.color = \"#F44336\" series.upper_fill_color = \"rgba(76, 175, 80, 0.1)\" series.lower_fill_color = \"rgba(244, 67, 54, 0.1)\"</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries","title":"BandSeries","text":"<p>Band series for lightweight charts (e.g., Bollinger Bands).</p> <p>This class represents a band series that displays upper, middle, and lower bands. It's commonly used for technical indicators like Bollinger Bands, Keltner Channels, and other envelope indicators.</p> <p>The BandSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>middle_line</code> <p>LineOptions instance for middle band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>upper_fill_color</code> <p>Fill color for upper band area.</p> <code>lower_fill_color</code> <p>Fill color for lower band area.</p> <code>upper_fill</code> <p>Whether to display the upper fill area.</p> <code>lower_fill</code> <p>Whether to display the lower fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/band.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"middle_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"upper_fill_color\", str, validator=\"color\")\n@chainable_property(\"lower_fill_color\", str, validator=\"color\")\n@chainable_property(\"upper_fill\", bool)\n@chainable_property(\"lower_fill\", bool)\nclass BandSeries(Series):\n    \"\"\"Band series for lightweight charts (e.g., Bollinger Bands).\n\n    This class represents a band series that displays upper, middle, and lower bands.\n    It's commonly used for technical indicators like Bollinger Bands, Keltner Channels,\n    and other envelope indicators.\n\n    The BandSeries supports various styling options including separate line styling\n    for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        middle_line: LineOptions instance for middle band styling.\n        lower_line: LineOptions instance for lower band styling.\n        upper_fill_color: Fill color for upper band area.\n        lower_fill_color: Fill color for lower band area.\n        upper_fill: Whether to display the upper fill area.\n        lower_fill: Whether to display the lower fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BandData\n\n    def __init__(\n        self,\n        data: Union[List[BandData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize BandSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = LineOptions(color=\"#4CAF50\", line_width=2, line_style=\"solid\")\n        self._middle_line = LineOptions(color=\"#2196F3\", line_width=2, line_style=\"solid\")\n        self._lower_line = LineOptions(color=\"#F44336\", line_width=2, line_style=\"solid\")\n\n        # Initialize fill colors\n        self._upper_fill_color = \"rgba(76, 175, 80, 0.1)\"\n        self._lower_fill_color = \"rgba(244, 67, 54, 0.1)\"\n\n        # Initialize fill visibility (default to True)\n        self._upper_fill = True\n        self._lower_fill = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAND\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band.BandSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/band.html#streamlit_lightweight_charts_pro.charts.series.band-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html","title":"streamlit_lightweight_charts_pro.charts.series.bar_series","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series","title":"bar_series","text":"<p>Bar series for streamlit-lightweight-charts.</p> <p>This module provides the BarSeries class for creating bar charts that display OHLC data as bars. Bar series are commonly used for price charts and volume overlays.</p> <p>The BarSeries class supports various styling options including bar color, base value, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BarSeries from streamlit_lightweight_charts_pro.data import SingleValueData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series--create-bar-data","title":"Create bar data","text":"<p>data = [     SingleValueData(\"2024-01-01\", 100),     SingleValueData(\"2024-01-02\", 105) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series--create-bar-series-with-styling","title":"Create bar series with styling","text":"<p>series = BarSeries(data=data) series.color = \"#26a69a\" series.base = 0</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries","title":"BarSeries","text":"<p>Bar series for lightweight charts.</p> <p>This class represents a bar series that displays data as bars. It's commonly used for price charts, volume overlays, and other bar-based visualizations.</p> <p>The BarSeries supports various styling options including bar colors, base value, and animation effects.</p> <p>Attributes:</p> Name Type Description <code>color</code> <p>Color of the bars (set via property).</p> <code>base</code> <p>Base value for the bars (set via property).</p> <code>up_color</code> <p>Color for up bars (set via property).</p> <code>down_color</code> <p>Color for down bars (set via property).</p> <code>open_visible</code> <p>Whether open values are visible (set via property).</p> <code>thin_bars</code> <p>Whether to use thin bars (set via property).</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/bar_series.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"open_visible\", bool)\n@chainable_property(\"thin_bars\", bool)\nclass BarSeries(Series):\n    \"\"\"Bar series for lightweight charts.\n\n    This class represents a bar series that displays data as bars.\n    It's commonly used for price charts, volume overlays, and other\n    bar-based visualizations.\n\n    The BarSeries supports various styling options including bar colors,\n    base value, and animation effects.\n\n    Attributes:\n        color: Color of the bars (set via property).\n        base: Base value for the bars (set via property).\n        up_color: Color for up bars (set via property).\n        down_color: Color for down bars (set via property).\n        open_visible: Whether open values are visible (set via property).\n        thin_bars: Whether to use thin bars (set via property).\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = BarData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BAR\n\n    def __init__(\n        self,\n        data: Union[List[BarData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize properties with default values\n        self._up_color = \"#26a69a\"\n        self._down_color = \"#ef5350\"\n        self._open_visible = True\n        self._thin_bars = True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series.BarSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/bar_series.html#streamlit_lightweight_charts_pro.charts.series.bar_series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html","title":"streamlit_lightweight_charts_pro.charts.series.base","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base","title":"base","text":"<p>Base series class for streamlit-lightweight-charts.</p> <p>This module provides the base Series class that defines the common interface for all series types in the library. It includes core functionality for data handling, configuration, and frontend integration.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series.base import Series\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n\nclass MyCustomSeries(Series):\n    DATA_CLASS = SingleValueData\n\n    @property\n    def chart_type(self):\n        return ChartType.LINE\n\n\n# Create series with data\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = MyCustomSeries(data=data)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series","title":"Series","text":"<p>Abstract base class for all series types in financial chart visualization.</p> <p>This class defines the common interface and functionality that all series classes must implement. It provides core data handling, configuration methods, and frontend integration capabilities with comprehensive support for pandas DataFrame integration, markers, price lines, and formatting.</p> <p>All series classes should inherit from this base class and implement the required abstract methods. The class supports method chaining for fluent API usage and provides extensive customization options.</p> Key Features <ul> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line management for annotations</li> <li>Price scale and pane configuration for multi-pane charts</li> <li>Visibility and formatting controls for UI customization</li> <li>Comprehensive data validation and error handling</li> <li>Method chaining support for fluent API design</li> <li>Frontend serialization for React component integration</li> </ul> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for this series. Can be a list of Data objects, pandas DataFrame, or pandas Series.</p> <code>visible</code> <code>bool</code> <p>Whether the series is currently visible on the chart.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Common values are \"left\", \"right\", or custom scale IDs.</p> <code>price_format</code> <code>PriceFormatOptions</code> <p>Price formatting configuration for display.</p> <code>price_lines</code> <code>List[PriceLineOptions]</code> <p>List of price lines for horizontal markers.</p> <code>markers</code> <code>List[MarkerBase]</code> <p>List of markers to display on this series.</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to for multi-pane charts.</p> <code>title</code> <code>Optional[str]</code> <p>Optional title for the series in legends and tooltips.</p> <code>z_index</code> <code>int</code> <p>Z-index for controlling series rendering order.</p> Class Attributes <p>DATA_CLASS (Type[Data]): The data class type used for this series.     Must be defined by subclasses for DataFrame conversion to work.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create series with list of data objects\ndata = [SingleValueData(\"2024-01-01\", 100)]\nseries = LineSeries(data=data)\n\n# Add markers and price lines\nseries.add_marker(bar_marker).add_price_line(price_line)\n\n# Configure series properties\nseries.set_visible(True).set_price_scale_id(\"right\")\n</code></pre> Note <p>Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work. The data_class property will always pick the most-derived DATA_CLASS in the MRO.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@chainable_property(\"title\", top_level=True)\n@chainable_property(\"visible\", top_level=True)\n@chainable_property(\"z_index\", allow_none=True, top_level=True)\n@chainable_property(\"price_scale_id\", top_level=True)\n@chainable_property(\"price_scale\", allow_none=True, top_level=True)\n@chainable_property(\"price_format\")\n@chainable_property(\"price_lines\", top_level=True)\n@chainable_property(\"markers\", List[MarkerBase], allow_none=True, top_level=True)\n@chainable_property(\"pane_id\", top_level=True)\n@chainable_property(\"last_value_visible\", top_level=True)\n@chainable_property(\"price_line_visible\", top_level=True)\n@chainable_property(\"price_line_source\", top_level=True)\n@chainable_property(\"price_line_width\", top_level=True)\n@chainable_property(\"price_line_color\", top_level=True)\n@chainable_property(\"price_line_style\", top_level=True)\n@chainable_property(\"tooltip\", allow_none=True, top_level=True)\n@chainable_property(\"legend\", allow_none=True, top_level=True)\nclass Series(ABC):  # noqa: B024\n    \"\"\"Abstract base class for all series types in financial chart visualization.\n\n    This class defines the common interface and functionality that all series\n    classes must implement. It provides core data handling, configuration\n    methods, and frontend integration capabilities with comprehensive support\n    for pandas DataFrame integration, markers, price lines, and formatting.\n\n    All series classes should inherit from this base class and implement\n    the required abstract methods. The class supports method chaining for\n    fluent API usage and provides extensive customization options.\n\n    Key Features:\n        - DataFrame integration with automatic column mapping\n        - Marker and price line management for annotations\n        - Price scale and pane configuration for multi-pane charts\n        - Visibility and formatting controls for UI customization\n        - Comprehensive data validation and error handling\n        - Method chaining support for fluent API design\n        - Frontend serialization for React component integration\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for this series.\n            Can be a list of Data objects, pandas DataFrame, or pandas Series.\n        visible (bool): Whether the series is currently visible on the chart.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Common values are \"left\", \"right\", or custom scale IDs.\n        price_format (PriceFormatOptions): Price formatting configuration for display.\n        price_lines (List[PriceLineOptions]): List of price lines for horizontal markers.\n        markers (List[MarkerBase]): List of markers to display on this series.\n        pane_id (Optional[int]): The pane index this series belongs to for multi-pane charts.\n        title (Optional[str]): Optional title for the series in legends and tooltips.\n        z_index (int): Z-index for controlling series rendering order.\n\n    Class Attributes:\n        DATA_CLASS (Type[Data]): The data class type used for this series.\n            Must be defined by subclasses for DataFrame conversion to work.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create series with list of data objects\n        data = [SingleValueData(\"2024-01-01\", 100)]\n        series = LineSeries(data=data)\n\n        # Add markers and price lines\n        series.add_marker(bar_marker).add_price_line(price_line)\n\n        # Configure series properties\n        series.set_visible(True).set_price_scale_id(\"right\")\n        ```\n\n    Note:\n        Subclasses must define a class-level DATA_CLASS attribute for from_dataframe to work.\n        The data_class property will always pick the most-derived DATA_CLASS in the MRO.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a series with data and configuration.\n\n        Creates a new series instance with the provided data and configuration options.\n        The constructor supports multiple data input types including lists of Data\n        objects, pandas DataFrames, and pandas Series with automatic validation\n        and conversion.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Series data as a list\n                of data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data objects, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic series with list of data objects\n            series = LineSeries(data=line_data)\n\n            # Series with DataFrame\n            series = LineSeries(data=df, column_mapping={\"time\": \"datetime\", \"value\": \"close\"})\n\n            # Series with Series\n             series = LineSeries(\n                 data=series_data,\n                 column_mapping={\"time\": \"index\", \"value\": \"values\"}\n             )\n\n            # Series with custom configuration\n            series = LineSeries(data=line_data, visible=False, price_scale_id=\"right\", pane_id=1)\n            ```\n        \"\"\"\n        # Validate and process data input based on type\n        if data is None:\n            # Handle None input by creating empty data list\n            self.data = []\n        elif isinstance(data, (pd.DataFrame, pd.Series)):\n            # DataFrame/Series input requires column mapping for conversion\n            if column_mapping is None:\n                raise ColumnMappingRequiredError()\n            # Process DataFrame/Series using from_dataframe logic\n            self.data = self._process_dataframe_input(data, column_mapping)\n        elif isinstance(data, list):\n            # Validate that all items in list are Data instances\n            if data and not all(isinstance(item, Data) for item in data):\n                raise DataItemsTypeError()\n            self.data = data\n        else:\n            # Raise error for unsupported data types\n            raise DataFrameValidationError.invalid_data_type(type(data))\n\n        # Initialize series configuration properties with default values\n        self._title = None  # Optional series title for legends and tooltips\n        self._visible = visible  # Series visibility flag\n        self._price_scale_id = price_scale_id  # Price scale attachment ID\n        self._price_scale = None  # Price scale configuration object\n        self._price_format = None  # Price formatting options\n        self._price_lines = []  # List of price line markers\n        self._markers = []  # List of chart markers for annotations\n        self._pane_id = pane_id  # Pane index for multi-pane charts\n        self._column_mapping = column_mapping  # DataFrame column mapping\n\n        # Initialize price line display properties\n        self._last_value_visible = True  # Show last value on price scale\n        self._price_line_visible = True  # Show price line by default\n        self._price_line_source = PriceLineSource.LAST_BAR  # Price line data source\n        self._price_line_width = 1  # Price line width in pixels\n        self._price_line_color = \"\"  # Price line color (empty for default)\n        self._price_line_style = LineStyle.DASHED  # Price line style\n\n        # Initialize optional UI components\n        self._tooltip = None  # Custom tooltip configuration\n        self._z_index = 100  # Z-index for rendering order\n        self._legend = None  # Legend configuration\n\n    @staticmethod\n    def prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n        \"\"\"Prepare index for column mapping.\n\n        Handles all index-related column mapping cases:\n        - Time column mapping with DatetimeIndex\n        - Level position mapping (e.g., \"0\", \"1\")\n        - \"index\" mapping (first unnamed level or level 0)\n        - Named level mapping (e.g., \"date\", \"symbol\")\n        - Single index reset for non-time columns\n\n        Args:\n            data_frame: DataFrame to prepare\n            column_mapping: Mapping of required fields to column names\n\n        Returns:\n            DataFrame with prepared index\n\n        Raises:\n            ValueError: If time column is not found and no DatetimeIndex is available\n        \"\"\"\n        # Handle time column mapping first (special case for DatetimeIndex)\n        if \"time\" in column_mapping:\n            time_col = column_mapping[\"time\"]\n            if time_col not in data_frame.columns:\n                # Handle single DatetimeIndex\n                if isinstance(data_frame.index, pd.DatetimeIndex):\n                    if data_frame.index.name is None:\n                        # Set name and reset index to make it a regular column\n                        data_frame.index.name = time_col\n                        data_frame = data_frame.reset_index()\n                    elif data_frame.index.name == time_col:\n                        # Index name already matches, just reset to make it a regular column\n                        data_frame = data_frame.reset_index()\n\n                # Handle MultiIndex with DatetimeIndex level\n                elif isinstance(data_frame.index, pd.MultiIndex):\n                    for i, level in enumerate(data_frame.index.levels):\n                        if isinstance(level, pd.DatetimeIndex):\n                            if data_frame.index.names[i] is None:\n                                # Set name for this level and reset it\n                                new_names = list(data_frame.index.names)\n                                new_names[i] = time_col\n                                data_frame.index.names = new_names\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                            if data_frame.index.names[i] == time_col:\n                                # Level name already matches, reset this level\n                                data_frame = data_frame.reset_index(level=time_col)\n                                break\n                    else:\n                        # No DatetimeIndex level found, check if any level name matches\n                        if time_col in data_frame.index.names or time_col == \"index\":\n                            # Reset the entire MultiIndex to get all levels as columns\n                            data_frame = data_frame.reset_index()\n                        else:\n                            # Check if time_col is an integer level position\n                            try:\n                                level_idx = int(time_col)\n                                if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                    # Reset the entire MultiIndex to get all levels as columns\n                                    data_frame = data_frame.reset_index()\n                                else:\n                                    # Invalid level position, just pass through\n                                    pass\n                            except ValueError:\n                                # Not an integer, just pass through\n                                pass\n                # No DatetimeIndex found\n                # Check if time_col is \"index\" and we have a regular index to reset\n                elif time_col == \"index\":\n                    # Reset the index to make it a regular column\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[\"time\"] = new_col_name\n                elif time_col == data_frame.index.name:\n                    # Time column matches index name, reset the index\n                    data_frame = data_frame.reset_index()\n                else:\n                    raise NotFoundError(\"Time Column\", time_col)\n\n        # Handle other index columns\n        for field, col_name in column_mapping.items():\n            if field == \"time\":\n                continue  # Already handled above\n\n            if col_name not in data_frame.columns:\n                if isinstance(data_frame.index, pd.MultiIndex):\n                    level_names = list(data_frame.index.names)\n\n                    # Integer string or int: treat as level position\n                    try:\n                        level_idx = int(col_name)\n                        if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                            data_frame = data_frame.reset_index(level=level_idx)\n                            level_name = level_names[level_idx]\n                            # Update column mapping to use actual column name\n                            new_col_name = (\n                                level_name if level_name is not None else f\"level_{level_idx}\"\n                            )\n                            column_mapping[field] = new_col_name\n                            continue\n                    except (ValueError, IndexError):\n                        pass\n\n                    # 'index': use first unnamed level if any, else first level\n                    if col_name == \"index\":\n                        unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                        level_idx = unnamed_levels[0] if unnamed_levels else 0\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n\n                    # Named level\n                    if col_name in level_names:\n                        level_idx = level_names.index(col_name)\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        continue\n\n                # Single index\n                elif col_name in (\"index\", data_frame.index.name):\n                    idx_name = data_frame.index.name\n                    data_frame = data_frame.reset_index()\n                    new_col_name = idx_name if idx_name is not None else \"index\"\n                    column_mapping[field] = new_col_name\n                    continue\n\n        return data_frame\n\n    def _process_dataframe_input(\n        self,\n        data: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n    ) -&gt; List[Data]:\n        \"\"\"Process DataFrame or Series input into a list of Data objects.\n\n        This method duplicates the logic from from_dataframe to handle\n        DataFrame/Series input in the constructor. It validates the input\n        data structure and converts it to the appropriate Data objects\n        based on the series type.\n\n        Args:\n            data (Union[pd.DataFrame, pd.Series]): DataFrame or Series to process.\n            column_mapping (Dict[str, str]): Mapping of required fields to column names.\n\n        Returns:\n            List[Data]: List of processed data objects suitable for the series type.\n\n        Raises:\n            ValueError: If required columns are missing from the DataFrame/Series.\n            ValueError: If the data structure is invalid for the series type.\n            ValueError: If time column is not found and no DatetimeIndex is available.\n\n        Note:\n            This method uses the data_class property to determine the appropriate\n            Data class for conversion.\n        \"\"\"\n        # Convert Series to DataFrame if needed (do this first)\n        if isinstance(data, pd.Series):\n            data = data.to_frame()\n\n        data_class = self.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check if all required columns are mapped\n        # Normalize keys to handle both snake_case and camelCase\n        def normalize_key(key):\n            \"\"\"Convert snake_case to camelCase for comparison.\"\"\"\n            if \"_\" in key:\n                parts = key.split(\"_\")\n                return parts[0] + \"\".join(part.capitalize() for part in parts[1:])\n            return key\n\n        # Create normalized versions of both sets for comparison\n        normalized_required = {normalize_key(key) for key in required}\n        normalized_mapping_keys = {normalize_key(key) for key in column_mapping}\n\n        missing_required = normalized_required - normalized_mapping_keys\n        if missing_required:\n            # Convert back to original format for error message\n            missing_original = {key for key in required if normalize_key(key) in missing_required}\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column mapping: {missing_original}\",\n            )\n\n        # Prepare index for all column mappings\n        data_frame = self.prepare_index(data, column_mapping)\n\n        # Check if all required columns are present in the DataFrame\n        mapped_columns = set(column_mapping.values())\n        available_columns = set(data_frame.columns.tolist())\n        missing_columns = mapped_columns - available_columns\n\n        if missing_columns:\n            raise ValueValidationError(\n                \"DataFrame\",\n                f\"is missing required column: {missing_columns}\",\n            )\n\n        # Create data objects\n        result = []\n        for _, row in data_frame.iterrows():\n            kwargs = {}\n            # Process both required and optional columns\n            for key in required.union(optional):\n                # Find the corresponding column mapping key (handle both snake_case and camelCase)\n                mapped_key = None\n                for mapping_key in column_mapping:\n                    if normalize_key(mapping_key) == normalize_key(key):\n                        mapped_key = mapping_key\n                        break\n\n                if mapped_key:\n                    col_name = column_mapping[mapped_key]\n                    if col_name in data_frame.columns:\n                        value = row[col_name]\n                        kwargs[key] = value\n            data_obj = data_class(**kwargs)\n            result.append(data_obj)\n\n        return result\n\n    @property\n    def data_dict(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the data in dictionary format.\n\n        Converts the series data to a list of dictionaries suitable for\n        frontend serialization. Handles various data formats including\n        dictionaries, lists of dictionaries, or lists of objects with\n        asdict() methods.\n\n        Returns:\n            List[Dict[str, Any]]: List of data dictionaries ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            # Get data as dictionaries\n            data_dicts = series.data_dict\n\n            # Access individual data points\n            for data_point in data_dicts:\n                # Data point contains time and value information\n                pass\n            ```\n        \"\"\"\n        if isinstance(self.data, dict):\n            return self.data\n        if isinstance(self.data, list):\n            if len(self.data) == 0:\n                return self.data\n            # If already list of dicts\n            if isinstance(self.data[0], dict):\n                return self.data\n                # If list of objects with asdict\n        if hasattr(self.data[0], \"asdict\"):\n            return [item.asdict() for item in self.data]\n        # Fallback: return as-is\n        return self.data\n\n    def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n        \"\"\"Add a marker to this series.\n\n        Adds a marker object to the series for highlighting specific data points\n        or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n        Args:\n            marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If the marker position is not valid for its type.\n\n        Example:\n            ```python\n            from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n             from streamlit_lightweight_charts_pro.type_definitions.enums import (\n                 MarkerPosition, MarkerShape\n             )\n\n            # Add a bar marker\n            bar_marker = BarMarker(\n                time=\"2024-01-01 10:00:00\",\n                position=MarkerPosition.ABOVE_BAR,\n                color=\"red\",\n                shape=MarkerShape.CIRCLE,\n                text=\"Buy Signal\",\n            )\n            series.add_marker(bar_marker)\n\n            # Add a price marker\n            price_marker = PriceMarker(\n                time=1640995200,\n                position=MarkerPosition.AT_PRICE_TOP,\n                color=\"#00ff00\",\n                shape=MarkerShape.ARROW_UP,\n                price=100.50,\n                text=\"Resistance Level\",\n            )\n            series.add_marker(price_marker)\n\n            # Method chaining\n            series.add_marker(marker1).add_marker(marker2)\n            ```\n        \"\"\"\n        # Validate the marker position\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.append(marker)\n        return self\n\n    def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n        \"\"\"Add multiple markers to this series.\n\n        Adds a list of markers to the series. Returns self for method chaining.\n\n        Args:\n            markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            ValueError: If any marker position is not valid for its type.\n        \"\"\"\n        # Validate all markers before adding\n        for marker in markers:\n            if not marker.validate_position():\n                raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n        self._markers.extend(markers)\n        return self\n\n    def clear_markers(self) -&gt; \"Series\":\n        \"\"\"Clear all markers from this series.\n\n        Removes all markers from the series. Returns self for method chaining.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._markers.clear()\n        return self\n\n    def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n        \"\"\"Add a price line option to this series.\n\n        Args:\n            price_line (PriceLineOptions): The price line option to add.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.append(price_line)\n        return self\n\n    def clear_price_lines(self) -&gt; \"Series\":\n        \"\"\"Remove all price line options from this series.\n\n        Returns:\n            Series: Self for method chaining.\n        \"\"\"\n        self._price_lines.clear()\n        return self\n\n    def _validate_pane_config(self) -&gt; None:\n        \"\"\"Validate pane configuration for the series.\n\n        This method ensures that pane_id is properly set.\n        It should be called by subclasses in their asdict() method.\n\n        Raises:\n            ValueError: If pane_id is negative.\n        \"\"\"\n        if self._pane_id is not None and self._pane_id &lt; 0:\n            raise ValueValidationError(\"pane_id\", \"must be non-negative\")\n        if self._pane_id is None:\n            self._pane_id = 0\n\n    def _get_attr_name(self, key: str) -&gt; str:\n        \"\"\"Get the attribute name for a given key.\"\"\"\n        # Convert camelCase to snake_case for attribute lookup\n        attr_name = self._camel_to_snake(key)\n\n        # Check if attribute exists (try multiple variations)\n        if not hasattr(self, attr_name):\n            # Try the original key in case it's already snake_case\n            if hasattr(self, key):\n                attr_name = key\n            # Try with _ prefix (for private attributes)\n            elif hasattr(self, f\"_{attr_name}\"):\n                attr_name = f\"_{attr_name}\"\n            # Try original key with _ prefix\n            elif hasattr(self, f\"_{key}\"):\n                attr_name = f\"_{key}\"\n            else:\n                # Ignore invalid attributes instead of raising an error\n\n                attr_name = None\n\n        return attr_name\n\n    def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n        \"\"\"Update series configuration with a dictionary of values.\n\n        This method updates series properties using a configuration dictionary. It supports\n        updating simple attributes, nested options objects, and lists of options. Keys may be\n        in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n        Args:\n            updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n                or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n        Returns:\n            Series: Self for method chaining.\n\n        Raises:\n            AttributeError: If an attribute cannot be set due to type or value errors.\n\n        Example:\n            ```python\n            series = LineSeries(data=data)\n            series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n            series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n            series.update(\n                {\n                    \"price_lines\": [\n                        {\"price\": 105, \"color\": \"#00ff00\"},\n                        {\"price\": 110, \"color\": \"#ff0000\"},\n                    ]\n                }\n            )\n            series.update({\"visible\": True}).update({\"pane_id\": 1})\n            ```\n        \"\"\"\n        for key, value in updates.items():\n            if value is None:\n                continue  # Skip None values for method chaining\n\n            attr_name = self._get_attr_name(key)\n\n            if attr_name is None:\n                continue\n\n            try:\n                if isinstance(value, dict):\n                    self._update_dict_value(attr_name, value)\n                elif isinstance(value, list):\n                    self._update_list_value(attr_name, value)\n                else:\n                    setattr(self, attr_name, value)\n            except Exception:\n                logger.exception(\"Failed to update attribute '%s'\", attr_name)\n                raise\n\n        return self\n\n    def _update_dict_value(self, attr_name: str, value: dict) -&gt; None:\n        \"\"\"Update a nested options object attribute with a dictionary.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (dict): Dictionary of values to update the nested object.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        if current_value is not None and hasattr(current_value, \"update\"):\n            current_value.update(value)\n            return\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            return\n\n        # Handle Union types (e.g., Optional[T])\n        if getattr(attr_type, \"__origin__\", None) is Union:\n            for arg in attr_type.__args__:\n                if arg is not type(None):\n                    attr_type = arg\n                    break\n\n        if hasattr(attr_type, \"update\"):\n            try:\n                instance = attr_type()\n                setattr(self, attr_name, instance)\n                instance.update(value)\n            except Exception:\n                logger.exception(\"Failed to instantiate or update %s\", attr_name)\n                raise\n        else:\n            # No update method for this attribute\n            pass\n\n    def _update_list_value(self, attr_name: str, value: list) -&gt; None:\n        \"\"\"Update a list attribute, instantiating and updating items as needed.\n\n        Args:\n            attr_name (str): Attribute name to update.\n            value (list): List of values or dicts to update the list attribute.\n\n        Raises:\n            AttributeError: If the attribute cannot be updated.\n        \"\"\"\n        current_value = getattr(self, attr_name, None)\n\n        type_hints = get_type_hints(self.__class__)\n\n        attr_type = type_hints.get(attr_name)\n\n        if attr_type is None:\n            setattr(self, attr_name, value)\n            return\n\n        if getattr(attr_type, \"__origin__\", None) is list:\n            item_type = attr_type.__args__[0]\n\n            if not hasattr(item_type, \"update\"):\n                setattr(self, attr_name, value)\n                return\n\n            if current_value is None:\n                current_value = []\n                setattr(self, attr_name, current_value)\n\n            for _i, item in enumerate(value):\n                if isinstance(item, dict):\n                    try:\n                        instance = item_type()\n                        instance.update(item)\n                        current_value.append(instance)\n                    except Exception:\n                        logger.exception(\n                            \"Failed to instantiate or update list item for %s\",\n                            attr_name,\n                        )\n                        raise\n                else:\n                    current_value.append(item)\n        else:\n            setattr(self, attr_name, value)\n\n    def _camel_to_snake(self, camel_case: str) -&gt; str:\n        \"\"\"Convert camelCase to snake_case.\n\n        Args:\n            camel_case: String in camelCase format.\n\n        Returns:\n            String in snake_case format.\n        \"\"\"\n        import re  # pylint: disable=import-outside-toplevel\n\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert series to dictionary representation.\n\n        This method creates a dictionary representation of the series\n        that can be consumed by the frontend React component.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing series configuration for the frontend.\n        \"\"\"\n        # Validate pane configuration\n        self._validate_pane_config()\n\n        # Get base configuration\n        config = {\n            \"type\": self.chart_type.value,\n            \"data\": self.data_dict,\n        }\n\n        # Add options from chainable properties only\n        options = {}\n        for attr_name in dir(self):\n            if attr_name.startswith(\"_\"):\n                continue\n            # Skip data attribute as it's handled separately\n            if attr_name == \"data\":\n                continue\n            # Skip class attributes (like DATA_CLASS)\n            if attr_name.isupper():\n                continue\n            # Skip class properties (like data_class)\n            if attr_name == \"data_class\":\n                continue\n\n            # Rule 1: Only include attributes decorated with chainable_property\n            if not self._is_chainable_property(attr_name):\n                continue\n\n            attr_value = getattr(self, attr_name)\n\n            # Rule 2: Skip if None and allow_none is True\n            if attr_value is None and self._is_allow_none(attr_name):\n                continue\n\n            # Determine if this should go to top level or options\n            is_top_level = self._is_top_level(attr_name)\n\n            # Handle objects with asdict() method\n            if (\n                hasattr(attr_value, \"asdict\")\n                and callable(attr_value.asdict)\n                and not isinstance(attr_value, type)\n            ):\n                # Rule 3: If property ends with _options, flatten it into options\n                if attr_name.endswith(\"_options\"):\n                    options.update(attr_value.asdict())\n                else:\n                    # Convert snake_case to camelCase for the key\n                    key = snake_to_camel(attr_name)\n                    if is_top_level:\n                        config[key] = attr_value.asdict()\n                    else:\n                        options[key] = attr_value.asdict()\n\n            # Handle lists of objects with asdict() method\n            elif (\n                isinstance(attr_value, list)\n                and attr_value\n                and hasattr(attr_value[0], \"asdict\")\n                and callable(attr_value[0].asdict)\n            ):\n                # Convert list of objects to list of dictionaries\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = [item.asdict() for item in attr_value]\n                else:\n                    options[key] = [item.asdict() for item in attr_value]\n\n            # Also include individual option attributes that are not None\n            elif (\n                not callable(attr_value)\n                and not isinstance(attr_value, type)\n                and attr_value is not None\n            ):\n                # Skip empty lists (they should not be included in configuration)\n                if isinstance(attr_value, list) and not attr_value:\n                    continue\n\n                # Convert snake_case to camelCase for the key\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    # Include empty strings for top-level properties (they are valid)\n                    config[key] = attr_value\n                # Skip empty strings for options (they are not meaningful)\n                elif attr_value != \"\":\n                    options[key] = attr_value\n\n        # Only include options field if it's not empty\n        if options:\n            config[\"options\"] = options\n\n        return config\n\n    def _is_chainable_property(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if an attribute is decorated with chainable_property.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute is a chainable property\n        \"\"\"\n        return (\n            hasattr(self.__class__, \"_chainable_properties\")\n            and attr_name in self.__class__._chainable_properties  # pylint: disable=protected-access\n        )\n\n    def _is_allow_none(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property allows None values.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the property allows None values\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"allow_none\"]\n        return False\n\n    def _is_top_level(self, attr_name: str) -&gt; bool:\n        \"\"\"Check if a chainable property should be output at the top level.\n\n        Args:\n            attr_name: Name of the attribute to check\n\n        Returns:\n            bool: True if the attribute should be at the top level\n        \"\"\"\n        if self._is_chainable_property(attr_name):\n            # pylint: disable=protected-access\n            return self.__class__._chainable_properties[attr_name][\"top_level\"]\n        return False\n\n    @classproperty\n    def data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n        \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n        for base in self.__mro__:\n            if hasattr(base, \"DATA_CLASS\"):\n                return base.DATA_CLASS\n        raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n\n    @classmethod\n    def from_dataframe(\n        cls,\n        df: Union[pd.DataFrame, pd.Series],\n        column_mapping: Dict[str, str],\n        price_scale_id: str = \"\",\n        **kwargs,\n    ) -&gt; \"Series\":\n        \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n        Args:\n            df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n            column_mapping (dict): Mapping of required fields\n                (e.g., {'time': 'datetime', 'value': 'close', ...}).\n            price_scale_id (str): Price scale ID (default '').\n            **kwargs: Additional arguments for the Series constructor.\n\n        Returns:\n            Series: An instance of the Series (or subclass) with normalized data.\n\n        Raises:\n            NotImplementedError: If the subclass does not define DATA_CLASS.\n            ValueError: If required columns are missing in column_mapping or DataFrame.\n            AttributeError: If the data class does not define REQUIRED_COLUMNS.\n        \"\"\"\n        # Convert Series to DataFrame if needed\n        dataframe = df\n        if isinstance(dataframe, pd.Series):\n            dataframe = dataframe.to_frame()\n\n        data_class = cls.data_class\n        required = data_class.required_columns\n        optional = data_class.optional_columns\n\n        # Check required columns in column_mapping\n        missing_mapping = [col for col in required if col not in column_mapping]\n        if missing_mapping:\n            raise ValueValidationError(\n                \"column_mapping\",\n                f\"missing required columns: {missing_mapping}\",\n            )\n        # Removed print\n\n        # Prepare index for all column mappings\n        data_frame = cls.prepare_index(dataframe, column_mapping)\n\n        # Check required columns in DataFrame (including index) - after processing\n        for key in required:\n            col = column_mapping[key]\n            if col not in data_frame.columns:\n                raise NotFoundError(\"Column\", col)\n            # Removed print\n\n        # Build data objects\n        data = []\n        for i in range(len(dataframe)):\n            kwargs_data = {}\n            for key in required.union(optional):\n                if key in column_mapping:\n                    col = column_mapping[key]\n                    if col in data_frame.columns:\n                        value = data_frame.iloc[i][col]\n                        kwargs_data[key] = value\n                    else:\n                        raise NotFoundError(\"Column\", col)\n                else:\n                    # Skip optional columns that are not in column_mapping\n                    continue\n\n            data.append(data_class(**kwargs_data))\n\n        return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.data_dict","title":"data_dict  <code>property</code>","text":"<pre><code>data_dict: List[Dict[str, Any]]\n</code></pre> <p>Get the data in dictionary format.</p> <p>Converts the series data to a list of dictionaries suitable for frontend serialization. Handles various data formats including dictionaries, lists of dictionaries, or lists of objects with asdict() methods.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of data dictionaries ready for frontend consumption.</p> Example <pre><code># Get data as dictionaries\ndata_dicts = series.data_dict\n\n# Access individual data points\nfor data_point in data_dicts:\n    # Data point contains time and value information\n    pass\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.prepare_index","title":"prepare_index  <code>staticmethod</code>","text":"<pre><code>prepare_index(\n    data_frame: DataFrame, column_mapping: Dict[str, str]\n) -&gt; DataFrame\n</code></pre> <p>Prepare index for column mapping.</p> <p>Handles all index-related column mapping cases: - Time column mapping with DatetimeIndex - Level position mapping (e.g., \"0\", \"1\") - \"index\" mapping (first unnamed level or level 0) - Named level mapping (e.g., \"date\", \"symbol\") - Single index reset for non-time columns</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>DataFrame to prepare</p> required <code>column_mapping</code> <code>Dict[str, str]</code> <p>Mapping of required fields to column names</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with prepared index</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time column is not found and no DatetimeIndex is available</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@staticmethod\ndef prepare_index(data_frame: pd.DataFrame, column_mapping: Dict[str, str]) -&gt; pd.DataFrame:\n    \"\"\"Prepare index for column mapping.\n\n    Handles all index-related column mapping cases:\n    - Time column mapping with DatetimeIndex\n    - Level position mapping (e.g., \"0\", \"1\")\n    - \"index\" mapping (first unnamed level or level 0)\n    - Named level mapping (e.g., \"date\", \"symbol\")\n    - Single index reset for non-time columns\n\n    Args:\n        data_frame: DataFrame to prepare\n        column_mapping: Mapping of required fields to column names\n\n    Returns:\n        DataFrame with prepared index\n\n    Raises:\n        ValueError: If time column is not found and no DatetimeIndex is available\n    \"\"\"\n    # Handle time column mapping first (special case for DatetimeIndex)\n    if \"time\" in column_mapping:\n        time_col = column_mapping[\"time\"]\n        if time_col not in data_frame.columns:\n            # Handle single DatetimeIndex\n            if isinstance(data_frame.index, pd.DatetimeIndex):\n                if data_frame.index.name is None:\n                    # Set name and reset index to make it a regular column\n                    data_frame.index.name = time_col\n                    data_frame = data_frame.reset_index()\n                elif data_frame.index.name == time_col:\n                    # Index name already matches, just reset to make it a regular column\n                    data_frame = data_frame.reset_index()\n\n            # Handle MultiIndex with DatetimeIndex level\n            elif isinstance(data_frame.index, pd.MultiIndex):\n                for i, level in enumerate(data_frame.index.levels):\n                    if isinstance(level, pd.DatetimeIndex):\n                        if data_frame.index.names[i] is None:\n                            # Set name for this level and reset it\n                            new_names = list(data_frame.index.names)\n                            new_names[i] = time_col\n                            data_frame.index.names = new_names\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                        if data_frame.index.names[i] == time_col:\n                            # Level name already matches, reset this level\n                            data_frame = data_frame.reset_index(level=time_col)\n                            break\n                else:\n                    # No DatetimeIndex level found, check if any level name matches\n                    if time_col in data_frame.index.names or time_col == \"index\":\n                        # Reset the entire MultiIndex to get all levels as columns\n                        data_frame = data_frame.reset_index()\n                    else:\n                        # Check if time_col is an integer level position\n                        try:\n                            level_idx = int(time_col)\n                            if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                                # Reset the entire MultiIndex to get all levels as columns\n                                data_frame = data_frame.reset_index()\n                            else:\n                                # Invalid level position, just pass through\n                                pass\n                        except ValueError:\n                            # Not an integer, just pass through\n                            pass\n            # No DatetimeIndex found\n            # Check if time_col is \"index\" and we have a regular index to reset\n            elif time_col == \"index\":\n                # Reset the index to make it a regular column\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[\"time\"] = new_col_name\n            elif time_col == data_frame.index.name:\n                # Time column matches index name, reset the index\n                data_frame = data_frame.reset_index()\n            else:\n                raise NotFoundError(\"Time Column\", time_col)\n\n    # Handle other index columns\n    for field, col_name in column_mapping.items():\n        if field == \"time\":\n            continue  # Already handled above\n\n        if col_name not in data_frame.columns:\n            if isinstance(data_frame.index, pd.MultiIndex):\n                level_names = list(data_frame.index.names)\n\n                # Integer string or int: treat as level position\n                try:\n                    level_idx = int(col_name)\n                    if 0 &lt;= level_idx &lt; len(data_frame.index.levels):\n                        data_frame = data_frame.reset_index(level=level_idx)\n                        level_name = level_names[level_idx]\n                        # Update column mapping to use actual column name\n                        new_col_name = (\n                            level_name if level_name is not None else f\"level_{level_idx}\"\n                        )\n                        column_mapping[field] = new_col_name\n                        continue\n                except (ValueError, IndexError):\n                    pass\n\n                # 'index': use first unnamed level if any, else first level\n                if col_name == \"index\":\n                    unnamed_levels = [i for i, name in enumerate(level_names) if name is None]\n                    level_idx = unnamed_levels[0] if unnamed_levels else 0\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    level_name = level_names[level_idx]\n                    new_col_name = (\n                        level_name if level_name is not None else f\"level_{level_idx}\"\n                    )\n                    column_mapping[field] = new_col_name\n                    continue\n\n                # Named level\n                if col_name in level_names:\n                    level_idx = level_names.index(col_name)\n                    data_frame = data_frame.reset_index(level=level_idx)\n                    continue\n\n            # Single index\n            elif col_name in (\"index\", data_frame.index.name):\n                idx_name = data_frame.index.name\n                data_frame = data_frame.reset_index()\n                new_col_name = idx_name if idx_name is not None else \"index\"\n                column_mapping[field] = new_col_name\n                continue\n\n    return data_frame\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_marker","title":"add_marker","text":"<pre><code>add_marker(marker: MarkerBase) -&gt; Series\n</code></pre> <p>Add a marker to this series.</p> <p>Adds a marker object to the series for highlighting specific data points or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>MarkerBase</code> <p>The marker object to add. Must be a BarMarker or PriceMarker.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker position is not valid for its type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n from streamlit_lightweight_charts_pro.type_definitions.enums import (\n     MarkerPosition, MarkerShape\n )\n\n# Add a bar marker\nbar_marker = BarMarker(\n    time=\"2024-01-01 10:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    color=\"red\",\n    shape=MarkerShape.CIRCLE,\n    text=\"Buy Signal\",\n)\nseries.add_marker(bar_marker)\n\n# Add a price marker\nprice_marker = PriceMarker(\n    time=1640995200,\n    position=MarkerPosition.AT_PRICE_TOP,\n    color=\"#00ff00\",\n    shape=MarkerShape.ARROW_UP,\n    price=100.50,\n    text=\"Resistance Level\",\n)\nseries.add_marker(price_marker)\n\n# Method chaining\nseries.add_marker(marker1).add_marker(marker2)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_marker(self, marker: MarkerBase) -&gt; \"Series\":\n    \"\"\"Add a marker to this series.\n\n    Adds a marker object to the series for highlighting specific data points\n    or events. The marker must be a valid MarkerBase subclass (BarMarker or PriceMarker).\n\n    Args:\n        marker (MarkerBase): The marker object to add. Must be a BarMarker or PriceMarker.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If the marker position is not valid for its type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data.marker import BarMarker, PriceMarker\n         from streamlit_lightweight_charts_pro.type_definitions.enums import (\n             MarkerPosition, MarkerShape\n         )\n\n        # Add a bar marker\n        bar_marker = BarMarker(\n            time=\"2024-01-01 10:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            color=\"red\",\n            shape=MarkerShape.CIRCLE,\n            text=\"Buy Signal\",\n        )\n        series.add_marker(bar_marker)\n\n        # Add a price marker\n        price_marker = PriceMarker(\n            time=1640995200,\n            position=MarkerPosition.AT_PRICE_TOP,\n            color=\"#00ff00\",\n            shape=MarkerShape.ARROW_UP,\n            price=100.50,\n            text=\"Resistance Level\",\n        )\n        series.add_marker(price_marker)\n\n        # Method chaining\n        series.add_marker(marker1).add_marker(marker2)\n        ```\n    \"\"\"\n    # Validate the marker position\n    if not marker.validate_position():\n        raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.append(marker)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_markers","title":"add_markers","text":"<pre><code>add_markers(markers: List[MarkerBase]) -&gt; Series\n</code></pre> <p>Add multiple markers to this series.</p> <p>Adds a list of markers to the series. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>List[MarkerBase]</code> <p>List of marker objects to add. Must be MarkerBase subclasses.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any marker position is not valid for its type.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_markers(self, markers: List[MarkerBase]) -&gt; \"Series\":\n    \"\"\"Add multiple markers to this series.\n\n    Adds a list of markers to the series. Returns self for method chaining.\n\n    Args:\n        markers: List of marker objects to add. Must be MarkerBase subclasses.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        ValueError: If any marker position is not valid for its type.\n    \"\"\"\n    # Validate all markers before adding\n    for marker in markers:\n        if not marker.validate_position():\n            raise InvalidMarkerPositionError(marker.position, type(marker).__name__)\n\n    self._markers.extend(markers)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.clear_markers","title":"clear_markers","text":"<pre><code>clear_markers() -&gt; Series\n</code></pre> <p>Clear all markers from this series.</p> <p>Removes all markers from the series. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_markers(self) -&gt; \"Series\":\n    \"\"\"Clear all markers from this series.\n\n    Removes all markers from the series. Returns self for method chaining.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._markers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.add_price_line","title":"add_price_line","text":"<pre><code>add_price_line(price_line: PriceLineOptions) -&gt; Series\n</code></pre> <p>Add a price line option to this series.</p> <p>Parameters:</p> Name Type Description Default <code>price_line</code> <code>PriceLineOptions</code> <p>The price line option to add.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def add_price_line(self, price_line: PriceLineOptions) -&gt; \"Series\":\n    \"\"\"Add a price line option to this series.\n\n    Args:\n        price_line (PriceLineOptions): The price line option to add.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.append(price_line)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.clear_price_lines","title":"clear_price_lines","text":"<pre><code>clear_price_lines() -&gt; Series\n</code></pre> <p>Remove all price line options from this series.</p> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def clear_price_lines(self) -&gt; \"Series\":\n    \"\"\"Remove all price line options from this series.\n\n    Returns:\n        Series: Self for method chaining.\n    \"\"\"\n    self._price_lines.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.update","title":"update","text":"<pre><code>update(updates: Dict[str, Any]) -&gt; Series\n</code></pre> <p>Update series configuration with a dictionary of values.</p> <p>This method updates series properties using a configuration dictionary. It supports updating simple attributes, nested options objects, and lists of options. Keys may be in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>Dict[str, Any]</code> <p>Dictionary of updates to apply. Keys can be in snake_case or camelCase. Values can be simple types, dictionaries for nested objects, or lists.</p> required <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute cannot be set due to type or value errors.</p> Example <pre><code>series = LineSeries(data=data)\nseries.update({\"visible\": False, \"price_scale_id\": \"left\"})\nseries.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\nseries.update(\n    {\n        \"price_lines\": [\n            {\"price\": 105, \"color\": \"#00ff00\"},\n            {\"price\": 110, \"color\": \"#ff0000\"},\n        ]\n    }\n)\nseries.update({\"visible\": True}).update({\"pane_id\": 1})\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def update(self, updates: Dict[str, Any]) -&gt; \"Series\":\n    \"\"\"Update series configuration with a dictionary of values.\n\n    This method updates series properties using a configuration dictionary. It supports\n    updating simple attributes, nested options objects, and lists of options. Keys may be\n    in snake_case or camelCase. Invalid or unknown attributes will be logged and skipped.\n\n    Args:\n        updates (Dict[str, Any]): Dictionary of updates to apply. Keys can be in snake_case\n            or camelCase. Values can be simple types, dictionaries for nested objects, or lists.\n\n    Returns:\n        Series: Self for method chaining.\n\n    Raises:\n        AttributeError: If an attribute cannot be set due to type or value errors.\n\n    Example:\n        ```python\n        series = LineSeries(data=data)\n        series.update({\"visible\": False, \"price_scale_id\": \"left\"})\n        series.update({\"price_format\": {\"precision\": 2, \"minMove\": 0.01}})\n        series.update(\n            {\n                \"price_lines\": [\n                    {\"price\": 105, \"color\": \"#00ff00\"},\n                    {\"price\": 110, \"color\": \"#ff0000\"},\n                ]\n            }\n        )\n        series.update({\"visible\": True}).update({\"pane_id\": 1})\n        ```\n    \"\"\"\n    for key, value in updates.items():\n        if value is None:\n            continue  # Skip None values for method chaining\n\n        attr_name = self._get_attr_name(key)\n\n        if attr_name is None:\n            continue\n\n        try:\n            if isinstance(value, dict):\n                self._update_dict_value(attr_name, value)\n            elif isinstance(value, list):\n                self._update_list_value(attr_name, value)\n            else:\n                setattr(self, attr_name, value)\n        except Exception:\n            logger.exception(\"Failed to update attribute '%s'\", attr_name)\n            raise\n\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert series to dictionary representation.</p> <p>This method creates a dictionary representation of the series that can be consumed by the frontend React component.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing series configuration for the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert series to dictionary representation.\n\n    This method creates a dictionary representation of the series\n    that can be consumed by the frontend React component.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing series configuration for the frontend.\n    \"\"\"\n    # Validate pane configuration\n    self._validate_pane_config()\n\n    # Get base configuration\n    config = {\n        \"type\": self.chart_type.value,\n        \"data\": self.data_dict,\n    }\n\n    # Add options from chainable properties only\n    options = {}\n    for attr_name in dir(self):\n        if attr_name.startswith(\"_\"):\n            continue\n        # Skip data attribute as it's handled separately\n        if attr_name == \"data\":\n            continue\n        # Skip class attributes (like DATA_CLASS)\n        if attr_name.isupper():\n            continue\n        # Skip class properties (like data_class)\n        if attr_name == \"data_class\":\n            continue\n\n        # Rule 1: Only include attributes decorated with chainable_property\n        if not self._is_chainable_property(attr_name):\n            continue\n\n        attr_value = getattr(self, attr_name)\n\n        # Rule 2: Skip if None and allow_none is True\n        if attr_value is None and self._is_allow_none(attr_name):\n            continue\n\n        # Determine if this should go to top level or options\n        is_top_level = self._is_top_level(attr_name)\n\n        # Handle objects with asdict() method\n        if (\n            hasattr(attr_value, \"asdict\")\n            and callable(attr_value.asdict)\n            and not isinstance(attr_value, type)\n        ):\n            # Rule 3: If property ends with _options, flatten it into options\n            if attr_name.endswith(\"_options\"):\n                options.update(attr_value.asdict())\n            else:\n                # Convert snake_case to camelCase for the key\n                key = snake_to_camel(attr_name)\n                if is_top_level:\n                    config[key] = attr_value.asdict()\n                else:\n                    options[key] = attr_value.asdict()\n\n        # Handle lists of objects with asdict() method\n        elif (\n            isinstance(attr_value, list)\n            and attr_value\n            and hasattr(attr_value[0], \"asdict\")\n            and callable(attr_value[0].asdict)\n        ):\n            # Convert list of objects to list of dictionaries\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                config[key] = [item.asdict() for item in attr_value]\n            else:\n                options[key] = [item.asdict() for item in attr_value]\n\n        # Also include individual option attributes that are not None\n        elif (\n            not callable(attr_value)\n            and not isinstance(attr_value, type)\n            and attr_value is not None\n        ):\n            # Skip empty lists (they should not be included in configuration)\n            if isinstance(attr_value, list) and not attr_value:\n                continue\n\n            # Convert snake_case to camelCase for the key\n            key = snake_to_camel(attr_name)\n            if is_top_level:\n                # Include empty strings for top-level properties (they are valid)\n                config[key] = attr_value\n            # Skip empty strings for options (they are not meaningful)\n            elif attr_value != \"\":\n                options[key] = attr_value\n\n    # Only include options field if it's not empty\n    if options:\n        config[\"options\"] = options\n\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.data_class","title":"data_class","text":"<pre><code>data_class() -&gt; Type[Data]\n</code></pre> <p>Return the first DATA_CLASS found in the MRO (most-derived class wins).</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classproperty\ndef data_class(self) -&gt; Type[Data]:  # pylint: disable=no-self-argument\n    \"\"\"Return the first DATA_CLASS found in the MRO (most-derived class wins).\"\"\"\n    for base in self.__mro__:\n        if hasattr(base, \"DATA_CLASS\"):\n            return base.DATA_CLASS\n    raise NotImplementedError(\"No DATA_CLASS defined in the class hierarchy.\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base.Series.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(\n    df: Union[DataFrame, Series],\n    column_mapping: Dict[str, str],\n    price_scale_id: str = \"\",\n    **kwargs\n) -&gt; Series\n</code></pre> <p>Create a Series instance from a pandas DataFrame or Series.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Union[DataFrame, Series]</code> <p>The input DataFrame or Series.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields (e.g., {'time': 'datetime', 'value': 'close', ...}).</p> required <code>price_scale_id</code> <code>str</code> <p>Price scale ID (default '').</p> <code>''</code> <code>**kwargs</code> <p>Additional arguments for the Series constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Series</code> <code>Series</code> <p>An instance of the Series (or subclass) with normalized data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the subclass does not define DATA_CLASS.</p> <code>ValueError</code> <p>If required columns are missing in column_mapping or DataFrame.</p> <code>AttributeError</code> <p>If the data class does not define REQUIRED_COLUMNS.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/base.py</code> <pre><code>@classmethod\ndef from_dataframe(\n    cls,\n    df: Union[pd.DataFrame, pd.Series],\n    column_mapping: Dict[str, str],\n    price_scale_id: str = \"\",\n    **kwargs,\n) -&gt; \"Series\":\n    \"\"\"Create a Series instance from a pandas DataFrame or Series.\n\n    Args:\n        df (Union[pd.DataFrame, pd.Series]): The input DataFrame or Series.\n        column_mapping (dict): Mapping of required fields\n            (e.g., {'time': 'datetime', 'value': 'close', ...}).\n        price_scale_id (str): Price scale ID (default '').\n        **kwargs: Additional arguments for the Series constructor.\n\n    Returns:\n        Series: An instance of the Series (or subclass) with normalized data.\n\n    Raises:\n        NotImplementedError: If the subclass does not define DATA_CLASS.\n        ValueError: If required columns are missing in column_mapping or DataFrame.\n        AttributeError: If the data class does not define REQUIRED_COLUMNS.\n    \"\"\"\n    # Convert Series to DataFrame if needed\n    dataframe = df\n    if isinstance(dataframe, pd.Series):\n        dataframe = dataframe.to_frame()\n\n    data_class = cls.data_class\n    required = data_class.required_columns\n    optional = data_class.optional_columns\n\n    # Check required columns in column_mapping\n    missing_mapping = [col for col in required if col not in column_mapping]\n    if missing_mapping:\n        raise ValueValidationError(\n            \"column_mapping\",\n            f\"missing required columns: {missing_mapping}\",\n        )\n    # Removed print\n\n    # Prepare index for all column mappings\n    data_frame = cls.prepare_index(dataframe, column_mapping)\n\n    # Check required columns in DataFrame (including index) - after processing\n    for key in required:\n        col = column_mapping[key]\n        if col not in data_frame.columns:\n            raise NotFoundError(\"Column\", col)\n        # Removed print\n\n    # Build data objects\n    data = []\n    for i in range(len(dataframe)):\n        kwargs_data = {}\n        for key in required.union(optional):\n            if key in column_mapping:\n                col = column_mapping[key]\n                if col in data_frame.columns:\n                    value = data_frame.iloc[i][col]\n                    kwargs_data[key] = value\n                else:\n                    raise NotFoundError(\"Column\", col)\n            else:\n                # Skip optional columns that are not in column_mapping\n                continue\n\n        data.append(data_class(**kwargs_data))\n\n    return cls(data=data, price_scale_id=price_scale_id, **kwargs)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/base.html#streamlit_lightweight_charts_pro.charts.series.base-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html","title":"streamlit_lightweight_charts_pro.charts.series.baseline","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline","title":"baseline","text":"<p>Baseline series for streamlit-lightweight-charts.</p> <p>This module provides the BaselineSeries class for creating baseline charts that display areas above and below a baseline value with different colors. Baseline series are commonly used for highlighting positive/negative trends and threshold analysis.</p> <p>The BaselineSeries class supports various styling options for the baseline, fill colors, and animation effects. It also supports markers and price line configurations.</p> Example <p>from streamlit_lightweight_charts_pro.charts.series import BaselineSeries from streamlit_lightweight_charts_pro.data.baseline_data import BaselineData</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline--create-baseline-data","title":"Create baseline data","text":"<p>data = [     BaselineData(time=1640995200, value=100.5),     BaselineData(time=1641081600, value=105.2) ]</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline--create-baseline-series-with-styling","title":"Create baseline series with styling","text":"<p>series = BaselineSeries(data=data) series.base_value = {\"type\": \"price\", \"price\": 100} series.top_line_color = \"#26a69a\" series.bottom_line_color = \"#ef5350\"</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries","title":"BaselineSeries","text":"<p>Baseline series for lightweight charts.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/baseline.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=_validate_base_value_static)\n@chainable_property(\"relative_gradient\", bool)\n@chainable_property(\"top_fill_color1\", str, validator=\"color\")\n@chainable_property(\"top_fill_color2\", str, validator=\"color\")\n@chainable_property(\"top_line_color\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color1\", str, validator=\"color\")\n@chainable_property(\"bottom_fill_color2\", str, validator=\"color\")\n@chainable_property(\"bottom_line_color\", str, validator=\"color\")\nclass BaselineSeries(Series):\n    \"\"\"Baseline series for lightweight charts.\"\"\"\n\n    DATA_CLASS = BaselineData\n\n    def __init__(\n        self,\n        data: Union[List[BaselineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize LineOptions for common line properties\n        self._line_options = LineOptions()\n\n        # Baseline-specific properties (not in LineOptions) - set default values internally\n        self._base_value = self._validate_base_value({\"type\": \"price\", \"price\": 0})\n        self._relative_gradient = False\n        self._top_fill_color1 = \"rgba(38, 166, 154, 0.28)\"\n        self._top_fill_color2 = \"rgba(38, 166, 154, 0.05)\"\n        self._top_line_color = \"rgba(38, 166, 154, 1)\"\n        self._bottom_fill_color1 = \"rgba(239, 83, 80, 0.05)\"\n        self._bottom_fill_color2 = \"rgba(239, 83, 80, 0.28)\"\n        self._bottom_line_color = \"rgba(239, 83, 80, 1)\"\n\n    def _validate_base_value(self, base_value: Union[int, float, Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate and normalize base_value.\"\"\"\n        if isinstance(base_value, (int, float)):\n            return {\"type\": \"price\", \"price\": float(base_value)}\n        if isinstance(base_value, dict):\n            if \"type\" not in base_value or \"price\" not in base_value:\n                raise BaseValueFormatError()\n            return {\"type\": str(base_value[\"type\"]), \"price\": float(base_value[\"price\"])}\n        raise BaseValueFormatError()\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format.\"\"\"\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.BASELINE\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline.BaselineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/baseline.html#streamlit_lightweight_charts_pro.charts.series.baseline-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html","title":"streamlit_lightweight_charts_pro.charts.series.candlestick","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick","title":"candlestick","text":"<p>Candlestick series for Streamlit Lightweight Charts Pro.</p> <p>This module provides the CandlestickSeries class for creating candlestick charts that display OHLC or OHLCV data. Candlestick series are commonly used for price charts and technical analysis in financial visualization, providing a comprehensive view of price action.</p> <p>The CandlestickSeries class supports extensive styling options for up/down colors, wicks, borders, and animation effects. It also supports markers, price line configurations, trade visualizations, and various customization options through chainable properties.</p> The module includes <ul> <li>CandlestickSeries: Main class for creating candlestick chart series</li> <li>Color validation and styling options</li> <li>DataFrame support with column mapping</li> <li>Method chaining for fluent API usage</li> </ul> Key Features <ul> <li>Support for CandlestickData and OHLC data types</li> <li>Comprehensive color customization (up/down, border, wick colors)</li> <li>Visibility controls for wicks and borders</li> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line support</li> <li>Method chaining for fluent configuration</li> <li>Color format validation</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries","title":"CandlestickSeries","text":"<p>Candlestick series for creating OHLC candlestick charts in financial visualization.</p> <p>This class represents a candlestick series that displays OHLC (Open, High, Low, Close) data as candlestick bars. It's commonly used for price charts, technical analysis, and comprehensive price action visualization in financial applications.</p> <p>The CandlestickSeries extends the base Series class with candlestick-specific functionality and supports extensive styling options through chainable properties. It provides comprehensive color customization for bullish/bearish candles, wicks, borders, and other visual elements.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[CandlestickData], DataFrame, Series]</code> <p>Data points for the candlestick series. Can be a list of CandlestickData objects, a pandas DataFrame, or a pandas Series.</p> <code>up_color</code> <code>str</code> <p>Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).</p> <code>down_color</code> <code>str</code> <p>Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).</p> <code>wick_visible</code> <code>bool</code> <p>Whether wicks are visible. Defaults to True.</p> <code>border_visible</code> <code>bool</code> <p>Whether borders are visible. Defaults to False.</p> <code>border_color</code> <code>str</code> <p>General border color. Defaults to \"#378658\" (green).</p> <code>border_up_color</code> <code>str</code> <p>Border color for bullish candles. Defaults to \"#26a69a\".</p> <code>border_down_color</code> <code>str</code> <p>Border color for bearish candles. Defaults to \"#ef5350\".</p> <code>wick_color</code> <code>str</code> <p>General wick color. Defaults to \"#737375\" (gray).</p> <code>wick_up_color</code> <code>str</code> <p>Wick color for bullish candles. Defaults to \"#26a69a\".</p> <code>wick_down_color</code> <code>str</code> <p>Wick color for bearish candles. Defaults to \"#ef5350\".</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (CandlestickData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data\ndata = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n]\n\n# Create candlestick series with styling\nseries = (\n    CandlestickSeries(data=data)\n    .set_up_color(\"#4CAF50\")\n    .set_down_color(\"#F44336\")\n    .set_border_visible(True)\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. CandlestickData: Data class for candlestick chart data points.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/candlestick.py</code> <pre><code>@chainable_property(\"up_color\", str, validator=\"color\")\n@chainable_property(\"down_color\", str, validator=\"color\")\n@chainable_property(\"wick_visible\", bool)\n@chainable_property(\"border_visible\", bool)\n@chainable_property(\"border_color\", str, validator=\"color\")\n@chainable_property(\"border_up_color\", str, validator=\"color\")\n@chainable_property(\"border_down_color\", str, validator=\"color\")\n@chainable_property(\"wick_color\", str, validator=\"color\")\n@chainable_property(\"wick_up_color\", str, validator=\"color\")\n@chainable_property(\"wick_down_color\", str, validator=\"color\")\nclass CandlestickSeries(Series):\n    \"\"\"Candlestick series for creating OHLC candlestick charts in financial visualization.\n\n    This class represents a candlestick series that displays OHLC (Open, High, Low, Close)\n    data as candlestick bars. It's commonly used for price charts, technical analysis,\n    and comprehensive price action visualization in financial applications.\n\n    The CandlestickSeries extends the base Series class with candlestick-specific\n    functionality and supports extensive styling options through chainable properties.\n    It provides comprehensive color customization for bullish/bearish candles,\n    wicks, borders, and other visual elements.\n\n    Attributes:\n        data (Union[List[CandlestickData], pd.DataFrame, pd.Series]): Data points for\n            the candlestick series. Can be a list of CandlestickData objects,\n            a pandas DataFrame, or a pandas Series.\n        up_color (str): Color for bullish (up) candlesticks. Defaults to \"#26a69a\" (teal).\n        down_color (str): Color for bearish (down) candlesticks. Defaults to \"#ef5350\" (red).\n        wick_visible (bool): Whether wicks are visible. Defaults to True.\n        border_visible (bool): Whether borders are visible. Defaults to False.\n        border_color (str): General border color. Defaults to \"#378658\" (green).\n        border_up_color (str): Border color for bullish candles. Defaults to \"#26a69a\".\n        border_down_color (str): Border color for bearish candles. Defaults to \"#ef5350\".\n        wick_color (str): General wick color. Defaults to \"#737375\" (gray).\n        wick_up_color (str): Wick color for bullish candles. Defaults to \"#26a69a\".\n        wick_down_color (str): Wick color for bearish candles. Defaults to \"#ef5350\".\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (CandlestickData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import CandlestickSeries\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data\n        data = [\n            CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n            CandlestickData(\"2024-01-02\", 103, 108, 102, 106),\n        ]\n\n        # Create candlestick series with styling\n        series = (\n            CandlestickSeries(data=data)\n            .set_up_color(\"#4CAF50\")\n            .set_down_color(\"#F44336\")\n            .set_border_visible(True)\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        CandlestickData: Data class for candlestick chart data points.\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = CandlestickData\n\n    def __init__(\n        self,\n        data: Union[List[CandlestickData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a CandlestickSeries instance with data and configuration options.\n\n        This constructor initializes a candlestick series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes candlestick-specific styling properties with default values.\n\n        Args:\n            data: Data points for the candlestick series. Can be a list of\n                CandlestickData objects, a pandas DataFrame, or a pandas Series.\n                If DataFrame is provided, column_mapping can be used to specify\n                field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize candlestick-specific properties with default values\n        # Up color for bullish candles - defaults to teal\n        self._up_color = \"#26a69a\"\n        # Down color for bearish candles - defaults to red\n        self._down_color = \"#ef5350\"\n        # Wick visibility - defaults to True (wicks visible)\n        self._wick_visible = True\n        # Border visibility - defaults to False (borders hidden)\n        self._border_visible = False\n        # General border color - defaults to green\n        self._border_color = \"#378658\"\n        # Border color for bullish candles - defaults to teal\n        self._border_up_color = \"#26a69a\"\n        # Border color for bearish candles - defaults to red\n        self._border_down_color = \"#ef5350\"\n        # General wick color - defaults to gray\n        self._wick_color = \"#737375\"\n        # Wick color for bullish candles - defaults to teal\n        self._wick_up_color = \"#26a69a\"\n        # Wick color for bearish candles - defaults to red\n        self._wick_down_color = \"#ef5350\"\n\n    def _validate_color(self, color: str, property_name: str) -&gt; str:\n        \"\"\"Validate color format for candlestick styling properties.\n\n        This method validates that the provided color string is in a valid\n        format (hex or rgba) for use in candlestick styling. It's used\n        internally by the chainable property validators.\n\n        Args:\n            color: The color string to validate in hex or rgba format.\n            property_name: The name of the property being validated (for error messages).\n\n        Returns:\n            str: The validated color string.\n\n        Raises:\n            ColorValidationError: If the color format is invalid.\n        \"\"\"\n        # Validate color format using utility function\n        if not is_valid_color(color):\n            raise ColorValidationError(property_name, color)\n        return color\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for candlestick charts.\n        \"\"\"\n        return ChartType.CANDLESTICK\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick.CandlestickSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for candlestick charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/candlestick.html#streamlit_lightweight_charts_pro.charts.series.candlestick-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html","title":"streamlit_lightweight_charts_pro.charts.series.gradient_ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon","title":"gradient_ribbon","text":"<p>Gradient ribbon series for streamlit-lightweight-charts.</p> <p>This module provides the GradientRibbonSeries class for creating ribbon charts that display upper and lower bands with gradient fill areas based on gradient values.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries","title":"GradientRibbonSeries","text":"<p>Gradient ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with gradient fill areas based on gradient values. It extends RibbonSeries with gradient fill capabilities, allowing for dynamic color transitions based on data values.</p> <p>The GradientRibbonSeries supports various styling options including separate line styling for each band via LineOptions, and gradient color effects based on data values.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>gradient_start_color</code> <p>Starting color for gradient fills (minimum value).</p> <code>gradient_end_color</code> <p>Ending color for gradient fills (maximum value).</p> <code>normalize_gradients</code> <p>Whether to normalize gradient values to 0-1 range.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>@chainable_property(\"gradient_start_color\", str, validator=\"color\")\n@chainable_property(\"gradient_end_color\", str, validator=\"color\")\n@chainable_property(\"normalize_gradients\", bool)\nclass GradientRibbonSeries(RibbonSeries):\n    \"\"\"Gradient ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with gradient fill areas based on gradient values. It extends RibbonSeries\n    with gradient fill capabilities, allowing for dynamic color transitions\n    based on data values.\n\n    The GradientRibbonSeries supports various styling options including separate\n    line styling for each band via LineOptions, and gradient color effects based\n    on data values.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill_visible: Whether to display the fill area.\n        gradient_start_color: Starting color for gradient fills (minimum value).\n        gradient_end_color: Ending color for gradient fills (maximum value).\n        normalize_gradients: Whether to normalize gradient values to 0-1 range.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = GradientRibbonData\n\n    def __init__(\n        self,\n        data: Union[List[GradientRibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        gradient_start_color: str = \"#4CAF50\",\n        gradient_end_color: str = \"#F44336\",\n        normalize_gradients: bool = False,\n    ):\n        \"\"\"Initialize GradientRibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            gradient_start_color: Starting color for gradient fills\n            gradient_end_color: Ending color for gradient fills\n            normalize_gradients: Whether to normalize gradient values to 0-1 range\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize gradient-specific properties\n        self._gradient_start_color = gradient_start_color\n        self._gradient_end_color = gradient_end_color\n        self._normalize_gradients = normalize_gradients\n        self._gradient_bounds = None\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.GRADIENT_RIBBON\n\n    def _calculate_gradient_bounds(self) -&gt; None:\n        \"\"\"Calculate min/max gradient values for normalization with optimized performance.\"\"\"\n        if not self.data:\n            self._gradient_bounds = None\n            return\n\n        # Ultra-optimized single-pass min/max tracking\n        min_grad = float(\"inf\")\n        max_grad = float(\"-inf\")\n        valid_count = 0\n\n        # Single pass with inline min/max tracking - no list building\n        for data_point in self.data:\n            gradient = data_point.gradient\n            if (\n                gradient is not None\n                and isinstance(gradient, (int, float))\n                and not math.isnan(gradient)  # Not NaN\n                and gradient != float(\"inf\")\n                and gradient != float(\"-inf\")\n            ):\n                # Update min/max inline - no list operations\n                min_grad = min(min_grad, gradient)\n                max_grad = max(max_grad, gradient)\n                valid_count += 1\n                continue\n\n        # Set bounds efficiently - only if we found valid values\n        if valid_count &gt; 0:\n            self._gradient_bounds = (min_grad, max_grad)\n        else:\n            self._gradient_bounds = None\n\n    def asdict(self):\n        \"\"\"Override to include normalized gradients and exclude inherited fill property.\"\"\"\n        data_dict = super().asdict()\n\n        # Remove inherited fill property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n        data_dict.get(\"options\", {}).pop(\"fill\", None)\n\n        if self._normalize_gradients:\n            # Calculate bounds if not already calculated\n            if self._gradient_bounds is None:\n                self._calculate_gradient_bounds()\n\n            if self._gradient_bounds:\n                min_grad, max_grad = self._gradient_bounds\n                range_grad = max_grad - min_grad\n\n                if range_grad &gt; 0:  # Avoid division by zero\n                    # Ultra-optimized normalization with minimal function calls\n                    data_items = data_dict[\"data\"]\n                    range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                    for item in data_items:  # Remove enumerate for speed\n                        gradient = item.get(\"gradient\")\n                        if gradient is not None:\n                            # Since we already validated in _calculate_gradient_bounds,\n                            # we can trust the gradient values here\n                            try:\n                                # Use pre-calculated inverse for faster division\n                                normalized = (gradient - min_grad) * range_grad_inv\n                                # Fast clamping using conditional expression\n                                item[\"gradient\"] = (\n                                    0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                                )\n                            except (TypeError, ValueError):\n                                item.pop(\"gradient\", None)\n\n        return data_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon.GradientRibbonSeries.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Override to include normalized gradients and exclude inherited fill property.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.py</code> <pre><code>def asdict(self):\n    \"\"\"Override to include normalized gradients and exclude inherited fill property.\"\"\"\n    data_dict = super().asdict()\n\n    # Remove inherited fill property - gradient ribbon uses gradientStartColor/gradientEndColor instead\n    data_dict.get(\"options\", {}).pop(\"fill\", None)\n\n    if self._normalize_gradients:\n        # Calculate bounds if not already calculated\n        if self._gradient_bounds is None:\n            self._calculate_gradient_bounds()\n\n        if self._gradient_bounds:\n            min_grad, max_grad = self._gradient_bounds\n            range_grad = max_grad - min_grad\n\n            if range_grad &gt; 0:  # Avoid division by zero\n                # Ultra-optimized normalization with minimal function calls\n                data_items = data_dict[\"data\"]\n                range_grad_inv = 1.0 / range_grad  # Pre-calculate inverse\n\n                for item in data_items:  # Remove enumerate for speed\n                    gradient = item.get(\"gradient\")\n                    if gradient is not None:\n                        # Since we already validated in _calculate_gradient_bounds,\n                        # we can trust the gradient values here\n                        try:\n                            # Use pre-calculated inverse for faster division\n                            normalized = (gradient - min_grad) * range_grad_inv\n                            # Fast clamping using conditional expression\n                            item[\"gradient\"] = (\n                                0.0 if normalized &lt; 0.0 else (min(normalized, 1.0))\n                            )\n                        except (TypeError, ValueError):\n                            item.pop(\"gradient\", None)\n\n    return data_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/gradient_ribbon.html#streamlit_lightweight_charts_pro.charts.series.gradient_ribbon-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html","title":"streamlit_lightweight_charts_pro.charts.series.histogram","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram","title":"histogram","text":"<p>Histogram series for streamlit-lightweight-charts.</p> <p>This module provides the HistogramSeries class for creating histogram charts that display volume or other single-value data as bars. Histogram series are commonly used for volume overlays and technical indicators in financial visualization.</p> <p>The HistogramSeries class supports various styling options including bar color, base value, and animation effects. It also supports markers and price line configurations for comprehensive chart customization.</p> Key Features <ul> <li>Bar-based visualization for volume and single-value data</li> <li>Customizable bar colors and base values</li> <li>Volume series factory with bullish/bearish color coding</li> <li>DataFrame integration with automatic column mapping</li> <li>Marker and price line support for annotations</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries","title":"HistogramSeries","text":"<p>Histogram series for creating bar-based charts in financial visualization.</p> <p>This class represents a histogram series that displays data as bars. It's commonly used for volume overlays, technical indicators, and other bar-based visualizations where individual data points are represented as vertical bars.</p> <p>The HistogramSeries supports various styling options including bar color, base value, and animation effects. It also provides a factory method for creating volume series with automatic bullish/bearish color coding.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Union[List[Data], DataFrame, Series]</code> <p>Data points for the histogram series. Can be a list of Data objects, a pandas DataFrame, or a pandas Series.</p> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to \"#26a69a\" (teal). Can be hex or rgba format.</p> <code>base</code> <code>Union[int, float]</code> <p>Base value for the histogram bars. Defaults to 0. This determines the baseline from which bars extend.</p> <code>scale_margins</code> <code>dict</code> <p>Scale margins for the histogram series. Controls the top and bottom margins of the price scale. Defaults to {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.</p> <code>column_mapping</code> <code>Optional[dict]</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <code>bool</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <code>str</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <code>Optional[int]</code> <p>The pane index this series belongs to. Defaults to 0.</p> Class Attributes <p>DATA_CLASS: The data class type used for this series (HistogramData).</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\nfrom streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data\ndata = [\n    HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n    HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n]\n\n# Create histogram series with styling\nseries = HistogramSeries(data=data)\nseries.set_color(\"#2196F3\").set_base(0)\n\n# Create volume series with color coding\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n    up_color=\"rgba(38,166,154,0.5)\",\n    down_color=\"rgba(239,83,80,0.5)\",\n)\n</code></pre> See also <p>Series: Base class providing common series functionality. HistogramData: Data class for histogram chart data points. create_volume_series: Factory method for volume series with color coding.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"base\", (int, float))\n@chainable_property(\"scale_margins\", dict)\nclass HistogramSeries(Series):\n    \"\"\"Histogram series for creating bar-based charts in financial visualization.\n\n    This class represents a histogram series that displays data as bars.\n    It's commonly used for volume overlays, technical indicators, and other\n    bar-based visualizations where individual data points are represented\n    as vertical bars.\n\n    The HistogramSeries supports various styling options including bar color,\n    base value, and animation effects. It also provides a factory method\n    for creating volume series with automatic bullish/bearish color coding.\n\n    Attributes:\n        data (Union[List[Data], pd.DataFrame, pd.Series]): Data points for\n            the histogram series. Can be a list of Data objects, a pandas\n            DataFrame, or a pandas Series.\n        color (str): Color of the histogram bars. Defaults to \"#26a69a\" (teal).\n            Can be hex or rgba format.\n        base (Union[int, float]): Base value for the histogram bars. Defaults to 0.\n            This determines the baseline from which bars extend.\n        scale_margins (dict): Scale margins for the histogram series. Controls\n            the top and bottom margins of the price scale. Defaults to\n            {\"top\": 0.75, \"bottom\": 0}. Values are between 0 and 1.\n        column_mapping (Optional[dict]): Optional mapping for DataFrame columns\n            to data fields. Used when data is provided as a DataFrame.\n        visible (bool): Whether the series is visible on the chart. Defaults to True.\n        price_scale_id (str): ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id (Optional[int]): The pane index this series belongs to.\n            Defaults to 0.\n\n    Class Attributes:\n        DATA_CLASS: The data class type used for this series (HistogramData).\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import HistogramSeries\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data\n        data = [\n            HistogramData(\"2024-01-01\", 1000, color=\"#2196F3\"),\n            HistogramData(\"2024-01-02\", 1200, color=\"#2196F3\"),\n        ]\n\n        # Create histogram series with styling\n        series = HistogramSeries(data=data)\n        series.set_color(\"#2196F3\").set_base(0)\n\n        # Create volume series with color coding\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\"time\": \"datetime\", \"volume\": \"volume\"},\n            up_color=\"rgba(38,166,154,0.5)\",\n            down_color=\"rgba(239,83,80,0.5)\",\n        )\n        ```\n\n    See also:\n        Series: Base class providing common series functionality.\n        HistogramData: Data class for histogram chart data points.\n        create_volume_series: Factory method for volume series with color coding.\n    \"\"\"\n\n    DATA_CLASS = HistogramData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type identifier for this series.\n\n        Returns the ChartType enum value that identifies this series as a histogram chart.\n        This is used by the frontend to determine the appropriate rendering method.\n\n        Returns:\n            ChartType: The histogram chart type identifier.\n\n        Example:\n            ```python\n            series = HistogramSeries(data=data)\n            chart_type = series.chart_type  # ChartType.HISTOGRAM\n            ```\n        \"\"\"\n        return ChartType.HISTOGRAM\n\n    @classmethod\n    def create_volume_series(\n        cls,\n        data: Union[Sequence[OhlcvData], pd.DataFrame],\n        column_mapping: dict,\n        up_color: str = \"rgba(38,166,154,0.5)\",\n        down_color: str = \"rgba(239,83,80,0.5)\",\n        **kwargs,\n    ) -&gt; \"HistogramSeries\":\n        \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n        This factory method processes OHLCV data and creates a HistogramSeries\n        with volume bars colored based on whether the candle is bullish (close &gt;= open)\n        or bearish (close &lt; open). This provides visual context for volume analysis\n        by showing whether volume occurred during price increases or decreases.\n\n        Args:\n            data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n                or sequence of OhlcvData objects containing price and volume information.\n            column_mapping (dict): Mapping of required fields to column names.\n                Must include \"open\", \"close\", and \"volume\" mappings.\n            up_color (str, optional): Color for bullish candles (close &gt;= open).\n                Defaults to \"rgba(38,166,154,0.5)\" (teal with transparency).\n            down_color (str, optional): Color for bearish candles (close &lt; open).\n                Defaults to \"rgba(239,83,80,0.5)\" (red with transparency).\n            **kwargs: Additional arguments for HistogramSeries constructor.\n\n        Returns:\n            HistogramSeries: Configured histogram series for volume visualization\n                with color-coded bars based on price movement.\n\n        Raises:\n            ValueError: If required columns are missing from the data or column mapping.\n            KeyError: If column mapping doesn't include required fields.\n\n        Example:\n            ```python\n            # Create volume series with default colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping={\n                    \"time\": \"datetime\",\n                    \"open\": \"open_price\",\n                    \"close\": \"close_price\",\n                    \"volume\": \"trading_volume\",\n                },\n            )\n\n            # Create volume series with custom colors\n            volume_series = HistogramSeries.create_volume_series(\n                data=ohlcv_data,\n                column_mapping=column_mapping,\n                up_color=\"#4CAF50\",  # Green for bullish\n                down_color=\"#F44336\",  # Red for bearish\n            )\n            ```\n\n        Note:\n            The method automatically sets _last_value_visible to False for volume series\n            as it's typically used as an overlay rather than a main price series.\n        \"\"\"\n        if isinstance(data, pd.DataFrame):\n            # Use vectorized operations for efficient color assignment on large datasets\n            volume_dataframe = data.copy()\n\n            # Extract column names for open and close prices from mapping\n            open_col = column_mapping.get(\"open\", \"open\")\n            close_col = column_mapping.get(\"close\", \"close\")\n\n            # Use NumPy vectorized operations to assign colors based on price movement\n            # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n            colors = np.where(\n                volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n                up_color,\n                down_color,\n            )\n\n            # Add color column to DataFrame for histogram visualization\n            volume_dataframe[\"color\"] = colors\n\n            # Update column mapping to include color field and map volume to value\n            volume_col = column_mapping.get(\"volume\", \"volume\")\n            updated_mapping = column_mapping.copy()\n            updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n            updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n            # Use from_dataframe factory method to create the series\n            return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)\n\n        # Handle sequence of OhlcvData objects (non-DataFrame input)\n        if data is None:\n            # Return empty series for None data input\n            return cls(data=[])\n\n        # Process each item in the sequence individually\n        processed_data = []\n        for item in data:\n            if isinstance(item, dict):\n                # Determine color based on price movement for dictionary input\n                color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n                processed_item = item.copy()\n                processed_item[\"color\"] = color  # Add color information\n                processed_data.append(processed_item)\n            else:\n                # For OhlcvData objects, convert to dict and add color\n                item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n                color = (\n                    up_color\n                    if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                    else down_color\n                )\n                item_dict[\"color\"] = color  # Add color information\n                processed_data.append(item_dict)\n\n        # Convert processed data to DataFrame and use from_dataframe factory method\n        processed_dataframe = pd.DataFrame(processed_data)\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n        # Map volume to value for HistogramSeries compatibility\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping[\"value\"] = volume_col\n\n        # Create the volume series using the factory method\n        volume_series = cls.from_dataframe(\n            processed_dataframe,\n            column_mapping=updated_mapping,\n            **kwargs,\n        )\n\n        # Disable last value visibility for volume series (typically used as overlay)\n        volume_series._last_value_visible = False\n\n        return volume_series\n\n    def __init__(\n        self,\n        data: Union[List[Data], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize HistogramSeries with data and configuration options.\n\n        Creates a new histogram series instance with the provided data and configuration.\n        The constructor supports multiple data input types and initializes histogram-specific\n        styling properties with sensible defaults.\n\n        Args:\n            data (Union[List[Data], pd.DataFrame, pd.Series]): Histogram data as a list\n                of Data objects, pandas DataFrame, or pandas Series.\n            column_mapping (Optional[dict]): Optional column mapping for DataFrame/Series\n                input. Required when providing DataFrame or Series data.\n            visible (bool, optional): Whether the series is visible. Defaults to True.\n            price_scale_id (str, optional): ID of the price scale to attach to.\n                Defaults to \"right\".\n            pane_id (Optional[int], optional): The pane index this series belongs to.\n                Defaults to 0.\n\n        Raises:\n            ValueError: If data is not a valid type (list of Data, DataFrame, or Series).\n            ValueError: If DataFrame/Series is provided without column_mapping.\n            ValueError: If all items in data list are not instances of Data or its subclasses.\n\n        Example:\n            ```python\n            # Basic histogram series with list of data objects\n            data = [HistogramData(\"2024-01-01\", 1000)]\n            series = HistogramSeries(data=data)\n\n            # Histogram series with DataFrame\n            series = HistogramSeries(data=dataframe, column_mapping={\"time\": \"datetime\", \"value\": \"volume\"})\n\n            # Histogram series with Series\n            series = HistogramSeries(data=series_data, column_mapping={\"time\": \"index\", \"value\": \"values\"})\n            ```\n        \"\"\"\n        # Initialize base series functionality\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize histogram-specific properties with default values\n        self._color = \"#26a69a\"  # Default teal color for histogram bars\n        self._base = 0  # Default base value (baseline for bars)\n        self._scale_margins = {\"top\": 0.75, \"bottom\": 0}  # Default scale margins\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type identifier for this series.</p> <p>Returns the ChartType enum value that identifies this series as a histogram chart. This is used by the frontend to determine the appropriate rendering method.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The histogram chart type identifier.</p> Example <pre><code>series = HistogramSeries(data=data)\nchart_type = series.chart_type  # ChartType.HISTOGRAM\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram.HistogramSeries.create_volume_series","title":"create_volume_series  <code>classmethod</code>","text":"<pre><code>create_volume_series(\n    data: Union[Sequence[OhlcvData], DataFrame],\n    column_mapping: dict,\n    up_color: str = \"rgba(38,166,154,0.5)\",\n    down_color: str = \"rgba(239,83,80,0.5)\",\n    **kwargs\n) -&gt; HistogramSeries\n</code></pre> <p>Create a histogram series for volume data with colors based on price movement.</p> <p>This factory method processes OHLCV data and creates a HistogramSeries with volume bars colored based on whether the candle is bullish (close &gt;= open) or bearish (close &lt; open). This provides visual context for volume analysis by showing whether volume occurred during price increases or decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Sequence[OhlcvData], DataFrame]</code> <p>OHLCV data as DataFrame or sequence of OhlcvData objects containing price and volume information.</p> required <code>column_mapping</code> <code>dict</code> <p>Mapping of required fields to column names. Must include \"open\", \"close\", and \"volume\" mappings.</p> required <code>up_color</code> <code>str</code> <p>Color for bullish candles (close &gt;= open). Defaults to \"rgba(38,166,154,0.5)\" (teal with transparency).</p> <code>'rgba(38,166,154,0.5)'</code> <code>down_color</code> <code>str</code> <p>Color for bearish candles (close &lt; open). Defaults to \"rgba(239,83,80,0.5)\" (red with transparency).</p> <code>'rgba(239,83,80,0.5)'</code> <code>**kwargs</code> <p>Additional arguments for HistogramSeries constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HistogramSeries</code> <code>HistogramSeries</code> <p>Configured histogram series for volume visualization with color-coded bars based on price movement.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing from the data or column mapping.</p> <code>KeyError</code> <p>If column mapping doesn't include required fields.</p> Example <pre><code># Create volume series with default colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping={\n        \"time\": \"datetime\",\n        \"open\": \"open_price\",\n        \"close\": \"close_price\",\n        \"volume\": \"trading_volume\",\n    },\n)\n\n# Create volume series with custom colors\nvolume_series = HistogramSeries.create_volume_series(\n    data=ohlcv_data,\n    column_mapping=column_mapping,\n    up_color=\"#4CAF50\",  # Green for bullish\n    down_color=\"#F44336\",  # Red for bearish\n)\n</code></pre> Note <p>The method automatically sets _last_value_visible to False for volume series as it's typically used as an overlay rather than a main price series.</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/histogram.py</code> <pre><code>@classmethod\ndef create_volume_series(\n    cls,\n    data: Union[Sequence[OhlcvData], pd.DataFrame],\n    column_mapping: dict,\n    up_color: str = \"rgba(38,166,154,0.5)\",\n    down_color: str = \"rgba(239,83,80,0.5)\",\n    **kwargs,\n) -&gt; \"HistogramSeries\":\n    \"\"\"Create a histogram series for volume data with colors based on price movement.\n\n    This factory method processes OHLCV data and creates a HistogramSeries\n    with volume bars colored based on whether the candle is bullish (close &gt;= open)\n    or bearish (close &lt; open). This provides visual context for volume analysis\n    by showing whether volume occurred during price increases or decreases.\n\n    Args:\n        data (Union[Sequence[OhlcvData], pd.DataFrame]): OHLCV data as DataFrame\n            or sequence of OhlcvData objects containing price and volume information.\n        column_mapping (dict): Mapping of required fields to column names.\n            Must include \"open\", \"close\", and \"volume\" mappings.\n        up_color (str, optional): Color for bullish candles (close &gt;= open).\n            Defaults to \"rgba(38,166,154,0.5)\" (teal with transparency).\n        down_color (str, optional): Color for bearish candles (close &lt; open).\n            Defaults to \"rgba(239,83,80,0.5)\" (red with transparency).\n        **kwargs: Additional arguments for HistogramSeries constructor.\n\n    Returns:\n        HistogramSeries: Configured histogram series for volume visualization\n            with color-coded bars based on price movement.\n\n    Raises:\n        ValueError: If required columns are missing from the data or column mapping.\n        KeyError: If column mapping doesn't include required fields.\n\n    Example:\n        ```python\n        # Create volume series with default colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping={\n                \"time\": \"datetime\",\n                \"open\": \"open_price\",\n                \"close\": \"close_price\",\n                \"volume\": \"trading_volume\",\n            },\n        )\n\n        # Create volume series with custom colors\n        volume_series = HistogramSeries.create_volume_series(\n            data=ohlcv_data,\n            column_mapping=column_mapping,\n            up_color=\"#4CAF50\",  # Green for bullish\n            down_color=\"#F44336\",  # Red for bearish\n        )\n        ```\n\n    Note:\n        The method automatically sets _last_value_visible to False for volume series\n        as it's typically used as an overlay rather than a main price series.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # Use vectorized operations for efficient color assignment on large datasets\n        volume_dataframe = data.copy()\n\n        # Extract column names for open and close prices from mapping\n        open_col = column_mapping.get(\"open\", \"open\")\n        close_col = column_mapping.get(\"close\", \"close\")\n\n        # Use NumPy vectorized operations to assign colors based on price movement\n        # Bullish: close &gt;= open (green/up_color), Bearish: close &lt; open (red/down_color)\n        colors = np.where(\n            volume_dataframe[close_col] &gt;= volume_dataframe[open_col],\n            up_color,\n            down_color,\n        )\n\n        # Add color column to DataFrame for histogram visualization\n        volume_dataframe[\"color\"] = colors\n\n        # Update column mapping to include color field and map volume to value\n        volume_col = column_mapping.get(\"volume\", \"volume\")\n        updated_mapping = column_mapping.copy()\n        updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n        updated_mapping[\"value\"] = volume_col  # Map volume to value for HistogramSeries\n\n        # Use from_dataframe factory method to create the series\n        return cls.from_dataframe(volume_dataframe, column_mapping=updated_mapping, **kwargs)\n\n    # Handle sequence of OhlcvData objects (non-DataFrame input)\n    if data is None:\n        # Return empty series for None data input\n        return cls(data=[])\n\n    # Process each item in the sequence individually\n    processed_data = []\n    for item in data:\n        if isinstance(item, dict):\n            # Determine color based on price movement for dictionary input\n            color = up_color if item.get(\"close\", 0) &gt;= item.get(\"open\", 0) else down_color\n            processed_item = item.copy()\n            processed_item[\"color\"] = color  # Add color information\n            processed_data.append(processed_item)\n        else:\n            # For OhlcvData objects, convert to dict and add color\n            item_dict = item.asdict() if hasattr(item, \"asdict\") else item.__dict__\n            color = (\n                up_color\n                if item_dict.get(\"close\", 0) &gt;= item_dict.get(\"open\", 0)\n                else down_color\n            )\n            item_dict[\"color\"] = color  # Add color information\n            processed_data.append(item_dict)\n\n    # Convert processed data to DataFrame and use from_dataframe factory method\n    processed_dataframe = pd.DataFrame(processed_data)\n    updated_mapping = column_mapping.copy()\n    updated_mapping[\"color\"] = \"color\"  # Map color field to DataFrame column\n\n    # Map volume to value for HistogramSeries compatibility\n    volume_col = column_mapping.get(\"volume\", \"volume\")\n    updated_mapping[\"value\"] = volume_col\n\n    # Create the volume series using the factory method\n    volume_series = cls.from_dataframe(\n        processed_dataframe,\n        column_mapping=updated_mapping,\n        **kwargs,\n    )\n\n    # Disable last value visibility for volume series (typically used as overlay)\n    volume_series._last_value_visible = False\n\n    return volume_series\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/histogram.html#streamlit_lightweight_charts_pro.charts.series.histogram-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html","title":"streamlit_lightweight_charts_pro.charts.series.line","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line","title":"line","text":"<p>Line series for Streamlit Lightweight Charts Pro.</p> <p>This module provides the LineSeries class for creating line charts that display continuous data points connected by lines. Line series are commonly used for price charts, technical indicators, and trend analysis in financial visualization.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create line data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 102),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries","title":"LineSeries","text":"<p>Line series for creating continuous line charts in financial visualization.</p> <p>This class represents a line series that displays continuous data points connected by lines. It's commonly used for price charts, technical indicators, trend analysis, and other time-series data visualization in financial applications.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Data points for the line series. Can be a list of LineData objects, a pandas DataFrame, or a pandas Series.</p> <code>line_options</code> <p>LineOptions instance for all line style options including color, width, style, and animation effects.</p> <code>column_mapping</code> <p>Optional mapping for DataFrame columns to data fields. Used when data is provided as a DataFrame.</p> <code>visible</code> <p>Whether the series is visible on the chart. Defaults to True.</p> <code>price_scale_id</code> <p>ID of the price scale this series is attached to. Defaults to \"right\".</p> <code>pane_id</code> <p>The pane index this series belongs to. Defaults to 0.</p> Example <pre><code>from streamlit_lightweight_charts_pro.charts.series import LineSeries\nfrom streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data\ndata = [\n    LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n    LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n    LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n]\n\n# Create line series with styling\nseries = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n# Add to chart\nchart = Chart(series=series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/line.py</code> <pre><code>@chainable_property(\"line_options\", LineOptions, allow_none=True)\nclass LineSeries(Series):\n    \"\"\"Line series for creating continuous line charts in financial visualization.\n\n    This class represents a line series that displays continuous data points\n    connected by lines. It's commonly used for price charts, technical\n    indicators, trend analysis, and other time-series data visualization\n    in financial applications.\n\n    Attributes:\n        data: Data points for the line series. Can be a list of LineData\n            objects, a pandas DataFrame, or a pandas Series.\n        line_options: LineOptions instance for all line style options\n            including color, width, style, and animation effects.\n        column_mapping: Optional mapping for DataFrame columns to data fields.\n            Used when data is provided as a DataFrame.\n        visible: Whether the series is visible on the chart. Defaults to True.\n        price_scale_id: ID of the price scale this series is attached to.\n            Defaults to \"right\".\n        pane_id: The pane index this series belongs to.\n            Defaults to 0.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.charts.series import LineSeries\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data\n        data = [\n            LineData(\"2024-01-01\", 100.0, color=\"#2196F3\"),\n            LineData(\"2024-01-02\", 105.0, color=\"#2196F3\"),\n            LineData(\"2024-01-03\", 102.0, color=\"#2196F3\"),\n        ]\n\n        # Create line series with styling\n        series = LineSeries(data=data).line_options.set_color(\"#2196F3\").set_width(2)\n\n        # Add to chart\n        chart = Chart(series=series)\n        ```\n    \"\"\"\n\n    # Define the data class type for this series - used for validation and conversion\n    DATA_CLASS = LineData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: The chart type identifier for line charts.\n        \"\"\"\n        return ChartType.LINE\n\n    def __init__(\n        self,\n        data: Union[List[LineData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize a LineSeries instance with data and configuration options.\n\n        This constructor initializes a line series with the provided data and\n        configuration options. It sets up the base series functionality and\n        initializes line-specific styling options with default values.\n\n        Args:\n            data: Data points for the line series. Can be a list of LineData\n                objects, a pandas DataFrame, or a pandas Series. If DataFrame\n                is provided, column_mapping can be used to specify field mappings.\n            column_mapping: Optional dictionary mapping DataFrame column names\n                to data fields. Used when data is provided as a DataFrame.\n                If None, automatic column mapping will be attempted.\n            visible: Whether the series should be visible on the chart.\n                Defaults to True.\n            price_scale_id: ID of the price scale this series is attached to.\n                Defaults to \"right\" for right-side price scale.\n            pane_id: The pane index this series belongs to. Defaults to 0\n                for the main pane.\n\n        Raises:\n            DataItemsTypeError: If data items are not of the expected type.\n            DataFrameMissingColumnError: If required columns are missing from DataFrame.\n            ColumnMappingRequiredError: If column mapping is required but not provided.\n        \"\"\"\n        # Call parent constructor to initialize base series functionality\n        # This sets up data validation, column mapping processing, and basic properties\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n        # Initialize line_options with default styling configuration\n        # This creates an empty LineOptions instance for future customization\n        self._line_options = LineOptions()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line.LineSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>The chart type identifier for line charts.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/line.html#streamlit_lightweight_charts_pro.charts.series.line-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html","title":"streamlit_lightweight_charts_pro.charts.series.ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon","title":"ribbon","text":"<p>Ribbon series for streamlit-lightweight-charts.</p> <p>This module provides the RibbonSeries class for creating ribbon charts that display upper and lower bands with fill areas between them.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries","title":"RibbonSeries","text":"<p>Ribbon series for lightweight charts.</p> <p>This class represents a ribbon series that displays upper and lower bands with a fill area between them. It's commonly used for technical indicators like Bollinger Bands without the middle line, or other envelope indicators.</p> <p>The RibbonSeries supports various styling options including separate line styling for each band via LineOptions, fill colors, and gradient effects.</p> <p>Attributes:</p> Name Type Description <code>upper_line</code> <p>LineOptions instance for upper band styling.</p> <code>lower_line</code> <p>LineOptions instance for lower band styling.</p> <code>fill</code> <p>Fill color for the area between upper and lower bands.</p> <code>fill_visible</code> <p>Whether to display the fill area.</p> <code>price_lines</code> <p>List of PriceLineOptions for price lines (set after construction)</p> <code>price_format</code> <p>PriceFormatOptions for price formatting (set after construction)</p> <code>markers</code> <p>List of markers to display on this series (set after construction)</p> Source code in <code>streamlit_lightweight_charts_pro/charts/series/ribbon.py</code> <pre><code>@chainable_property(\"upper_line\", LineOptions, allow_none=True)\n@chainable_property(\"lower_line\", LineOptions, allow_none=True)\n@chainable_property(\"fill\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass RibbonSeries(Series):\n    \"\"\"Ribbon series for lightweight charts.\n\n    This class represents a ribbon series that displays upper and lower bands\n    with a fill area between them. It's commonly used for technical indicators\n    like Bollinger Bands without the middle line, or other envelope indicators.\n\n    The RibbonSeries supports various styling options including separate line\n    styling for each band via LineOptions, fill colors, and gradient effects.\n\n    Attributes:\n        upper_line: LineOptions instance for upper band styling.\n        lower_line: LineOptions instance for lower band styling.\n        fill: Fill color for the area between upper and lower bands.\n        fill_visible: Whether to display the fill area.\n        price_lines: List of PriceLineOptions for price lines (set after construction)\n        price_format: PriceFormatOptions for price formatting (set after construction)\n        markers: List of markers to display on this series (set after construction)\n    \"\"\"\n\n    DATA_CLASS = RibbonData\n\n    def __init__(\n        self,\n        data: Union[List[RibbonData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize RibbonSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize line options with default values\n        self._upper_line = LineOptions(color=\"#4CAF50\", line_width=2, line_style=\"solid\")\n        self._lower_line = LineOptions(color=\"#F44336\", line_width=2, line_style=\"solid\")\n\n        # Initialize fill color\n        self._fill = \"rgba(76, 175, 80, 0.1)\"\n\n        # Initialize fill visibility (default to True)\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\"\"\"\n        return ChartType.RIBBON\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon.RibbonSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/ribbon.html#streamlit_lightweight_charts_pro.charts.series.ribbon-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html","title":"streamlit_lightweight_charts_pro.charts.series.signal_series","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series","title":"signal_series","text":"<p>Signal series for background coloring in charts.</p> <p>This module provides the SignalSeries class for creating signal-based background coloring in financial charts. SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries","title":"SignalSeries","text":"<p>Signal series for background coloring in charts.</p> <p>SignalSeries creates vertical background bands that span the entire chart height, colored based on signal values at specific time points. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>The series takes signal data with binary or ternary values and maps them to background colors for specific time periods. The background bands appear across all chart panes and provide visual context for the data.</p> <p>Attributes:</p> Name Type Description <code>neutral_color</code> <p>Background color for signal value=0 (default: \"#ffffff\")</p> <code>signal_color</code> <p>Background color for signal value=1 (default: \"#ff0000\")</p> <code>alert_color</code> <p>Background color for signal value=2 (optional, default: None)</p> Example <pre><code># Create signal data\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n    SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n]\n\n# Create signal series\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n\n# Add to chart\nchart.add_series(signal_series)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/signal_series.py</code> <pre><code>@chainable_property(\"neutral_color\", str, validator=\"color\")\n@chainable_property(\"signal_color\", str, validator=\"color\")\n@chainable_property(\"alert_color\", str, validator=\"color\", allow_none=True)\nclass SignalSeries(Series):\n    \"\"\"Signal series for background coloring in charts.\n\n    SignalSeries creates vertical background bands that span the entire chart\n    height, colored based on signal values at specific time points. This is\n    commonly used in financial charts to highlight specific market conditions,\n    trading signals, or events.\n\n    The series takes signal data with binary or ternary values and maps them\n    to background colors for specific time periods. The background bands\n    appear across all chart panes and provide visual context for the data.\n\n    Attributes:\n        neutral_color: Background color for signal value=0 (default: \"#ffffff\")\n        signal_color: Background color for signal value=1 (default: \"#ff0000\")\n        alert_color: Background color for signal value=2 (optional, default: None)\n\n    Example:\n        ```python\n        # Create signal data\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level neutral_color\n            SignalData(\"2024-01-02\", 1),  # Uses series-level signal_color\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual color overrides series color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual color overrides series color\n        ]\n\n        # Create signal series\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n\n        # Add to chart\n        chart.add_series(signal_series)\n        ```\n    \"\"\"\n\n    DATA_CLASS = SignalData\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Get the chart type for this series.\n\n        Returns:\n            ChartType: ChartType.SIGNAL indicating this is a signal series.\n        \"\"\"\n        return ChartType.SIGNAL\n\n    def __init__(\n        self,\n        data: Union[List[SignalData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        neutral_color: str = \"#f0f0f0\",\n        signal_color: str = \"#ff0000\",\n        alert_color: Optional[str] = None,\n        visible: bool = True,\n        price_scale_id: str = \"right\",\n        pane_id: Optional[int] = 0,\n    ):\n        \"\"\"Initialize SignalSeries.\n\n        Args:\n            data: List of SignalData objects, DataFrame, or Series.\n            column_mapping: Optional column mapping for DataFrame input.\n            neutral_color: Background color for value=0. Defaults to \"#ffffff\".\n            signal_color: Background color for value=1. Defaults to \"#ff0000\".\n            alert_color: Background color for value=2. Defaults to None.\n            visible: Whether the signal series should be visible. Defaults to True.\n            price_scale_id: Price scale ID. Defaults to \"right\".\n            pane_id: Pane ID for multi-pane charts. Defaults to 0.\n\n        Raises:\n            ValueError: If data is empty or invalid.\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Initialize signal-specific properties with default values\n        self._neutral_color = neutral_color\n        self._signal_color = signal_color\n        self._alert_color = alert_color\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the signal series.\"\"\"\n        return (\n            f\"SignalSeries(data_points={len(self.data)}, neutral_color='{self._neutral_color}',\"\n            f\" signal_color='{self._signal_color}')\"\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series.SignalSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Get the chart type for this series.</p> <p>Returns:</p> Name Type Description <code>ChartType</code> <code>ChartType</code> <p>ChartType.SIGNAL indicating this is a signal series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/signal_series.html#streamlit_lightweight_charts_pro.charts.series.signal_series-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html","title":"streamlit_lightweight_charts_pro.charts.series.trend_fill","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill","title":"trend_fill","text":"<p>Trend fill series for streamlit-lightweight-charts.</p> <p>This module provides the TrendFillSeries class for creating trend-based fill charts that display fills between trend lines and base lines, similar to Supertrend indicators with dynamic trend-colored backgrounds.</p> <p>The series now properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries","title":"TrendFillSeries","text":"<p>Trend fill series for lightweight charts.</p> <p>This class represents a trend fill series that displays fills between trend lines and base lines. It's commonly used for technical indicators like Supertrend, where the fill area changes color based on trend direction.</p> <p>The series properly handles separate trend lines based on trend direction: - Uptrend (+1): Uses uptrend_line options for trend line above price - Downtrend (-1): Uses downtrend_line options for trend line below price</p> <p>Attributes:</p> Name Type Description <code>uptrend_line</code> <code>LineOptions</code> <p>Line options for the uptrend line.</p> <code>downtrend_line</code> <code>LineOptions</code> <p>Line options for the downtrend line.</p> <code>base_line</code> <code>LineOptions</code> <p>Line options for the base line.</p> <code>uptrend_fill_color</code> <code>str</code> <p>Color for uptrend fills (default: green).</p> <code>downtrend_fill_color</code> <code>str</code> <p>Color for downtrend fills (default: red).</p> <code>fill_visible</code> <code>bool</code> <p>Whether fills are visible.</p> Example <pre><code>from streamlit_lightweight_charts_pro import TrendFillSeries\nfrom streamlit_lightweight_charts_pro.data import TrendFillData\n\n# Create trend fill data\ndata = [\n    TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n    TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n]\n\n# Create series with custom colors\nseries = (TrendFillSeries(data)\n         .set_uptrend_fill_color(\"#00FF00\")\n         .set_downtrend_fill_color(\"#FF0000\"))\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/charts/series/trend_fill.py</code> <pre><code>@chainable_property(\"uptrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"downtrend_line\", LineOptions, allow_none=True)\n@chainable_property(\"base_line\", LineOptions, allow_none=True)\n@chainable_property(\"uptrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"downtrend_fill_color\", str, validator=\"color\")\n@chainable_property(\"fill_visible\", bool)\nclass TrendFillSeries(Series):\n    \"\"\"Trend fill series for lightweight charts.\n\n    This class represents a trend fill series that displays fills between\n    trend lines and base lines. It's commonly used for technical\n    indicators like Supertrend, where the fill area changes color based on\n    trend direction.\n\n    The series properly handles separate trend lines based on trend direction:\n    - Uptrend (+1): Uses uptrend_line options for trend line above price\n    - Downtrend (-1): Uses downtrend_line options for trend line below price\n\n    Attributes:\n        uptrend_line (LineOptions): Line options for the uptrend line.\n        downtrend_line (LineOptions): Line options for the downtrend line.\n        base_line (LineOptions): Line options for the base line.\n        uptrend_fill_color (str): Color for uptrend fills (default: green).\n        downtrend_fill_color (str): Color for downtrend fills (default: red).\n        fill_visible (bool): Whether fills are visible.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro import TrendFillSeries\n        from streamlit_lightweight_charts_pro.data import TrendFillData\n\n        # Create trend fill data\n        data = [\n            TrendFillData(time=\"2024-01-01\", trend=1.0, base=100.0, trend_value=105.0),\n            TrendFillData(time=\"2024-01-02\", trend=-1.0, base=102.0, trend_value=98.0),\n        ]\n\n        # Create series with custom colors\n        series = (TrendFillSeries(data)\n                 .set_uptrend_fill_color(\"#00FF00\")\n                 .set_downtrend_fill_color(\"#FF0000\"))\n        ```\n    \"\"\"\n\n    DATA_CLASS = TrendFillData\n\n    def __init__(\n        self,\n        data: Union[List[TrendFillData], pd.DataFrame, pd.Series],\n        column_mapping: Optional[dict] = None,\n        visible: bool = True,\n        price_scale_id: str = \"\",\n        pane_id: Optional[int] = 0,\n        uptrend_fill_color: str = \"#4CAF50\",\n        downtrend_fill_color: str = \"#F44336\",\n    ):\n        \"\"\"Initialize TrendFillSeries.\n\n        Args:\n            data: List of data points or DataFrame\n            column_mapping: Column mapping for DataFrame conversion\n            visible: Whether the series is visible\n            price_scale_id: ID of the price scale\n            pane_id: The pane index this series belongs to\n            uptrend_fill_color: Color for uptrend fills (green)\n            downtrend_fill_color: Color for downtrend fills (red)\n        \"\"\"\n        super().__init__(\n            data=data,\n            column_mapping=column_mapping,\n            visible=visible,\n            price_scale_id=price_scale_id,\n            pane_id=pane_id,\n        )\n\n        # Convert colors to rgba with default opacity\n        def _add_opacity(color: str, opacity: float = 0.3) -&gt; str:\n            if not color.startswith(\"#\"):\n                return color\n            r = int(color[1:3], 16)\n            g = int(color[3:5], 16)\n            b = int(color[5:7], 16)\n            return f\"rgba({r}, {g}, {b}, {opacity})\"\n\n        self._uptrend_fill_color = _add_opacity(uptrend_fill_color)\n        self._downtrend_fill_color = _add_opacity(downtrend_fill_color)\n\n        # Initialize line options for uptrend line, downtrend line, and base line\n        self._uptrend_line = LineOptions(\n            color=\"#4CAF50\",  # Green for uptrend\n            line_width=2,\n            line_style=LineStyle.SOLID,\n        )\n        self._downtrend_line = LineOptions(\n            color=\"#F44336\",  # Red for downtrend\n            line_width=2,\n            line_style=LineStyle.SOLID,\n        )\n        self._base_line = LineOptions(\n            color=\"#666666\",\n            line_width=1,\n            line_style=LineStyle.DOTTED,\n            line_visible=False,\n        )\n        self._fill_visible = True\n\n    @property\n    def chart_type(self) -&gt; ChartType:\n        \"\"\"Return the chart type for this series.\"\"\"\n        return ChartType.TREND_FILL\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill.TrendFillSeries.chart_type","title":"chart_type  <code>property</code>","text":"<pre><code>chart_type: ChartType\n</code></pre> <p>Return the chart type for this series.</p>"},{"location":"api/streamlit_lightweight_charts_pro/charts/series/trend_fill.html#streamlit_lightweight_charts_pro.charts.series.trend_fill-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html","title":"streamlit_lightweight_charts_pro.data.annotation","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation","title":"annotation","text":"<p>Annotation system for streamlit-lightweight-charts.</p> <p>This module provides a comprehensive annotation system for adding text, arrows, shapes, and other visual elements to charts. It includes classes for individual annotations, annotation layers for organization, and an annotation manager for coordinating multiple layers.</p> The annotation system supports <ul> <li>Multiple annotation types (text, arrow, shape, line, rectangle, circle)</li> <li>Annotation positioning (above, below, inline)</li> <li>Layer-based organization for grouping related annotations</li> <li>Visibility and opacity controls</li> <li>Method chaining for fluent API usage</li> </ul> Example <pre><code>from streamlit_lightweight_charts_pro.data.annotation import (\n    create_text_annotation,\n    create_arrow_annotation,\n    AnnotationManager,\n)\n\n# Create annotations\ntext_ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\narrow_ann = create_arrow_annotation(\"2024-01-02\", 105, \"Buy Signal\")\n\n# Use with annotation manager\nmanager = (\n    AnnotationManager()\n    .create_layer(\"events\")\n    .add_annotation(text_ann, \"events\")\n    .add_annotation(arrow_ann, \"events\")\n)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation","title":"Annotation","text":"<p>Represents a chart annotation.</p> <p>This class defines an annotation that can be displayed on charts to provide additional context, highlight important events, or add explanatory information. Annotations support various types, positions, and styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Annotation time (accepts pd.Timestamp, datetime, or string)</p> <code>price</code> <code>float</code> <p>Price level for the annotation</p> <code>text</code> <code>str</code> <p>Annotation text content</p> <code>annotation_type</code> <code>Union[AnnotationType, str]</code> <p>Type of annotation (text, arrow, shape, etc.)</p> <code>position</code> <code>Union[AnnotationPosition, str]</code> <p>Position of the annotation relative to the price level</p> <code>color</code> <code>str</code> <p>Primary color of the annotation</p> <code>background_color</code> <code>str</code> <p>Background color for text annotations</p> <code>font_size</code> <code>int</code> <p>Font size for text annotations</p> <code>font_weight</code> <code>str</code> <p>Font weight for text annotations</p> <code>text_color</code> <code>str</code> <p>Color of the text content</p> <code>border_color</code> <code>str</code> <p>Border color for shape annotations</p> <code>border_width</code> <code>int</code> <p>Border width for shape annotations</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the annotation (0.0 to 1.0)</p> <code>show_time</code> <code>bool</code> <p>Whether to show time in the annotation text</p> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip text for hover interactions</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class Annotation:\n    \"\"\"Represents a chart annotation.\n\n    This class defines an annotation that can be displayed on charts to\n    provide additional context, highlight important events, or add\n    explanatory information. Annotations support various types, positions,\n    and styling options.\n\n    Attributes:\n        time: Annotation time (accepts pd.Timestamp, datetime, or string)\n        price: Price level for the annotation\n        text: Annotation text content\n        annotation_type: Type of annotation (text, arrow, shape, etc.)\n        position: Position of the annotation relative to the price level\n        color: Primary color of the annotation\n        background_color: Background color for text annotations\n        font_size: Font size for text annotations\n        font_weight: Font weight for text annotations\n        text_color: Color of the text content\n        border_color: Border color for shape annotations\n        border_width: Border width for shape annotations\n        opacity: Overall opacity of the annotation (0.0 to 1.0)\n        show_time: Whether to show time in the annotation text\n        tooltip: Optional tooltip text for hover interactions\n    \"\"\"\n\n    time: Union[pd.Timestamp, datetime, str, int, float]\n    price: float\n    text: str\n    annotation_type: Union[AnnotationType, str] = AnnotationType.TEXT\n    position: Union[AnnotationPosition, str] = AnnotationPosition.ABOVE\n    color: str = \"#2196F3\"\n    background_color: str = \"rgba(255, 255, 255, 0.9)\"\n    font_size: int = 12\n    font_weight: str = \"normal\"\n    text_color: str = \"#000000\"\n    border_color: str = \"#CCCCCC\"\n    border_width: int = 1\n    opacity: float = 1.0\n    show_time: bool = False\n    tooltip: Optional[str] = None\n\n    def __init__(\n        self,\n        time: Union[pd.Timestamp, datetime, str, int, float],\n        price: float,\n        text: str,\n        annotation_type: Union[str, AnnotationType] = AnnotationType.TEXT,\n        position: Union[str, AnnotationPosition] = AnnotationPosition.ABOVE,\n        color: str = \"#2196F3\",\n        background_color: str = \"rgba(255, 255, 255, 0.9)\",\n        font_size: int = 12,\n        font_weight: str = \"normal\",\n        text_color: str = \"#000000\",\n        border_color: str = \"#CCCCCC\",\n        border_width: int = 1,\n        opacity: float = 1.0,\n        show_time: bool = False,\n        tooltip: Optional[str] = None,\n    ):\n        # Convert time to UTC timestamp for consistent storage\n        self._timestamp = to_utc_timestamp(time)\n\n        # Accept both str and Enum for annotation_type\n        if isinstance(annotation_type, str):\n            self.annotation_type = AnnotationType(annotation_type)\n        else:\n            self.annotation_type = annotation_type\n\n        # Accept both str and Enum for position\n        if isinstance(position, str):\n            self.position = AnnotationPosition(position)\n        else:\n            self.position = position\n\n        # Validate price value\n        if not isinstance(price, (int, float)):\n            raise TypeValidationError(\"price\", \"a number\")\n        self.price = price\n\n        # Validate text content\n        if not text:\n            raise ValueValidationError.required_field(\"text\")\n        self.text = text\n\n        # Validate opacity range\n        if opacity &lt; 0 or opacity &gt; 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n\n        # Validate font size\n        if font_size &lt;= 0:\n            raise ValueValidationError.positive_value(\"font_size\", font_size)\n        self.font_size = font_size\n\n        # Validate border width\n        if border_width &lt; 0:\n            raise ValueValidationError(\"border_width\", f\"must be non-negative, got {border_width}\")\n        self.border_width = border_width\n\n        self.color = color\n        self.background_color = background_color\n        self.font_weight = font_weight\n        self.text_color = text_color\n        self.border_color = border_color\n        self.show_time = show_time\n        self.tooltip = tooltip\n\n    @property\n    def timestamp(self) -&gt; Union[int, str]:\n        \"\"\"Get time as UTC timestamp.\n\n        Returns:\n            Union[int, str]: UTC timestamp as integer (seconds) or\n                date string if the original input was a date string.\n        \"\"\"\n        return self._timestamp\n\n    @property\n    def datetime_value(self) -&gt; pd.Timestamp:\n        \"\"\"Get time as pandas Timestamp.\n\n        Returns:\n            pd.Timestamp: Pandas Timestamp object representing the\n                annotation time.\n        \"\"\"\n        return pd.Timestamp(from_utc_timestamp(self._timestamp))\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert annotation to dictionary for serialization.\n\n        This method creates a dictionary representation of the annotation\n        suitable for JSON serialization or frontend consumption.\n\n        Returns:\n            Dict[str, Any]: Dictionary containing all annotation properties\n                in a format suitable for the frontend component.\n        \"\"\"\n        return {\n            ColumnNames.TIME: self.timestamp,\n            \"price\": self.price,\n            \"text\": self.text,\n            \"type\": self.annotation_type.value,\n            \"position\": self.position.value,\n            \"color\": self.color,\n            \"background_color\": self.background_color,\n            \"font_size\": self.font_size,\n            \"font_weight\": self.font_weight,\n            \"text_color\": self.text_color,\n            \"border_color\": self.border_color,\n            \"border_width\": self.border_width,\n            \"opacity\": self.opacity,\n            \"show_time\": self.show_time,\n            \"tooltip\": self.tooltip,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: Union[int, str]\n</code></pre> <p>Get time as UTC timestamp.</p> <p>Returns:</p> Type Description <code>Union[int, str]</code> <p>Union[int, str]: UTC timestamp as integer (seconds) or date string if the original input was a date string.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.datetime_value","title":"datetime_value  <code>property</code>","text":"<pre><code>datetime_value: Timestamp\n</code></pre> <p>Get time as pandas Timestamp.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: Pandas Timestamp object representing the annotation time.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.Annotation.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert annotation to dictionary for serialization.</p> <p>This method creates a dictionary representation of the annotation suitable for JSON serialization or frontend consumption.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing all annotation properties in a format suitable for the frontend component.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert annotation to dictionary for serialization.\n\n    This method creates a dictionary representation of the annotation\n    suitable for JSON serialization or frontend consumption.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing all annotation properties\n            in a format suitable for the frontend component.\n    \"\"\"\n    return {\n        ColumnNames.TIME: self.timestamp,\n        \"price\": self.price,\n        \"text\": self.text,\n        \"type\": self.annotation_type.value,\n        \"position\": self.position.value,\n        \"color\": self.color,\n        \"background_color\": self.background_color,\n        \"font_size\": self.font_size,\n        \"font_weight\": self.font_weight,\n        \"text_color\": self.text_color,\n        \"border_color\": self.border_color,\n        \"border_width\": self.border_width,\n        \"opacity\": self.opacity,\n        \"show_time\": self.show_time,\n        \"tooltip\": self.tooltip,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer","title":"AnnotationLayer  <code>dataclass</code>","text":"<p>Manages a layer of annotations for a chart.</p> <p>This class provides functionality for grouping related annotations together and applying bulk operations to them. Layers can be shown, hidden, or have their opacity adjusted as a group.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this layer</p> <code>annotations</code> <code>List[Annotation]</code> <p>List of annotation objects in this layer</p> <code>visible</code> <code>bool</code> <p>Whether this layer is currently visible</p> <code>opacity</code> <code>float</code> <p>Overall opacity of the layer (0.0 to 1.0)</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>@dataclass\nclass AnnotationLayer:\n    \"\"\"Manages a layer of annotations for a chart.\n\n    This class provides functionality for grouping related annotations\n    together and applying bulk operations to them. Layers can be shown,\n    hidden, or have their opacity adjusted as a group.\n\n    Attributes:\n        name: Unique name identifier for this layer\n        annotations: List of annotation objects in this layer\n        visible: Whether this layer is currently visible\n        opacity: Overall opacity of the layer (0.0 to 1.0)\n    \"\"\"\n\n    name: str\n    annotations: List[Annotation]\n    visible: bool = True\n    opacity: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"Validate annotation layer after initialization.\n\n        Raises:\n            ValueError: If layer name is empty or opacity is invalid.\n        \"\"\"\n        if not self.name:\n            raise ValueValidationError.required_field(\"layer name\")\n\n        if not 0 &lt;= self.opacity &lt;= 1:\n            raise ValueValidationError(\n                \"opacity\",\n                f\"must be between 0.0 and 1.0, got {self.opacity}\",\n            )\n\n    def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n        \"\"\"Add annotation to layer.\n\n        Adds a single annotation to this layer and returns self for\n        method chaining.\n\n        Args:\n            annotation: Annotation object to add to the layer.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.add_annotation(text_annotation)\n            ```\n        \"\"\"\n        self.annotations.append(annotation)\n        return self\n\n    def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n        \"\"\"Remove annotation by index.\n\n        Removes an annotation from the layer by its index position\n        and returns self for method chaining.\n\n        Args:\n            index: Index of the annotation to remove.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.remove_annotation(0)  # Remove first annotation\n            ```\n        \"\"\"\n        if 0 &lt;= index &lt; len(self.annotations):\n            self.annotations.pop(index)\n        return self\n\n    def clear_annotations(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Clear all annotations from layer.\n\n        Removes all annotations from this layer and returns self\n        for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.clear_annotations()\n            ```\n        \"\"\"\n        self.annotations.clear()\n        return self\n\n    def hide(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Hide the layer.\n\n        Makes this layer and all its annotations invisible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.hide()\n            ```\n        \"\"\"\n        self.visible = False\n        return self\n\n    def show(self) -&gt; \"AnnotationLayer\":\n        \"\"\"Show the layer.\n\n        Makes this layer and all its annotations visible and\n        returns self for method chaining.\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Example:\n            ```python\n            layer.show()\n            ```\n        \"\"\"\n        self.visible = True\n        return self\n\n    def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n        \"\"\"Set layer opacity.\n\n        Sets the overall opacity of this layer and returns self\n        for method chaining.\n\n        Args:\n            opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n        Returns:\n            AnnotationLayer: Self for method chaining.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n\n        Example:\n            ```python\n            layer.set_opacity(0.5)  # 50% opacity\n            ```\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n        self.opacity = opacity\n        return self\n\n    def filter_by_time_range(\n        self,\n        start_time: Union[pd.Timestamp, datetime, str, int, float],\n        end_time: Union[pd.Timestamp, datetime, str, int, float],\n    ) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by time range.\n\n        Returns a list of annotations that fall within the specified\n        time range.\n\n        Args:\n            start_time: Start of the time range in various formats.\n            end_time: End of the time range in various formats.\n\n        Returns:\n            List[Annotation]: List of annotations within the time range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n            ```\n        \"\"\"\n        start_ts = to_utc_timestamp(start_time)\n        end_ts = to_utc_timestamp(end_time)\n\n        return [\n            annotation\n            for annotation in self.annotations\n            if start_ts &lt;= annotation.timestamp &lt;= end_ts\n        ]\n\n    def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n        \"\"\"Filter annotations by price range.\n\n        Returns a list of annotations that fall within the specified\n        price range.\n\n        Args:\n            min_price: Minimum price value.\n            max_price: Maximum price value.\n\n        Returns:\n            List[Annotation]: List of annotations within the price range.\n\n        Example:\n            ```python\n            annotations = layer.filter_by_price_range(100.0, 200.0)\n            ```\n        \"\"\"\n        return [\n            annotation\n            for annotation in self.annotations\n            if min_price &lt;= annotation.price &lt;= max_price\n        ]\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert layer to dictionary for serialization.\n\n        Creates a dictionary representation of the layer including\n        its properties and all contained annotations.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the layer.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"visible\": self.visible,\n            \"opacity\": self.opacity,\n            \"annotations\": [annotation.asdict() for annotation in self.annotations],\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation: Annotation) -&gt; AnnotationLayer\n</code></pre> <p>Add annotation to layer.</p> <p>Adds a single annotation to this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add to the layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.add_annotation(text_annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(self, annotation: Annotation) -&gt; \"AnnotationLayer\":\n    \"\"\"Add annotation to layer.\n\n    Adds a single annotation to this layer and returns self for\n    method chaining.\n\n    Args:\n        annotation: Annotation object to add to the layer.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.add_annotation(text_annotation)\n        ```\n    \"\"\"\n    self.annotations.append(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(index: int) -&gt; AnnotationLayer\n</code></pre> <p>Remove annotation by index.</p> <p>Removes an annotation from the layer by its index position and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the annotation to remove.</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.remove_annotation(0)  # Remove first annotation\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_annotation(self, index: int) -&gt; \"AnnotationLayer\":\n    \"\"\"Remove annotation by index.\n\n    Removes an annotation from the layer by its index position\n    and returns self for method chaining.\n\n    Args:\n        index: Index of the annotation to remove.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.remove_annotation(0)  # Remove first annotation\n        ```\n    \"\"\"\n    if 0 &lt;= index &lt; len(self.annotations):\n        self.annotations.pop(index)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.clear_annotations","title":"clear_annotations","text":"<pre><code>clear_annotations() -&gt; AnnotationLayer\n</code></pre> <p>Clear all annotations from layer.</p> <p>Removes all annotations from this layer and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.clear_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_annotations(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Clear all annotations from layer.\n\n    Removes all annotations from this layer and returns self\n    for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.clear_annotations()\n        ```\n    \"\"\"\n    self.annotations.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.hide","title":"hide","text":"<pre><code>hide() -&gt; AnnotationLayer\n</code></pre> <p>Hide the layer.</p> <p>Makes this layer and all its annotations invisible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.hide()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Hide the layer.\n\n    Makes this layer and all its annotations invisible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.hide()\n        ```\n    \"\"\"\n    self.visible = False\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.show","title":"show","text":"<pre><code>show() -&gt; AnnotationLayer\n</code></pre> <p>Show the layer.</p> <p>Makes this layer and all its annotations visible and returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> Example <pre><code>layer.show()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show(self) -&gt; \"AnnotationLayer\":\n    \"\"\"Show the layer.\n\n    Makes this layer and all its annotations visible and\n    returns self for method chaining.\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Example:\n        ```python\n        layer.show()\n        ```\n    \"\"\"\n    self.visible = True\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.set_opacity","title":"set_opacity","text":"<pre><code>set_opacity(opacity: float) -&gt; AnnotationLayer\n</code></pre> <p>Set layer opacity.</p> <p>Sets the overall opacity of this layer and returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0.0 (transparent) and 1.0 (opaque).</p> required <p>Returns:</p> Name Type Description <code>AnnotationLayer</code> <code>AnnotationLayer</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opacity is not between 0 and 1.</p> Example <pre><code>layer.set_opacity(0.5)  # 50% opacity\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def set_opacity(self, opacity: float) -&gt; \"AnnotationLayer\":\n    \"\"\"Set layer opacity.\n\n    Sets the overall opacity of this layer and returns self\n    for method chaining.\n\n    Args:\n        opacity: Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n    Returns:\n        AnnotationLayer: Self for method chaining.\n\n    Raises:\n        ValueError: If opacity is not between 0 and 1.\n\n    Example:\n        ```python\n        layer.set_opacity(0.5)  # 50% opacity\n        ```\n    \"\"\"\n    if not 0 &lt;= opacity &lt;= 1:\n        raise ValueValidationError(\"opacity\", f\"must be between 0 and 1, got {opacity}\")\n    self.opacity = opacity\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.filter_by_time_range","title":"filter_by_time_range","text":"<pre><code>filter_by_time_range(\n    start_time: Union[Timestamp, datetime, str, int, float],\n    end_time: Union[Timestamp, datetime, str, int, float],\n) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by time range.</p> <p>Returns a list of annotations that fall within the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Start of the time range in various formats.</p> required <code>end_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>End of the time range in various formats.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the time range.</p> Example <pre><code>annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_time_range(\n    self,\n    start_time: Union[pd.Timestamp, datetime, str, int, float],\n    end_time: Union[pd.Timestamp, datetime, str, int, float],\n) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by time range.\n\n    Returns a list of annotations that fall within the specified\n    time range.\n\n    Args:\n        start_time: Start of the time range in various formats.\n        end_time: End of the time range in various formats.\n\n    Returns:\n        List[Annotation]: List of annotations within the time range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_time_range(\"2024-01-01\", \"2024-01-31\")\n        ```\n    \"\"\"\n    start_ts = to_utc_timestamp(start_time)\n    end_ts = to_utc_timestamp(end_time)\n\n    return [\n        annotation\n        for annotation in self.annotations\n        if start_ts &lt;= annotation.timestamp &lt;= end_ts\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.filter_by_price_range","title":"filter_by_price_range","text":"<pre><code>filter_by_price_range(\n    min_price: float, max_price: float\n) -&gt; List[Annotation]\n</code></pre> <p>Filter annotations by price range.</p> <p>Returns a list of annotations that fall within the specified price range.</p> <p>Parameters:</p> Name Type Description Default <code>min_price</code> <code>float</code> <p>Minimum price value.</p> required <code>max_price</code> <code>float</code> <p>Maximum price value.</p> required <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of annotations within the price range.</p> Example <pre><code>annotations = layer.filter_by_price_range(100.0, 200.0)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def filter_by_price_range(self, min_price: float, max_price: float) -&gt; List[Annotation]:\n    \"\"\"Filter annotations by price range.\n\n    Returns a list of annotations that fall within the specified\n    price range.\n\n    Args:\n        min_price: Minimum price value.\n        max_price: Maximum price value.\n\n    Returns:\n        List[Annotation]: List of annotations within the price range.\n\n    Example:\n        ```python\n        annotations = layer.filter_by_price_range(100.0, 200.0)\n        ```\n    \"\"\"\n    return [\n        annotation\n        for annotation in self.annotations\n        if min_price &lt;= annotation.price &lt;= max_price\n    ]\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationLayer.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert layer to dictionary for serialization.</p> <p>Creates a dictionary representation of the layer including its properties and all contained annotations.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the layer.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert layer to dictionary for serialization.\n\n    Creates a dictionary representation of the layer including\n    its properties and all contained annotations.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the layer.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"visible\": self.visible,\n        \"opacity\": self.opacity,\n        \"annotations\": [annotation.asdict() for annotation in self.annotations],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager","title":"AnnotationManager","text":"<p>Manages multiple annotation layers for a chart.</p> <p>This class provides a centralized way to manage multiple annotation layers, allowing for organization of annotations into logical groups. It supports creating, removing, and manipulating layers, as well as bulk operations across all layers.</p> <p>The AnnotationManager supports method chaining for fluent API usage and provides comprehensive layer management capabilities.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>Dict[str, AnnotationLayer]</code> <p>Dictionary mapping layer names to AnnotationLayer objects</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>class AnnotationManager:\n    \"\"\"Manages multiple annotation layers for a chart.\n\n    This class provides a centralized way to manage multiple annotation\n    layers, allowing for organization of annotations into logical groups.\n    It supports creating, removing, and manipulating layers, as well as\n    bulk operations across all layers.\n\n    The AnnotationManager supports method chaining for fluent API usage\n    and provides comprehensive layer management capabilities.\n\n    Attributes:\n        layers: Dictionary mapping layer names to AnnotationLayer objects\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the annotation manager.\n\n        Creates a new AnnotationManager with an empty layers dictionary.\n        \"\"\"\n        self.layers: Dict[str, AnnotationLayer] = {}\n\n    def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Create a new annotation layer.\n\n        Creates a new empty annotation layer with the specified name.\n        If a layer with that name already exists, returns self for method chaining.\n\n        Args:\n            name: Name for the new layer.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.create_layer(\"technical_analysis\")\n            ```\n        \"\"\"\n        if name not in self.layers:\n            layer = AnnotationLayer(name=name, annotations=[])\n            self.layers[name] = layer\n        return self\n\n    def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n        \"\"\"Get an annotation layer by name.\n\n        Args:\n            name: Name of the layer to retrieve.\n\n        Returns:\n            Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n        Example:\n            ```python\n            layer = manager.get_layer(\"events\")\n            if layer:\n                layer.add_annotation(annotation)\n            ```\n        \"\"\"\n        return self.layers.get(name)\n\n    def remove_layer(self, name: str) -&gt; bool:\n        \"\"\"Remove an annotation layer by name.\n\n        Removes the specified layer and all its annotations. Returns\n        True if the layer was found and removed, False otherwise.\n\n        Args:\n            name: Name of the layer to remove.\n\n        Returns:\n            bool: True if layer was removed, False if layer didn't exist.\n\n        Example:\n            ```python\n            success = manager.remove_layer(\"old_layer\")\n            if success:\n                logger.info(\"Layer removed successfully\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            del self.layers[name]\n            return True\n        return False\n\n    def clear_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotation layers.\n\n        Removes all layers and their annotations. Returns self for\n        method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_all_layers()\n            ```\n        \"\"\"\n        self.layers.clear()\n        return self\n\n    def add_annotation(\n        self,\n        annotation: Annotation,\n        layer_name: str = \"default\",\n    ) -&gt; \"AnnotationManager\":\n        \"\"\"Add annotation to a specific layer.\n\n        Adds an annotation to the specified layer. If the layer doesn't exist,\n        it will be created automatically. Returns self for method chaining.\n\n        Args:\n            annotation: Annotation object to add.\n            layer_name: Name of the layer to add the annotation to.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.add_annotation(text_annotation, \"events\")\n            ```\n        \"\"\"\n        if layer_name not in self.layers:\n            self.create_layer(layer_name)\n\n        self.layers[layer_name].add_annotation(annotation)\n        return self\n\n    def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Hide a specific annotation layer.\n\n        Makes the specified layer and all its annotations invisible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to hide.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].hide()\n        return self\n\n    def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Show a specific annotation layer.\n\n        Makes the specified layer and all its annotations visible.\n        Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to show.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].show()\n        return self\n\n    def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n        \"\"\"Clear all annotations from a specific layer.\n\n        Removes all annotations from the specified layer while keeping\n        the layer itself. Returns self for method chaining.\n\n        Args:\n            name: Name of the layer to clear.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.clear_layer(\"events\")\n            ```\n        \"\"\"\n        if name in self.layers:\n            self.layers[name].clear_annotations()\n        return self\n\n    def get_all_annotations(self) -&gt; List[Annotation]:\n        \"\"\"Get all annotations from all layers.\n\n        Returns a flat list of all annotations from all layers,\n        regardless of layer visibility.\n\n        Returns:\n            List[Annotation]: List of all annotations across all layers.\n\n        Example:\n            ```python\n            all_annotations = manager.get_all_annotations()\n            ```\n        \"\"\"\n        all_annotations = []\n        for layer in self.layers.values():\n            all_annotations.extend(layer.annotations)\n        return all_annotations\n\n    def hide_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Hide all annotation layers.\n\n        Makes all layers and their annotations invisible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.hide_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.hide()\n        return self\n\n    def show_all_layers(self) -&gt; \"AnnotationManager\":\n        \"\"\"Show all annotation layers.\n\n        Makes all layers and their annotations visible. Returns\n        self for method chaining.\n\n        Returns:\n            AnnotationManager: Self for method chaining.\n\n        Example:\n            ```python\n            manager.show_all_layers()\n            ```\n        \"\"\"\n        for layer in self.layers.values():\n            layer.show()\n        return self\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert manager to dictionary for serialization.\n\n        Creates a dictionary representation of all layers and their\n        annotations suitable for serialization.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of all layers with\n                a \"layers\" wrapper containing layer names as keys.\n        \"\"\"\n        return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.create_layer","title":"create_layer","text":"<pre><code>create_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Create a new annotation layer.</p> <p>Creates a new empty annotation layer with the specified name. If a layer with that name already exists, returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new layer.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.create_layer(\"technical_analysis\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Create a new annotation layer.\n\n    Creates a new empty annotation layer with the specified name.\n    If a layer with that name already exists, returns self for method chaining.\n\n    Args:\n        name: Name for the new layer.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.create_layer(\"technical_analysis\")\n        ```\n    \"\"\"\n    if name not in self.layers:\n        layer = AnnotationLayer(name=name, annotations=[])\n        self.layers[name] = layer\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str) -&gt; Optional[AnnotationLayer]\n</code></pre> <p>Get an annotation layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[AnnotationLayer]</code> <p>Optional[AnnotationLayer]: The layer if found, None otherwise.</p> Example <pre><code>layer = manager.get_layer(\"events\")\nif layer:\n    layer.add_annotation(annotation)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_layer(self, name: str) -&gt; Optional[\"AnnotationLayer\"]:\n    \"\"\"Get an annotation layer by name.\n\n    Args:\n        name: Name of the layer to retrieve.\n\n    Returns:\n        Optional[AnnotationLayer]: The layer if found, None otherwise.\n\n    Example:\n        ```python\n        layer = manager.get_layer(\"events\")\n        if layer:\n            layer.add_annotation(annotation)\n        ```\n    \"\"\"\n    return self.layers.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.remove_layer","title":"remove_layer","text":"<pre><code>remove_layer(name: str) -&gt; bool\n</code></pre> <p>Remove an annotation layer by name.</p> <p>Removes the specified layer and all its annotations. Returns True if the layer was found and removed, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if layer was removed, False if layer didn't exist.</p> Example <pre><code>success = manager.remove_layer(\"old_layer\")\nif success:\n    logger.info(\"Layer removed successfully\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def remove_layer(self, name: str) -&gt; bool:\n    \"\"\"Remove an annotation layer by name.\n\n    Removes the specified layer and all its annotations. Returns\n    True if the layer was found and removed, False otherwise.\n\n    Args:\n        name: Name of the layer to remove.\n\n    Returns:\n        bool: True if layer was removed, False if layer didn't exist.\n\n    Example:\n        ```python\n        success = manager.remove_layer(\"old_layer\")\n        if success:\n            logger.info(\"Layer removed successfully\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        del self.layers[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.clear_all_layers","title":"clear_all_layers","text":"<pre><code>clear_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Clear all annotation layers.</p> <p>Removes all layers and their annotations. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotation layers.\n\n    Removes all layers and their annotations. Returns self for\n    method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_all_layers()\n        ```\n    \"\"\"\n    self.layers.clear()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(\n    annotation: Annotation, layer_name: str = \"default\"\n) -&gt; AnnotationManager\n</code></pre> <p>Add annotation to a specific layer.</p> <p>Adds an annotation to the specified layer. If the layer doesn't exist, it will be created automatically. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>Annotation object to add.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer to add the annotation to.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.add_annotation(text_annotation, \"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def add_annotation(\n    self,\n    annotation: Annotation,\n    layer_name: str = \"default\",\n) -&gt; \"AnnotationManager\":\n    \"\"\"Add annotation to a specific layer.\n\n    Adds an annotation to the specified layer. If the layer doesn't exist,\n    it will be created automatically. Returns self for method chaining.\n\n    Args:\n        annotation: Annotation object to add.\n        layer_name: Name of the layer to add the annotation to.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.add_annotation(text_annotation, \"events\")\n        ```\n    \"\"\"\n    if layer_name not in self.layers:\n        self.create_layer(layer_name)\n\n    self.layers[layer_name].add_annotation(annotation)\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.hide_layer","title":"hide_layer","text":"<pre><code>hide_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Hide a specific annotation layer.</p> <p>Makes the specified layer and all its annotations invisible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to hide.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Hide a specific annotation layer.\n\n    Makes the specified layer and all its annotations invisible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to hide.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.show_layer","title":"show_layer","text":"<pre><code>show_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Show a specific annotation layer.</p> <p>Makes the specified layer and all its annotations visible. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to show.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Show a specific annotation layer.\n\n    Makes the specified layer and all its annotations visible.\n    Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to show.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.clear_layer","title":"clear_layer","text":"<pre><code>clear_layer(name: str) -&gt; AnnotationManager\n</code></pre> <p>Clear all annotations from a specific layer.</p> <p>Removes all annotations from the specified layer while keeping the layer itself. Returns self for method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to clear.</p> required <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.clear_layer(\"events\")\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def clear_layer(self, name: str) -&gt; \"AnnotationManager\":\n    \"\"\"Clear all annotations from a specific layer.\n\n    Removes all annotations from the specified layer while keeping\n    the layer itself. Returns self for method chaining.\n\n    Args:\n        name: Name of the layer to clear.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.clear_layer(\"events\")\n        ```\n    \"\"\"\n    if name in self.layers:\n        self.layers[name].clear_annotations()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.get_all_annotations","title":"get_all_annotations","text":"<pre><code>get_all_annotations() -&gt; List[Annotation]\n</code></pre> <p>Get all annotations from all layers.</p> <p>Returns a flat list of all annotations from all layers, regardless of layer visibility.</p> <p>Returns:</p> Type Description <code>List[Annotation]</code> <p>List[Annotation]: List of all annotations across all layers.</p> Example <pre><code>all_annotations = manager.get_all_annotations()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def get_all_annotations(self) -&gt; List[Annotation]:\n    \"\"\"Get all annotations from all layers.\n\n    Returns a flat list of all annotations from all layers,\n    regardless of layer visibility.\n\n    Returns:\n        List[Annotation]: List of all annotations across all layers.\n\n    Example:\n        ```python\n        all_annotations = manager.get_all_annotations()\n        ```\n    \"\"\"\n    all_annotations = []\n    for layer in self.layers.values():\n        all_annotations.extend(layer.annotations)\n    return all_annotations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.hide_all_layers","title":"hide_all_layers","text":"<pre><code>hide_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Hide all annotation layers.</p> <p>Makes all layers and their annotations invisible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.hide_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def hide_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Hide all annotation layers.\n\n    Makes all layers and their annotations invisible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.hide_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.hide()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.show_all_layers","title":"show_all_layers","text":"<pre><code>show_all_layers() -&gt; AnnotationManager\n</code></pre> <p>Show all annotation layers.</p> <p>Makes all layers and their annotations visible. Returns self for method chaining.</p> <p>Returns:</p> Name Type Description <code>AnnotationManager</code> <code>AnnotationManager</code> <p>Self for method chaining.</p> Example <pre><code>manager.show_all_layers()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def show_all_layers(self) -&gt; \"AnnotationManager\":\n    \"\"\"Show all annotation layers.\n\n    Makes all layers and their annotations visible. Returns\n    self for method chaining.\n\n    Returns:\n        AnnotationManager: Self for method chaining.\n\n    Example:\n        ```python\n        manager.show_all_layers()\n        ```\n    \"\"\"\n    for layer in self.layers.values():\n        layer.show()\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.AnnotationManager.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert manager to dictionary for serialization.</p> <p>Creates a dictionary representation of all layers and their annotations suitable for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of all layers with a \"layers\" wrapper containing layer names as keys.</p> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert manager to dictionary for serialization.\n\n    Creates a dictionary representation of all layers and their\n    annotations suitable for serialization.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of all layers with\n            a \"layers\" wrapper containing layer names as keys.\n    \"\"\"\n    return {\"layers\": {layer_name: layer.asdict() for layer_name, layer in self.layers.items()}}\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_text_annotation","title":"create_text_annotation","text":"<pre><code>create_text_annotation(\n    time: Union[Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs\n) -&gt; Annotation\n</code></pre> <p>Create a text annotation.</p> <p>Convenience function for creating text annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display.</p> required <code>**kwargs</code> <p>Additional styling options (color, background_color, font_size, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured text annotation.</p> Example <pre><code># Basic text annotation\nann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n# With custom styling\nann = create_text_annotation(\n    \"2024-01-01\",\n    100,\n    \"Buy Signal\",\n    color=\"green\",\n    background_color=\"rgba(0, 255, 0, 0.2)\",\n    font_size=14,\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_text_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a text annotation.\n\n    Convenience function for creating text annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display.\n        **kwargs: Additional styling options (color, background_color,\n            font_size, position, etc.).\n\n    Returns:\n        Annotation: Configured text annotation.\n\n    Example:\n        ```python\n        # Basic text annotation\n        ann = create_text_annotation(\"2024-01-01\", 100, \"Important Event\")\n\n        # With custom styling\n        ann = create_text_annotation(\n            \"2024-01-01\",\n            100,\n            \"Buy Signal\",\n            color=\"green\",\n            background_color=\"rgba(0, 255, 0, 0.2)\",\n            font_size=14,\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.TEXT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_arrow_annotation","title":"create_arrow_annotation","text":"<pre><code>create_arrow_annotation(\n    time: Union[Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs\n) -&gt; Annotation\n</code></pre> <p>Create an arrow annotation.</p> <p>Convenience function for creating arrow annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the arrow.</p> required <code>**kwargs</code> <p>Additional styling options (color, position, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured arrow annotation.</p> Example <pre><code># Basic arrow annotation\nann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n# With custom styling\nann = create_arrow_annotation(\n    \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_arrow_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create an arrow annotation.\n\n    Convenience function for creating arrow annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the arrow.\n        **kwargs: Additional styling options (color, position, etc.).\n\n    Returns:\n        Annotation: Configured arrow annotation.\n\n    Example:\n        ```python\n        # Basic arrow annotation\n        ann = create_arrow_annotation(\"2024-01-01\", 100, \"Buy Signal\")\n\n        # With custom styling\n        ann = create_arrow_annotation(\n            \"2024-01-01\", 100, \"Sell Signal\", color=\"red\", position=AnnotationPosition.BELOW\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.ARROW,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/annotation.html#streamlit_lightweight_charts_pro.data.annotation.create_shape_annotation","title":"create_shape_annotation","text":"<pre><code>create_shape_annotation(\n    time: Union[Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs\n) -&gt; Annotation\n</code></pre> <p>Create a shape annotation.</p> <p>Convenience function for creating shape annotations with sensible defaults. Additional styling options can be passed as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Time for the annotation in various formats.</p> required <code>price</code> <code>float</code> <p>Price level for the annotation.</p> required <code>text</code> <code>str</code> <p>Text content to display with the shape.</p> required <code>**kwargs</code> <p>Additional styling options (color, border_color, border_width, etc.).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Annotation</code> <code>Annotation</code> <p>Configured shape annotation.</p> Example <pre><code># Basic shape annotation\nann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n# With custom styling\nann = create_shape_annotation(\n    \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/annotation.py</code> <pre><code>def create_shape_annotation(\n    time: Union[pd.Timestamp, datetime, str, int, float],\n    price: float,\n    text: str,\n    **kwargs,\n) -&gt; Annotation:\n    \"\"\"Create a shape annotation.\n\n    Convenience function for creating shape annotations with sensible\n    defaults. Additional styling options can be passed as keyword arguments.\n\n    Args:\n        time: Time for the annotation in various formats.\n        price: Price level for the annotation.\n        text: Text content to display with the shape.\n        **kwargs: Additional styling options (color, border_color,\n            border_width, etc.).\n\n    Returns:\n        Annotation: Configured shape annotation.\n\n    Example:\n        ```python\n        # Basic shape annotation\n        ann = create_shape_annotation(\"2024-01-01\", 100, \"Event\")\n\n        # With custom styling\n        ann = create_shape_annotation(\n            \"2024-01-01\", 100, \"Important\", color=\"yellow\", border_color=\"orange\", border_width=2\n        )\n        ```\n    \"\"\"\n    return Annotation(\n        time=time,\n        price=price,\n        text=text,\n        annotation_type=AnnotationType.SHAPE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html","title":"streamlit_lightweight_charts_pro.data.area_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data","title":"area_data","text":"<p>Area data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for area chart data points with optional color styling capabilities. The AreaData class extends SingleValueData with area-specific color validation and serialization features.</p> The module includes <ul> <li>AreaData: Data class for area chart data points with color styling</li> <li>Color validation for line, top, and bottom colors</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color fields with validation (line, top, bottom colors)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data.AreaData","title":"AreaData  <code>dataclass</code>","text":"<p>Data class for area chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color fields for area chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding area-specific color features for enhanced visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>line_color</code> <code>Optional[str]</code> <p>Color for the area line in hex or rgba format. If not provided, the line_color field is not serialized.</p> <code>top_color</code> <code>Optional[str]</code> <p>Color for the top of the area fill in hex or rgba format. If not provided, the top_color field is not serialized.</p> <code>bottom_color</code> <code>Optional[str]</code> <p>Color for the bottom of the area fill in hex or rgba format. If not provided, the bottom_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import AreaData\n\n# Create area data point with colors\ndata = AreaData(\n    time=\"2024-01-01T00:00:00\",\n    value=100.0,\n    line_color=\"#2196F3\",\n    top_color=\"rgba(33,150,243,0.3)\",\n    bottom_color=\"rgba(33,150,243,0.1)\",\n)\n\n# Create area data point without colors\ndata = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/area_data.py</code> <pre><code>@dataclass\nclass AreaData(SingleValueData):\n    \"\"\"Data class for area chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color fields for area chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding area-specific color features\n    for enhanced visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        line_color (Optional[str]): Color for the area line in hex or rgba format.\n            If not provided, the line_color field is not serialized.\n        top_color (Optional[str]): Color for the top of the area fill in hex or rgba format.\n            If not provided, the top_color field is not serialized.\n        bottom_color (Optional[str]): Color for the bottom of the area fill in hex or rgba format.\n            If not provided, the bottom_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing area-specific color optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import AreaData\n\n        # Create area data point with colors\n        data = AreaData(\n            time=\"2024-01-01T00:00:00\",\n            value=100.0,\n            line_color=\"#2196F3\",\n            top_color=\"rgba(33,150,243,0.3)\",\n            bottom_color=\"rgba(33,150,243,0.1)\",\n        )\n\n        # Create area data point without colors\n        data = AreaData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - area-specific color fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"line_color\", \"top_color\", \"bottom_color\"}\n\n    # Optional color field for the area line\n    line_color: Optional[str] = None\n    # Optional color field for the top of the area fill\n    top_color: Optional[str] = None\n    # Optional color field for the bottom of the area fill\n    bottom_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate color formats.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Validates all color format fields if colors are provided\n        3. Cleans up empty or whitespace-only color values\n\n        The method ensures that if colors are specified, they follow valid\n        hex or rgba format standards for frontend compatibility.\n\n        Raises:\n            ColorValidationError: If any color format is invalid.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Clean up and validate all area-specific color properties\n        for color_attr in [\"line_color\", \"top_color\", \"bottom_color\"]:\n            color_value = getattr(self, color_attr)\n            # Check if color is provided and not empty/whitespace\n            if color_value is not None and color_value.strip():\n                # Validate color format if color is provided\n                if not is_valid_color(color_value):\n                    raise ColorValidationError(color_attr, color_value)\n            else:\n                # Set to None if empty/whitespace to avoid serialization\n                setattr(self, color_attr, None)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/area_data.html#streamlit_lightweight_charts_pro.data.area_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html","title":"streamlit_lightweight_charts_pro.data.band","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band","title":"band","text":"<p>Band data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for band data points used in band charts such as Bollinger Bands and other envelope indicators.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/band.html#streamlit_lightweight_charts_pro.data.band.BandData","title":"BandData  <code>dataclass</code>","text":"<p>Data point for band charts (e.g., Bollinger Bands).</p> <p>This class represents a band data point with upper, middle, and lower values. It's used for band charts that show multiple lines simultaneously, such as Bollinger Bands, Keltner Channels, or other envelope indicators.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>float</code> <p>The upper band value.</p> <code>middle</code> <code>float</code> <p>The middle band value (usually the main line).</p> <code>lower</code> <code>float</code> <p>The lower band value.</p> Source code in <code>streamlit_lightweight_charts_pro/data/band.py</code> <pre><code>@dataclass\nclass BandData(Data):\n    \"\"\"Data point for band charts (e.g., Bollinger Bands).\n\n    This class represents a band data point with upper, middle, and lower values.\n    It's used for band charts that show multiple lines simultaneously,\n    such as Bollinger Bands, Keltner Channels, or other envelope indicators.\n\n    Attributes:\n        upper: The upper band value.\n        middle: The middle band value (usually the main line).\n        lower: The lower band value.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"middle\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    upper: float\n    middle: float\n    lower: float\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n        # Handle NaN in value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = 0.0\n        elif self.upper is None:\n            raise ValueValidationError(\"upper\", \"must not be None\")\n        if isinstance(self.middle, float) and math.isnan(self.middle):\n            self.middle = 0.0\n        elif self.middle is None:\n            raise ValueValidationError(\"middle\", \"must not be None\")\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = 0.0\n        elif self.lower is None:\n            raise ValueValidationError(\"lower\", \"must not be None\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html","title":"streamlit_lightweight_charts_pro.data.bar_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data","title":"bar_data","text":"<p>Bar chart data model for streamlit-lightweight-charts.</p> <p>This module provides the BarData class for representing individual bar chart data points with OHLC (Open, High, Low, Close) values and optional color customization.</p> <p>The BarData class extends OhlcData to provide bar-specific functionality while maintaining compatibility with the OHLC data structure used throughout the charting library.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BarData\n\n# Create a bar data point\nbar = BarData(\n    time=\"2024-01-01\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=103.0,\n    color=\"#4CAF50\"  # Optional: Green bar\n)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data.BarData","title":"BarData  <code>dataclass</code>","text":"<p>Data class for a single value (line/area/histogram) chart point.</p> <p>Inherits from SingleValueData and adds an optional color field.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point (hex or rgba).                    If not provided, not serialized.</p> <p>See also: SingleValueData</p> Note <ul> <li>Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/bar_data.py</code> <pre><code>@dataclass\nclass BarData(OhlcData):\n    \"\"\"Data class for a single value (line/area/histogram) chart point.\n\n    Inherits from SingleValueData and adds an optional color field.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        color (Optional[str]): Color for this data point (hex or rgba).\n                               If not provided, not serialized.\n\n    See also: SingleValueData\n\n    Note:\n        - Color should be a valid hex (e.g., #2196F3) or rgba string (e.g., rgba(33,150,243,1)).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate bar data.\n\n        This method is automatically called after the dataclass is initialized.\n        It validates the color field if provided.\n\n        Raises:\n            ValueValidationError: If the color format is invalid.\n        \"\"\"\n        # Call parent class post_init to validate OHLC data\n        super().__post_init__()\n\n        # Validate color if provided\n        # Empty strings are allowed (meaning use default color)\n        if self.color is not None and self.color != \"\" and not is_valid_color(self.color):\n            raise ValueValidationError(\"color\", \"Invalid color format\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/bar_data.html#streamlit_lightweight_charts_pro.data.bar_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html","title":"streamlit_lightweight_charts_pro.data.baseline_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data","title":"baseline_data","text":"<p>Baseline data for streamlit-lightweight-charts.</p> <p>This module provides the BaselineData class for creating baseline chart data points that support both top and bottom area styling with individual color controls.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data.BaselineData","title":"BaselineData  <code>dataclass</code>","text":"<p>Data class for a baseline chart point.</p> <p>Inherits from SingleValueData and adds optional color properties for baseline series. Baseline series display data with both top and bottom areas, each with their own styling options.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds.</p> <code>value</code> <code>float</code> <p>Data value. NaN is converted to 0.0.</p> <code>top_fill_color1</code> <code>Optional[str]</code> <p>Optional top area top fill color (hex or rgba).</p> <code>top_fill_color2</code> <code>Optional[str]</code> <p>Optional top area bottom fill color (hex or rgba).</p> <code>top_line_color</code> <code>Optional[str]</code> <p>Optional top area line color (hex or rgba).</p> <code>bottom_fill_color1</code> <code>Optional[str]</code> <p>Optional bottom area top fill color (hex or rgba).</p> <code>bottom_fill_color2</code> <code>Optional[str]</code> <p>Optional bottom area bottom fill color (hex or rgba).</p> <code>bottom_line_color</code> <code>Optional[str]</code> <p>Optional bottom area line color (hex or rgba).</p> <p>See also: SingleValueData</p> Note <ul> <li>All color properties should be valid hex (e.g., #2196F3) or rgba strings   (e.g., rgba(33,150,243,1)).</li> </ul> <pre><code>- If color properties are not provided, colors from series options will be used.\n - Baseline series display data with both positive and negative areas relative\n   to a baseline value.\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/baseline_data.py</code> <pre><code>@dataclass\nclass BaselineData(SingleValueData):\n    \"\"\"Data class for a baseline chart point.\n\n    Inherits from SingleValueData and adds optional color properties for baseline series.\n    Baseline series display data with both top and bottom areas, each with their own\n    styling options.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds.\n        value (float): Data value. NaN is converted to 0.0.\n        top_fill_color1 (Optional[str]): Optional top area top fill color (hex or rgba).\n        top_fill_color2 (Optional[str]): Optional top area bottom fill color (hex or rgba).\n        top_line_color (Optional[str]): Optional top area line color (hex or rgba).\n        bottom_fill_color1 (Optional[str]): Optional bottom area top fill color (hex or rgba).\n        bottom_fill_color2 (Optional[str]): Optional bottom area bottom fill color\n            (hex or rgba).\n        bottom_line_color (Optional[str]): Optional bottom area line color (hex or rgba).\n\n    See also: SingleValueData\n\n    Note:\n         - All color properties should be valid hex (e.g., #2196F3) or rgba strings\n           (e.g., rgba(33,150,243,1)).\n        - If color properties are not provided, colors from series options will be used.\n         - Baseline series display data with both positive and negative areas relative\n           to a baseline value.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"top_fill_color1\",\n        \"top_fill_color2\",\n        \"top_line_color\",\n        \"bottom_fill_color1\",\n        \"bottom_fill_color2\",\n        \"bottom_line_color\",\n    }\n\n    top_fill_color1: Optional[str] = None\n    top_fill_color2: Optional[str] = None\n    top_line_color: Optional[str] = None\n    bottom_fill_color1: Optional[str] = None\n    bottom_fill_color2: Optional[str] = None\n    bottom_line_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Validate color properties after initialization.\"\"\"\n        super().__post_init__()\n\n        # Validate all color properties if provided\n        color_properties = [\n            \"top_fill_color1\",\n            \"top_fill_color2\",\n            \"top_line_color\",\n            \"bottom_fill_color1\",\n            \"bottom_fill_color2\",\n            \"bottom_line_color\",\n        ]\n\n        for prop_name in color_properties:\n            color_value = getattr(self, prop_name)\n            if color_value is not None and color_value != \"\" and not is_valid_color(color_value):\n                raise ColorValidationError(prop_name, color_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/baseline_data.html#streamlit_lightweight_charts_pro.data.baseline_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html","title":"streamlit_lightweight_charts_pro.data.candlestick_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data","title":"candlestick_data","text":"<p>Candlestick data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for candlestick chart data points with optional color styling capabilities. The CandlestickData class extends OhlcData with color validation and serialization features for candlestick visualization.</p> The module includes <ul> <li>CandlestickData: Data class for candlestick chart data points with color styling</li> <li>Color validation for candlestick body, border, and wick colors</li> <li>OHLC relationship validation and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>Optional color fields with validation (body, border, wick colors)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data.CandlestickData","title":"CandlestickData  <code>dataclass</code>","text":"<p>Data class for candlestick chart data points with optional color styling.</p> <p>This class extends OhlcData to add optional color fields for candlestick styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for candlestick visualization.</p> <p>The class automatically handles time normalization, OHLC validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>color</code> <code>Optional[str]</code> <p>Color for the candlestick body in hex or rgba format. If not provided, the color field is not serialized.</p> <code>border_color</code> <code>Optional[str]</code> <p>Border color for the candlestick in hex or rgba format. If not provided, the border_color field is not serialized.</p> <code>wick_color</code> <code>Optional[str]</code> <p>Wick color for the candlestick in hex or rgba format. If not provided, the wick_color field is not serialized.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Set containing color-related optional columns     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import CandlestickData\n\n# Create candlestick data point with colors\ndata = CandlestickData(\n    time=\"2024-01-01T00:00:00\",\n    open=100.0,\n    high=105.0,\n    low=98.0,\n    close=102.0,\n    color=\"#4CAF50\",  # Green body for bullish candle\n    border_color=\"#2E7D32\",\n    wick_color=\"#1B5E20\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>ColorValidationError</code> <p>If any color format is invalid (not hex or rgba).</p> <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/candlestick_data.py</code> <pre><code>@dataclass\nclass CandlestickData(OhlcData):\n    \"\"\"Data class for candlestick chart data points with optional color styling.\n\n    This class extends OhlcData to add optional color fields for candlestick\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for candlestick visualization.\n\n    The class automatically handles time normalization, OHLC validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        color (Optional[str]): Color for the candlestick body in hex or rgba format.\n            If not provided, the color field is not serialized.\n        border_color (Optional[str]): Border color for the candlestick in hex or rgba format.\n            If not provided, the border_color field is not serialized.\n        wick_color (Optional[str]): Wick color for the candlestick in hex or rgba format.\n            If not provided, the wick_color field is not serialized.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Set containing color-related optional columns\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import CandlestickData\n\n        # Create candlestick data point with colors\n        data = CandlestickData(\n            time=\"2024-01-01T00:00:00\",\n            open=100.0,\n            high=105.0,\n            low=98.0,\n            close=102.0,\n            color=\"#4CAF50\",  # Green body for bullish candle\n            border_color=\"#2E7D32\",\n            wick_color=\"#1B5E20\",\n        )\n        ```\n\n    Raises:\n        ColorValidationError: If any color format is invalid (not hex or rgba).\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color fields are optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\", \"border_color\", \"wick_color\"}\n\n    # Optional color field for the candlestick body\n    color: Optional[str] = None\n    # Optional color field for the candlestick border\n    border_color: Optional[str] = None\n    # Optional color field for the candlestick wick\n    wick_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLC data and color formats.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate OHLC data and time\n        2. Validates all color format fields if colors are provided\n\n        The method ensures that all OHLC data points have valid relationships\n        and that any provided colors follow valid hex or rgba format standards\n        for frontend compatibility.\n\n        Raises:\n            ColorValidationError: If any color format is invalid.\n            ValueValidationError: If high &lt; low (invalid OHLC relationship).\n            NonNegativeValueError: If any OHLC value is negative.\n            RequiredFieldError: If any required OHLC field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to validate OHLC data and time normalization\n        super().__post_init__()\n\n        # Validate all color properties if provided - iterate through all color fields\n        color_properties = [\"color\", \"border_color\", \"wick_color\"]\n\n        for prop_name in color_properties:\n            color_value = getattr(self, prop_name)\n            # Check if color is provided and not empty, then validate format\n            if color_value is not None and color_value != \"\" and not is_valid_color(color_value):\n                raise ColorValidationError(prop_name, color_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/candlestick_data.html#streamlit_lightweight_charts_pro.data.candlestick_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html","title":"streamlit_lightweight_charts_pro.data.data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data","title":"data","text":"<p>Data classes and utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides the base data class and utility functions for time format conversion used throughout the library for representing financial data points. The Data class serves as the foundation for all chart data structures, providing standardized serialization and time normalization capabilities.</p> The module includes <ul> <li>Data: Abstract base class for all chart data points</li> <li>classproperty: Descriptor for creating class-level properties</li> <li>Column management utilities for DataFrame conversion</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>CamelCase serialization for frontend communication</li> <li>NaN handling and NumPy type conversion</li> <li>Column management for DataFrame operations</li> <li>Enum value extraction for serialization</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import Data\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass MyData(Data):\n    value: float\n\n\n# Create data point with automatic time normalization\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize to frontend format\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.classproperty","title":"classproperty","text":"<p>Descriptor to create class-level properties.</p> <p>This class provides a way to define properties that work at the class level rather than the instance level. It's used for accessing class attributes that may be computed or inherited from parent classes.</p> <p>This pattern is correct, but pylint may not recognize it and will warn about missing 'self'.</p> Example <pre><code>class MyClass:\n    @classproperty\n    def required_columns(cls):\n        return {\"time\", \"value\"}\n\n\n# Usage\ncolumns = MyClass.required_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>class classproperty(property):  # noqa: N801\n    \"\"\"Descriptor to create class-level properties.\n\n    This class provides a way to define properties that work at the class level\n    rather than the instance level. It's used for accessing class attributes\n    that may be computed or inherited from parent classes.\n\n    This pattern is correct, but pylint may not recognize it and will warn about missing 'self'.\n\n    Example:\n        ```python\n        class MyClass:\n            @classproperty\n            def required_columns(cls):\n                return {\"time\", \"value\"}\n\n\n        # Usage\n        columns = MyClass.required_columns\n        ```\n    \"\"\"\n\n    def __get__(self, obj, cls):\n        \"\"\"Get the class property value.\n\n        Args:\n            obj: The instance (unused for class properties).\n            cls: The class object.\n\n        Returns:\n            The computed class property value.\n        \"\"\"\n        return self.fget(cls)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data","title":"Data  <code>dataclass</code>","text":"<p>Abstract base class for chart data points.</p> <p>All chart data classes should inherit from Data. This class provides the foundation for all data structures in the library, handling time normalization, serialization, and column management for DataFrame operations.</p> <p>The class automatically normalizes time values to UNIX timestamps and provides standardized serialization to camelCase dictionaries for frontend communication. It also manages required and optional columns for DataFrame conversion operations.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion. OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.</p> See also <p>LineData: Single value data points for line charts. OhlcData: OHLC data points for candlestick charts. OhlcvData: OHLCV data points with volume information.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.data import Data\n\n\n@dataclass\nclass MyData(Data):\n    value: float\n\n\n# Create data point\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> Note <ul> <li>All imports must be at the top of the file unless justified.</li> <li>Use specific exceptions and lazy string formatting for logging.</li> <li>Time values are automatically normalized to seconds.</li> <li>NaN values are converted to 0.0 for frontend compatibility.</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@dataclass\nclass Data(SerializableMixin, ABC):\n    \"\"\"Abstract base class for chart data points.\n\n    All chart data classes should inherit from Data. This class provides the foundation\n    for all data structures in the library, handling time normalization, serialization,\n    and column management for DataFrame operations.\n\n    The class automatically normalizes time values to UNIX timestamps and provides\n    standardized serialization to camelCase dictionaries for frontend communication.\n    It also manages required and optional columns for DataFrame conversion operations.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set of required column names for DataFrame conversion.\n        OPTIONAL_COLUMNS (set): Set of optional column names for DataFrame conversion.\n\n    See also:\n        LineData: Single value data points for line charts.\n        OhlcData: OHLC data points for candlestick charts.\n        OhlcvData: OHLCV data points with volume information.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.data import Data\n\n\n        @dataclass\n        class MyData(Data):\n            value: float\n\n\n        # Create data point\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Note:\n        - All imports must be at the top of the file unless justified.\n        - Use specific exceptions and lazy string formatting for logging.\n        - Time values are automatically normalized to seconds.\n        - NaN values are converted to 0.0 for frontend compatibility.\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"time\"}  # Required columns for DataFrame conversion\n    OPTIONAL_COLUMNS: ClassVar[set] = set()  # Optional columns for DataFrame conversion\n\n    time: int\n\n    @classproperty\n    def required_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all required columns\n        defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All required columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n            class ChildData(ParentData):\n                REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n            # Returns {\"time\", \"value\", \"volume\"}\n            columns = ChildData.required_columns\n            ```\n        \"\"\"\n        required = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"REQUIRED_COLUMNS\"):\n                required |= base.REQUIRED_COLUMNS\n        return required\n\n    @classproperty\n    def optional_columns(self):  # pylint: disable=no-self-argument\n        \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n        This method traverses the class hierarchy to collect all optional columns\n        defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n        columns from parent classes are included in the result.\n\n        Returns:\n            set: All optional columns from the class hierarchy.\n\n        Example:\n            ```python\n            class ParentData(Data):\n                OPTIONAL_COLUMNS = {\"color\"}\n\n\n            class ChildData(ParentData):\n                OPTIONAL_COLUMNS = {\"size\"}\n\n\n            # Returns {\"color\", \"size\"}\n            columns = ChildData.optional_columns\n            ```\n        \"\"\"\n        optional = set()\n        for base in self.__mro__:  # pylint: disable=no-member\n            if hasattr(base, \"OPTIONAL_COLUMNS\"):\n                optional |= base.OPTIONAL_COLUMNS\n        return optional\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize time values.\n\n        This method is automatically called after the dataclass is initialized.\n        It normalizes the time value to ensure consistent format across all\n        data points in the library.\n\n        The normalization process converts various time formats (strings,\n        datetime objects, etc.) to UNIX timestamps in seconds.\n        \"\"\"\n        # Normalize time to ensure consistent format\n        self.time = normalize_time(self.time)\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n        Converts the data point to a dictionary format suitable for frontend\n        communication. This method handles various data type conversions and\n        ensures proper formatting for JavaScript consumption.\n\n        The method performs the following transformations:\n        - Converts field names from snake_case to camelCase\n        - Normalizes time values to UNIX timestamps\n        - Converts NaN values to 0.0 for frontend compatibility\n        - Converts NumPy scalar types to Python native types\n        - Extracts enum values using their .value property\n        - Skips None values and empty strings\n\n        Returns:\n            Dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            @dataclass\n            class MyData(Data):\n                value: float\n                color: str = \"red\"\n\n\n            data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n            result = data.asdict()\n            # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n            ```\n\n        Note:\n            - NaN values are converted to 0.0\n            - NumPy scalar types are converted to Python native types\n            - Enum values are extracted using their .value property\n            - Time column uses standardized ColumnNames.TIME.value\n        \"\"\"\n        # Use the inherited serialization from SerializableMixin\n        return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.required_columns","title":"required_columns","text":"<pre><code>required_columns()\n</code></pre> <p>Return the union of all REQUIRED_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all required columns defined in REQUIRED_COLUMNS class attributes. It ensures that all required columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All required columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\nclass ChildData(ParentData):\n    REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n# Returns {\"time\", \"value\", \"volume\"}\ncolumns = ChildData.required_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef required_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all REQUIRED_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all required columns\n    defined in REQUIRED_COLUMNS class attributes. It ensures that all required\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All required columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            REQUIRED_COLUMNS = {\"time\", \"value\"}\n\n\n        class ChildData(ParentData):\n            REQUIRED_COLUMNS = {\"time\", \"volume\"}\n\n\n        # Returns {\"time\", \"value\", \"volume\"}\n        columns = ChildData.required_columns\n        ```\n    \"\"\"\n    required = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"REQUIRED_COLUMNS\"):\n            required |= base.REQUIRED_COLUMNS\n    return required\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.optional_columns","title":"optional_columns","text":"<pre><code>optional_columns()\n</code></pre> <p>Return the union of all OPTIONAL_COLUMNS from the class and its parents.</p> <p>This method traverses the class hierarchy to collect all optional columns defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional columns from parent classes are included in the result.</p> <p>Returns:</p> Name Type Description <code>set</code> <p>All optional columns from the class hierarchy.</p> Example <pre><code>class ParentData(Data):\n    OPTIONAL_COLUMNS = {\"color\"}\n\n\nclass ChildData(ParentData):\n    OPTIONAL_COLUMNS = {\"size\"}\n\n\n# Returns {\"color\", \"size\"}\ncolumns = ChildData.optional_columns\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>@classproperty\ndef optional_columns(self):  # pylint: disable=no-self-argument\n    \"\"\"Return the union of all OPTIONAL_COLUMNS from the class and its parents.\n\n    This method traverses the class hierarchy to collect all optional columns\n    defined in OPTIONAL_COLUMNS class attributes. It ensures that all optional\n    columns from parent classes are included in the result.\n\n    Returns:\n        set: All optional columns from the class hierarchy.\n\n    Example:\n        ```python\n        class ParentData(Data):\n            OPTIONAL_COLUMNS = {\"color\"}\n\n\n        class ChildData(ParentData):\n            OPTIONAL_COLUMNS = {\"size\"}\n\n\n        # Returns {\"color\", \"size\"}\n        columns = ChildData.optional_columns\n        ```\n    \"\"\"\n    optional = set()\n    for base in self.__mro__:  # pylint: disable=no-member\n        if hasattr(base, \"OPTIONAL_COLUMNS\"):\n            optional |= base.OPTIONAL_COLUMNS\n    return optional\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data.Data.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the data class to a dict with camelCase keys for frontend.</p> <p>Converts the data point to a dictionary format suitable for frontend communication. This method handles various data type conversions and ensures proper formatting for JavaScript consumption.</p> <p>The method performs the following transformations: - Converts field names from snake_case to camelCase - Normalizes time values to UNIX timestamps - Converts NaN values to 0.0 for frontend compatibility - Converts NumPy scalar types to Python native types - Extracts enum values using their .value property - Skips None values and empty strings</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized data with camelCase keys ready for frontend consumption.</p> Example <pre><code>@dataclass\nclass MyData(Data):\n    value: float\n    color: str = \"red\"\n\n\ndata = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\nresult = data.asdict()\n# Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n</code></pre> Note <ul> <li>NaN values are converted to 0.0</li> <li>NumPy scalar types are converted to Python native types</li> <li>Enum values are extracted using their .value property</li> <li>Time column uses standardized ColumnNames.TIME.value</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/data.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the data class to a dict with camelCase keys for frontend.\n\n    Converts the data point to a dictionary format suitable for frontend\n    communication. This method handles various data type conversions and\n    ensures proper formatting for JavaScript consumption.\n\n    The method performs the following transformations:\n    - Converts field names from snake_case to camelCase\n    - Normalizes time values to UNIX timestamps\n    - Converts NaN values to 0.0 for frontend compatibility\n    - Converts NumPy scalar types to Python native types\n    - Extracts enum values using their .value property\n    - Skips None values and empty strings\n\n    Returns:\n        Dict[str, Any]: Serialized data with camelCase keys ready for\n            frontend consumption.\n\n    Example:\n        ```python\n        @dataclass\n        class MyData(Data):\n            value: float\n            color: str = \"red\"\n\n\n        data = MyData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"blue\")\n        result = data.asdict()\n        # Returns: {'time': 1704067200, 'value': 100.0, 'color': 'blue'}\n        ```\n\n    Note:\n        - NaN values are converted to 0.0\n        - NumPy scalar types are converted to Python native types\n        - Enum values are extracted using their .value property\n        - Time column uses standardized ColumnNames.TIME.value\n    \"\"\"\n    # Use the inherited serialization from SerializableMixin\n    return dict(self._serialize_to_dict())\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/data.html#streamlit_lightweight_charts_pro.data.data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html","title":"streamlit_lightweight_charts_pro.data.gradient_ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon","title":"gradient_ribbon","text":"<p>Gradient ribbon data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for gradient ribbon data points used in ribbon charts that display upper and lower bands with gradient fill areas.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/gradient_ribbon.html#streamlit_lightweight_charts_pro.data.gradient_ribbon.GradientRibbonData","title":"GradientRibbonData  <code>dataclass</code>","text":"<p>Data point for gradient ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional fill color override and gradient value for color calculation. It's used for ribbon charts that show upper and lower bands with gradient fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>Optional[float]</code> <p>The upper band value.</p> <code>lower</code> <code>Optional[float]</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional fill color override (highest priority).</p> <code>gradient</code> <code>Optional[float]</code> <p>Optional gradient value for color calculation (0.0 to 1.0 or raw value).</p> Source code in <code>streamlit_lightweight_charts_pro/data/gradient_ribbon.py</code> <pre><code>@dataclass\nclass GradientRibbonData(RibbonData):\n    \"\"\"Data point for gradient ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional fill color override and gradient value for color calculation.\n    It's used for ribbon charts that show upper and lower bands with gradient\n    fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional fill color override (highest priority).\n        gradient: Optional gradient value for color calculation (0.0 to 1.0 or raw value).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\", \"gradient\"}\n\n    upper: Optional[float] = None\n    lower: Optional[float] = None\n    fill: Optional[str] = None\n    gradient: Optional[float] = None\n\n    def __post_init__(self):\n        # Call parent's __post_init__ for time normalization and NaN handling\n        super().__post_init__()\n\n        # Validate gradient if provided\n        if self.gradient is not None:\n            if not isinstance(self.gradient, (int, float)):\n                raise ValueValidationError(\"gradient\", \"must be numeric\")\n            if math.isnan(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be NaN\")\n            if math.isinf(self.gradient):\n                raise ValueValidationError(\"gradient\", \"cannot be infinite\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html","title":"streamlit_lightweight_charts_pro.data.histogram_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data","title":"histogram_data","text":"<p>Histogram data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for histogram chart data points with optional color styling capabilities. The HistogramData class extends SingleValueData with color validation and serialization features.</p> The module includes <ul> <li>HistogramData: Data class for histogram chart data points with color styling</li> <li>Color validation for hex and rgba color formats</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color field with validation</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data.HistogramData","title":"HistogramData  <code>dataclass</code>","text":"<p>Data class for histogram chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for histogram chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features for histogram visualization.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import HistogramData\n\n# Create histogram data point with color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n# Create histogram data point without color\ndata = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. LineData: Similar data class for line charts. AreaData: Similar data class for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/histogram_data.py</code> <pre><code>@dataclass\nclass HistogramData(SingleValueData):\n    \"\"\"Data class for histogram chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for histogram chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features\n    for histogram visualization.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import HistogramData\n\n        # Create histogram data point with color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#FF5722\")\n\n        # Create histogram data point without color\n        data = HistogramData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        LineData: Similar data class for line charts.\n        AreaData: Similar data class for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this histogram data point\n    color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate color format.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Validates the color format if a color is provided\n\n        The method ensures that if a color is specified, it follows valid\n        hex or rgba format standards for frontend compatibility.\n\n        Raises:\n            ValueValidationError: If the color format is invalid.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Validate color format if color is provided and not empty\n        if self.color is not None and self.color != \"\" and not is_valid_color(self.color):\n            raise ValueValidationError(\"color\", \"Invalid color format\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/histogram_data.html#streamlit_lightweight_charts_pro.data.histogram_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html","title":"streamlit_lightweight_charts_pro.data.line_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data","title":"line_data","text":"<p>Line data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for line chart data points with optional color styling capabilities. The LineData class extends SingleValueData with color validation and serialization features.</p> The module includes <ul> <li>LineData: Data class for line chart data points with optional color</li> <li>Color validation for hex and rgba color formats</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Optional color field with validation</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>CamelCase serialization for frontend communication</li> <li>Color format validation (hex and rgba)</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data.LineData","title":"LineData  <code>dataclass</code>","text":"<p>Data class for line chart data points with optional color styling.</p> <p>This class extends SingleValueData to add optional color field for line chart styling. It provides validation for color formats and maintains all the functionality of the parent class while adding color-specific features.</p> <p>The class automatically handles time normalization, value validation, and color format validation for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> <code>color</code> <code>Optional[str]</code> <p>Color for this data point in hex or rgba format. If not provided, the color field is not serialized. Valid formats include hex colors (e.g., \"#2196F3\") and rgba colors (e.g., \"rgba(33,150,243,1)\").</p> Class Attributes <p>REQUIRED_COLUMNS (set): Empty set as all required columns are inherited     from SingleValueData (\"time\" and \"value\"). OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column     for DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import LineData\n\n# Create line data point with color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n# Create line data point without color\ndata = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If the color format is invalid (not hex or rgba).</p> See also <p>SingleValueData: Base class providing time normalization and value validation. AreaData: Similar data class for area charts. HistogramData: Similar data class for histogram charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/line_data.py</code> <pre><code>@dataclass\nclass LineData(SingleValueData):\n    \"\"\"Data class for line chart data points with optional color styling.\n\n    This class extends SingleValueData to add optional color field for line chart\n    styling. It provides validation for color formats and maintains all the\n    functionality of the parent class while adding color-specific features.\n\n    The class automatically handles time normalization, value validation, and\n    color format validation for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n        color (Optional[str]): Color for this data point in hex or rgba format.\n            If not provided, the color field is not serialized. Valid formats\n            include hex colors (e.g., \"#2196F3\") and rgba colors\n            (e.g., \"rgba(33,150,243,1)\").\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Empty set as all required columns are inherited\n            from SingleValueData (\"time\" and \"value\").\n        OPTIONAL_COLUMNS (set): Set containing \"color\" as the optional column\n            for DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import LineData\n\n        # Create line data point with color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0, color=\"#2196F3\")\n\n        # Create line data point without color\n        data = LineData(time=\"2024-01-01T00:00:00\", value=100.0)\n        ```\n\n    Raises:\n        ValueValidationError: If the color format is invalid (not hex or rgba).\n\n    See also:\n        SingleValueData: Base class providing time normalization and value validation.\n        AreaData: Similar data class for area charts.\n        HistogramData: Similar data class for histogram charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - none additional beyond\n    # what's inherited from SingleValueData (\"time\" and \"value\")\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n\n    # Define optional columns for DataFrame conversion - color is optional\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    # Optional color field for styling this data point\n    color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate color format.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate time and value\n        2. Validates the color format if a color is provided\n\n        The method ensures that if a color is specified, it follows valid\n        hex or rgba format standards for frontend compatibility.\n\n        Raises:\n            ValueValidationError: If the color format is invalid.\n        \"\"\"\n        # Call parent's __post_init__ to validate time and value fields\n        super().__post_init__()\n\n        # Validate color format if color is provided and not empty\n        if self.color is not None and self.color != \"\" and not is_valid_color(self.color):\n            raise ValueValidationError(\"color\", \"Invalid color format\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/line_data.html#streamlit_lightweight_charts_pro.data.line_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html","title":"streamlit_lightweight_charts_pro.data.marker","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker","title":"marker","text":"<p>Marker data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for chart markers used to highlight specific data points or events on charts, following the TradingView Lightweight Charts API. The module includes different types of markers for various positioning scenarios.</p> The module includes <ul> <li>MarkerBase: Base class for all chart markers</li> <li>PriceMarker: Marker positioned at exact price levels</li> <li>BarMarker: Marker positioned relative to bars</li> <li>Marker: Backward compatibility alias for BarMarker</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>Position validation for different marker types</li> <li>Shape and color customization</li> <li>Optional text and ID fields</li> <li>Size control for marker appearance</li> <li>Enum-based position and shape validation</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import Marker, PriceMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create bar marker\nbar_marker = Marker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#FF0000\",\n    text=\"Important Event\",\n)\n\n# Create price marker\nprice_marker = PriceMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.AT_PRICE_TOP,\n    shape=MarkerShape.ARROW_DOWN,\n    price=100.0,\n    color=\"#00FF00\",\n)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase","title":"MarkerBase  <code>dataclass</code>","text":"<p>Base chart marker definition for highlighting data points.</p> <p>This class represents the base marker that can be displayed on charts to highlight specific data points, events, or annotations. Based on the TradingView Lightweight Charts SeriesMarkerBase interface, it provides the foundation for all marker types in the library.</p> <p>The class automatically handles time normalization, position and shape validation, and provides a flexible interface for marker customization.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Where to position the marker relative to the data point. Can be a string or MarkerPosition enum. Defaults to ABOVE_BAR.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker. Can be a string or MarkerShape enum. Defaults to CIRCLE.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker. If not provided, the id field is not serialized.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker. If not provided, the text field is not serialized.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import MarkerBase\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create base marker\nmarker = MarkerBase(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#FF0000\",\n    text=\"Important Event\",\n    size=2,\n)\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. PriceMarker: Marker positioned at exact price levels. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass MarkerBase(Data):\n    \"\"\"Base chart marker definition for highlighting data points.\n\n    This class represents the base marker that can be displayed on charts to\n    highlight specific data points, events, or annotations. Based on the\n    TradingView Lightweight Charts SeriesMarkerBase interface, it provides\n    the foundation for all marker types in the library.\n\n    The class automatically handles time normalization, position and shape\n    validation, and provides a flexible interface for marker customization.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Where to position the marker\n            relative to the data point. Can be a string or MarkerPosition enum.\n            Defaults to ABOVE_BAR.\n        shape (Union[str, MarkerShape]): Shape of the marker. Can be a string\n            or MarkerShape enum. Defaults to CIRCLE.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n            If not provided, the id field is not serialized.\n        text (Optional[str]): Optional text to display with the marker.\n            If not provided, the text field is not serialized.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import MarkerBase\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create base marker\n        marker = MarkerBase(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#FF0000\",\n            text=\"Important Event\",\n            size=2,\n        )\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        PriceMarker: Marker positioned at exact price levels.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - position and shape are required\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - styling and metadata fields\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Position of the marker relative to the data point - defaults to above bar\n    position: Union[str, MarkerPosition] = MarkerPosition.ABOVE_BAR\n    # Shape of the marker - defaults to circle\n    shape: Union[str, MarkerShape] = MarkerShape.CIRCLE\n    # Color of the marker in hex format - defaults to blue\n    color: str = \"#2196F3\"\n    # Optional unique identifier for the marker\n    id: Optional[str] = None\n    # Optional text to display with the marker\n    text: Optional[str] = None\n    # Size of the marker in pixels - defaults to 1\n    size: int = 1\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize enums and validate data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Converts string position values to MarkerPosition enum\n        3. Converts string shape values to MarkerShape enum\n\n        The method ensures that all marker data points have properly normalized\n        enum values that can be safely serialized and transmitted to the frontend.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Convert position string to enum if it's provided as a string\n        if isinstance(self.position, str):\n            self.position = MarkerPosition(self.position)\n\n        # Convert shape string to enum if it's provided as a string\n        if isinstance(self.shape, str):\n            self.shape = MarkerShape(self.shape)\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for this marker type.\n\n        This method provides a base implementation that allows all positions.\n        Subclasses should override this method to implement position-specific\n        validation logic for their marker types.\n\n        Returns:\n            bool: True if position is valid, False otherwise. Base implementation\n                always returns True.\n        \"\"\"\n        # Base class allows all positions - subclasses will override with specific validation\n        return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.MarkerBase.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for this marker type.</p> <p>This method provides a base implementation that allows all positions. Subclasses should override this method to implement position-specific validation logic for their marker types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid, False otherwise. Base implementation always returns True.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for this marker type.\n\n    This method provides a base implementation that allows all positions.\n    Subclasses should override this method to implement position-specific\n    validation logic for their marker types.\n\n    Returns:\n        bool: True if position is valid, False otherwise. Base implementation\n            always returns True.\n    \"\"\"\n    # Base class allows all positions - subclasses will override with specific validation\n    return True\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker","title":"PriceMarker  <code>dataclass</code>","text":"<p>Price marker for exact Y-axis positioning on charts.</p> <p>This class represents a marker that can be positioned at exact price levels on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice interface, it provides precise positioning control for markers that need to be placed at specific price values.</p> <p>The class automatically handles time normalization, price validation, and position validation for price-specific positioning scenarios.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of AT_PRICE_TOP, AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>price</code> <code>float</code> <p>Price value for exact Y-axis positioning. Required field that must be greater than 0.0.</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"     as required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns for     DataFrame conversion operations.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import PriceMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create price marker at resistance level\nprice_marker = PriceMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.AT_PRICE_TOP,\n    shape=MarkerShape.ARROW_DOWN,\n    price=100.0,\n    color=\"#FF0000\",\n    text=\"Resistance Level\",\n)\n</code></pre> <p>Raises:</p> Type Description <code>RequiredFieldError</code> <p>If the price field is 0.0 or missing.</p> See also <p>MarkerBase: Base class providing marker functionality. BarMarker: Marker positioned relative to bars.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass PriceMarker(MarkerBase):\n    \"\"\"Price marker for exact Y-axis positioning on charts.\n\n    This class represents a marker that can be positioned at exact price levels\n    on the Y-axis. Based on the TradingView Lightweight Charts SeriesMarkerPrice\n    interface, it provides precise positioning control for markers that need\n    to be placed at specific price values.\n\n    The class automatically handles time normalization, price validation, and\n    position validation for price-specific positioning scenarios.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of AT_PRICE_TOP,\n            AT_PRICE_BOTTOM, or AT_PRICE_MIDDLE for price markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        price (float): Price value for exact Y-axis positioning. Required field\n            that must be greater than 0.0.\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\", \"shape\", and \"price\"\n            as required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns for\n            DataFrame conversion operations.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import PriceMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create price marker at resistance level\n        price_marker = PriceMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.AT_PRICE_TOP,\n            shape=MarkerShape.ARROW_DOWN,\n            price=100.0,\n            color=\"#FF0000\",\n            text=\"Resistance Level\",\n        )\n        ```\n\n    Raises:\n        RequiredFieldError: If the price field is 0.0 or missing.\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        BarMarker: Marker positioned relative to bars.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - price is additional requirement\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\", \"price\"}\n\n    # Define optional columns for DataFrame conversion - same as base class\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\"}\n\n    # Price value for exact Y-axis positioning - required for price markers\n    price: float = 0.0\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate price value.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize time and enums\n        2. Validates that the price field is provided and not 0.0\n\n        The method ensures that all price markers have valid price values\n        for proper Y-axis positioning.\n\n        Raises:\n            RequiredFieldError: If the price field is 0.0 or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize time and convert enums\n        super().__post_init__()\n\n        # Validate that price is provided and not 0.0 (required field)\n        if self.price == 0.0:\n            raise RequiredFieldError(\"Price\")\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for price markers.\n\n        This method validates that the position is one of the valid price-specific\n        positions that work with exact Y-axis positioning.\n\n        Returns:\n            bool: True if position is valid for price markers, False otherwise.\n        \"\"\"\n        # Define valid positions for price markers - must be price-specific positions\n        valid_positions = {\n            MarkerPosition.AT_PRICE_TOP,\n            MarkerPosition.AT_PRICE_BOTTOM,\n            MarkerPosition.AT_PRICE_MIDDLE,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.PriceMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for price markers.</p> <p>This method validates that the position is one of the valid price-specific positions that work with exact Y-axis positioning.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for price markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for price markers.\n\n    This method validates that the position is one of the valid price-specific\n    positions that work with exact Y-axis positioning.\n\n    Returns:\n        bool: True if position is valid for price markers, False otherwise.\n    \"\"\"\n    # Define valid positions for price markers - must be price-specific positions\n    valid_positions = {\n        MarkerPosition.AT_PRICE_TOP,\n        MarkerPosition.AT_PRICE_BOTTOM,\n        MarkerPosition.AT_PRICE_MIDDLE,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker","title":"BarMarker  <code>dataclass</code>","text":"<p>Bar marker for positioning relative to bars on charts.</p> <p>This class represents a marker that can be positioned relative to bars on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar interface, it provides flexible positioning options for markers that need to be placed relative to chart bars or candlesticks.</p> <p>The class automatically handles time normalization, position validation, and provides optional price positioning for enhanced flexibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the marker time. This value is automatically normalized during initialization.</p> <code>position</code> <code>Union[str, MarkerPosition]</code> <p>Must be one of ABOVE_BAR, BELOW_BAR, or IN_BAR for bar markers.</p> <code>shape</code> <code>Union[str, MarkerShape]</code> <p>Shape of the marker.</p> <code>color</code> <code>str</code> <p>Color of the marker in hex format. Defaults to \"#2196F3\" (blue).</p> <code>id</code> <code>Optional[str]</code> <p>Optional unique identifier for the marker.</p> <code>text</code> <code>Optional[str]</code> <p>Optional text to display with the marker.</p> <code>size</code> <code>int</code> <p>Size of the marker in pixels. Defaults to 1.</p> <code>price</code> <code>Optional[float]</code> <p>Optional price value for exact Y-axis positioning. If provided, overrides the relative bar positioning.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as     required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Set containing optional columns including     \"price\" for enhanced positioning flexibility.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import BarMarker\nfrom streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n# Create bar marker above the bar\nbar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.CIRCLE,\n    color=\"#00FF00\",\n    text=\"Buy Signal\",\n)\n\n# Create bar marker with exact price positioning\nprice_bar_marker = BarMarker(\n    time=\"2024-01-01T00:00:00\",\n    position=MarkerPosition.ABOVE_BAR,\n    shape=MarkerShape.ARROW_UP,\n    price=105.0,\n    color=\"#FF0000\",\n)\n</code></pre> See also <p>MarkerBase: Base class providing marker functionality. PriceMarker: Marker positioned at exact price levels. Marker: Backward compatibility alias for BarMarker.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>@dataclass\nclass BarMarker(MarkerBase):\n    \"\"\"Bar marker for positioning relative to bars on charts.\n\n    This class represents a marker that can be positioned relative to bars\n    on the chart. Based on the TradingView Lightweight Charts SeriesMarkerBar\n    interface, it provides flexible positioning options for markers that need\n    to be placed relative to chart bars or candlesticks.\n\n    The class automatically handles time normalization, position validation,\n    and provides optional price positioning for enhanced flexibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the marker time.\n            This value is automatically normalized during initialization.\n        position (Union[str, MarkerPosition]): Must be one of ABOVE_BAR,\n            BELOW_BAR, or IN_BAR for bar markers.\n        shape (Union[str, MarkerShape]): Shape of the marker.\n        color (str): Color of the marker in hex format. Defaults to \"#2196F3\" (blue).\n        id (Optional[str]): Optional unique identifier for the marker.\n        text (Optional[str]): Optional text to display with the marker.\n        size (int): Size of the marker in pixels. Defaults to 1.\n        price (Optional[float]): Optional price value for exact Y-axis positioning.\n            If provided, overrides the relative bar positioning.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"position\" and \"shape\" as\n            required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Set containing optional columns including\n            \"price\" for enhanced positioning flexibility.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import BarMarker\n        from streamlit_lightweight_charts_pro.type_definitions.enums import MarkerPosition, MarkerShape\n\n        # Create bar marker above the bar\n        bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.CIRCLE,\n            color=\"#00FF00\",\n            text=\"Buy Signal\",\n        )\n\n        # Create bar marker with exact price positioning\n        price_bar_marker = BarMarker(\n            time=\"2024-01-01T00:00:00\",\n            position=MarkerPosition.ABOVE_BAR,\n            shape=MarkerShape.ARROW_UP,\n            price=105.0,\n            color=\"#FF0000\",\n        )\n        ```\n\n    See also:\n        MarkerBase: Base class providing marker functionality.\n        PriceMarker: Marker positioned at exact price levels.\n        Marker: Backward compatibility alias for BarMarker.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - same as base class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"position\", \"shape\"}\n\n    # Define optional columns for DataFrame conversion - includes price for flexibility\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"text\", \"color\", \"size\", \"id\", \"price\"}\n\n    # Optional price value for exact Y-axis positioning - provides enhanced flexibility\n    price: Optional[float] = None\n\n    def validate_position(self) -&gt; bool:\n        \"\"\"Validate that the position is valid for bar markers.\n\n        This method validates that the position is one of the valid bar-relative\n        positions that work with bar and candlestick charts.\n\n        Returns:\n            bool: True if position is valid for bar markers, False otherwise.\n        \"\"\"\n        # Define valid positions for bar markers - must be bar-relative positions\n        valid_positions = {\n            MarkerPosition.ABOVE_BAR,\n            MarkerPosition.BELOW_BAR,\n            MarkerPosition.IN_BAR,\n        }\n        # Check if the current position is in the valid set\n        return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/marker.html#streamlit_lightweight_charts_pro.data.marker.BarMarker.validate_position","title":"validate_position","text":"<pre><code>validate_position() -&gt; bool\n</code></pre> <p>Validate that the position is valid for bar markers.</p> <p>This method validates that the position is one of the valid bar-relative positions that work with bar and candlestick charts.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if position is valid for bar markers, False otherwise.</p> Source code in <code>streamlit_lightweight_charts_pro/data/marker.py</code> <pre><code>def validate_position(self) -&gt; bool:\n    \"\"\"Validate that the position is valid for bar markers.\n\n    This method validates that the position is one of the valid bar-relative\n    positions that work with bar and candlestick charts.\n\n    Returns:\n        bool: True if position is valid for bar markers, False otherwise.\n    \"\"\"\n    # Define valid positions for bar markers - must be bar-relative positions\n    valid_positions = {\n        MarkerPosition.ABOVE_BAR,\n        MarkerPosition.BELOW_BAR,\n        MarkerPosition.IN_BAR,\n    }\n    # Check if the current position is in the valid set\n    return self.position in valid_positions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html","title":"streamlit_lightweight_charts_pro.data.ohlc_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data","title":"ohlc_data","text":"<p>OHLC data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for OHLC (Open, High, Low, Close) data points used in candlestick and bar charts. The OhlcData class extends the base Data class with OHLC-specific validation and serialization capabilities.</p> The module includes <ul> <li>OhlcData: Data class for OHLC data points</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>NaN handling and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high must be &gt;= low)</li> <li>Non-negative value validation for all price fields</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for all OHLC parameters</li> <li>CamelCase serialization for frontend communication</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import OhlcData\n\n# Create OHLC data point\ndata = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n# Serialize to frontend format\nserialized = data.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlc_data.html#streamlit_lightweight_charts_pro.data.ohlc_data.OhlcData","title":"OhlcData  <code>dataclass</code>","text":"<p>Data class for OHLC (Open, High, Low, Close) data points in financial charts.</p> <p>This class represents an OHLC data point commonly used in candlestick and bar charts for displaying financial market data. It extends the base Data class with OHLC-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships (high &gt;= low), ensures all values are non-negative, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"open\", \"high\", \"low\", and \"close\"     as required columns for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcData\n\n# Create OHLC data point\ndata = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship).</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLC field is None or missing.</p> See also <p>Data: Base class providing time normalization and serialization. OhlcvData: OHLC data with additional volume information. CandlestickData: Specialized OHLC data for candlestick charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlc_data.py</code> <pre><code>@dataclass\nclass OhlcData(Data):\n    \"\"\"Data class for OHLC (Open, High, Low, Close) data points in financial charts.\n\n    This class represents an OHLC data point commonly used in candlestick and bar charts\n    for displaying financial market data. It extends the base Data class with OHLC-specific\n    validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships (high &gt;= low), ensures all values\n    are non-negative, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"open\", \"high\", \"low\", and \"close\"\n            as required columns for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcData\n\n        # Create OHLC data point\n        data = OhlcData(time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship).\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLC field is None or missing.\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        OhlcvData: OHLC data with additional volume information.\n        CandlestickData: Specialized OHLC data for candlestick charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - all OHLC fields are required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"open\", \"high\", \"low\", \"close\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Opening price for the time period\n    open: float\n    # Highest price reached during the time period\n    high: float\n    # Lowest price reached during the time period\n    low: float\n    # Closing price for the time period\n    close: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLC data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates OHLC relationships (high must be &gt;= low)\n        3. Validates that all values are non-negative\n        4. Handles NaN values by converting them to 0.0\n        5. Validates that all required fields are present and not None\n\n        The method ensures that all OHLC data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If high &lt; low (invalid OHLC relationship).\n            NonNegativeValueError: If any OHLC value is negative.\n            RequiredFieldError: If any required OHLC field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Validate OHLC relationships - high must be greater than or equal to low\n        if self.high &lt; self.low:\n            raise ValueValidationError(\"high\", \"must be greater than or equal to low\")\n\n        # Validate that all OHLC values are non-negative (prices cannot be negative)\n        if self.open &lt; 0 or self.high &lt; 0 or self.low &lt; 0 or self.close &lt; 0:\n            raise ValueValidationError.non_negative_value(\"all OHLC values\")\n\n        # Handle NaN values in all OHLC fields - convert to 0.0 for frontend compatibility\n        for field_name in [\"open\", \"high\", \"low\", \"close\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - all OHLC fields are required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html","title":"streamlit_lightweight_charts_pro.data.ohlcv_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data","title":"ohlcv_data","text":"<p>OHLCV data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for OHLCV (Open, High, Low, Close, Volume) data points used in candlestick and bar charts with volume information. The OhlcvData class extends OhlcData with volume validation and serialization capabilities.</p> The module includes <ul> <li>OhlcvData: Data class for OHLCV data points with volume</li> <li>Volume validation and non-negative value checking</li> <li>OHLC relationship validation and value normalization</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>OHLC relationship validation (high &gt;= low, all values &gt;= 0)</li> <li>Volume validation (must be non-negative)</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for all OHLCV parameters</li> <li>CamelCase serialization for frontend communication</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize to frontend format\nserialized = data.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ohlcv_data.html#streamlit_lightweight_charts_pro.data.ohlcv_data.OhlcvData","title":"OhlcvData  <code>dataclass</code>","text":"<p>Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.</p> <p>This class represents an OHLCV data point commonly used in candlestick and bar charts for displaying financial market data with volume information. It extends the OhlcData class with volume-specific validation and serialization capabilities.</p> <p>The class automatically validates OHLC relationships, ensures all values are non-negative, validates volume data, and handles NaN values for frontend compatibility.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>open</code> <code>float</code> <p>Opening price for the time period. Must be non-negative.</p> <code>high</code> <code>float</code> <p>Highest price during the time period. Must be &gt;= low and non-negative.</p> <code>low</code> <code>float</code> <p>Lowest price during the time period. Must be &lt;= high and non-negative.</p> <code>close</code> <code>float</code> <p>Closing price for the time period. Must be non-negative.</p> <code>volume</code> <code>float</code> <p>Trading volume for the time period. Must be non-negative.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column     beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\"). OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import OhlcvData\n\n# Create OHLCV data point with volume\ndata = OhlcvData(\n    time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n)\n\n# Serialize for frontend\nserialized = data.asdict()\n</code></pre> <p>Raises:</p> Type Description <code>ValueValidationError</code> <p>If high &lt; low (invalid OHLC relationship) or volume &lt; 0.</p> <code>NonNegativeValueError</code> <p>If any OHLC value is negative.</p> <code>RequiredFieldError</code> <p>If any required OHLCV field is None or missing.</p> See also <p>OhlcData: Base class providing OHLC validation and serialization. CandlestickData: OHLC data with color styling capabilities. BarData: Similar data class for bar charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/ohlcv_data.py</code> <pre><code>@dataclass\nclass OhlcvData(OhlcData):\n    \"\"\"Data class for OHLCV (Open, High, Low, Close, Volume) data points in financial charts.\n\n    This class represents an OHLCV data point commonly used in candlestick and bar charts\n    for displaying financial market data with volume information. It extends the OhlcData\n    class with volume-specific validation and serialization capabilities.\n\n    The class automatically validates OHLC relationships, ensures all values are non-negative,\n    validates volume data, and handles NaN values for frontend compatibility.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        open (float): Opening price for the time period. Must be non-negative.\n        high (float): Highest price during the time period. Must be &gt;= low and non-negative.\n        low (float): Lowest price during the time period. Must be &lt;= high and non-negative.\n        close (float): Closing price for the time period. Must be non-negative.\n        volume (float): Trading volume for the time period. Must be non-negative.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"volume\" as an additional required column\n            beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\").\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import OhlcvData\n\n        # Create OHLCV data point with volume\n        data = OhlcvData(\n            time=\"2024-01-01T00:00:00\", open=100.0, high=105.0, low=98.0, close=102.0, volume=1000000\n        )\n\n        # Serialize for frontend\n        serialized = data.asdict()\n        ```\n\n    Raises:\n        ValueValidationError: If high &lt; low (invalid OHLC relationship) or volume &lt; 0.\n        NonNegativeValueError: If any OHLC value is negative.\n        RequiredFieldError: If any required OHLCV field is None or missing.\n\n    See also:\n        OhlcData: Base class providing OHLC validation and serialization.\n        CandlestickData: OHLC data with color styling capabilities.\n        BarData: Similar data class for bar charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - volume is additional requirement\n    # beyond what's inherited from OhlcData (\"time\", \"open\", \"high\", \"low\", \"close\")\n    REQUIRED_COLUMNS: ClassVar[set] = {\"volume\"}\n\n    # Define optional columns for DataFrame conversion - none for this data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # Trading volume for the time period - must be non-negative\n    volume: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate OHLCV data and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to validate OHLC data and time\n        2. Validates that volume is non-negative\n        3. Handles NaN values in the volume field\n        4. Validates that volume is not None\n\n        The method ensures that all OHLCV data points have valid relationships\n        and non-NaN values that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            ValueValidationError: If volume &lt; 0 (volume cannot be negative).\n            RequiredFieldError: If volume field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to validate OHLC data and time normalization\n        super().__post_init__()\n\n        # Validate that volume is non-negative (volume cannot be negative)\n        if self.volume &lt; 0:\n            raise ValueValidationError(\"volume\", \"must be non-negative\")\n\n        # Handle NaN values in volume field - convert to 0.0 for frontend compatibility\n        for field_name in [\"volume\"]:\n            value = getattr(self, field_name)\n            # Check if the value is a float and is NaN\n            if isinstance(value, float) and math.isnan(value):\n                setattr(self, field_name, 0.0)\n            # Validate that the field is not None - volume is required\n            elif value is None:\n                raise RequiredFieldError(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html","title":"streamlit_lightweight_charts_pro.data.ribbon","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon","title":"ribbon","text":"<p>Ribbon data classes for streamlit-lightweight-charts.</p> <p>This module provides data classes for ribbon data points used in ribbon charts that display upper and lower bands with fill areas.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/ribbon.html#streamlit_lightweight_charts_pro.data.ribbon.RibbonData","title":"RibbonData  <code>dataclass</code>","text":"<p>Data point for ribbon charts.</p> <p>This class represents a ribbon data point with upper and lower values, along with optional fill color. It's used for ribbon charts that show upper and lower bands with fill areas between them.</p> <p>Attributes:</p> Name Type Description <code>upper</code> <code>float</code> <p>The upper band value.</p> <code>lower</code> <code>float</code> <p>The lower band value.</p> <code>fill</code> <code>Optional[str]</code> <p>Optional color for the fill area (uses series default if not specified).</p> Source code in <code>streamlit_lightweight_charts_pro/data/ribbon.py</code> <pre><code>@dataclass\nclass RibbonData(Data):\n    \"\"\"Data point for ribbon charts.\n\n    This class represents a ribbon data point with upper and lower values,\n    along with optional fill color. It's used for ribbon charts\n    that show upper and lower bands with fill areas between them.\n\n    Attributes:\n        upper: The upper band value.\n        lower: The lower band value.\n        fill: Optional color for the fill area (uses series default if not specified).\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"upper\", \"lower\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"fill\"}\n\n    upper: float\n    lower: float\n    fill: Optional[str] = None\n\n    def __post_init__(self):\n        # Normalize time\n        super().__post_init__()  # Call parent's __post_init__\n\n        # Handle NaN in upper value\n        if isinstance(self.upper, float) and math.isnan(self.upper):\n            self.upper = None\n        # Allow None for missing data (no validation error)\n\n        # Handle NaN in lower value\n        if isinstance(self.lower, float) and math.isnan(self.lower):\n            self.lower = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html","title":"streamlit_lightweight_charts_pro.data.signal_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data","title":"signal_data","text":"<p>Signal data for background coloring in charts.</p> <p>This module provides the SignalData class for creating signal-based background coloring in financial charts. Signal data consists of time points with binary or ternary values that determine background colors for specific time periods.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data.SignalData","title":"SignalData  <code>dataclass</code>","text":"<p>Signal data point for background coloring.</p> <p>SignalData represents a single time point with a signal value that determines the background color for that time period. This is commonly used in financial charts to highlight specific market conditions, trading signals, or events.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>Union[str, datetime]</code> <p>Time point for the signal. Can be a string in ISO format (YYYY-MM-DD) or a datetime object.</p> <code>value</code> <code>int</code> <p>Signal value that determines background color. 0: First color (typically neutral/white) 1: Second color (typically highlight color) 2: Third color (optional, for ternary signals)</p> Example <pre><code># Create signal data for background coloring\nsignal_data = [\n    SignalData(\"2024-01-01\", 0),  # Uses series-level color for value=0\n    SignalData(\"2024-01-02\", 1),  # Uses series-level color for value=1\n    SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual light green color\n    SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual light red color\n]\n\n# Use with SignalSeries\nsignal_series = SignalSeries(\n    data=signal_data,\n    neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n    signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/signal_data.py</code> <pre><code>@dataclass\nclass SignalData(SingleValueData):\n    \"\"\"Signal data point for background coloring.\n\n    SignalData represents a single time point with a signal value that determines\n    the background color for that time period. This is commonly used in financial\n    charts to highlight specific market conditions, trading signals, or events.\n\n    Attributes:\n        time (Union[str, datetime]): Time point for the signal. Can be a string\n            in ISO format (YYYY-MM-DD) or a datetime object.\n        value (int): Signal value that determines background color.\n            0: First color (typically neutral/white)\n            1: Second color (typically highlight color)\n            2: Third color (optional, for ternary signals)\n\n    Example:\n        ```python\n        # Create signal data for background coloring\n        signal_data = [\n            SignalData(\"2024-01-01\", 0),  # Uses series-level color for value=0\n            SignalData(\"2024-01-02\", 1),  # Uses series-level color for value=1\n            SignalData(\"2024-01-03\", 0, color=\"#e8f5e8\"),  # Individual light green color\n            SignalData(\"2024-01-04\", 1, color=\"#ffe8e8\"),  # Individual light red color\n        ]\n\n        # Use with SignalSeries\n        signal_series = SignalSeries(\n            data=signal_data,\n            neutral_color=\"#ffffff\",  # White for value=0 (when no individual color)\n            signal_color=\"#ff0000\",  # Red for value=1 (when no individual color)\n        )\n        ```\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = set()\n    OPTIONAL_COLUMNS: ClassVar[set] = {\"color\"}\n\n    color: Optional[str] = None\n\n    def __post_init__(self):\n        super().__post_init__()\n        if self.color is not None and self.color != \"\" and not is_valid_color(self.color):\n            raise ValueValidationError(\"color\", \"Invalid color format\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/signal_data.html#streamlit_lightweight_charts_pro.data.signal_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html","title":"streamlit_lightweight_charts_pro.data.single_value_data","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data","title":"single_value_data","text":"<p>Single value data classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides data classes for single value data points used in line charts, area charts, and other chart types that display a single numeric value per time point. The SingleValueData class extends the base Data class with value-specific validation and serialization capabilities.</p> The module includes <ul> <li>SingleValueData: Data class for single value data points</li> <li>Value validation and NaN handling</li> <li>Time normalization and serialization utilities</li> </ul> Key Features <ul> <li>Automatic time normalization to UNIX timestamps</li> <li>NaN value handling (converts NaN to 0.0)</li> <li>Required field validation for value parameter</li> <li>CamelCase serialization for frontend communication</li> <li>Column management for DataFrame conversion operations</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize to frontend format\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data.SingleValueData","title":"SingleValueData  <code>dataclass</code>","text":"<p>Data class for single value data points used in line and area charts.</p> <p>This class represents a single numeric value at a specific time point, commonly used for line charts, area charts, and other chart types that display one value per time. It extends the base Data class with value-specific validation and NaN handling.</p> <p>The class automatically handles time normalization, value validation, and serialization to camelCase dictionaries suitable for frontend communication.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>UNIX timestamp in seconds representing the data point time. This value is automatically normalized during initialization.</p> <code>value</code> <code>float</code> <p>The numeric value for this data point. NaN values are automatically converted to 0.0 for frontend compatibility.</p> Class Attributes <p>REQUIRED_COLUMNS (set): Set containing \"value\" as the required column     for DataFrame conversion operations. OPTIONAL_COLUMNS (set): Empty set indicating no optional columns     are available for this data type.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Create single value data point\ndata = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n# Serialize for frontend\nserialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n</code></pre> See also <p>Data: Base class providing time normalization and serialization. LineData: Specialized single value data for line charts. AreaData: Specialized single value data for area charts.</p> Source code in <code>streamlit_lightweight_charts_pro/data/single_value_data.py</code> <pre><code>@dataclass\nclass SingleValueData(Data):\n    \"\"\"Data class for single value data points used in line and area charts.\n\n    This class represents a single numeric value at a specific time point, commonly used\n    for line charts, area charts, and other chart types that display one value per time.\n    It extends the base Data class with value-specific validation and NaN handling.\n\n    The class automatically handles time normalization, value validation, and serialization\n    to camelCase dictionaries suitable for frontend communication.\n\n    Attributes:\n        time (int): UNIX timestamp in seconds representing the data point time.\n            This value is automatically normalized during initialization.\n        value (float): The numeric value for this data point. NaN values are\n            automatically converted to 0.0 for frontend compatibility.\n\n    Class Attributes:\n        REQUIRED_COLUMNS (set): Set containing \"value\" as the required column\n            for DataFrame conversion operations.\n        OPTIONAL_COLUMNS (set): Empty set indicating no optional columns\n            are available for this data type.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import SingleValueData\n\n        # Create single value data point\n        data = SingleValueData(time=\"2024-01-01T00:00:00\", value=100.0)\n\n        # Serialize for frontend\n        serialized = data.asdict()  # {'time': 1704067200, 'value': 100.0}\n        ```\n\n    See also:\n        Data: Base class providing time normalization and serialization.\n        LineData: Specialized single value data for line charts.\n        AreaData: Specialized single value data for area charts.\n    \"\"\"\n\n    # Define required columns for DataFrame conversion - only \"value\" is required\n    # beyond the base \"time\" column inherited from Data class\n    REQUIRED_COLUMNS: ClassVar[set] = {\"value\"}\n\n    # Define optional columns for DataFrame conversion - none for this simple data type\n    OPTIONAL_COLUMNS: ClassVar[set] = set()\n\n    # The single numeric value for this data point\n    value: float\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate and normalize values.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Calls the parent class __post_init__ to normalize the time value\n        2. Validates the value field for None values\n        3. Converts NaN values to 0.0 for frontend compatibility\n\n        The method ensures that all data points have valid, non-NaN values\n        that can be safely serialized and transmitted to the frontend.\n\n        Raises:\n            RequiredFieldError: If the value field is None or missing.\n        \"\"\"\n        # Call parent's __post_init__ to normalize the time value to UNIX timestamp\n        super().__post_init__()\n\n        # Handle NaN values in the value field - convert to 0.0 for frontend compatibility\n        if isinstance(self.value, float) and math.isnan(self.value):\n            self.value = 0.0\n        # Validate that value is not None - this is a required field\n        elif self.value is None:\n            raise RequiredFieldError(\"value\")\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/single_value_data.html#streamlit_lightweight_charts_pro.data.single_value_data-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html","title":"streamlit_lightweight_charts_pro.data.tooltip","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip","title":"tooltip","text":"<p>Tooltip data structures and utilities for Lightweight Charts.</p> <p>This module provides comprehensive tooltip functionality with support for dynamic content using placeholders, multiple tooltip types, and flexible configuration options.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField","title":"TooltipField  <code>dataclass</code>","text":"<p>Represents a single field in a tooltip.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Display label for the field</p> <code>value_key</code> <code>str</code> <p>Key to access the value from data</p> <code>formatter</code> <code>Optional[Callable[[Any], str]]</code> <p>Optional function to format the value</p> <code>color</code> <code>Optional[str]</code> <p>Optional color for the field</p> <code>font_size</code> <code>Optional[int]</code> <p>Optional font size for the field</p> <code>font_weight</code> <code>Optional[str]</code> <p>Optional font weight for the field</p> <code>prefix</code> <code>Optional[str]</code> <p>Optional prefix to add before the value</p> <code>suffix</code> <code>Optional[str]</code> <p>Optional suffix to add after the value</p> <code>precision</code> <code>Optional[int]</code> <p>Optional decimal precision for numeric values</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipField:\n    \"\"\"Represents a single field in a tooltip.\n\n    Attributes:\n        label: Display label for the field\n        value_key: Key to access the value from data\n        formatter: Optional function to format the value\n        color: Optional color for the field\n        font_size: Optional font size for the field\n        font_weight: Optional font weight for the field\n        prefix: Optional prefix to add before the value\n        suffix: Optional suffix to add after the value\n        precision: Optional decimal precision for numeric values\n    \"\"\"\n\n    label: str\n    value_key: str\n    formatter: Optional[Callable[[Any], str]] = None\n    color: Optional[str] = None\n    font_size: Optional[int] = None\n    font_weight: Optional[str] = None\n    prefix: Optional[str] = None\n    suffix: Optional[str] = None\n    precision: Optional[int] = None\n\n    def format_value(self, value: Any) -&gt; str:\n        \"\"\"Format the value according to field configuration.\"\"\"\n        if self.formatter:\n            return self.formatter(value)\n\n        # Apply precision for numeric values\n        if self.precision is not None and isinstance(value, (int, float)):\n            value = f\"{value:.{self.precision}f}\"\n        else:\n            value = str(value)\n\n        # Add prefix and suffix\n        result = value\n        if self.prefix:\n            result = f\"{self.prefix}{result}\"\n        if self.suffix:\n            result = f\"{result}{self.suffix}\"\n\n        return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipField.format_value","title":"format_value","text":"<pre><code>format_value(value: Any) -&gt; str\n</code></pre> <p>Format the value according to field configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_value(self, value: Any) -&gt; str:\n    \"\"\"Format the value according to field configuration.\"\"\"\n    if self.formatter:\n        return self.formatter(value)\n\n    # Apply precision for numeric values\n    if self.precision is not None and isinstance(value, (int, float)):\n        value = f\"{value:.{self.precision}f}\"\n    else:\n        value = str(value)\n\n    # Add prefix and suffix\n    result = value\n    if self.prefix:\n        result = f\"{self.prefix}{result}\"\n    if self.suffix:\n        result = f\"{result}{self.suffix}\"\n\n    return result\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipStyle","title":"TooltipStyle  <code>dataclass</code>","text":"<p>Styling configuration for tooltips.</p> <p>Attributes:</p> Name Type Description <code>background_color</code> <code>str</code> <p>Background color of the tooltip</p> <code>border_color</code> <code>str</code> <p>Border color of the tooltip</p> <code>border_width</code> <code>int</code> <p>Border width in pixels</p> <code>border_radius</code> <code>int</code> <p>Border radius in pixels</p> <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>font_size</code> <code>int</code> <p>Font size in pixels</p> <code>font_family</code> <code>str</code> <p>Font family</p> <code>color</code> <code>str</code> <p>Text color</p> <code>box_shadow</code> <code>str</code> <p>CSS box shadow</p> <code>z_index</code> <code>int</code> <p>Z-index for layering</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipStyle:\n    \"\"\"Styling configuration for tooltips.\n\n    Attributes:\n        background_color: Background color of the tooltip\n        border_color: Border color of the tooltip\n        border_width: Border width in pixels\n        border_radius: Border radius in pixels\n        padding: Padding in pixels\n        font_size: Font size in pixels\n        font_family: Font family\n        color: Text color\n        box_shadow: CSS box shadow\n        z_index: Z-index for layering\n    \"\"\"\n\n    background_color: str = \"rgba(255, 255, 255, 0.95)\"\n    border_color: str = \"#e1e3e6\"\n    border_width: int = 1\n    border_radius: int = 4\n    padding: int = 6\n    font_size: int = 12\n    font_family: str = \"sans-serif\"\n    color: str = \"#131722\"\n    box_shadow: str = \"0 2px 4px rgba(0, 0, 0, 0.1)\"\n    z_index: int = 1000\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig","title":"TooltipConfig  <code>dataclass</code>","text":"<p>Configuration for tooltip functionality.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether tooltips are enabled</p> <code>type</code> <code>TooltipType</code> <p>Type of tooltip to display</p> <code>template</code> <code>Optional[str]</code> <p>Template string with placeholders</p> <code>fields</code> <code>List[TooltipField]</code> <p>List of tooltip fields</p> <code>position</code> <code>TooltipPosition</code> <p>Tooltip positioning</p> <code>offset</code> <code>Optional[Dict[str, int]]</code> <p>Offset from cursor or fixed position</p> <code>style</code> <code>TooltipStyle</code> <p>Tooltip styling</p> <code>show_date</code> <code>bool</code> <p>Whether to show date</p> <code>date_format</code> <code>str</code> <p>Date format string</p> <code>show_time</code> <code>bool</code> <p>Whether to show time</p> <code>time_format</code> <code>str</code> <p>Time format string</p> <code>custom_formatters</code> <code>Dict[str, Callable[[Any], str]]</code> <p>Custom formatter functions</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>@dataclass\nclass TooltipConfig:\n    \"\"\"Configuration for tooltip functionality.\n\n    Attributes:\n        enabled: Whether tooltips are enabled\n        type: Type of tooltip to display\n        template: Template string with placeholders\n        fields: List of tooltip fields\n        position: Tooltip positioning\n        offset: Offset from cursor or fixed position\n        style: Tooltip styling\n        show_date: Whether to show date\n        date_format: Date format string\n        show_time: Whether to show time\n        time_format: Time format string\n        custom_formatters: Custom formatter functions\n    \"\"\"\n\n    enabled: bool = True\n    type: TooltipType = TooltipType.OHLC\n    template: Optional[str] = None\n    fields: List[TooltipField] = field(default_factory=list)\n    position: TooltipPosition = TooltipPosition.CURSOR\n    offset: Optional[Dict[str, int]] = None\n    style: TooltipStyle = field(default_factory=TooltipStyle)\n    show_date: bool = True\n    date_format: str = \"%Y-%m-%d\"\n    show_time: bool = True\n    time_format: str = \"%H:%M:%S\"\n    custom_formatters: Dict[str, Callable[[Any], str]] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize default fields based on tooltip type.\"\"\"\n        if not self.fields and self.type == TooltipType.OHLC:\n            self.fields = self._get_default_ohlc_fields()\n        elif not self.fields and self.type == TooltipType.SINGLE:\n            self.fields = self._get_default_single_fields()\n        elif not self.fields and self.type == TooltipType.TRADE:\n            self.fields = self._get_default_trade_fields()\n\n    def _get_default_ohlc_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for OHLC tooltip.\"\"\"\n        return [\n            TooltipField(\"Open\", \"open\", precision=2, prefix=\"$\"),\n            TooltipField(\"High\", \"high\", precision=2, prefix=\"$\"),\n            TooltipField(\"Low\", \"low\", precision=2, prefix=\"$\"),\n            TooltipField(\"Close\", \"close\", precision=2, prefix=\"$\"),\n            TooltipField(\"Volume\", \"volume\", formatter=self._format_volume),\n        ]\n\n    def _get_default_single_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for single value tooltip.\"\"\"\n        return [\n            TooltipField(\"Value\", \"value\", precision=2),\n        ]\n\n    def _get_default_trade_fields(self) -&gt; List[TooltipField]:\n        \"\"\"Get default fields for trade tooltip.\"\"\"\n        return [\n            TooltipField(\"Entry\", \"entryPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Exit\", \"exitPrice\", precision=2, prefix=\"$\"),\n            TooltipField(\"Quantity\", \"quantity\"),\n            TooltipField(\"P&amp;L\", \"pnl\", precision=2, prefix=\"$\"),\n            TooltipField(\"P&amp;L %\", \"pnlPercentage\", precision=1, suffix=\"%\"),\n        ]\n\n    def _format_volume(self, value: Any) -&gt; str:\n        \"\"\"Format volume with K, M, B suffixes.\"\"\"\n        if not isinstance(value, (int, float)):\n            return str(value)\n\n        if value &gt;= 1e9:\n            return f\"{value / 1e9:.1f}B\"\n        if value &gt;= 1e6:\n            return f\"{value / 1e6:.1f}M\"\n        if value &gt;= 1e3:\n            return f\"{value / 1e3:.1f}K\"\n        return f\"{value:,.0f}\"\n\n    def format_tooltip(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip content using template or fields.\n\n        Args:\n            data: Data dictionary containing values\n            time_value: Optional time value for date/time formatting\n\n        Returns:\n            Formatted tooltip string\n        \"\"\"\n        if self.template:\n            return self._format_with_template(data, time_value)\n        return self._format_with_fields(data, time_value)\n\n    def _format_with_template(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using template string with placeholders.\"\"\"\n        if not self.template:\n            return \"\"\n\n        # Start with the template\n        result = self.template\n\n        # Replace placeholders with actual values\n        for key, value in data.items():\n            placeholder = f\"{{{key}}}\"\n            if placeholder in result:\n                # Format the value based on field configuration\n                field = next((f for f in self.fields if f.value_key == key), None)\n                formatted_value = field.format_value(value) if field else str(value)\n                result = result.replace(placeholder, formatted_value)\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                result = f\"{time_str}\\n{result}\"\n\n        return result\n\n    def _format_with_fields(\n        self,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using field configuration.\"\"\"\n        lines = []\n\n        # Add date/time if configured\n        if time_value and (self.show_date or self.show_time):\n            time_str = self._format_time(time_value)\n            if time_str:\n                lines.append(time_str)\n\n        # Add field values\n        for tooltip_field in self.fields:\n            if tooltip_field.value_key in data:\n                value = data[tooltip_field.value_key]\n                formatted_value = tooltip_field.format_value(value)\n                lines.append(f\"{tooltip_field.label}: {formatted_value}\")\n\n        return \"\\n\".join(lines)\n\n    def _format_time(self, time_value: Union[int, str, pd.Timestamp]) -&gt; str:\n        \"\"\"Format time value according to configuration.\"\"\"\n        try:\n            if isinstance(time_value, (int, float)):\n                # Convert timestamp to datetime\n                dt = pd.to_datetime(time_value, unit=\"s\")\n            elif isinstance(time_value, str):\n                dt = pd.to_datetime(time_value)\n            else:\n                dt = pd.to_datetime(time_value)\n\n            parts = []\n            if self.show_date:\n                parts.append(dt.strftime(self.date_format))\n            if self.show_time:\n                parts.append(dt.strftime(self.time_format))\n\n            return \" \".join(parts)\n        except Exception:\n            return str(time_value)\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n        return {\n            \"enabled\": self.enabled,\n            \"type\": self.type.value,\n            \"template\": self.template,\n            \"fields\": [self._field_to_dict(field) for field in self.fields],\n            \"position\": self.position.value,\n            \"offset\": self.offset,\n            \"style\": self._style_to_dict(self.style),\n            \"showDate\": self.show_date,\n            \"dateFormat\": self.date_format,\n            \"showTime\": self.show_time,\n            \"timeFormat\": self.time_format,\n        }\n\n    def _field_to_dict(self, field: TooltipField) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip field to dictionary.\"\"\"\n        return {\n            \"label\": field.label,\n            \"valueKey\": field.value_key,\n            \"color\": field.color,\n            \"fontSize\": field.font_size,\n            \"fontWeight\": field.font_weight,\n            \"prefix\": field.prefix,\n            \"suffix\": field.suffix,\n            \"precision\": field.precision,\n        }\n\n    def _style_to_dict(self, style: TooltipStyle) -&gt; Dict[str, Any]:\n        \"\"\"Convert tooltip style to dictionary.\"\"\"\n        return {\n            \"backgroundColor\": style.background_color,\n            \"borderColor\": style.border_color,\n            \"borderWidth\": style.border_width,\n            \"borderRadius\": style.border_radius,\n            \"padding\": style.padding,\n            \"fontSize\": style.font_size,\n            \"fontFamily\": style.font_family,\n            \"color\": style.color,\n            \"boxShadow\": style.box_shadow,\n            \"zIndex\": style.z_index,\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, Timestamp]] = None,\n) -&gt; str\n</code></pre> <p>Format tooltip content using template or fields.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Data dictionary containing values</p> required <code>time_value</code> <code>Optional[Union[int, str, Timestamp]]</code> <p>Optional time value for date/time formatting</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted tooltip string</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip content using template or fields.\n\n    Args:\n        data: Data dictionary containing values\n        time_value: Optional time value for date/time formatting\n\n    Returns:\n        Formatted tooltip string\n    \"\"\"\n    if self.template:\n        return self._format_with_template(data, time_value)\n    return self._format_with_fields(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipConfig.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert tooltip config to dictionary for serialization.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert tooltip config to dictionary for serialization.\"\"\"\n    return {\n        \"enabled\": self.enabled,\n        \"type\": self.type.value,\n        \"template\": self.template,\n        \"fields\": [self._field_to_dict(field) for field in self.fields],\n        \"position\": self.position.value,\n        \"offset\": self.offset,\n        \"style\": self._style_to_dict(self.style),\n        \"showDate\": self.show_date,\n        \"dateFormat\": self.date_format,\n        \"showTime\": self.show_time,\n        \"timeFormat\": self.time_format,\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager","title":"TooltipManager","text":"<p>Manages tooltip functionality across multiple series and data types.</p> <p>This class provides centralized tooltip management with support for different data types, dynamic content, and consistent formatting.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>class TooltipManager:\n    \"\"\"Manages tooltip functionality across multiple series and data types.\n\n    This class provides centralized tooltip management with support for\n    different data types, dynamic content, and consistent formatting.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize tooltip manager.\"\"\"\n        self.configs: Dict[str, TooltipConfig] = {}\n        self.custom_formatters: Dict[str, Callable[[Any], str]] = {}\n\n    def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n        \"\"\"Add a tooltip configuration.\"\"\"\n        self.configs[name] = config\n        return self\n\n    def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n        \"\"\"Get a tooltip configuration by name.\"\"\"\n        return self.configs.get(name)\n\n    def remove_config(self, name: str) -&gt; bool:\n        \"\"\"Remove a tooltip configuration.\"\"\"\n        if name in self.configs:\n            del self.configs[name]\n            return True\n        return False\n\n    def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n        \"\"\"Add a custom formatter function.\"\"\"\n        self.custom_formatters[name] = formatter\n        return self\n\n    def format_tooltip(\n        self,\n        config_name: str,\n        data: Dict[str, Any],\n        time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n    ) -&gt; str:\n        \"\"\"Format tooltip using specified configuration.\"\"\"\n        config = self.get_config(config_name)\n        if not config:\n            return \"\"\n\n        # Add custom formatters to config\n        config.custom_formatters.update(self.custom_formatters)\n\n        return config.format_tooltip(data, time_value)\n\n    def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n        \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.OHLC)\n        self.add_config(name, config)\n        return config\n\n    def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n        \"\"\"Create a standard trade tooltip configuration.\"\"\"\n        config = TooltipConfig(type=TooltipType.TRADE)\n        self.add_config(name, config)\n        return config\n\n    def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n        \"\"\"Create a custom tooltip configuration with template.\"\"\"\n        config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n        self.add_config(name, config)\n        return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.add_config","title":"add_config","text":"<pre><code>add_config(\n    name: str, config: TooltipConfig\n) -&gt; TooltipManager\n</code></pre> <p>Add a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_config(self, name: str, config: TooltipConfig) -&gt; \"TooltipManager\":\n    \"\"\"Add a tooltip configuration.\"\"\"\n    self.configs[name] = config\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.get_config","title":"get_config","text":"<pre><code>get_config(name: str) -&gt; Optional[TooltipConfig]\n</code></pre> <p>Get a tooltip configuration by name.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def get_config(self, name: str) -&gt; Optional[TooltipConfig]:\n    \"\"\"Get a tooltip configuration by name.\"\"\"\n    return self.configs.get(name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.remove_config","title":"remove_config","text":"<pre><code>remove_config(name: str) -&gt; bool\n</code></pre> <p>Remove a tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def remove_config(self, name: str) -&gt; bool:\n    \"\"\"Remove a tooltip configuration.\"\"\"\n    if name in self.configs:\n        del self.configs[name]\n        return True\n    return False\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.add_custom_formatter","title":"add_custom_formatter","text":"<pre><code>add_custom_formatter(\n    name: str, formatter: Callable[[Any], str]\n) -&gt; TooltipManager\n</code></pre> <p>Add a custom formatter function.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def add_custom_formatter(self, name: str, formatter: Callable[[Any], str]) -&gt; \"TooltipManager\":\n    \"\"\"Add a custom formatter function.\"\"\"\n    self.custom_formatters[name] = formatter\n    return self\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.format_tooltip","title":"format_tooltip","text":"<pre><code>format_tooltip(\n    config_name: str,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, Timestamp]] = None,\n) -&gt; str\n</code></pre> <p>Format tooltip using specified configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def format_tooltip(\n    self,\n    config_name: str,\n    data: Dict[str, Any],\n    time_value: Optional[Union[int, str, pd.Timestamp]] = None,\n) -&gt; str:\n    \"\"\"Format tooltip using specified configuration.\"\"\"\n    config = self.get_config(config_name)\n    if not config:\n        return \"\"\n\n    # Add custom formatters to config\n    config.custom_formatters.update(self.custom_formatters)\n\n    return config.format_tooltip(data, time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip(name: str = 'default') -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip(self, name: str = \"default\") -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.OHLC)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip(name: str = 'trade') -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip(self, name: str = \"trade\") -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    config = TooltipConfig(type=TooltipType.TRADE)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.TooltipManager.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(\n    template: str, name: str = \"custom\"\n) -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(self, template: str, name: str = \"custom\") -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    config = TooltipConfig(type=TooltipType.CUSTOM, template=template)\n    self.add_config(name, config)\n    return config\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_ohlc_tooltip","title":"create_ohlc_tooltip","text":"<pre><code>create_ohlc_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard OHLC tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_ohlc_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard OHLC tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.OHLC)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_trade_tooltip","title":"create_trade_tooltip","text":"<pre><code>create_trade_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a standard trade tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_trade_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a standard trade tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.TRADE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_custom_tooltip","title":"create_custom_tooltip","text":"<pre><code>create_custom_tooltip(template: str) -&gt; TooltipConfig\n</code></pre> <p>Create a custom tooltip configuration with template.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_custom_tooltip(template: str) -&gt; TooltipConfig:\n    \"\"\"Create a custom tooltip configuration with template.\"\"\"\n    return TooltipConfig(type=TooltipType.CUSTOM, template=template)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_single_value_tooltip","title":"create_single_value_tooltip","text":"<pre><code>create_single_value_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a single value tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_single_value_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a single value tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.SINGLE)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/tooltip.html#streamlit_lightweight_charts_pro.data.tooltip.create_multi_series_tooltip","title":"create_multi_series_tooltip","text":"<pre><code>create_multi_series_tooltip() -&gt; TooltipConfig\n</code></pre> <p>Create a multi-series tooltip configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/data/tooltip.py</code> <pre><code>def create_multi_series_tooltip() -&gt; TooltipConfig:\n    \"\"\"Create a multi-series tooltip configuration.\"\"\"\n    return TooltipConfig(type=TooltipType.MULTI)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html","title":"streamlit_lightweight_charts_pro.data.trade","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade","title":"trade","text":"<p>Trade data model for visualizing trades on charts.</p> <p>This module provides the TradeData class for representing individual trades with entry and exit information, profit/loss calculations, and flexible metadata storage. Trade visualization (markers, rectangles, tooltips) is handled by the frontend using template-based rendering.</p> The module includes <ul> <li>TradeData: Complete trade representation with entry/exit data</li> <li>Automatic profit/loss calculations and percentage calculations</li> <li>Flexible additional_data for custom trade metadata</li> <li>Comprehensive serialization for frontend communication</li> </ul> Key Features <ul> <li>Entry and exit time/price tracking with validation</li> <li>Automatic profit/loss and percentage calculations</li> <li>Flexible additional_data dictionary for custom fields</li> <li>Tooltip text generation with trade details</li> <li>Time normalization and validation</li> <li>Frontend-compatible serialization with camelCase keys</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")\nprint(f\"Profitable: {trade.is_profitable}\")\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData","title":"TradeData  <code>dataclass</code>","text":"<p>Represents a single trade with entry and exit information.</p> <p>This class provides a comprehensive representation of a trading transaction, including entry and exit details, profit/loss calculations, and visualization capabilities. It supports both long and short trades with automatic P&amp;L calculations and marker generation for chart display.</p> <p>The class automatically validates trade data, normalizes time values, and provides computed properties for profit/loss analysis. It can convert trades to marker representations for visual display on charts.</p> <p>Attributes:</p> Name Type Description <code>entry_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Entry time in various formats (automatically normalized to UTC timestamp).</p> <code>entry_price</code> <code>Union[float, int]</code> <p>Entry price for the trade.</p> <code>exit_time</code> <code>Union[Timestamp, datetime, str, int, float]</code> <p>Exit time in various formats (automatically normalized to UTC timestamp).</p> <code>exit_price</code> <code>Union[float, int]</code> <p>Exit price for the trade.</p> <code>is_profitable</code> <code>bool</code> <p>Whether the trade was profitable (True) or not (False).</p> <code>id</code> <code>str</code> <p>Unique identifier for the trade (required).</p> <code>additional_data</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing any additional trade data such as quantity, trade_type, notes, etc. This provides maximum flexibility for custom fields.</p> Example <pre><code>from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n# Create a profitable long trade\ntrade = TradeData(\n    entry_time=\"2024-01-01T09:00:00\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01T16:00:00\",\n    exit_price=105.0,\n    is_profitable=True,\n    id=\"trade_001\",\n    additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n)\n\n# Access calculated properties\nprint(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\nprint(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\nprint(f\"Profitable: {trade.is_profitable}\")  # True\n\n# Serialize for frontend\ntrade_dict = trade.asdict()\n</code></pre> Note <ul> <li>Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised</li> <li>Price values are automatically converted to appropriate numeric types</li> <li>Time values are normalized to UTC timestamps for consistent handling</li> <li>All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data</li> <li>The id field is required for trade identification</li> </ul> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>@dataclass\nclass TradeData(SerializableMixin):\n    \"\"\"Represents a single trade with entry and exit information.\n\n    This class provides a comprehensive representation of a trading transaction,\n    including entry and exit details, profit/loss calculations, and visualization\n    capabilities. It supports both long and short trades with automatic P&amp;L\n    calculations and marker generation for chart display.\n\n    The class automatically validates trade data, normalizes time values, and\n    provides computed properties for profit/loss analysis. It can convert trades\n    to marker representations for visual display on charts.\n\n    Attributes:\n        entry_time (Union[pd.Timestamp, datetime, str, int, float]): Entry time\n            in various formats (automatically normalized to UTC timestamp).\n        entry_price (Union[float, int]): Entry price for the trade.\n        exit_time (Union[pd.Timestamp, datetime, str, int, float]): Exit time\n            in various formats (automatically normalized to UTC timestamp).\n        exit_price (Union[float, int]): Exit price for the trade.\n        is_profitable (bool): Whether the trade was profitable (True) or not (False).\n        id (str): Unique identifier for the trade (required).\n        additional_data (Optional[Dict[str, Any]]): Optional dictionary containing\n            any additional trade data such as quantity, trade_type, notes, etc.\n            This provides maximum flexibility for custom fields.\n\n    Example:\n        ```python\n        from streamlit_lightweight_charts_pro.data import TradeData, TradeType\n\n        # Create a profitable long trade\n        trade = TradeData(\n            entry_time=\"2024-01-01T09:00:00\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01T16:00:00\",\n            exit_price=105.0,\n            is_profitable=True,\n            id=\"trade_001\",\n            additional_data={\"quantity\": 100, \"trade_type\": \"long\", \"notes\": \"Strong momentum trade\"},\n        )\n\n        # Access calculated properties\n        print(f\"P&amp;L: ${trade.pnl:.2f}\")  # $500.00\n        print(f\"P&amp;L %: {trade.pnl_percentage:.1f}%\")  # 5.0%\n        print(f\"Profitable: {trade.is_profitable}\")  # True\n\n        # Serialize for frontend\n        trade_dict = trade.asdict()\n        ```\n\n    Note:\n        - Exit time must be after entry time, otherwise ExitTimeAfterEntryTimeError is raised\n        - Price values are automatically converted to appropriate numeric types\n        - Time values are normalized to UTC timestamps for consistent handling\n        - All additional data (quantity, trade_type, notes, etc.) should be provided in additional_data\n        - The id field is required for trade identification\n    \"\"\"\n\n    # Core fields required for trade visualization\n    entry_time: Union[pd.Timestamp, datetime, str, int, float]\n    entry_price: Union[float, int]\n    exit_time: Union[pd.Timestamp, datetime, str, int, float]\n    exit_price: Union[float, int]\n    is_profitable: bool\n    id: str  # Required for trade identification\n\n    # All other data moved to additional_data for maximum flexibility\n    additional_data: Optional[Dict[str, Any]] = None\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to normalize and validate trade data.\n\n        This method is automatically called after the dataclass is initialized.\n        It performs the following operations:\n        1. Converts price values to appropriate numeric types\n        2. Normalizes entry and exit times to UTC timestamps\n        3. Validates that exit time is after entry time\n        4. Ensures is_profitable is a boolean\n\n        Raises:\n            ExitTimeAfterEntryTimeError: If exit time is not after entry time.\n            ValueValidationError: If time validation fails.\n        \"\"\"\n        # Step 1: Convert price values to float for consistent calculations\n        # This ensures prices are always numeric, regardless of input type\n        self.entry_price = float(self.entry_price)\n        self.exit_price = float(self.exit_price)\n\n        # Step 2: Ensure is_profitable is a boolean for consistent logic\n        # Converts any truthy/falsy value to explicit True/False\n        self.is_profitable = bool(self.is_profitable)\n\n        # Step 3: Convert times to UTC timestamps for consistent handling\n        # This normalizes various time formats (datetime, string, timestamp) to UTC\n        self._entry_timestamp = to_utc_timestamp(self.entry_time)\n        self._exit_timestamp = to_utc_timestamp(self.exit_time)\n\n        # Step 4: Validate that exit time is after entry time\n        # This is critical for trade logic - a trade cannot exit before it enters\n        if isinstance(self._entry_timestamp, (int, float)) and isinstance(\n            self._exit_timestamp,\n            (int, float),\n        ):\n            # Case 1: Both timestamps are numeric - compare directly\n            if self._exit_timestamp &lt;= self._entry_timestamp:\n                raise ExitTimeAfterEntryTimeError()\n        elif (\n            isinstance(self._entry_timestamp, str)\n            and isinstance(self._exit_timestamp, str)\n            and self._exit_timestamp &lt;= self._entry_timestamp\n        ):\n            # Case 2: Both timestamps are strings - compare lexicographically\n            raise ValueValidationError(\"Exit time\", \"must be after entry time\")\n\n    def generate_tooltip_text(self) -&gt; str:\n        \"\"\"Generate tooltip text for the trade.\n\n        Creates a comprehensive tooltip text that displays key trade information\n        including entry/exit prices, quantity, profit/loss, and optional notes.\n        The tooltip is designed to be informative and easy to read when displayed\n        on charts.\n\n        Returns:\n            str: Formatted tooltip text with trade details and P&amp;L information.\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                quantity=100,\n                trade_type=TradeType.LONG,\n            )\n            tooltip = trade.generate_tooltip_text()\n            # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n            ```\n        \"\"\"\n        # Step 1: Calculate profit/loss metrics for tooltip display\n        # Uses the pnl and pnl_percentage properties which check additional_data first\n        pnl = self.pnl\n        pnl_pct = self.pnl_percentage\n\n        # Step 2: Determine win/loss label based on P&amp;L value\n        # Positive P&amp;L = Win, negative or zero = Loss\n        win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n        # Step 3: Build tooltip components with formatted trade information\n        # Start with core entry/exit prices (always shown)\n        tooltip_parts = [\n            f\"Entry: {self.entry_price:.2f}\",\n            f\"Exit: {self.exit_price:.2f}\",\n        ]\n\n        # Step 4: Add quantity if available in additional_data\n        # Quantity is optional and only shown if user provided it\n        if self.additional_data and \"quantity\" in self.additional_data:\n            tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n        # Step 5: Add P&amp;L information (always shown)\n        # Shows both absolute P&amp;L and percentage for complete picture\n        tooltip_parts.extend(\n            [\n                f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n                f\"{win_loss}\",\n            ],\n        )\n\n        # Step 6: Add custom notes if provided for additional context\n        # Notes are optional and only shown if user provided them\n        if self.additional_data and \"notes\" in self.additional_data:\n            tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n        # Step 7: Join all parts with newlines for multi-line tooltip display\n        return \"\\n\".join(tooltip_parts)\n\n    @property\n    def pnl(self) -&gt; float:\n        \"\"\"Get profit/loss amount from additional_data or calculate basic price difference.\n\n        First checks if P&amp;L is provided in additional_data, otherwise calculates\n        basic price difference. This allows users to provide their own P&amp;L calculation\n        logic while maintaining a fallback for basic visualization.\n\n        Returns:\n            float: Profit/loss amount. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl\n            trade = TradeData(..., additional_data={\"pnl\": 500.0})\n            trade.pnl  # Returns: 500.0\n\n            # Without additional_data, calculates basic difference\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl  # Returns: 5.0 (basic price difference)\n            ```\n        \"\"\"\n        # Check if P&amp;L is provided in additional_data dictionary\n        # User may provide custom P&amp;L calculation (e.g., accounting for fees, quantity)\n        if self.additional_data and \"pnl\" in self.additional_data:\n            return float(self.additional_data[\"pnl\"])\n\n        # Fallback: Calculate basic price difference for visualization\n        # Simple formula: exit_price - entry_price (doesn't account for quantity or fees)\n        return float(self.exit_price - self.entry_price)\n\n    @property\n    def pnl_percentage(self) -&gt; float:\n        \"\"\"Get profit/loss percentage from additional_data or calculate basic percentage.\n\n        First checks if P&amp;L percentage is provided in additional_data, otherwise\n        calculates basic percentage based on price difference relative to entry price.\n\n        Returns:\n            float: Profit/loss percentage. Positive values indicate profit,\n                negative values indicate loss.\n\n        Example:\n            ```python\n            # With additional_data containing pnl_percentage\n            trade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\n            trade.pnl_percentage  # Returns: 5.0\n\n            # Without additional_data, calculates basic percentage\n            trade = TradeData(entry_price=100, exit_price=105, ...)\n            trade.pnl_percentage  # Returns: 5.0 (5% gain)\n            ```\n        \"\"\"\n        # Check if P&amp;L percentage is provided in additional_data dictionary\n        # User may provide custom percentage calculation\n        if self.additional_data and \"pnl_percentage\" in self.additional_data:\n            return float(self.additional_data[\"pnl_percentage\"])\n\n        # Fallback: Calculate basic percentage from price difference\n        # Formula: ((exit - entry) / entry) * 100\n        if self.entry_price != 0:\n            return ((self.exit_price - self.entry_price) / self.entry_price) * 100\n\n        # Edge case: Return 0.0 if entry price is zero to avoid division by zero\n        return 0.0\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n        Converts the trade to a dictionary format suitable for frontend\n        communication. Only includes core fields required for visualization.\n\n        Returns:\n            Dict[str, Any]: Serialized trade with camelCase keys ready for\n                frontend consumption. Contains:\n                - entryTime: Entry timestamp\n                - entryPrice: Entry price\n                - exitTime: Exit timestamp\n                - exitPrice: Exit price\n                - isProfitable: Profitability status\n                - pnl: Profit/loss amount (from additional_data or calculated)\n                - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n                - All fields from additional_data (merged for template access)\n\n        Example:\n            ```python\n            trade = TradeData(\n                entry_time=\"2024-01-01\",\n                entry_price=100.0,\n                exit_time=\"2024-01-01\",\n                exit_price=105.0,\n                is_profitable=True,\n                additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n            )\n\n            result = trade.asdict()\n            # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n            #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n            #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n            ```\n        \"\"\"\n        # Step 1: Create base trade dictionary with core fields\n        # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n        trade_dict = {\n            \"entryTime\": self._entry_timestamp,  # Normalized UTC timestamp\n            \"entryPrice\": self.entry_price,  # Entry price as float\n            \"exitTime\": self._exit_timestamp,  # Normalized UTC timestamp\n            \"exitPrice\": self.exit_price,  # Exit price as float\n            \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n            \"id\": self.id,  # Unique trade identifier (required)\n            \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n            \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n        }\n\n        # Step 2: Merge additional data into the trade dict for template access\n        # This allows frontend templates to access custom fields like quantity, notes, etc.\n        if self.additional_data:\n            trade_dict.update(self.additional_data)\n\n        return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.pnl","title":"pnl  <code>property</code>","text":"<pre><code>pnl: float\n</code></pre> <p>Get profit/loss amount from additional_data or calculate basic price difference.</p> <p>First checks if P&amp;L is provided in additional_data, otherwise calculates basic price difference. This allows users to provide their own P&amp;L calculation logic while maintaining a fallback for basic visualization.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss amount. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl\ntrade = TradeData(..., additional_data={\"pnl\": 500.0})\ntrade.pnl  # Returns: 500.0\n\n# Without additional_data, calculates basic difference\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl  # Returns: 5.0 (basic price difference)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.pnl_percentage","title":"pnl_percentage  <code>property</code>","text":"<pre><code>pnl_percentage: float\n</code></pre> <p>Get profit/loss percentage from additional_data or calculate basic percentage.</p> <p>First checks if P&amp;L percentage is provided in additional_data, otherwise calculates basic percentage based on price difference relative to entry price.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Profit/loss percentage. Positive values indicate profit, negative values indicate loss.</p> Example <pre><code># With additional_data containing pnl_percentage\ntrade = TradeData(..., additional_data={\"pnl_percentage\": 5.0})\ntrade.pnl_percentage  # Returns: 5.0\n\n# Without additional_data, calculates basic percentage\ntrade = TradeData(entry_price=100, exit_price=105, ...)\ntrade.pnl_percentage  # Returns: 5.0 (5% gain)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.generate_tooltip_text","title":"generate_tooltip_text","text":"<pre><code>generate_tooltip_text() -&gt; str\n</code></pre> <p>Generate tooltip text for the trade.</p> <pre><code>    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\n</code></pre> <p>Exit: 105.00 Qty: 100.00 P&amp;L: 500.00 (5.0%) Win\"             ```</p> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def generate_tooltip_text(self) -&gt; str:\n    \"\"\"Generate tooltip text for the trade.\n\n    Creates a comprehensive tooltip text that displays key trade information\n    including entry/exit prices, quantity, profit/loss, and optional notes.\n    The tooltip is designed to be informative and easy to read when displayed\n    on charts.\n\n    Returns:\n        str: Formatted tooltip text with trade details and P&amp;L information.\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            quantity=100,\n            trade_type=TradeType.LONG,\n        )\n        tooltip = trade.generate_tooltip_text()\n        # Returns: \"Entry: 100.00\\nExit: 105.00\\nQty: 100.00\\nP&amp;L: 500.00 (5.0%)\\nWin\"\n        ```\n    \"\"\"\n    # Step 1: Calculate profit/loss metrics for tooltip display\n    # Uses the pnl and pnl_percentage properties which check additional_data first\n    pnl = self.pnl\n    pnl_pct = self.pnl_percentage\n\n    # Step 2: Determine win/loss label based on P&amp;L value\n    # Positive P&amp;L = Win, negative or zero = Loss\n    win_loss = \"Win\" if pnl &gt; 0 else \"Loss\"\n\n    # Step 3: Build tooltip components with formatted trade information\n    # Start with core entry/exit prices (always shown)\n    tooltip_parts = [\n        f\"Entry: {self.entry_price:.2f}\",\n        f\"Exit: {self.exit_price:.2f}\",\n    ]\n\n    # Step 4: Add quantity if available in additional_data\n    # Quantity is optional and only shown if user provided it\n    if self.additional_data and \"quantity\" in self.additional_data:\n        tooltip_parts.append(f\"Qty: {self.additional_data['quantity']:.2f}\")\n\n    # Step 5: Add P&amp;L information (always shown)\n    # Shows both absolute P&amp;L and percentage for complete picture\n    tooltip_parts.extend(\n        [\n            f\"P&amp;L: {pnl:.2f} ({pnl_pct:.1f}%)\",\n            f\"{win_loss}\",\n        ],\n    )\n\n    # Step 6: Add custom notes if provided for additional context\n    # Notes are optional and only shown if user provided them\n    if self.additional_data and \"notes\" in self.additional_data:\n        tooltip_parts.append(f\"Notes: {self.additional_data['notes']}\")\n\n    # Step 7: Join all parts with newlines for multi-line tooltip display\n    return \"\\n\".join(tooltip_parts)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade.TradeData.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the trade data to a dict with camelCase keys for frontend.</p> <p>Converts the trade to a dictionary format suitable for frontend communication. Only includes core fields required for visualization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Serialized trade with camelCase keys ready for frontend consumption. Contains: - entryTime: Entry timestamp - entryPrice: Entry price - exitTime: Exit timestamp - exitPrice: Exit price - isProfitable: Profitability status - pnl: Profit/loss amount (from additional_data or calculated) - pnlPercentage: Profit/loss percentage (from additional_data or calculated) - All fields from additional_data (merged for template access)</p> Example <pre><code>trade = TradeData(\n    entry_time=\"2024-01-01\",\n    entry_price=100.0,\n    exit_time=\"2024-01-01\",\n    exit_price=105.0,\n    is_profitable=True,\n    additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n)\n\nresult = trade.asdict()\n# Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n#          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n#          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/data/trade.py</code> <pre><code>def asdict(self) -&gt; Dict[str, Any]:\n    \"\"\"Serialize the trade data to a dict with camelCase keys for frontend.\n\n    Converts the trade to a dictionary format suitable for frontend\n    communication. Only includes core fields required for visualization.\n\n    Returns:\n        Dict[str, Any]: Serialized trade with camelCase keys ready for\n            frontend consumption. Contains:\n            - entryTime: Entry timestamp\n            - entryPrice: Entry price\n            - exitTime: Exit timestamp\n            - exitPrice: Exit price\n            - isProfitable: Profitability status\n            - pnl: Profit/loss amount (from additional_data or calculated)\n            - pnlPercentage: Profit/loss percentage (from additional_data or calculated)\n            - All fields from additional_data (merged for template access)\n\n    Example:\n        ```python\n        trade = TradeData(\n            entry_time=\"2024-01-01\",\n            entry_price=100.0,\n            exit_time=\"2024-01-01\",\n            exit_price=105.0,\n            is_profitable=True,\n            additional_data={\"strategy\": \"momentum\", \"pnl\": 500.0},\n        )\n\n        result = trade.asdict()\n        # Returns: {\"entryTime\": 1704067200, \"entryPrice\": 100.0,\n        #          \"exitTime\": 1704070800, \"exitPrice\": 105.0,\n        #          \"isProfitable\": True, \"pnl\": 500.0, \"strategy\": \"momentum\"}\n        ```\n    \"\"\"\n    # Step 1: Create base trade dictionary with core fields\n    # Uses camelCase keys for JavaScript/TypeScript frontend compatibility\n    trade_dict = {\n        \"entryTime\": self._entry_timestamp,  # Normalized UTC timestamp\n        \"entryPrice\": self.entry_price,  # Entry price as float\n        \"exitTime\": self._exit_timestamp,  # Normalized UTC timestamp\n        \"exitPrice\": self.exit_price,  # Exit price as float\n        \"isProfitable\": self.is_profitable,  # Profitability flag (required)\n        \"id\": self.id,  # Unique trade identifier (required)\n        \"pnl\": self.pnl,  # Profit/loss amount (calculated or from additional_data)\n        \"pnlPercentage\": self.pnl_percentage,  # P&amp;L % (calculated or from additional_data)\n    }\n\n    # Step 2: Merge additional data into the trade dict for template access\n    # This allows frontend templates to access custom fields like quantity, notes, etc.\n    if self.additional_data:\n        trade_dict.update(self.additional_data)\n\n    return trade_dict\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trade.html#streamlit_lightweight_charts_pro.data.trade-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html","title":"streamlit_lightweight_charts_pro.data.trend_fill","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill","title":"trend_fill","text":"<p>Trend fill data classes for streamlit-lightweight-charts.</p> <p>This module provides TrendFillData class for creating trend-based fill charts that display fills between trend lines and base lines, similar to Supertrend indicators with dynamic trend-colored backgrounds.</p> <p>The class now uses a simplified approach with a single trendLine field: - Uptrend (+1): Shows trend line above price, base line for reference - Downtrend (-1): Shows trend line below price, base line for reference - Neutral (0): No trend line displayed</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData","title":"TrendFillData  <code>dataclass</code>","text":"<p>Trend fill data for lightweight charts.</p> <p>This data class represents a single data point for trend fill charts, with simplified trend line handling:</p> <ul> <li>Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference</li> <li>Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference</li> <li>Neutral (0): No trend line displayed</li> </ul> <p>The fill area is created between the trend line and base line, with colors automatically selected based on trend direction.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>int</code> <p>Time value for the data point</p> <code>baseLine</code> <code>int</code> <p>Base line value (e.g., candle body midpoint, price level)</p> <code>trendLine</code> <code>int</code> <p>Value of the trend line (used for both uptrend and downtrend)</p> <code>trendDirection</code> <code>int</code> <p>Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)</p> <code>uptrendFillColor</code> <code>int</code> <p>Optional custom uptrend fill color</p> <code>downtrendFillColor</code> <code>int</code> <p>Optional custom downtrend fill color</p> Source code in <code>streamlit_lightweight_charts_pro/data/trend_fill.py</code> <pre><code>@dataclass\nclass TrendFillData(Data):\n    \"\"\"Trend fill data for lightweight charts.\n\n    This data class represents a single data point for trend fill charts,\n    with simplified trend line handling:\n\n    - Uptrend (+1): Uses trendLine above price as trend line, baseLine for reference\n    - Downtrend (-1): Uses trendLine below price as trend line, baseLine for reference\n    - Neutral (0): No trend line displayed\n\n    The fill area is created between the trend line and base line,\n    with colors automatically selected based on trend direction.\n\n    Attributes:\n        time: Time value for the data point\n        baseLine: Base line value (e.g., candle body midpoint, price level)\n        trendLine: Value of the trend line (used for both uptrend and downtrend)\n        trendDirection: Trend direction indicator (-1 for downtrend, 1 for uptrend, 0 for neutral)\n\n        # Fill color fields\n        uptrendFillColor: Optional custom uptrend fill color\n        downtrendFillColor: Optional custom downtrend fill color\n    \"\"\"\n\n    REQUIRED_COLUMNS: ClassVar[set] = {\"base_line\", \"trend_line\", \"trend_direction\"}\n    OPTIONAL_COLUMNS: ClassVar[set] = {\n        \"uptrend_fill_color\",\n        \"downtrend_fill_color\",\n    }\n\n    # Core fields\n    base_line: float = 0\n    trend_line: float = 0\n    trend_direction: int = 0\n\n    # Fill color fields\n    uptrend_fill_color: Optional[str] = None\n    downtrend_fill_color: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"Validate and process data after initialization.\"\"\"\n        super().__post_init__()\n\n        # Handle NaN values for trend line fields\n        if isinstance(self.trend_line, float) and math.isnan(self.trend_line):\n            self.trend_line = None\n        if isinstance(self.base_line, float) and math.isnan(self.base_line):\n            self.base_line = None\n\n        # Validate trend_direction\n        if not isinstance(self.trend_direction, int):\n            raise TrendDirectionIntegerError(\n                \"trend_direction\",\n                \"integer\",\n                type(self.trend_direction).__name__,\n            )\n\n        if self.trend_direction not in [-1, 0, 1]:\n            raise ValueValidationError(\"trend_direction\", \"must be -1, 0, or 1\")\n\n        # Validate fill colors if provided\n        if self.uptrend_fill_color is not None and not isinstance(self.uptrend_fill_color, str):\n            raise TypeValidationError(\"uptrend_fill_color\", \"string\")\n        if self.downtrend_fill_color is not None and not isinstance(self.downtrend_fill_color, str):\n            raise TypeValidationError(\"downtrend_fill_color\", \"string\")\n\n    @property\n    def is_uptrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents an uptrend.\"\"\"\n        return self.trend_direction == 1\n\n    @property\n    def is_downtrend(self) -&gt; bool:\n        \"\"\"Check if this data point represents a downtrend.\"\"\"\n        return self.trend_direction == -1\n\n    @property\n    def is_neutral(self) -&gt; bool:\n        \"\"\"Check if this data point represents a neutral trend.\"\"\"\n        return self.trend_direction == 0\n\n    @property\n    def has_valid_fill_data(self) -&gt; bool:\n        \"\"\"Check if this data point has valid data for creating fills.\n\n        Returns True if we have a valid trend line and base line,\n        with the appropriate trend line based on direction.\n        \"\"\"\n        if self.trend_direction == 0 or self.base_line is None:\n            return False\n\n        # Check if we have a valid trend line\n        return self.trend_line is not None\n\n    @property\n    def has_valid_uptrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid uptrend fill data.\"\"\"\n        return (\n            self.base_line is not None and self.trend_direction == 1 and self.trend_line is not None\n        )\n\n    @property\n    def has_valid_downtrend_fill(self) -&gt; bool:\n        \"\"\"Check if this data point has valid downtrend fill data.\"\"\"\n        return (\n            self.base_line is not None\n            and self.trend_direction == -1\n            and self.trend_line is not None\n        )\n\n    @property\n    def active_trend_line(self) -&gt; Optional[float]:\n        \"\"\"Get the active trend line value based on trend direction.\n\n        Returns the trend line value for the current trend direction:\n        - Uptrend (+1): Returns trend_line (trend line above price)\n        - Downtrend (-1): Returns trend_line (trend line below price)\n        \"\"\"\n        if self.trend_direction in [1, -1]:  # Both uptrend and downtrend use trend_line\n            return self.trend_line\n        return None\n\n    @property\n    def active_fill_color(self) -&gt; Optional[str]:\n        \"\"\"Get the active fill color based on trend direction.\n\n        Returns the appropriate fill color for the current trend direction,\n        prioritizing direction-specific colors.\n        \"\"\"\n        if self.trend_direction == 1:  # Uptrend\n            return self.uptrend_fill_color\n        if self.trend_direction == -1:  # Downtrend\n            return self.downtrend_fill_color\n        return None\n\n    @property\n    def trend_line_type(self) -&gt; Optional[str]:\n        \"\"\"Get the type of trend line being displayed.\n\n        Returns:\n            'upper' for uptrend (trend line above price)\n            'lower' for downtrend (trend line below price)\n            None for neutral\n        \"\"\"\n        if self.trend_direction == 1:\n            return \"upper\"\n        if self.trend_direction == -1:\n            return \"lower\"\n        return None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData-attributes","title":"Attributes","text":""},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_uptrend","title":"is_uptrend  <code>property</code>","text":"<pre><code>is_uptrend: bool\n</code></pre> <p>Check if this data point represents an uptrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_downtrend","title":"is_downtrend  <code>property</code>","text":"<pre><code>is_downtrend: bool\n</code></pre> <p>Check if this data point represents a downtrend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.is_neutral","title":"is_neutral  <code>property</code>","text":"<pre><code>is_neutral: bool\n</code></pre> <p>Check if this data point represents a neutral trend.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_fill_data","title":"has_valid_fill_data  <code>property</code>","text":"<pre><code>has_valid_fill_data: bool\n</code></pre> <p>Check if this data point has valid data for creating fills.</p> <p>Returns True if we have a valid trend line and base line, with the appropriate trend line based on direction.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_uptrend_fill","title":"has_valid_uptrend_fill  <code>property</code>","text":"<pre><code>has_valid_uptrend_fill: bool\n</code></pre> <p>Check if this data point has valid uptrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.has_valid_downtrend_fill","title":"has_valid_downtrend_fill  <code>property</code>","text":"<pre><code>has_valid_downtrend_fill: bool\n</code></pre> <p>Check if this data point has valid downtrend fill data.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.active_trend_line","title":"active_trend_line  <code>property</code>","text":"<pre><code>active_trend_line: Optional[float]\n</code></pre> <p>Get the active trend line value based on trend direction.</p> <p>Returns the trend line value for the current trend direction: - Uptrend (+1): Returns trend_line (trend line above price) - Downtrend (-1): Returns trend_line (trend line below price)</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.active_fill_color","title":"active_fill_color  <code>property</code>","text":"<pre><code>active_fill_color: Optional[str]\n</code></pre> <p>Get the active fill color based on trend direction.</p> <p>Returns the appropriate fill color for the current trend direction, prioritizing direction-specific colors.</p>"},{"location":"api/streamlit_lightweight_charts_pro/data/trend_fill.html#streamlit_lightweight_charts_pro.data.trend_fill.TrendFillData.trend_line_type","title":"trend_line_type  <code>property</code>","text":"<pre><code>trend_line_type: Optional[str]\n</code></pre> <p>Get the type of trend line being displayed.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>'upper' for uptrend (trend line above price)</p> <code>Optional[str]</code> <p>'lower' for downtrend (trend line below price)</p> <code>Optional[str]</code> <p>None for neutral</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html","title":"streamlit_lightweight_charts_pro.type_definitions.colors","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors","title":"colors","text":"<p>Color-related classes for Streamlit Lightweight Charts Pro.</p> <p>This module provides comprehensive background classes for chart backgrounds with proper validation and type safety. It includes classes for solid colors and gradient backgrounds, with extensive color format validation supporting hex, RGB/RGBA, and named colors commonly used in financial chart visualization.</p> The module provides <ul> <li>BackgroundSolid: For solid color backgrounds with validation</li> <li>BackgroundGradient: For gradient backgrounds with color transitions</li> <li>Background: Union type for both background types</li> <li>Color validation utilities with comprehensive format support</li> <li>Background style enumeration for different rendering modes</li> </ul> <p>These classes ensure type safety, proper color formatting, and validation for chart backgrounds, with automatic validation during initialization and comprehensive error handling for invalid color formats.</p> Key Features <ul> <li>Comprehensive color format validation (hex, RGB, RGBA, named colors)</li> <li>Type-safe background configuration with validation</li> <li>Gradient support with top and bottom color specification</li> <li>Automatic color format normalization and validation</li> <li>Clear error messages for invalid color formats</li> <li>Support for transparency and alpha channels</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.type_definitions.colors import (\n    BackgroundSolid,\n    BackgroundGradient,\n    Background,\n)\n\n# Solid background with validation\nsolid_bg = BackgroundSolid(color=\"#ffffff\")\n\n# Gradient background with color transitions\ngradient_bg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#f0f0f0\")\n\n# Using with charts\nchart = Chart().set_background(solid_bg)\n</code></pre> Supported Color Formats <ul> <li>Hex: \"#FF0000\", \"#F00\" (3 or 6 digit hex codes)</li> <li>RGB: \"rgb(255, 0, 0)\" (with or without spaces)</li> <li>RGBA: \"rgba(255, 0, 0, 0.5)\" (with alpha channel support)</li> <li>Named colors: \"red\", \"blue\", \"white\", \"transparent\", etc.</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors.BackgroundSolid","title":"BackgroundSolid  <code>dataclass</code>","text":"<p>Solid background color configuration.</p> <p>This class represents a solid color background for charts. It provides type safety and validation for color values, ensuring that only valid color formats are accepted.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>The color string in any valid CSS format. Defaults to white.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to SOLID for this class.</p> Example <pre><code># Create a solid white background\nbg = BackgroundSolid(color=\"#ffffff\")\n\n# Create a solid red background\nbg = BackgroundSolid(color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color format is invalid.</p> Note <p>The color attribute is validated during initialization using the is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundSolid(Options, ABC):\n    \"\"\"Solid background color configuration.\n\n    This class represents a solid color background for charts. It provides\n    type safety and validation for color values, ensuring that only valid\n    color formats are accepted.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        color: The color string in any valid CSS format. Defaults to white.\n        style: The background style, always set to SOLID for this class.\n\n    Example:\n        ```python\n        # Create a solid white background\n        bg = BackgroundSolid(color=\"#ffffff\")\n\n        # Create a solid red background\n        bg = BackgroundSolid(color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If the color format is invalid.\n\n    Note:\n        The color attribute is validated during initialization using\n        the is_valid_color function.\n    \"\"\"\n\n    color: str = \"#ffffff\"\n    style: BackgroundStyle = BackgroundStyle.SOLID\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates the color format after the dataclass is initialized.\n        Raises a ValueError if the color is not in a valid format.\n\n        Raises:\n            ValueError: If the color format is invalid.\n        \"\"\"\n        # Validate the color format using the comprehensive validation function\n        # This ensures that only valid CSS color formats are accepted\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong during initialization\n            raise ColorValidationError(\"color\", self.color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors.BackgroundGradient","title":"BackgroundGradient  <code>dataclass</code>","text":"<p>Gradient background configuration.</p> <p>This class represents a gradient background for charts, transitioning from a top color to a bottom color. It provides type safety and validation for both color values.</p> <p>The class inherits from Options and ABC to provide consistent interface with other chart options and enable proper serialization.</p> <p>Attributes:</p> Name Type Description <code>top_color</code> <code>str</code> <p>The top color string in any valid CSS format. Defaults to white.</p> <code>bottom_color</code> <code>str</code> <p>The bottom color string in any valid CSS format. Defaults to black.</p> <code>style</code> <code>BackgroundStyle</code> <p>The background style, always set to VERTICAL_GRADIENT for this class.</p> Example <pre><code># Create a white to black gradient\nbg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n# Create a blue to red gradient\nbg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n# Use with chart\nchart = Chart().set_background(bg)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either color format is invalid.</p> Note <p>Both top_color and bottom_color are validated during initialization using the _is_valid_color function.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/colors.py</code> <pre><code>@dataclass\nclass BackgroundGradient(Options, ABC):\n    \"\"\"Gradient background configuration.\n\n    This class represents a gradient background for charts, transitioning\n    from a top color to a bottom color. It provides type safety and\n    validation for both color values.\n\n    The class inherits from Options and ABC to provide consistent interface\n    with other chart options and enable proper serialization.\n\n    Attributes:\n        top_color: The top color string in any valid CSS format. Defaults to white.\n        bottom_color: The bottom color string in any valid CSS format. Defaults to black.\n        style: The background style, always set to VERTICAL_GRADIENT for this class.\n\n    Example:\n        ```python\n        # Create a white to black gradient\n        bg = BackgroundGradient(top_color=\"#ffffff\", bottom_color=\"#000000\")\n\n        # Create a blue to red gradient\n        bg = BackgroundGradient(top_color=\"blue\", bottom_color=\"red\")\n\n        # Use with chart\n        chart = Chart().set_background(bg)\n        ```\n\n    Raises:\n        ValueError: If either color format is invalid.\n\n    Note:\n        Both top_color and bottom_color are validated during initialization\n        using the _is_valid_color function.\n    \"\"\"\n\n    top_color: str = \"#ffffff\"\n    bottom_color: str = \"#000000\"\n    style: BackgroundStyle = BackgroundStyle.VERTICAL_GRADIENT\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Validates both color formats after the dataclass is initialized.\n        Raises a ValueError if either color is not in a valid format.\n\n        Raises:\n            ValueError: If either color format is invalid.\n        \"\"\"\n        # Validate the top color format using the comprehensive validation function\n        # This ensures that the top color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.top_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the top color\n            raise ColorValidationError(\"top_color\", self.top_color)\n\n        # Validate the bottom color format using the comprehensive validation function\n        # This ensures that the bottom color is in a valid CSS format\n        # The validation supports hex, RGB, RGBA, and named colors\n        if not is_valid_color(self.bottom_color):\n            # Raise a specific validation error with the field name and invalid value\n            # This provides clear feedback about what went wrong with the bottom color\n            raise ColorValidationError(\"bottom_color\", self.bottom_color)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/colors.html#streamlit_lightweight_charts_pro.type_definitions.colors-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html","title":"streamlit_lightweight_charts_pro.type_definitions.enums","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums","title":"enums","text":"<p>Enum definitions for streamlit-lightweight-charts.</p> <p>This module contains comprehensive enumeration types used throughout the library for defining chart types, styling options, configuration parameters, and behavior modes. These enums ensure type safety, provide a consistent interface for chart configuration, and enable IntelliSense support for better developer experience.</p> The module provides enums for <ul> <li>Chart types and visualization modes</li> <li>Color and styling options</li> <li>Line styles and types</li> <li>Crosshair and interaction modes</li> <li>Price scale and time scale configurations</li> <li>Marker positions and shapes</li> <li>Animation and tracking modes</li> </ul> <p>These enums are designed to be compatible with TradingView's Lightweight Charts library while providing a Python-native interface for configuration.</p> Key Features <ul> <li>Type-safe enum values with proper string/int representations</li> <li>Comprehensive coverage of all chart configuration options</li> <li>Clear documentation for each enum value</li> <li>Compatibility with frontend JavaScript enum values</li> <li>IntelliSense support for IDE autocompletion</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.type_definitions.enums import (\n    ChartType,\n    LineStyle,\n    MarkerPosition,\n    PriceScaleMode,\n)\n\n# Use enums for type-safe configuration\nchart_type = ChartType.CANDLESTICK\nline_style = LineStyle.SOLID\nmarker_pos = MarkerPosition.ABOVE_BAR\nscale_mode = PriceScaleMode.NORMAL\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ChartType","title":"ChartType","text":"<p>Chart type enumeration.</p> <p>Defines the available chart types that can be created and rendered. Each chart type corresponds to a specific visualization style and data format requirements.</p> <p>Attributes:</p> Name Type Description <code>AREA</code> <p>Area chart - filled area below a line.</p> <code>BAND</code> <p>Band chart - multiple lines with fill areas (e.g., Bollinger Bands).</p> <code>BASELINE</code> <p>Baseline chart - values relative to a baseline.</p> <code>HISTOGRAM</code> <p>Histogram chart - bar chart for volume or distribution.</p> <code>LINE</code> <p>Line chart - simple line connecting data points.</p> <code>BAR</code> <p>Bar chart - OHLC bars for price data.</p> <code>CANDLESTICK</code> <p>Candlestick chart - traditional Japanese candlesticks.</p> <code>RIBBON</code> <p>Ribbon chart - upper and lower bands with fill areas.</p> <code>GRADIENT_RIBBON</code> <p>Gradient ribbon chart - ribbon with gradient fills.</p> <code>TREND_FILL</code> <p>Trend fill chart - fills between trend lines and candle body midpoints.</p> <code>SIGNAL</code> <p>Signal chart - background coloring based on signal values.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ChartType(str, Enum):\n    \"\"\"Chart type enumeration.\n\n    Defines the available chart types that can be created and rendered.\n    Each chart type corresponds to a specific visualization style and\n    data format requirements.\n\n    Attributes:\n        AREA: Area chart - filled area below a line.\n        BAND: Band chart - multiple lines with fill areas (e.g., Bollinger Bands).\n        BASELINE: Baseline chart - values relative to a baseline.\n        HISTOGRAM: Histogram chart - bar chart for volume or distribution.\n        LINE: Line chart - simple line connecting data points.\n        BAR: Bar chart - OHLC bars for price data.\n        CANDLESTICK: Candlestick chart - traditional Japanese candlesticks.\n        RIBBON: Ribbon chart - upper and lower bands with fill areas.\n        GRADIENT_RIBBON: Gradient ribbon chart - ribbon with gradient fills.\n        TREND_FILL: Trend fill chart - fills between trend lines and candle body midpoints.\n        SIGNAL: Signal chart - background coloring based on signal values.\n    \"\"\"\n\n    AREA = \"area\"\n    BAND = \"band\"\n    BASELINE = \"baseline\"\n    HISTOGRAM = \"histogram\"\n    LINE = \"line\"\n    BAR = \"bar\"\n    CANDLESTICK = \"candlestick\"\n    RIBBON = \"ribbon\"\n    GRADIENT_RIBBON = \"gradient_ribbon\"\n    TREND_FILL = \"trend_fill\"\n    SIGNAL = \"signal\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ColorType","title":"ColorType","text":"<p>Color type enumeration.</p> <p>Defines how colors should be applied to chart elements. Controls whether colors are solid or use gradient effects.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid color - uniform color across the element.</p> <code>VERTICAL_GRADIENT</code> <p>Vertical gradient - color gradient from top to bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColorType(str, Enum):\n    \"\"\"Color type enumeration.\n\n    Defines how colors should be applied to chart elements.\n    Controls whether colors are solid or use gradient effects.\n\n    Attributes:\n        SOLID: Solid color - uniform color across the element.\n        VERTICAL_GRADIENT: Vertical gradient - color gradient from top to bottom.\n    \"\"\"\n\n    SOLID = \"solid\"\n    VERTICAL_GRADIENT = \"gradient\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LineStyle","title":"LineStyle","text":"<p>Line style enumeration.</p> <p>Defines the visual style of lines in charts, including borders, grid lines, and series lines.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid line - continuous line without breaks.</p> <code>DOTTED</code> <p>Dotted line - series of dots.</p> <code>DASHED</code> <p>Dashed line - series of short dashes.</p> <code>LARGE_DASHED</code> <p>Large dashed line - series of long dashes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineStyle(IntEnum):\n    \"\"\"Line style enumeration.\n\n    Defines the visual style of lines in charts, including borders,\n    grid lines, and series lines.\n\n    Attributes:\n        SOLID: Solid line - continuous line without breaks.\n        DOTTED: Dotted line - series of dots.\n        DASHED: Dashed line - series of short dashes.\n        LARGE_DASHED: Large dashed line - series of long dashes.\n    \"\"\"\n\n    SOLID = 0\n    DOTTED = 1\n    DASHED = 2\n    LARGE_DASHED = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LineType","title":"LineType","text":"<p>Line type enumeration.</p> <p>Defines how lines should be drawn between data points. Controls the interpolation method used for line series.</p> <p>Attributes:</p> Name Type Description <code>SIMPLE</code> <p>Simple line - straight lines between points.</p> <code>CURVED</code> <p>Curved line - smooth curves between points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LineType(IntEnum):\n    \"\"\"Line type enumeration.\n\n    Defines how lines should be drawn between data points.\n    Controls the interpolation method used for line series.\n\n    Attributes:\n        SIMPLE: Simple line - straight lines between points.\n        CURVED: Curved line - smooth curves between points.\n    \"\"\"\n\n    SIMPLE = 0\n    WITH_STEPS = 1\n    CURVED = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.CrosshairMode","title":"CrosshairMode","text":"<p>Crosshair mode enumeration.</p> <p>Defines how the crosshair behaves when hovering over the chart. Controls whether the crosshair snaps to data points or moves freely.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal mode - crosshair moves freely across the chart.</p> <code>MAGNET</code> <p>Magnet mode - crosshair snaps to nearest data points.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class CrosshairMode(IntEnum):\n    \"\"\"Crosshair mode enumeration.\n\n    Defines how the crosshair behaves when hovering over the chart.\n    Controls whether the crosshair snaps to data points or moves freely.\n\n    Attributes:\n        NORMAL: Normal mode - crosshair moves freely across the chart.\n        MAGNET: Magnet mode - crosshair snaps to nearest data points.\n    \"\"\"\n\n    NORMAL = 0\n    MAGNET = 1\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.LastPriceAnimationMode","title":"LastPriceAnimationMode","text":"<p>Last price animation mode enumeration.</p> <p>Defines how the last price line should be animated when new data is added to the chart.</p> <p>Attributes:</p> Name Type Description <code>DISABLED</code> <p>No animation - last price line updates instantly.</p> <code>CONTINUOUS</code> <p>Continuous animation - smooth transitions for all updates.</p> <code>ON_DATA_UPDATE</code> <p>Update animation - animation only when new data arrives.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class LastPriceAnimationMode(IntEnum):\n    \"\"\"Last price animation mode enumeration.\n\n    Defines how the last price line should be animated when new data\n    is added to the chart.\n\n    Attributes:\n        DISABLED: No animation - last price line updates instantly.\n        CONTINUOUS: Continuous animation - smooth transitions for all updates.\n        ON_DATA_UPDATE: Update animation - animation only when new data arrives.\n    \"\"\"\n\n    DISABLED = 0\n    CONTINUOUS = 1\n    ON_DATA_UPDATE = 2\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.PriceScaleMode","title":"PriceScaleMode","text":"<p>Price scale mode enumeration.</p> <p>Defines how the price scale (y-axis) should be displayed and calculated. Controls the scale type and reference point for price values.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>Normal scale - linear price scale.</p> <code>LOGARITHMIC</code> <p>Logarithmic scale - log-based price scale.</p> <code>PERCENTAGE</code> <p>Percentage scale - values as percentages.</p> <code>INDEXED_TO_100</code> <p>Indexed scale - values relative to 100.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class PriceScaleMode(IntEnum):\n    \"\"\"Price scale mode enumeration.\n\n    Defines how the price scale (y-axis) should be displayed and calculated.\n    Controls the scale type and reference point for price values.\n\n    Attributes:\n        NORMAL: Normal scale - linear price scale.\n        LOGARITHMIC: Logarithmic scale - log-based price scale.\n        PERCENTAGE: Percentage scale - values as percentages.\n        INDEXED_TO_100: Indexed scale - values relative to 100.\n    \"\"\"\n\n    NORMAL = 0\n    LOGARITHMIC = 1\n    PERCENTAGE = 2\n    INDEXED_TO_100 = 3\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.HorzAlign","title":"HorzAlign","text":"<p>Horizontal alignment enumeration.</p> <p>Defines horizontal text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left alignment - text aligned to the left.</p> <code>CENTER</code> <p>Center alignment - text centered horizontally.</p> <code>RIGHT</code> <p>Right alignment - text aligned to the right.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class HorzAlign(str, Enum):\n    \"\"\"Horizontal alignment enumeration.\n\n    Defines horizontal text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        LEFT: Left alignment - text aligned to the left.\n        CENTER: Center alignment - text centered horizontally.\n        RIGHT: Right alignment - text aligned to the right.\n    \"\"\"\n\n    LEFT = \"left\"\n    CENTER = \"center\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.VertAlign","title":"VertAlign","text":"<p>Vertical alignment enumeration.</p> <p>Defines vertical text alignment for labels, annotations, and other text elements on the chart.</p> <p>Attributes:</p> Name Type Description <code>TOP</code> <p>Top alignment - text aligned to the top.</p> <code>CENTER</code> <p>Center alignment - text centered vertically.</p> <code>BOTTOM</code> <p>Bottom alignment - text aligned to the bottom.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class VertAlign(str, Enum):\n    \"\"\"Vertical alignment enumeration.\n\n    Defines vertical text alignment for labels, annotations, and\n    other text elements on the chart.\n\n    Attributes:\n        TOP: Top alignment - text aligned to the top.\n        CENTER: Center alignment - text centered vertically.\n        BOTTOM: Bottom alignment - text aligned to the bottom.\n    \"\"\"\n\n    TOP = \"top\"\n    CENTER = \"center\"\n    BOTTOM = \"bottom\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TrackingExitMode","title":"TrackingExitMode","text":"<p>Tracking exit mode enumeration.</p> <p>Defines when the tracking mode should exit.</p> <p>Attributes:</p> Name Type Description <code>EXIT_ON_MOVE</code> <p>Exit tracking mode when mouse moves.</p> <code>EXIT_ON_CROSS</code> <p>Exit tracking mode when crosshair crosses series.</p> <code>NEVER_EXIT</code> <p>Never exit tracking mode automatically.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingExitMode(str, Enum):\n    \"\"\"Tracking exit mode enumeration.\n\n    Defines when the tracking mode should exit.\n\n    Attributes:\n        EXIT_ON_MOVE: Exit tracking mode when mouse moves.\n        EXIT_ON_CROSS: Exit tracking mode when crosshair crosses series.\n        NEVER_EXIT: Never exit tracking mode automatically.\n    \"\"\"\n\n    EXIT_ON_MOVE = \"EXIT_ON_MOVE\"\n    EXIT_ON_CROSS = \"EXIT_ON_CROSS\"\n    NEVER_EXIT = \"NEVER_EXIT\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TrackingActivationMode","title":"TrackingActivationMode","text":"<p>Tracking activation mode enumeration.</p> <p>Defines when the tracking mode should be activated.</p> <p>Attributes:</p> Name Type Description <code>ON_MOUSE_ENTER</code> <p>Activate tracking mode when mouse enters chart.</p> <code>ON_TOUCH_START</code> <p>Activate tracking mode when touch starts.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TrackingActivationMode(str, Enum):\n    \"\"\"Tracking activation mode enumeration.\n\n    Defines when the tracking mode should be activated.\n\n    Attributes:\n        ON_MOUSE_ENTER: Activate tracking mode when mouse enters chart.\n        ON_TOUCH_START: Activate tracking mode when touch starts.\n    \"\"\"\n\n    ON_MOUSE_ENTER = \"ON_MOUSE_ENTER\"\n    ON_TOUCH_START = \"ON_TOUCH_START\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.MarkerPosition","title":"MarkerPosition","text":"<p>Marker position enumeration for chart markers.</p> <p>Defines where markers should be positioned relative to the data bars or points on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE_BAR</code> <p>Position marker above the data bar/point.</p> <code>BELOW_BAR</code> <p>Position marker below the data bar/point.</p> <code>IN_BAR</code> <p>Position marker inside the data bar/point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerPosition(str, Enum):\n    \"\"\"Marker position enumeration for chart markers.\n\n    Defines where markers should be positioned relative to the data bars\n    or points on the chart.\n\n    Attributes:\n        ABOVE_BAR: Position marker above the data bar/point.\n        BELOW_BAR: Position marker below the data bar/point.\n        IN_BAR: Position marker inside the data bar/point.\n    \"\"\"\n\n    ABOVE_BAR = \"aboveBar\"\n    BELOW_BAR = \"belowBar\"\n    IN_BAR = \"inBar\"\n    AT_PRICE_TOP = \"atPriceTop\"\n    AT_PRICE_BOTTOM = \"atPriceBottom\"\n    AT_PRICE_MIDDLE = \"atPriceMiddle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.MarkerShape","title":"MarkerShape","text":"<p>Marker shape enumeration for chart markers.</p> <p>Defines the available shapes for chart markers that can be displayed on charts to highlight specific data points or events.</p> <p>Attributes:</p> Name Type Description <code>CIRCLE</code> <p>Circular marker shape.</p> <code>SQUARE</code> <p>Square marker shape.</p> <code>ARROW_UP</code> <p>Upward-pointing arrow marker.</p> <code>ARROW_DOWN</code> <p>Downward-pointing arrow marker.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class MarkerShape(str, Enum):\n    \"\"\"Marker shape enumeration for chart markers.\n\n    Defines the available shapes for chart markers that can be displayed\n    on charts to highlight specific data points or events.\n\n    Attributes:\n        CIRCLE: Circular marker shape.\n        SQUARE: Square marker shape.\n        ARROW_UP: Upward-pointing arrow marker.\n        ARROW_DOWN: Downward-pointing arrow marker.\n    \"\"\"\n\n    CIRCLE = \"circle\"\n    SQUARE = \"square\"\n    ARROW_UP = \"arrowUp\"\n    ARROW_DOWN = \"arrowDown\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.AnnotationType","title":"AnnotationType","text":"<p>Annotation type enumeration.</p> <p>Defines the available types of annotations that can be placed on charts to mark important points, draw shapes, or add visual indicators.</p> <p>Attributes:</p> Name Type Description <code>TEXT</code> <p>Text annotation - displays text at a specific location.</p> <code>ARROW</code> <p>Arrow annotation - points to a specific location with an arrow.</p> <code>SHAPE</code> <p>Shape annotation - draws geometric shapes (circles, squares, etc.).</p> <code>LINE</code> <p>Line annotation - draws horizontal or vertical lines.</p> <code>RECTANGLE</code> <p>Rectangle annotation - draws rectangular shapes.</p> <code>CIRCLE</code> <p>Circle annotation - draws circular shapes.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationType(str, Enum):\n    \"\"\"Annotation type enumeration.\n\n    Defines the available types of annotations that can be placed on charts\n    to mark important points, draw shapes, or add visual indicators.\n\n    Attributes:\n        TEXT: Text annotation - displays text at a specific location.\n        ARROW: Arrow annotation - points to a specific location with an arrow.\n        SHAPE: Shape annotation - draws geometric shapes (circles, squares, etc.).\n        LINE: Line annotation - draws horizontal or vertical lines.\n        RECTANGLE: Rectangle annotation - draws rectangular shapes.\n        CIRCLE: Circle annotation - draws circular shapes.\n    \"\"\"\n\n    TEXT = \"text\"\n    ARROW = \"arrow\"\n    SHAPE = \"shape\"\n    LINE = \"line\"\n    RECTANGLE = \"rectangle\"\n    CIRCLE = \"circle\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.AnnotationPosition","title":"AnnotationPosition","text":"<p>Annotation position enumeration.</p> <p>Defines where annotations should be positioned relative to the data point or price level on the chart.</p> <p>Attributes:</p> Name Type Description <code>ABOVE</code> <p>Position annotation above the data point.</p> <code>BELOW</code> <p>Position annotation below the data point.</p> <code>INLINE</code> <p>Position annotation inline with the data point.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class AnnotationPosition(str, Enum):\n    \"\"\"Annotation position enumeration.\n\n    Defines where annotations should be positioned relative to the data point\n    or price level on the chart.\n\n    Attributes:\n        ABOVE: Position annotation above the data point.\n        BELOW: Position annotation below the data point.\n        INLINE: Position annotation inline with the data point.\n    \"\"\"\n\n    ABOVE = \"above\"\n    BELOW = \"below\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.ColumnNames","title":"ColumnNames","text":"<p>Column name enumeration for DataFrame integration.</p> <p>Defines the standard column names used when converting pandas DataFrames to chart data. These names ensure consistent mapping between DataFrame columns and chart data fields.</p> <p>Attributes:</p> Name Type Description <code>TIME</code> <p>Time or datetime column.</p> <code>OPEN</code> <p>Open price column (for OHLC data).</p> <code>HIGH</code> <p>High price column (for OHLC data).</p> <code>LOW</code> <p>Low price column (for OHLC data).</p> <code>CLOSE</code> <p>Close price column (for OHLC data).</p> <code>VOLUME</code> <p>Volume column (for OHLCV data).</p> <code>DATETIME</code> <p>Datetime column (alternative to TIME).</p> <code>VALUE</code> <p>Value column (for single-value data like line charts).</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class ColumnNames(str, Enum):\n    \"\"\"Column name enumeration for DataFrame integration.\n\n    Defines the standard column names used when converting pandas DataFrames\n    to chart data. These names ensure consistent mapping between DataFrame\n    columns and chart data fields.\n\n    Attributes:\n        TIME: Time or datetime column.\n        OPEN: Open price column (for OHLC data).\n        HIGH: High price column (for OHLC data).\n        LOW: Low price column (for OHLC data).\n        CLOSE: Close price column (for OHLC data).\n        VOLUME: Volume column (for OHLCV data).\n        DATETIME: Datetime column (alternative to TIME).\n        VALUE: Value column (for single-value data like line charts).\n    \"\"\"\n\n    TIME = \"time\"\n    OPEN = \"open\"\n    HIGH = \"high\"\n    LOW = \"low\"\n    CLOSE = \"close\"\n    VOLUME = \"volume\"\n    DATETIME = \"datetime\"\n    VALUE = \"value\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TradeType","title":"TradeType","text":"<p>Trade type enumeration.</p> <p>Defines the direction of a trade (long or short). Used for trade visualization and profit/loss calculations.</p> <p>Attributes:</p> Name Type Description <code>LONG</code> <p>Long trade - profit when price goes up.</p> <code>SHORT</code> <p>Short trade - profit when price goes down.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeType(str, Enum):\n    \"\"\"Trade type enumeration.\n\n    Defines the direction of a trade (long or short).\n    Used for trade visualization and profit/loss calculations.\n\n    Attributes:\n        LONG: Long trade - profit when price goes up.\n        SHORT: Short trade - profit when price goes down.\n    \"\"\"\n\n    LONG = \"long\"\n    SHORT = \"short\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TradeVisualization","title":"TradeVisualization","text":"<p>Trade visualization style enumeration.</p> <p>Defines how trades should be visualized on the chart. Multiple visualization styles can be combined to create comprehensive trade displays.</p> <p>Attributes:</p> Name Type Description <code>MARKERS</code> <p>Display entry/exit markers only.</p> <code>RECTANGLES</code> <p>Display rectangle spanning from entry to exit.</p> <code>BOTH</code> <p>Display both markers and rectangles.</p> <code>LINES</code> <p>Display connecting lines between entry and exit.</p> <code>ARROWS</code> <p>Display directional arrows from entry to exit.</p> <code>ZONES</code> <p>Display colored zones with transparency around trades.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TradeVisualization(str, Enum):\n    \"\"\"Trade visualization style enumeration.\n\n    Defines how trades should be visualized on the chart.\n    Multiple visualization styles can be combined to create\n    comprehensive trade displays.\n\n    Attributes:\n        MARKERS: Display entry/exit markers only.\n        RECTANGLES: Display rectangle spanning from entry to exit.\n        BOTH: Display both markers and rectangles.\n        LINES: Display connecting lines between entry and exit.\n        ARROWS: Display directional arrows from entry to exit.\n        ZONES: Display colored zones with transparency around trades.\n    \"\"\"\n\n    MARKERS = \"markers\"  # Just entry/exit markers\n    RECTANGLES = \"rectangles\"  # Rectangle from entry to exit\n    BOTH = \"both\"  # Both markers and rectangles\n    LINES = \"lines\"  # Lines connecting entry to exit\n    ARROWS = \"arrows\"  # Arrows from entry to exit\n    ZONES = \"zones\"  # Colored zones with transparency\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.BackgroundStyle","title":"BackgroundStyle","text":"<p>Background style enumeration.</p> <p>Defines how chart backgrounds should be styled. Controls whether backgrounds use solid colors or gradients.</p> <p>Attributes:</p> Name Type Description <code>SOLID</code> <p>Solid background color.</p> <code>VERTICAL_GRADIENT</code> <p>Vertical gradient background.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class BackgroundStyle(str, Enum):\n    \"\"\"Background style enumeration.\n\n    Defines how chart backgrounds should be styled.\n    Controls whether backgrounds use solid colors or gradients.\n\n    Attributes:\n        SOLID: Solid background color.\n        VERTICAL_GRADIENT: Vertical gradient background.\n    \"\"\"\n\n    SOLID = \"solid\"\n    VERTICAL_GRADIENT = \"gradient\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.PriceLineSource","title":"PriceLineSource","text":"<p>Price line source enumeration.</p> <p>Defines the source to use for the value of the price line. Controls which data point determines the price line position.</p> <p>Attributes:</p> Name Type Description <code>LAST_BAR</code> <p>Last bar - use the last visible bar's price.</p> <code>LAST_VISIBLE</code> <p>Last visible - use the last visible data point's price.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class PriceLineSource(str, Enum):\n    \"\"\"Price line source enumeration.\n\n    Defines the source to use for the value of the price line.\n    Controls which data point determines the price line position.\n\n    Attributes:\n        LAST_BAR: Last bar - use the last visible bar's price.\n        LAST_VISIBLE: Last visible - use the last visible data point's price.\n    \"\"\"\n\n    LAST_BAR = \"lastBar\"\n    LAST_VISIBLE = \"lastVisible\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TooltipType","title":"TooltipType","text":"<p>Tooltip type enumeration.</p> <p>Defines the types of tooltips supported by the system. Each type corresponds to a specific data format and display style.</p> <p>Attributes:</p> Name Type Description <code>OHLC</code> <p>OHLC tooltip - displays open, high, low, close, and volume data.</p> <code>SINGLE</code> <p>Single value tooltip - displays a single data value.</p> <code>MULTI</code> <p>Multi-series tooltip - displays data from multiple series.</p> <code>CUSTOM</code> <p>Custom tooltip - displays custom content using templates.</p> <code>TRADE</code> <p>Trade tooltip - displays trade information (entry, exit, P&amp;L).</p> <code>MARKER</code> <p>Marker tooltip - displays marker-specific information.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipType(str, Enum):\n    \"\"\"Tooltip type enumeration.\n\n    Defines the types of tooltips supported by the system.\n    Each type corresponds to a specific data format and display style.\n\n    Attributes:\n        OHLC: OHLC tooltip - displays open, high, low, close, and volume data.\n        SINGLE: Single value tooltip - displays a single data value.\n        MULTI: Multi-series tooltip - displays data from multiple series.\n        CUSTOM: Custom tooltip - displays custom content using templates.\n        TRADE: Trade tooltip - displays trade information (entry, exit, P&amp;L).\n        MARKER: Marker tooltip - displays marker-specific information.\n    \"\"\"\n\n    OHLC = \"ohlc\"\n    SINGLE = \"single\"\n    MULTI = \"multi\"\n    CUSTOM = \"custom\"\n    TRADE = \"trade\"\n    MARKER = \"marker\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/type_definitions/enums.html#streamlit_lightweight_charts_pro.type_definitions.enums.TooltipPosition","title":"TooltipPosition","text":"<p>Tooltip position enumeration.</p> <p>Defines how tooltips should be positioned relative to the cursor or chart elements.</p> <p>Attributes:</p> Name Type Description <code>CURSOR</code> <p>Cursor position - tooltip follows the mouse cursor.</p> <code>FIXED</code> <p>Fixed position - tooltip appears at a fixed location.</p> <code>AUTO</code> <p>Auto position - tooltip position is automatically determined.</p> Source code in <code>streamlit_lightweight_charts_pro/type_definitions/enums.py</code> <pre><code>class TooltipPosition(str, Enum):\n    \"\"\"Tooltip position enumeration.\n\n    Defines how tooltips should be positioned relative to the cursor\n    or chart elements.\n\n    Attributes:\n        CURSOR: Cursor position - tooltip follows the mouse cursor.\n        FIXED: Fixed position - tooltip appears at a fixed location.\n        AUTO: Auto position - tooltip position is automatically determined.\n    \"\"\"\n\n    CURSOR = \"cursor\"\n    FIXED = \"fixed\"\n    AUTO = \"auto\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html","title":"streamlit_lightweight_charts_pro.types.series_config_types","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types","title":"series_config_types","text":"<p>Type definitions for series configuration system.</p>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChange","title":"SeriesConfigChange  <code>dataclass</code>","text":"<p>Represents a single series configuration change from frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"pane_id\", int)\n@chainable_field(\"series_id\", str)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"config\", dict)\n@chainable_field(\"timestamp\", int)\n@chainable_field(\"chart_id\", str)\nclass SeriesConfigChange(Options):\n    \"\"\"Represents a single series configuration change from frontend.\"\"\"\n\n    pane_id: int = 0\n    series_id: str = \"\"\n    series_type: str = \"\"\n    config: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n    chart_id: Optional[str] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigState","title":"SeriesConfigState  <code>dataclass</code>","text":"<p>Represents the complete series configuration state structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"config\", dict)\n@chainable_field(\"series_type\", str)\n@chainable_field(\"last_modified\", int)\nclass SeriesConfigState(Options):\n    \"\"\"Represents the complete series configuration state structure.\"\"\"\n\n    config: Dict[str, Any] = field(default_factory=dict)\n    series_type: str = \"\"\n    last_modified: int = 0\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigBackendData","title":"SeriesConfigBackendData  <code>dataclass</code>","text":"<p>Backend data passed to frontend for series configuration initialization.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"complete_state\", dict)\nclass SeriesConfigBackendData(Options):\n    \"\"\"Backend data passed to frontend for series configuration initialization.\"\"\"\n\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult","title":"SeriesConfigChangesResult  <code>dataclass</code>","text":"<p>Result object from frontend containing series configuration changes.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"type\", str)\n@chainable_field(\"changes\", list)\n@chainable_field(\"complete_state\", dict)\n@chainable_field(\"timestamp\", int)\nclass SeriesConfigChangesResult(Options):\n    \"\"\"Result object from frontend containing series configuration changes.\"\"\"\n\n    type: str = \"series_config_changes\"\n    changes: list[SeriesConfigChange] = field(default_factory=list)\n    complete_state: Dict[str, Any] = field(default_factory=dict)\n    timestamp: int = 0\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n        \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n        changes = [\n            SeriesConfigChange.fromdict(change_data) for change_data in data.get(\"changes\", [])\n        ]\n\n        return cls(\n            type=data.get(\"type\", \"series_config_changes\"),\n            changes=changes,\n            complete_state=data.get(\"completeState\", {}),\n            timestamp=data.get(\"timestamp\", 0),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigChangesResult.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfigChangesResult\n</code></pre> <p>Create from dictionary with proper change object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfigChangesResult\":\n    \"\"\"Create from dictionary with proper change object conversion.\"\"\"\n    changes = [\n        SeriesConfigChange.fromdict(change_data) for change_data in data.get(\"changes\", [])\n    ]\n\n    return cls(\n        type=data.get(\"type\", \"series_config_changes\"),\n        changes=changes,\n        complete_state=data.get(\"completeState\", {}),\n        timestamp=data.get(\"timestamp\", 0),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfigPersistenceOptions","title":"SeriesConfigPersistenceOptions  <code>dataclass</code>","text":"<p>Options for series configuration persistence.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"enabled\", bool)\n@chainable_field(\"auto_save\", bool)\n@chainable_field(\"session_key\", str)\n@chainable_field(\"export_format\", str)\nclass SeriesConfigPersistenceOptions(Options):\n    \"\"\"Options for series configuration persistence.\"\"\"\n\n    enabled: bool = True\n    auto_save: bool = True\n    session_key: str = \"series_configs\"\n    export_format: Literal[\"json\", \"yaml\"] = \"json\"\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesStyleConfig","title":"SeriesStyleConfig  <code>dataclass</code>","text":"<p>Style configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"color\", str)\n@chainable_field(\"opacity\", float)\n@chainable_field(\"line_width\", int)\n@chainable_field(\"line_style\", str)\n@chainable_field(\"last_price_visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"base_line_visible\", bool)\n@chainable_field(\"base_line_color\", str)\n@chainable_field(\"base_line_style\", str)\n@chainable_field(\"base_line_width\", int)\nclass SeriesStyleConfig(Options):\n    \"\"\"Style configuration options for series.\"\"\"\n\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    base_line_visible: Optional[bool] = None\n    base_line_color: Optional[str] = None\n    base_line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    base_line_width: Optional[int] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesVisibilityConfig","title":"SeriesVisibilityConfig  <code>dataclass</code>","text":"<p>Visibility configuration options for series.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"visible\", bool)\n@chainable_field(\"price_line_visible\", bool)\n@chainable_field(\"last_value_visible\", bool)\n@chainable_field(\"title\", str)\n@chainable_field(\"price_format\", dict)\n@chainable_field(\"precision\", int)\n@chainable_field(\"min_move\", float)\nclass SeriesVisibilityConfig(Options):\n    \"\"\"Visibility configuration options for series.\"\"\"\n\n    visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    last_value_visible: Optional[bool] = None\n    title: Optional[str] = None\n    price_format: Optional[Dict[str, Any]] = None\n    precision: Optional[int] = None\n    min_move: Optional[float] = None\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesInputConfig","title":"SeriesInputConfig  <code>dataclass</code>","text":"<p>Input configuration options for series (series-specific parameters).</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\nclass SeriesInputConfig(Options):\n    \"\"\"Input configuration options for series (series-specific parameters).\"\"\"\n\n    # This will contain series-specific properties dynamically\n    # Examples for different series types:\n    # Line series: none typically\n    # Candlestick: upColor, downColor, wickUpColor, wickDownColor\n    # Histogram: base value\n    # Area: topColor, bottomColor\n    # Ribbon: upperLineColor, lowerLineColor, fillColor\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize with dynamic properties based on series type.\"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration","title":"SeriesConfiguration  <code>dataclass</code>","text":"<p>Complete series configuration structure.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@dataclass\n@chainable_field(\"style\", SeriesStyleConfig)\n@chainable_field(\"visibility\", SeriesVisibilityConfig)\n@chainable_field(\"inputs\", SeriesInputConfig)\nclass SeriesConfiguration(Options):\n    \"\"\"Complete series configuration structure.\"\"\"\n\n    style: Optional[SeriesStyleConfig] = None\n    visibility: Optional[SeriesVisibilityConfig] = None\n    inputs: Optional[SeriesInputConfig] = None\n\n    # Legacy support for flat structure (backwards compatibility)\n    color: Optional[str] = None\n    opacity: Optional[float] = None\n    line_width: Optional[int] = None\n    line_style: Optional[Literal[\"solid\", \"dashed\", \"dotted\"]] = None\n    last_price_visible: Optional[bool] = None\n    price_line_visible: Optional[bool] = None\n    visible: Optional[bool] = None\n\n    @classmethod\n    def fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n        \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n        style = None\n        if \"style\" in data:\n            style = SeriesStyleConfig.fromdict(data[\"style\"])\n\n        visibility = None\n        if \"visibility\" in data:\n            visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])\n\n        inputs = None\n        if \"inputs\" in data:\n            inputs = SeriesInputConfig.fromdict(data[\"inputs\"])\n\n        return cls(\n            style=style,\n            visibility=visibility,\n            inputs=inputs,\n            # Legacy flat properties\n            color=data.get(\"color\"),\n            opacity=data.get(\"opacity\"),\n            line_width=data.get(\"lineWidth\"),\n            line_style=data.get(\"lineStyle\"),\n            last_price_visible=data.get(\"lastPriceVisible\"),\n            price_line_visible=data.get(\"priceLineVisible\"),\n            visible=data.get(\"visible\"),\n        )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types.SeriesConfiguration.fromdict","title":"fromdict  <code>classmethod</code>","text":"<pre><code>fromdict(data: dict) -&gt; SeriesConfiguration\n</code></pre> <p>Create from dictionary with proper nested object conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/types/series_config_types.py</code> <pre><code>@classmethod\ndef fromdict(cls, data: dict) -&gt; \"SeriesConfiguration\":\n    \"\"\"Create from dictionary with proper nested object conversion.\"\"\"\n    style = None\n    if \"style\" in data:\n        style = SeriesStyleConfig.fromdict(data[\"style\"])\n\n    visibility = None\n    if \"visibility\" in data:\n        visibility = SeriesVisibilityConfig.fromdict(data[\"visibility\"])\n\n    inputs = None\n    if \"inputs\" in data:\n        inputs = SeriesInputConfig.fromdict(data[\"inputs\"])\n\n    return cls(\n        style=style,\n        visibility=visibility,\n        inputs=inputs,\n        # Legacy flat properties\n        color=data.get(\"color\"),\n        opacity=data.get(\"opacity\"),\n        line_width=data.get(\"lineWidth\"),\n        line_style=data.get(\"lineStyle\"),\n        last_price_visible=data.get(\"lastPriceVisible\"),\n        price_line_visible=data.get(\"priceLineVisible\"),\n        visible=data.get(\"visible\"),\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/types/series_config_types.html#streamlit_lightweight_charts_pro.types.series_config_types-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html","title":"streamlit_lightweight_charts_pro.utils.chainable","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable","title":"chainable","text":"<p>Chainable decorators for enabling fluent API design in financial chart configuration.</p> <p>This module provides powerful decorators that automatically create setter methods for properties and dataclass fields, enabling both direct assignment and method chaining styles with comprehensive type validation and error handling.</p> <p>The module implements the fluent API design pattern used throughout the library, allowing for intuitive and readable method chaining when building charts and configuring options. This creates a more developer-friendly experience while maintaining type safety and validation.</p> Key Features <ul> <li>Automatic type validation with customizable validators</li> <li>Support for both property assignment and method chaining</li> <li>Built-in validators for common chart types (colors, precision, etc.)</li> <li>Special handling for complex types (marker lists, nested objects)</li> <li>Optional None value support for flexible configuration</li> <li>Top-level property configuration for serialization control</li> <li>Comprehensive error handling with descriptive messages</li> <li>Support for Union types and generic type checking</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils import chainable_property, chainable_field\nfrom dataclasses import dataclass\n\n\n# Using chainable_property for class properties\n@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"width\", int)\nclass ChartConfig:\n    def __init__(self):\n        self._color = \"#000000\"\n        self._width = 800\n\n\n# Using chainable_field for dataclass fields\n@dataclass\n@chainable_field(\"color\", str)\n@chainable_field(\"width\", int)\nclass Options:\n    color: str = \"#000000\"\n    width: int = 800\n\n\n# Usage examples\nconfig = ChartConfig()\nconfig.color = \"#ff0000\"  # Direct property assignment\nconfig.set_width(600).set_color(\"#00ff00\")  # Method chaining\n</code></pre> Built-in Validators <ul> <li>\"color\": Validates hex color codes and rgba values</li> <li>\"price_format_type\": Validates price format types</li> <li>\"precision\": Validates precision values for price formatting</li> <li>\"min_move\": Validates minimum move values for price scales</li> </ul> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable.chainable_property","title":"chainable_property","text":"<pre><code>chainable_property(\n    attr_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[\n        Union[Callable[[Any], Any], str]\n    ] = None,\n    allow_none: bool = False,\n    top_level: bool = False,\n)\n</code></pre> <p>Decorator that creates both a property setter and a chaining method with optional validation.</p> <p>This decorator enables two usage patterns for the same attribute: 1. Property assignment: <code>obj.attr = value</code> 2. Method chaining: <code>obj.set_attr(value).other_method()</code></p> <p>The decorator automatically creates both the property setter and a chaining method, applying the same validation logic to both. This provides flexibility in how developers interact with the API while maintaining consistency.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of the attribute to manage. This will be used to create both the property name and the setter method name (e.g., \"color\" creates both a \"color\" property and a \"set_color\" method).</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>Whether to allow None values. If True, None values bypass type validation but still go through custom validators.</p> <code>False</code> <code>top_level</code> <code>bool</code> <p>Whether this property should be output at the top level in asdict() instead of in the options dictionary. Useful for properties that should be serialized separately from the main options.</p> <code>False</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add both property and method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the attribute name conflicts with existing attributes.</p> Example <pre><code>@chainable_property(\"color\", str, validator=\"color\")\n@chainable_property(\"width\", int)\n@chainable_property(\"line_options\", LineOptions, allow_none=True)\n@chainable_property(\"base_value\", validator=validate_base_value)\n@chainable_property(\"price_scale_id\", top_level=True)\nclass MySeries(Series):\n    def __init__(self):\n        self._color = \"#000000\"\n        self._width = 800\n        self._line_options = None\n        self._base_value = 0\n        self._price_scale_id = \"right\"\n\n\n# Usage examples\nseries = MySeries()\n\n# Property assignment\nseries.color = \"#ff0000\"\nseries.width = 600\n\n# Method chaining\nseries.set_color(\"#00ff00\").set_width(800)\n\n# With validation\nseries.set_color(\"invalid\")  # Raises ValueError\nseries.set_width(\"not_a_number\")  # Raises TypeError\n</code></pre> Note <p>The decorator creates both a property setter and a method, so the class must have the corresponding private attribute (e.g., <code>_color</code> for <code>color</code>). The property getter is not created automatically - you may need to add it manually if needed.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_property(\n    attr_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n    allow_none: bool = False,\n    top_level: bool = False,\n):\n    \"\"\"Decorator that creates both a property setter and a chaining method with optional validation.\n\n    This decorator enables two usage patterns for the same attribute:\n    1. Property assignment: `obj.attr = value`\n    2. Method chaining: `obj.set_attr(value).other_method()`\n\n    The decorator automatically creates both the property setter and a chaining\n    method, applying the same validation logic to both. This provides flexibility\n    in how developers interact with the API while maintaining consistency.\n\n    Args:\n        attr_name: The name of the attribute to manage. This will be used to create\n            both the property name and the setter method name (e.g., \"color\" creates\n            both a \"color\" property and a \"set_color\" method).\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n        allow_none: Whether to allow None values. If True, None values bypass\n            type validation but still go through custom validators.\n        top_level: Whether this property should be output at the top level in\n            asdict() instead of in the options dictionary. Useful for properties\n            that should be serialized separately from the main options.\n\n    Returns:\n        Decorator function that modifies the class to add both property and method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the attribute name conflicts with existing attributes.\n\n    Example:\n        ```python\n        @chainable_property(\"color\", str, validator=\"color\")\n        @chainable_property(\"width\", int)\n        @chainable_property(\"line_options\", LineOptions, allow_none=True)\n        @chainable_property(\"base_value\", validator=validate_base_value)\n        @chainable_property(\"price_scale_id\", top_level=True)\n        class MySeries(Series):\n            def __init__(self):\n                self._color = \"#000000\"\n                self._width = 800\n                self._line_options = None\n                self._base_value = 0\n                self._price_scale_id = \"right\"\n\n\n        # Usage examples\n        series = MySeries()\n\n        # Property assignment\n        series.color = \"#ff0000\"\n        series.width = 600\n\n        # Method chaining\n        series.set_color(\"#00ff00\").set_width(800)\n\n        # With validation\n        series.set_color(\"invalid\")  # Raises ValueError\n        series.set_width(\"not_a_number\")  # Raises TypeError\n        ```\n\n    Note:\n        The decorator creates both a property setter and a method, so the class\n        must have the corresponding private attribute (e.g., `_color` for `color`).\n        The property getter is not created automatically - you may need to add\n        it manually if needed.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the class.\n\n        Args:\n            cls: The class to be decorated.\n\n        Returns:\n            The modified class with added property and setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{attr_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return self\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # Case 1: Boolean type - strict validation (no truthy/falsy coercion)\n                    # Only accept actual True/False, not 1/0 or other truthy values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif not isinstance(value, value_type):\n                    # Case 2: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # Case 3: Complex types (classes, custom types)\n                        # Indicate whether None is allowed in the error message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # Case 4: Union types like (int, float)\n                        # Create friendly error message from type names\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        # Special handling for numeric union types\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Step 3: Apply custom validation if specified\n            # Custom validators can transform values or perform additional checks\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Case 1: Built-in validators (string identifiers)\n                    # These are predefined validators for common chart properties\n                    if validator == \"color\":\n                        # Color validator: Accepts hex codes and rgba values\n                        # Empty string is treated as \"no color\" (converted to None)\n                        if value == \"\":\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        # Price format type validator\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        # Precision validator (for decimal places)\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        # Minimum move validator (for price scales)\n                        value = validate_min_move(value)\n                    else:\n                        # Unknown validator string\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Case 2: Custom validator function\n                    # Allows users to provide their own validation/transformation logic\n                    value = validator(value)\n\n            # Step 4: Set the validated value on the private attribute\n            # Uses the private attribute convention (_attr_name)\n            setattr(self, f\"_{attr_name}\", value)\n\n            # Step 5: Return self to enable method chaining\n            return self\n\n        def property_getter(self):\n            \"\"\"Property getter for accessing the attribute value.\n\n            Args:\n                self: The instance.\n\n            Returns:\n                The current value of the attribute.\n            \"\"\"\n            return getattr(self, f\"_{attr_name}\")\n\n        def property_setter(self, value):\n            \"\"\"Property setter for direct assignment with validation.\n\n            Args:\n                self: The instance being modified.\n                value: The new value to set.\n            \"\"\"\n            # Step 1: Handle None values early if they're allowed\n            # This bypasses all validation when None is explicitly permitted\n            if value is None and allow_none:\n                setattr(self, f\"_{attr_name}\", None)\n                return\n\n            # Step 2: Apply type validation if specified\n            # Checks that the value matches the expected type before assignment\n            if value_type is not None:\n                if value_type is bool:\n                    # For boolean properties, only accept actual boolean values\n                    if not isinstance(value, bool):\n                        raise TypeValidationError(attr_name, \"boolean\")\n                elif _is_list_of_markers(value_type):\n                    # Case 2a: Special handling for List[MarkerBase] and similar types\n                    # Markers require special validation due to their complex structure\n                    _validate_list_of_markers(value, attr_name)\n                elif not isinstance(value, value_type):\n                    # Case 2b: Type mismatch - create user-friendly error messages\n                    # Provide specific error messages for common types\n                    if value_type is str:\n                        raise TypeValidationError(attr_name, \"string\")\n                    if value_type is int:\n                        raise TypeValidationError(attr_name, \"integer\")\n                    if value_type is float:\n                        raise TypeValidationError(attr_name, \"number\")\n                    if value_type is bool:\n                        raise TypeValidationError(attr_name, \"boolean\")\n                    if hasattr(value_type, \"__name__\"):\n                        # For complex types, use a more user-friendly message\n                        if allow_none:\n                            raise InstanceTypeError(attr_name, value_type, allow_none=True)\n                        raise InstanceTypeError(attr_name, value_type)\n                    if isinstance(value_type, tuple):\n                        # For tuple types like (int, float), create a user-friendly message\n                        type_names = [\n                            t.__name__ if hasattr(t, \"__name__\") else str(t) for t in value_type\n                        ]\n                        if len(type_names) == 2 and \"int\" in type_names and \"float\" in type_names:\n                            raise TypeValidationError(attr_name, \"number\")\n                        raise TypeMismatchError(attr_name, value_type, type(value))\n\n            # Apply custom validation if specified\n            if validator is not None:\n                if isinstance(validator, str):\n                    # Built-in validators\n                    if validator == \"color\":\n                        # Treat empty strings as valid (meaning \"no color\")\n                        if value == \"\":\n                            # Convert empty string to None for consistent handling\n                            value = None\n                        elif not is_valid_color(value):\n                            raise ColorValidationError(attr_name, value)\n                    elif validator == \"price_format_type\":\n                        value = validate_price_format_type(value)\n                    elif validator == \"precision\":\n                        value = validate_precision(value)\n                    elif validator == \"min_move\":\n                        value = validate_min_move(value)\n                    else:\n                        raise ValueValidationError(\"validator\", \"unknown validator\")\n                else:\n                    # Custom validator function\n                    value = validator(value)\n\n            setattr(self, f\"_{attr_name}\", value)\n\n        # Create the property\n        prop = property(property_getter, property_setter)\n\n        # Add the property and method to the class\n        setattr(cls, attr_name, prop)\n        setattr(cls, setter_name, setter_method)\n\n        # Store metadata about serialization\n        if not hasattr(cls, \"_chainable_properties\"):\n            # pylint: disable=protected-access\n            cls._chainable_properties = {}\n\n        # pylint: disable=protected-access\n        cls._chainable_properties[attr_name] = {\n            \"allow_none\": allow_none,\n            \"value_type\": value_type,\n            \"top_level\": top_level,\n        }\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/chainable.html#streamlit_lightweight_charts_pro.utils.chainable.chainable_field","title":"chainable_field","text":"<pre><code>chainable_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[\n        Union[Callable[[Any], Any], str]\n    ] = None,\n)\n</code></pre> <p>Decorator that creates a setter method for dataclass fields with optional validation.</p> <p>This decorator enables method chaining for dataclass fields by creating a setter method that applies validation and returns the instance for chaining. Unlike chainable_property, this only creates the method and doesn't override direct assignment behavior.</p> <p>The created method follows the naming convention <code>set_{field_name}</code> and applies the same validation logic as chainable_property, but only when the method is explicitly called.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the dataclass field to create a setter for. The method will be named <code>set_{field_name}</code>.</p> required <code>value_type</code> <code>Optional[Union[Type, tuple]]</code> <p>Optional type or tuple of types for validation. If provided, the value will be checked against this type before assignment. Common types: str, int, float, bool, or custom classes.</p> <code>None</code> <code>validator</code> <code>Optional[Union[Callable[[Any], Any], str]]</code> <p>Optional validation function or string identifier. If callable, it should take a value and return the validated/transformed value. If string, uses built-in validators: \"color\", \"price_format_type\", \"precision\", \"min_move\".</p> <code>None</code> <p>Returns:</p> Type Description <p>Decorator function that modifies the class to add a setter method.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the specified type.</p> <code>ValueError</code> <p>If the value fails custom validation.</p> <code>AttributeError</code> <p>If the field name conflicts with existing attributes.</p> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n@dataclass\n@chainable_field(\"color\", str, validator=\"color\")\n@chainable_field(\"width\", int)\n@chainable_field(\"line_options\", LineOptions)\nclass MyOptions:\n    color: str = \"#000000\"\n    width: int = 800\n    line_options: Optional[LineOptions] = None\n\n\n# Usage examples\noptions = MyOptions()\n\n# Method chaining (with validation)\noptions.set_color(\"#ff0000\").set_width(600)\n\n# Direct assignment (no validation)\noptions.color = \"invalid_color\"  # No validation applied\noptions.set_color(\"invalid_color\")  # Raises ValueError\n</code></pre> Note <p>Direct assignment to dataclass fields bypasses validation. Use the generated setter methods when validation is required.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/chainable.py</code> <pre><code>def chainable_field(\n    field_name: str,\n    value_type: Optional[Union[Type, tuple]] = None,\n    validator: Optional[Union[Callable[[Any], Any], str]] = None,\n):\n    \"\"\"Decorator that creates a setter method for dataclass fields with optional validation.\n\n    This decorator enables method chaining for dataclass fields by creating a setter\n    method that applies validation and returns the instance for chaining. Unlike\n    chainable_property, this only creates the method and doesn't override direct\n    assignment behavior.\n\n    The created method follows the naming convention `set_{field_name}` and applies\n    the same validation logic as chainable_property, but only when the method is\n    explicitly called.\n\n    Args:\n        field_name: The name of the dataclass field to create a setter for.\n            The method will be named `set_{field_name}`.\n        value_type: Optional type or tuple of types for validation. If provided,\n            the value will be checked against this type before assignment.\n            Common types: str, int, float, bool, or custom classes.\n        validator: Optional validation function or string identifier. If callable,\n            it should take a value and return the validated/transformed value.\n            If string, uses built-in validators: \"color\", \"price_format_type\",\n            \"precision\", \"min_move\".\n\n    Returns:\n        Decorator function that modifies the class to add a setter method.\n\n    Raises:\n        TypeError: If the value doesn't match the specified type.\n        ValueError: If the value fails custom validation.\n        AttributeError: If the field name conflicts with existing attributes.\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils import chainable_field\n\n\n        @dataclass\n        @chainable_field(\"color\", str, validator=\"color\")\n        @chainable_field(\"width\", int)\n        @chainable_field(\"line_options\", LineOptions)\n        class MyOptions:\n            color: str = \"#000000\"\n            width: int = 800\n            line_options: Optional[LineOptions] = None\n\n\n        # Usage examples\n        options = MyOptions()\n\n        # Method chaining (with validation)\n        options.set_color(\"#ff0000\").set_width(600)\n\n        # Direct assignment (no validation)\n        options.color = \"invalid_color\"  # No validation applied\n        options.set_color(\"invalid_color\")  # Raises ValueError\n        ```\n\n    Note:\n        Direct assignment to dataclass fields bypasses validation. Use the\n        generated setter methods when validation is required.\n    \"\"\"\n\n    def decorator(cls):\n        \"\"\"Inner decorator function that modifies the dataclass.\n\n        Args:\n            cls: The dataclass to be decorated.\n\n        Returns:\n            The modified class with added setter method.\n        \"\"\"\n        # Step 1: Create the setter method name following convention set_{field}\n        setter_name = f\"set_{field_name}\"\n\n        def setter_method(self, value):\n            \"\"\"Chainable setter method with validation for dataclass fields.\n\n            Args:\n                self: The dataclass instance being modified.\n                value: The new value to set.\n\n            Returns:\n                Self for method chaining.\n            \"\"\"\n            # Step 1: Apply validation and transformation\n            validated_value = _validate_value(field_name, value, value_type, validator)\n\n            # Step 2: Set the validated value directly on the dataclass field\n            setattr(self, field_name, validated_value)\n\n            # Step 3: Return self to enable method chaining\n            return self\n\n        # Step 2: Add the generated setter method to the class\n        setattr(cls, setter_name, setter_method)\n\n        # Step 3: Return the modified class\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html","title":"streamlit_lightweight_charts_pro.utils.data_utils","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils","title":"data_utils","text":"<p>Data utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides comprehensive utility functions for data processing and manipulation used throughout the library. It includes functions for time normalization, data validation, format conversion, and other common data operations essential for financial chart rendering.</p> The module provides utilities for <ul> <li>Time conversion and normalization (UNIX timestamps)</li> <li>Color validation and format checking</li> <li>String format conversion (snake_case to camelCase)</li> <li>Data validation for chart configuration options</li> <li>Precision and minimum move validation for price formatting</li> <li>Type checking and conversion utilities</li> </ul> <p>These utilities ensure data consistency, proper formatting, and type safety across all components of the charting library, providing a robust foundation for financial data visualization.</p> Key Features <ul> <li>Robust time handling with multiple input format support</li> <li>Comprehensive color validation for hex and rgba formats</li> <li>Efficient string conversion utilities for frontend compatibility</li> <li>Type-safe validation with descriptive error messages</li> <li>NumPy type handling for scientific computing integration</li> <li>Pandas integration for DataFrame and Series processing</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils.data_utils import (\n    normalize_time,\n    is_valid_color,\n    snake_to_camel,\n    validate_precision,\n)\n\n# Time normalization\ntimestamp = normalize_time(\"2024-01-01T00:00:00\")  # Returns UNIX timestamp\n\n# Color validation\nis_valid = is_valid_color(\"#FF0000\")  # Returns True\n\n# Format conversion for frontend\ncamel_case = snake_to_camel(\"price_scale_id\")  # Returns \"priceScaleId\"\n\n# Precision validation\nvalidate_precision(2)  # Validates precision value\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.normalize_time","title":"normalize_time","text":"<pre><code>normalize_time(time_value: Any) -&gt; int\n</code></pre> <p>Convert time input to int UNIX seconds for consistent chart data handling.</p> <p>This function handles various time input formats and converts them to UNIX timestamps (seconds since epoch). It supports multiple input types including integers, floats, strings, datetime objects, and pandas Timestamps, providing a unified interface for time data processing across the library.</p> <p>The function is designed to be robust and handle edge cases such as numpy types and various string formats that pandas can parse, ensuring compatibility with different data sources and formats commonly used in financial applications.</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>Any</code> <p>Time value to convert. Supported types: - int/float: Already in UNIX seconds (returned as-is) - str: Date/time string (parsed by pandas.to_datetime()) - datetime: Python datetime object (converted to timestamp) - pd.Timestamp: Pandas timestamp object (converted to timestamp) - numpy types: Automatically converted to Python types first</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UNIX timestamp in seconds since epoch, suitable for chart rendering.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input string cannot be parsed as a valid date/time.</p> <code>TypeError</code> <p>If the input type is not supported or cannot be converted.</p> <code>TimeValidationError</code> <p>If the converted time value is invalid.</p> Example <pre><code>from datetime import datetime\nimport pandas as pd\n\n# Various input formats\nnormalize_time(1640995200)  # Returns: 1640995200\nnormalize_time(\"2024-01-01T00:00:00\")  # Returns: 1704067200\nnormalize_time(datetime(2024, 1, 1))  # Returns: 1704067200\nnormalize_time(pd.Timestamp(\"2024-01-01\"))  # Returns: 1704067200\n</code></pre> Note <p>String inputs are parsed using pandas.to_datetime(), which supports a wide variety of date/time formats including ISO format, common date formats, and relative dates. This ensures maximum compatibility with different data sources.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def normalize_time(time_value: Any) -&gt; int:\n    \"\"\"Convert time input to int UNIX seconds for consistent chart data handling.\n\n    This function handles various time input formats and converts them to\n    UNIX timestamps (seconds since epoch). It supports multiple input types\n    including integers, floats, strings, datetime objects, and pandas Timestamps,\n    providing a unified interface for time data processing across the library.\n\n    The function is designed to be robust and handle edge cases such as\n    numpy types and various string formats that pandas can parse, ensuring\n    compatibility with different data sources and formats commonly used\n    in financial applications.\n\n    Args:\n        time_value (Any): Time value to convert. Supported types:\n            - int/float: Already in UNIX seconds (returned as-is)\n            - str: Date/time string (parsed by pandas.to_datetime())\n            - datetime: Python datetime object (converted to timestamp)\n            - pd.Timestamp: Pandas timestamp object (converted to timestamp)\n            - numpy types: Automatically converted to Python types first\n\n    Returns:\n        int: UNIX timestamp in seconds since epoch, suitable for chart rendering.\n\n    Raises:\n        ValueError: If the input string cannot be parsed as a valid date/time.\n        TypeError: If the input type is not supported or cannot be converted.\n        TimeValidationError: If the converted time value is invalid.\n\n    Example:\n        ```python\n        from datetime import datetime\n        import pandas as pd\n\n        # Various input formats\n        normalize_time(1640995200)  # Returns: 1640995200\n        normalize_time(\"2024-01-01T00:00:00\")  # Returns: 1704067200\n        normalize_time(datetime(2024, 1, 1))  # Returns: 1704067200\n        normalize_time(pd.Timestamp(\"2024-01-01\"))  # Returns: 1704067200\n        ```\n\n    Note:\n        String inputs are parsed using pandas.to_datetime(), which supports\n        a wide variety of date/time formats including ISO format, common\n        date formats, and relative dates. This ensures maximum compatibility\n        with different data sources.\n    \"\"\"\n    # Handle numpy types by converting to Python native types first\n    # This prevents issues with numpy-specific type checking and conversion\n    if hasattr(time_value, \"item\"):\n        time_value = time_value.item()\n    elif hasattr(time_value, \"dtype\"):\n        # Handle numpy arrays and other numpy objects\n        try:\n            time_value = time_value.item()\n        except (ValueError, TypeError):\n            # If item() fails, try to convert to int/float\n            time_value = int(time_value) if hasattr(time_value, \"__int__\") else float(time_value)\n\n    if isinstance(time_value, int):\n        return time_value\n    if isinstance(time_value, float):\n        return int(time_value)\n    if isinstance(time_value, str):\n        # Try to parse and normalize the string\n        try:\n            dt = pd.to_datetime(time_value)\n            return int(dt.timestamp())\n        except (ValueError, TypeError) as exc:\n            raise TimeValidationError(time_value) from exc\n    if isinstance(time_value, datetime):\n        return int(time_value.timestamp())\n    if isinstance(time_value, pd.Timestamp):\n        return int(time_value.timestamp())\n    # Handle datetime.date objects\n    if hasattr(time_value, \"date\") and hasattr(time_value, \"timetuple\"):\n        dt = datetime.combine(time_value, datetime.min.time())\n        return int(dt.timestamp())\n    raise UnsupportedTimeTypeError(type(time_value))\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.to_utc_timestamp","title":"to_utc_timestamp","text":"<pre><code>to_utc_timestamp(time_value: Any) -&gt; int\n</code></pre> <p>Convert time input to int UNIX seconds.</p> <p>This is an alias for normalize_time for backward compatibility. It provides the same functionality as normalize_time().</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>Any</code> <p>Supported types are int, float, str, datetime, pd.Timestamp</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UNIX timestamp in seconds</p> See Also <p>normalize_time: The main function that performs the conversion.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def to_utc_timestamp(time_value: Any) -&gt; int:\n    \"\"\"Convert time input to int UNIX seconds.\n\n    This is an alias for normalize_time for backward compatibility.\n    It provides the same functionality as normalize_time().\n\n    Args:\n        time_value: Supported types are int, float, str, datetime, pd.Timestamp\n\n    Returns:\n        int: UNIX timestamp in seconds\n\n    See Also:\n        normalize_time: The main function that performs the conversion.\n    \"\"\"\n    return normalize_time(time_value)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.from_utc_timestamp","title":"from_utc_timestamp","text":"<pre><code>from_utc_timestamp(timestamp: int) -&gt; str\n</code></pre> <p>Convert UNIX timestamp to ISO format string.</p> <p>This function converts a UNIX timestamp (seconds since epoch) to an ISO format datetime string. The output is in UTC timezone.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>UNIX timestamp in seconds since epoch.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO format datetime string in UTC timezone.</p> Example <pre><code>from_utc_timestamp(1640995200)  # \"2022-01-01T00:00:00\"\nfrom_utc_timestamp(1704067200)  # \"2024-01-01T00:00:00\"\n</code></pre> Note <p>The function uses datetime.utcfromtimestamp() to ensure the output is always in UTC timezone, regardless of the system's local timezone.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def from_utc_timestamp(timestamp: int) -&gt; str:\n    \"\"\"Convert UNIX timestamp to ISO format string.\n\n    This function converts a UNIX timestamp (seconds since epoch) to an\n    ISO format datetime string. The output is in UTC timezone.\n\n    Args:\n        timestamp: UNIX timestamp in seconds since epoch.\n\n    Returns:\n        str: ISO format datetime string in UTC timezone.\n\n    Example:\n        ```python\n        from_utc_timestamp(1640995200)  # \"2022-01-01T00:00:00\"\n        from_utc_timestamp(1704067200)  # \"2024-01-01T00:00:00\"\n        ```\n\n    Note:\n        The function uses datetime.utcfromtimestamp() to ensure the output\n        is always in UTC timezone, regardless of the system's local timezone.\n    \"\"\"\n    return datetime.utcfromtimestamp(timestamp).isoformat()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.snake_to_camel","title":"snake_to_camel","text":"<pre><code>snake_to_camel(snake_str: str) -&gt; str\n</code></pre> <p>Convert snake_case string to camelCase.</p> <p>This function converts strings from snake_case format (e.g., \"price_scale_id\") to camelCase format (e.g., \"priceScaleId\"). It's commonly used for converting Python property names to JavaScript property names.</p> <p>Parameters:</p> Name Type Description Default <code>snake_str</code> <code>str</code> <p>String in snake_case format (e.g., \"price_scale_id\").</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in camelCase format (e.g., \"priceScaleId\").</p> Example <pre><code>snake_to_camel(\"price_scale_id\")  # \"priceScaleId\"\nsnake_to_camel(\"line_color\")  # \"lineColor\"\nsnake_to_camel(\"background_color\")  # \"backgroundColor\"\nsnake_to_camel(\"single_word\")  # \"singleWord\"\n</code></pre> Note <p>The function assumes the input string is in valid snake_case format. If the input contains no underscores, it returns the string as-is.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def snake_to_camel(snake_str: str) -&gt; str:\n    \"\"\"Convert snake_case string to camelCase.\n\n    This function converts strings from snake_case format (e.g., \"price_scale_id\")\n    to camelCase format (e.g., \"priceScaleId\"). It's commonly used for\n    converting Python property names to JavaScript property names.\n\n    Args:\n        snake_str: String in snake_case format (e.g., \"price_scale_id\").\n\n    Returns:\n        str: String in camelCase format (e.g., \"priceScaleId\").\n\n    Example:\n        ```python\n        snake_to_camel(\"price_scale_id\")  # \"priceScaleId\"\n        snake_to_camel(\"line_color\")  # \"lineColor\"\n        snake_to_camel(\"background_color\")  # \"backgroundColor\"\n        snake_to_camel(\"single_word\")  # \"singleWord\"\n        ```\n\n    Note:\n        The function assumes the input string is in valid snake_case format.\n        If the input contains no underscores, it returns the string as-is.\n    \"\"\"\n    components = snake_str.split(\"_\")\n    return components[0] + \"\".join(word.capitalize() for word in components[1:])\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.is_valid_color","title":"is_valid_color","text":"<pre><code>is_valid_color(color: str) -&gt; bool\n</code></pre> <p>Check if a color string is valid.</p> <p>This function validates color strings in various formats commonly used in web development and chart styling. It supports hex colors, RGB/RGBA colors, and named colors.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color string to validate. Supported formats: - Hex colors: \"#FF0000\", \"#F00\", \"#FF0000AA\" - RGB colors: \"rgb(255, 0, 0)\" - RGBA colors: \"rgba(255, 0, 0, 1)\" - Named colors: \"red\", \"blue\", \"white\", etc.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if color is valid, False otherwise.</p> Example <pre><code>is_valid_color(\"#FF0000\")  # True\nis_valid_color(\"#F00\")  # True\nis_valid_color(\"rgb(255, 0, 0)\")  # True\nis_valid_color(\"rgba(255, 0, 0, 1)\")  # True\nis_valid_color(\"red\")  # True\nis_valid_color(\"\")  # False (empty string is invalid)\nis_valid_color(\"invalid\")  # False\nis_valid_color(\"#GG0000\")  # False\n</code></pre> Note <p>The function is permissive with whitespace in RGB/RGBA formats and accepts both 3-digit and 6-digit hex codes. Named colors are case-insensitive.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def is_valid_color(color: str) -&gt; bool:\n    \"\"\"Check if a color string is valid.\n\n    This function validates color strings in various formats commonly used\n    in web development and chart styling. It supports hex colors, RGB/RGBA\n    colors, and named colors.\n\n    Args:\n        color: Color string to validate. Supported formats:\n            - Hex colors: \"#FF0000\", \"#F00\", \"#FF0000AA\"\n            - RGB colors: \"rgb(255, 0, 0)\"\n            - RGBA colors: \"rgba(255, 0, 0, 1)\"\n            - Named colors: \"red\", \"blue\", \"white\", etc.\n\n    Returns:\n        bool: True if color is valid, False otherwise.\n\n    Example:\n        ```python\n        is_valid_color(\"#FF0000\")  # True\n        is_valid_color(\"#F00\")  # True\n        is_valid_color(\"rgb(255, 0, 0)\")  # True\n        is_valid_color(\"rgba(255, 0, 0, 1)\")  # True\n        is_valid_color(\"red\")  # True\n        is_valid_color(\"\")  # False (empty string is invalid)\n        is_valid_color(\"invalid\")  # False\n        is_valid_color(\"#GG0000\")  # False\n        ```\n\n    Note:\n        The function is permissive with whitespace in RGB/RGBA formats\n        and accepts both 3-digit and 6-digit hex codes. Named colors\n        are case-insensitive.\n    \"\"\"\n    # Validate input: must be a string\n    if not isinstance(color, str):\n        return False\n\n    # Reject empty strings as invalid colors\n    if color == \"\":\n        return False\n\n    # Check hex color pattern: matches #RRGGBB (6 hex digits) or #RGB (3 hex digits)\n    # Also supports #RRGGBBAA format for alpha channel\n    hex_pattern = r\"^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}|[A-Fa-f0-9]{8})$\"\n    if re.match(hex_pattern, color):\n        return True\n\n    # Check RGB/RGBA pattern: matches rgb(r,g,b) or rgba(r,g,b,a) format\n    # Allows optional spaces around commas and parentheses\n    # Alpha channel is optional and can be decimal or integer values\n    rgba_pattern = r\"^rgba?\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*(?:,\\s*[\\d.]+\\s*)?\\)$\"\n    if re.match(rgba_pattern, color):\n        return True\n\n    # Check named colors: basic set of commonly used color names\n    # These are case-insensitive and include standard web colors\n    named_colors = {\n        \"black\",\n        \"white\",\n        \"red\",\n        \"green\",\n        \"blue\",\n        \"yellow\",\n        \"cyan\",\n        \"magenta\",\n        \"gray\",\n        \"grey\",\n        \"orange\",\n        \"purple\",\n        \"brown\",\n        \"pink\",\n        \"lime\",\n        \"navy\",\n        \"teal\",\n        \"silver\",\n        \"gold\",\n        \"maroon\",\n        \"olive\",\n        \"aqua\",\n        \"fuchsia\",\n        \"transparent\",\n    }\n\n    # Return True if the color (converted to lowercase) is in the named colors set\n    # This makes the named color check case-insensitive for user convenience\n    return color.lower() in named_colors\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_price_format_type","title":"validate_price_format_type","text":"<pre><code>validate_price_format_type(type_value: str) -&gt; str\n</code></pre> <p>Validate price format type.</p> <p>This function validates price format type strings used in chart configuration. It ensures that only valid format types are used for price display options.</p> <p>Parameters:</p> Name Type Description Default <code>type_value</code> <code>str</code> <p>Type string to validate. Must be one of the valid types.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated type string (same as input if valid).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If type is not one of the valid price format types.</p> Example <pre><code>validate_price_format_type(\"price\")  # \"price\"\nvalidate_price_format_type(\"volume\")  # \"volume\"\nvalidate_price_format_type(\"percent\")  # \"percent\"\nvalidate_price_format_type(\"custom\")  # \"custom\"\nvalidate_price_format_type(\"invalid\")  # ValueError\n</code></pre> Note <p>Valid types are: \"price\", \"volume\", \"percent\", \"custom\". The function is case-sensitive.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_price_format_type(type_value: str) -&gt; str:\n    \"\"\"Validate price format type.\n\n    This function validates price format type strings used in chart configuration.\n    It ensures that only valid format types are used for price display options.\n\n    Args:\n        type_value: Type string to validate. Must be one of the valid types.\n\n    Returns:\n        str: Validated type string (same as input if valid).\n\n    Raises:\n        ValueError: If type is not one of the valid price format types.\n\n    Example:\n        ```python\n        validate_price_format_type(\"price\")  # \"price\"\n        validate_price_format_type(\"volume\")  # \"volume\"\n        validate_price_format_type(\"percent\")  # \"percent\"\n        validate_price_format_type(\"custom\")  # \"custom\"\n        validate_price_format_type(\"invalid\")  # ValueError\n        ```\n\n    Note:\n        Valid types are: \"price\", \"volume\", \"percent\", \"custom\".\n        The function is case-sensitive.\n    \"\"\"\n    valid_types = {\"price\", \"volume\", \"percent\", \"custom\"}\n    if type_value not in valid_types:\n        raise ValueValidationError(\n            \"type\",\n            f\"must be one of {valid_types}, got {type_value!r}\",\n        )\n    return type_value\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_precision","title":"validate_precision","text":"<pre><code>validate_precision(precision: int) -&gt; int\n</code></pre> <p>Validate precision value.</p> <p>This function validates precision values used for number formatting in charts. Precision determines the number of decimal places shown for price and volume values.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>int</code> <p>Precision value to validate. Must be a non-negative integer.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Validated precision value (same as input if valid).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If precision is not a non-negative integer.</p> Example <pre><code>validate_precision(0)  # 0\nvalidate_precision(2)  # 2\nvalidate_precision(5)  # 5\nvalidate_precision(-1)  # ValueError\nvalidate_precision(2.5)  # ValueError\n</code></pre> Note <p>Precision values typically range from 0 to 8, but the function accepts any non-negative integer. Very large values may cause display issues in the frontend.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_precision(precision: int) -&gt; int:\n    \"\"\"Validate precision value.\n\n    This function validates precision values used for number formatting\n    in charts. Precision determines the number of decimal places shown\n    for price and volume values.\n\n    Args:\n        precision: Precision value to validate. Must be a non-negative integer.\n\n    Returns:\n        int: Validated precision value (same as input if valid).\n\n    Raises:\n        ValueError: If precision is not a non-negative integer.\n\n    Example:\n        ```python\n        validate_precision(0)  # 0\n        validate_precision(2)  # 2\n        validate_precision(5)  # 5\n        validate_precision(-1)  # ValueError\n        validate_precision(2.5)  # ValueError\n        ```\n\n    Note:\n        Precision values typically range from 0 to 8, but the function\n        accepts any non-negative integer. Very large values may cause\n        display issues in the frontend.\n    \"\"\"\n    if not isinstance(precision, int) or precision &lt; 0:\n        raise ValueValidationError(\n            \"precision\",\n            f\"must be a non-negative integer, got {precision}\",\n        )\n    return precision\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/data_utils.html#streamlit_lightweight_charts_pro.utils.data_utils.validate_min_move","title":"validate_min_move","text":"<pre><code>validate_min_move(min_move: float) -&gt; float\n</code></pre> <p>Validate minimum move value.</p> <p>This function validates minimum move values used in chart configuration. Minimum move determines the smallest price change that will trigger a visual update in the chart.</p> <p>Parameters:</p> Name Type Description Default <code>min_move</code> <code>float</code> <p>Minimum move value to validate. Must be a positive number.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Validated minimum move value (converted to float if needed).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If min_move is not a positive number.</p> Example <pre><code>validate_min_move(0.001)  # 0.001\nvalidate_min_move(1.0)  # 1.0\nvalidate_min_move(100)  # 100.0\nvalidate_min_move(0)  # ValueError\nvalidate_min_move(-0.1)  # ValueError\n</code></pre> Note <p>Minimum move values are typically very small positive numbers (e.g., 0.001 for stocks, 0.0001 for forex). The function accepts both integers and floats, converting them to float for consistency.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/data_utils.py</code> <pre><code>def validate_min_move(min_move: float) -&gt; float:\n    \"\"\"Validate minimum move value.\n\n    This function validates minimum move values used in chart configuration.\n    Minimum move determines the smallest price change that will trigger\n    a visual update in the chart.\n\n    Args:\n        min_move: Minimum move value to validate. Must be a positive number.\n\n    Returns:\n        float: Validated minimum move value (converted to float if needed).\n\n    Raises:\n        ValueError: If min_move is not a positive number.\n\n    Example:\n        ```python\n        validate_min_move(0.001)  # 0.001\n        validate_min_move(1.0)  # 1.0\n        validate_min_move(100)  # 100.0\n        validate_min_move(0)  # ValueError\n        validate_min_move(-0.1)  # ValueError\n        ```\n\n    Note:\n        Minimum move values are typically very small positive numbers\n        (e.g., 0.001 for stocks, 0.0001 for forex). The function accepts\n        both integers and floats, converting them to float for consistency.\n    \"\"\"\n    if not isinstance(min_move, (int, float)) or min_move &lt;= 0:\n        raise ValueValidationError.positive_value(\"min_move\", min_move)\n    return float(min_move)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html","title":"streamlit_lightweight_charts_pro.utils.profiler","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler","title":"profiler","text":"<p>Performance profiling and monitoring utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides comprehensive performance profiling tools for identifying bottlenecks and monitoring optimization effectiveness in the charting library. It includes advanced memory tracking, CPU monitoring, and automated performance analysis with intelligent recommendations.</p> The module provides <ul> <li>PerformanceProfiler: Advanced profiler with memory and CPU monitoring</li> <li>PerformanceProfile: Data class for individual operation profiles</li> <li>PerformanceReport: Comprehensive performance analysis report</li> <li>MemoryMonitor: Memory usage monitoring and optimization suggestions</li> <li>Convenience functions for easy profiling integration</li> </ul> Key Features <ul> <li>Real-time memory and CPU usage tracking</li> <li>Automatic bottleneck identification</li> <li>Performance optimization recommendations</li> <li>Thread-safe operation profiling</li> <li>Export capabilities for detailed analysis</li> <li>Memory leak detection and trend analysis</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils.profiler import profile_function, profile_operation\n\n\n# Profile a function\n@profile_function(\"chart_rendering\", data_size=1000)\ndef render_chart(data):\n    return Chart(data)\n\n\n# Profile an operation block\nwith profile_operation(\"data_processing\", data_size=5000):\n    processed_data = process_large_dataset(data)\n</code></pre> <p>Version: 0.1.0 Author: Streamlit Lightweight Charts Contributors License: MIT</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfile","title":"PerformanceProfile  <code>dataclass</code>","text":"<p>Performance profile data for a single operation.</p> <p>This class stores comprehensive performance metrics for a single operation execution, including timing, memory usage, CPU utilization, and optional metadata. It serves as the basic unit of performance measurement in the profiling system.</p> <p>Attributes:</p> Name Type Description <code>operation_name</code> <code>str</code> <p>Name identifier for the operation being profiled.</p> <code>execution_time</code> <code>float</code> <p>Total execution time in seconds.</p> <code>memory_peak</code> <code>int</code> <p>Peak memory usage during operation in bytes.</p> <code>memory_current</code> <code>int</code> <p>Current memory usage at operation end in bytes.</p> <code>memory_delta</code> <code>int</code> <p>Change in memory usage (current - initial) in bytes.</p> <code>cpu_percent</code> <code>float</code> <p>CPU utilization percentage during operation.</p> <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed (if applicable).</p> <code>cache_hits</code> <code>int</code> <p>Number of cache hits during operation. Defaults to 0.</p> <code>cache_misses</code> <code>int</code> <p>Number of cache misses during operation. Defaults to 0.</p> <code>timestamp</code> <code>float</code> <p>Unix timestamp when operation completed. Auto-generated.</p> <code>thread_id</code> <code>int</code> <p>Thread ID where operation executed. Auto-generated.</p> Example <pre><code>profile = PerformanceProfile(\n    operation_name=\"chart_rendering\",\n    execution_time=0.125,\n    memory_peak=52428800,\n    memory_current=10485760,\n    memory_delta=4194304,\n    cpu_percent=15.5,\n    data_size=1000,\n)\n</code></pre> Note <p>The timestamp and thread_id fields are automatically populated using the current time and thread identifier when the profile is created.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@dataclass\nclass PerformanceProfile:\n    \"\"\"Performance profile data for a single operation.\n\n    This class stores comprehensive performance metrics for a single operation\n    execution, including timing, memory usage, CPU utilization, and optional\n    metadata. It serves as the basic unit of performance measurement in the\n    profiling system.\n\n    Attributes:\n        operation_name (str): Name identifier for the operation being profiled.\n        execution_time (float): Total execution time in seconds.\n        memory_peak (int): Peak memory usage during operation in bytes.\n        memory_current (int): Current memory usage at operation end in bytes.\n        memory_delta (int): Change in memory usage (current - initial) in bytes.\n        cpu_percent (float): CPU utilization percentage during operation.\n        data_size (Optional[int]): Size of data being processed (if applicable).\n        cache_hits (int): Number of cache hits during operation. Defaults to 0.\n        cache_misses (int): Number of cache misses during operation. Defaults to 0.\n        timestamp (float): Unix timestamp when operation completed. Auto-generated.\n        thread_id (int): Thread ID where operation executed. Auto-generated.\n\n    Example:\n        ```python\n        profile = PerformanceProfile(\n            operation_name=\"chart_rendering\",\n            execution_time=0.125,\n            memory_peak=52428800,\n            memory_current=10485760,\n            memory_delta=4194304,\n            cpu_percent=15.5,\n            data_size=1000,\n        )\n        ```\n\n    Note:\n        The timestamp and thread_id fields are automatically populated\n        using the current time and thread identifier when the profile\n        is created.\n    \"\"\"\n\n    operation_name: str\n    execution_time: float\n    memory_peak: int\n    memory_current: int\n    memory_delta: int\n    cpu_percent: float\n    data_size: Optional[int] = None\n    cache_hits: int = 0\n    cache_misses: int = 0\n    timestamp: float = field(default_factory=time.time)  # Auto-generate current timestamp\n    thread_id: int = field(default_factory=threading.get_ident)  # Auto-generate current thread ID\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport","title":"PerformanceReport  <code>dataclass</code>","text":"<p>Comprehensive performance report with analysis and recommendations.</p> <p>This class aggregates performance data from multiple operations and provides comprehensive analysis including bottleneck identification and optimization recommendations. It serves as the main output of the profiling system.</p> <p>Attributes:</p> Name Type Description <code>total_operations</code> <code>int</code> <p>Total number of operations profiled.</p> <code>total_execution_time</code> <code>float</code> <p>Sum of all execution times in seconds.</p> <code>average_execution_time</code> <code>float</code> <p>Average execution time per operation.</p> <code>memory_peak_total</code> <code>int</code> <p>Peak memory usage across all operations in bytes.</p> <code>memory_current_total</code> <code>int</code> <p>Current memory usage at report generation.</p> <code>operations</code> <code>List[PerformanceProfile]</code> <p>List of all individual operation profiles.</p> <code>bottlenecks</code> <code>List[str]</code> <p>Identified performance bottlenecks with details.</p> <code>recommendations</code> <code>List[str]</code> <p>Optimization recommendations based on analysis.</p> Example <pre><code>report = PerformanceReport(\n    total_operations=100,\n    total_execution_time=12.5,\n    average_execution_time=0.125,\n    memory_peak_total=104857600,\n    memory_current_total=52428800,\n    operations=[...],\n    bottlenecks=[\"chart_rendering: 0.250s average\"],\n    recommendations=[\"Consider caching for repeated operations\"],\n)\n</code></pre> Note <p>The report is generated by the PerformanceProfiler and includes intelligent analysis of the collected performance data.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@dataclass\nclass PerformanceReport:\n    \"\"\"Comprehensive performance report with analysis and recommendations.\n\n    This class aggregates performance data from multiple operations and provides\n    comprehensive analysis including bottleneck identification and optimization\n    recommendations. It serves as the main output of the profiling system.\n\n    Attributes:\n        total_operations (int): Total number of operations profiled.\n        total_execution_time (float): Sum of all execution times in seconds.\n        average_execution_time (float): Average execution time per operation.\n        memory_peak_total (int): Peak memory usage across all operations in bytes.\n        memory_current_total (int): Current memory usage at report generation.\n        operations (List[PerformanceProfile]): List of all individual operation profiles.\n        bottlenecks (List[str]): Identified performance bottlenecks with details.\n        recommendations (List[str]): Optimization recommendations based on analysis.\n\n    Example:\n        ```python\n        report = PerformanceReport(\n            total_operations=100,\n            total_execution_time=12.5,\n            average_execution_time=0.125,\n            memory_peak_total=104857600,\n            memory_current_total=52428800,\n            operations=[...],\n            bottlenecks=[\"chart_rendering: 0.250s average\"],\n            recommendations=[\"Consider caching for repeated operations\"],\n        )\n        ```\n\n    Note:\n        The report is generated by the PerformanceProfiler and includes\n        intelligent analysis of the collected performance data.\n    \"\"\"\n\n    total_operations: int\n    total_execution_time: float\n    average_execution_time: float\n    memory_peak_total: int\n    memory_current_total: int\n    operations: List[PerformanceProfile]\n    bottlenecks: List[str]\n    recommendations: List[str]\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert report to dictionary for serialization.\n\n        This method converts the performance report to a dictionary format\n        suitable for JSON serialization or other data exchange formats.\n        It includes all key metrics and analysis results.\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the performance report\n                with all metrics and analysis results.\n\n        Example:\n            ```python\n            report = profiler.generate_report()\n            report_dict = report.to_dict()\n            # Use for JSON export or API responses\n            ```\n        \"\"\"\n        # Convert the performance report to a dictionary format\n        # This includes all key metrics and analysis results for serialization\n        return {\n            \"total_operations\": self.total_operations,  # Total number of operations\n            \"total_execution_time\": self.total_execution_time,  # Sum of all execution times\n            \"average_execution_time\": self.average_execution_time,  # Average time per operation\n            \"memory_peak_total\": self.memory_peak_total,  # Peak memory usage\n            \"memory_current_total\": self.memory_current_total,  # Current memory usage\n            \"operations_count\": len(self.operations),  # Count of individual profiles\n            \"bottlenecks\": self.bottlenecks,  # Identified bottlenecks\n            \"recommendations\": self.recommendations,  # Optimization suggestions\n        }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceReport.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert report to dictionary for serialization.</p> <p>This method converts the performance report to a dictionary format suitable for JSON serialization or other data exchange formats. It includes all key metrics and analysis results.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation of the performance report with all metrics and analysis results.</p> Example <pre><code>report = profiler.generate_report()\nreport_dict = report.to_dict()\n# Use for JSON export or API responses\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert report to dictionary for serialization.\n\n    This method converts the performance report to a dictionary format\n    suitable for JSON serialization or other data exchange formats.\n    It includes all key metrics and analysis results.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation of the performance report\n            with all metrics and analysis results.\n\n    Example:\n        ```python\n        report = profiler.generate_report()\n        report_dict = report.to_dict()\n        # Use for JSON export or API responses\n        ```\n    \"\"\"\n    # Convert the performance report to a dictionary format\n    # This includes all key metrics and analysis results for serialization\n    return {\n        \"total_operations\": self.total_operations,  # Total number of operations\n        \"total_execution_time\": self.total_execution_time,  # Sum of all execution times\n        \"average_execution_time\": self.average_execution_time,  # Average time per operation\n        \"memory_peak_total\": self.memory_peak_total,  # Peak memory usage\n        \"memory_current_total\": self.memory_current_total,  # Current memory usage\n        \"operations_count\": len(self.operations),  # Count of individual profiles\n        \"bottlenecks\": self.bottlenecks,  # Identified bottlenecks\n        \"recommendations\": self.recommendations,  # Optimization suggestions\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler","title":"PerformanceProfiler","text":"<p>Advanced performance profiler with memory and CPU monitoring.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>class PerformanceProfiler:\n    \"\"\"Advanced performance profiler with memory and CPU monitoring.\"\"\"\n\n    def __init__(self, enable_memory_tracking: bool = True):\n        \"\"\"Initialize profiler with optional memory tracking.\n\n        This method sets up the performance profiler with the specified\n        memory tracking configuration. It initializes data structures\n        for storing performance profiles and starts memory tracking\n        if enabled.\n\n        Args:\n            enable_memory_tracking (bool): Whether to enable detailed memory\n                tracking using tracemalloc. Defaults to True for comprehensive\n                memory analysis.\n\n        Note:\n            Memory tracking uses Python's tracemalloc module which may\n            have a small performance overhead but provides detailed\n            memory usage information.\n        \"\"\"\n        # Store memory tracking configuration\n        self.enable_memory_tracking = enable_memory_tracking\n\n        # Initialize data structures for storing performance data\n        self.profiles: List[PerformanceProfile] = []  # Store all operation profiles\n        self.operation_times: Dict[str, List[float]] = defaultdict(list)  # Group times by operation\n        self.memory_snapshots: List[Dict[str, int]] = []  # Store memory usage snapshots\n\n        # Thread lock for thread-safe operations\n        # This ensures that concurrent profiling doesn't corrupt data\n        self._lock = threading.Lock()\n\n        # Start memory tracking if enabled\n        # This uses Python's tracemalloc for detailed memory analysis\n        if enable_memory_tracking:\n            tracemalloc.start()  # Start tracking memory allocations\n\n    def profile_operation(self, operation_name: str, data_size: Optional[int] = None):\n        \"\"\"Decorator to profile a function or method.\"\"\"\n\n        def decorator(func: Callable) -&gt; Callable:\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                with self.measure_operation(operation_name, data_size):\n                    return func(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    @contextmanager\n    def measure_operation(self, operation_name: str, data_size: Optional[int] = None):\n        \"\"\"Context manager to measure operation performance.\n\n        This context manager measures the performance of a code block by\n        tracking execution time, memory usage, and CPU utilization. It\n        automatically creates a PerformanceProfile and stores it for analysis.\n\n        Args:\n            operation_name (str): Name identifier for the operation being measured.\n            data_size (Optional[int]): Size of data being processed (if applicable).\n\n        Yields:\n            None: The context manager yields control to the measured code block.\n\n        Example:\n            ```python\n            with profiler.measure_operation(\"chart_rendering\", data_size=1000):\n                chart = create_chart(data)\n            ```\n        \"\"\"\n        # Get the current process for memory and CPU monitoring\n        process = psutil.Process()\n\n        # Record initial memory state (Resident Set Size - actual physical memory)\n        initial_memory = process.memory_info().rss\n\n        # Initialize CPU monitoring (first call returns 0, subsequent calls return actual usage)\n        process.cpu_percent()\n\n        # Take initial memory snapshot if detailed tracking is enabled\n        # This provides baseline for memory usage analysis\n        if self.enable_memory_tracking:\n            tracemalloc.take_snapshot()\n\n        # Record start time for execution time measurement\n        start_time = time.time()\n\n        try:\n            # Yield control to the code block being measured\n            # This is where the actual operation executes\n            yield\n        finally:\n            # Record end time and calculate execution duration\n            end_time = time.time()\n            execution_time = end_time - start_time\n\n            # Get final memory state after operation completion\n            final_memory = process.memory_info().rss\n            final_cpu = process.cpu_percent()\n\n            # Calculate memory delta (change in memory usage)\n            memory_delta = final_memory - initial_memory\n\n            # Get peak memory usage if detailed tracking is enabled\n            # Use final memory as fallback, or calculate peak from tracemalloc\n            memory_peak = final_memory\n            if self.enable_memory_tracking:\n                # Take final snapshot and calculate total memory used\n                snapshot = tracemalloc.take_snapshot()\n                memory_peak = sum(stat.size for stat in snapshot.statistics(\"lineno\"))\n\n            # Create comprehensive performance profile for this operation\n            profile = PerformanceProfile(\n                operation_name=operation_name,  # Operation identifier\n                execution_time=execution_time,  # Total execution time\n                memory_peak=memory_peak,  # Peak memory usage\n                memory_current=final_memory,  # Current memory usage\n                memory_delta=memory_delta,  # Change in memory usage\n                cpu_percent=final_cpu,  # CPU utilization percentage\n                data_size=data_size,  # Optional data size metadata\n            )\n\n            # Store the profile in thread-safe manner\n            # This ensures concurrent profiling doesn't corrupt the data\n            with self._lock:\n                self.profiles.append(profile)  # Add to profiles list\n                self.operation_times[operation_name].append(\n                    execution_time,\n                )  # Group by operation name\n\n    def get_operation_stats(self, operation_name: str) -&gt; Dict[str, float]:\n        \"\"\"Get statistics for a specific operation.\"\"\"\n        times = self.operation_times.get(operation_name, [])\n        if not times:\n            return {}\n\n        return {\n            \"count\": len(times),\n            \"total_time\": sum(times),\n            \"average_time\": sum(times) / len(times),\n            \"min_time\": min(times),\n            \"max_time\": max(times),\n            \"median_time\": sorted(times)[len(times) // 2],\n        }\n\n    def identify_bottlenecks(self, threshold_percentile: float = 95.0) -&gt; List[str]:\n        \"\"\"Identify performance bottlenecks based on execution times.\"\"\"\n        if not self.profiles:\n            return []\n\n        # Calculate threshold\n        all_times = [p.execution_time for p in self.profiles]\n        threshold = sorted(all_times)[int(len(all_times) * threshold_percentile / 100)]\n\n        # Find operations above threshold\n        slow_operations = []\n        operation_stats = defaultdict(list)\n\n        for profile in self.profiles:\n            operation_stats[profile.operation_name].append(profile.execution_time)\n\n        for op_name, times in operation_stats.items():\n            avg_time = sum(times) / len(times)\n            if avg_time &gt; threshold:\n                slow_operations.append(f\"{op_name}: {avg_time:.4f}s average\")\n\n        return slow_operations\n\n    def generate_recommendations(self) -&gt; List[str]:\n        \"\"\"Generate performance optimization recommendations.\"\"\"\n        recommendations = []\n\n        if not self.profiles:\n            return recommendations\n\n        # Analyze memory usage\n        memory_profiles = [p for p in self.profiles if p.memory_delta &gt; 0]\n        if memory_profiles:\n            avg_memory_delta = sum(p.memory_delta for p in memory_profiles) / len(memory_profiles)\n            if avg_memory_delta &gt; 100 * 1024 * 1024:  # 100MB\n                recommendations.append(\n                    \"High memory usage detected. Consider using lazy loading or chunking.\",\n                )\n\n        # Analyze execution times\n        slow_operations = self.identify_bottlenecks(90.0)\n        if slow_operations:\n            recommendations.append(\n                f\"Slow operations detected: {', '.join(slow_operations[:3])}. \"\n                \"Consider optimization or caching.\",\n            )\n\n        # Analyze data size vs performance\n        large_data_ops = [p for p in self.profiles if p.data_size and p.data_size &gt; 10000]\n        if large_data_ops:\n            recommendations.append(\n                \"Large datasets detected. Consider using vectorized processing or \"\n                \"memory-efficient data classes.\",\n            )\n\n        # Check for repeated operations\n        operation_counts = defaultdict(int)\n        for profile in self.profiles:\n            operation_counts[profile.operation_name] += 1\n\n        repeated_ops = [op for op, count in operation_counts.items() if count &gt; 10]\n        if repeated_ops:\n            recommendations.append(\n                f\"Frequent operations detected: {', '.join(repeated_ops)}. \"\n                \"Consider caching or batching.\",\n            )\n\n        return recommendations\n\n    def generate_report(self) -&gt; PerformanceReport:\n        \"\"\"Generate comprehensive performance report.\"\"\"\n        if not self.profiles:\n            return PerformanceReport(\n                total_operations=0,\n                total_execution_time=0.0,\n                average_execution_time=0.0,\n                memory_peak_total=0,\n                memory_current_total=0,\n                operations=[],\n                bottlenecks=[],\n                recommendations=[],\n            )\n\n        total_time = sum(p.execution_time for p in self.profiles)\n        avg_time = total_time / len(self.profiles)\n        memory_peak_total = max(p.memory_peak for p in self.profiles)\n        memory_current_total = max(p.memory_current for p in self.profiles)\n\n        bottlenecks = self.identify_bottlenecks()\n        recommendations = self.generate_recommendations()\n\n        return PerformanceReport(\n            total_operations=len(self.profiles),\n            total_execution_time=total_time,\n            average_execution_time=avg_time,\n            memory_peak_total=memory_peak_total,\n            memory_current_total=memory_current_total,\n            operations=self.profiles.copy(),\n            bottlenecks=bottlenecks,\n            recommendations=recommendations,\n        )\n\n    def clear_profiles(self) -&gt; None:\n        \"\"\"Clear all stored profiles.\"\"\"\n        with self._lock:\n            self.profiles.clear()\n            self.operation_times.clear()\n            self.memory_snapshots.clear()\n\n        if self.enable_memory_tracking:\n            tracemalloc.stop()\n            tracemalloc.start()\n\n    def export_profiles(self, filename: str) -&gt; None:\n        \"\"\"Export profiles to a file for analysis.\"\"\"\n        report = self.generate_report()\n\n        with Path(filename).open(\"w\") as f:\n            json.dump(report.to_dict(), f, indent=2)\n\n        logger.info(\"Performance profiles exported to %s\", filename)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.profile_operation","title":"profile_operation","text":"<pre><code>profile_operation(\n    operation_name: str, data_size: Optional[int] = None\n)\n</code></pre> <p>Decorator to profile a function or method.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def profile_operation(self, operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Decorator to profile a function or method.\"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            with self.measure_operation(operation_name, data_size):\n                return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.measure_operation","title":"measure_operation","text":"<pre><code>measure_operation(\n    operation_name: str, data_size: Optional[int] = None\n)\n</code></pre> <p>Context manager to measure operation performance.</p> <p>This context manager measures the performance of a code block by tracking execution time, memory usage, and CPU utilization. It automatically creates a PerformanceProfile and stores it for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name identifier for the operation being measured.</p> required <code>data_size</code> <code>Optional[int]</code> <p>Size of data being processed (if applicable).</p> <code>None</code> <p>Yields:</p> Name Type Description <code>None</code> <p>The context manager yields control to the measured code block.</p> Example <pre><code>with profiler.measure_operation(\"chart_rendering\", data_size=1000):\n    chart = create_chart(data)\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@contextmanager\ndef measure_operation(self, operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Context manager to measure operation performance.\n\n    This context manager measures the performance of a code block by\n    tracking execution time, memory usage, and CPU utilization. It\n    automatically creates a PerformanceProfile and stores it for analysis.\n\n    Args:\n        operation_name (str): Name identifier for the operation being measured.\n        data_size (Optional[int]): Size of data being processed (if applicable).\n\n    Yields:\n        None: The context manager yields control to the measured code block.\n\n    Example:\n        ```python\n        with profiler.measure_operation(\"chart_rendering\", data_size=1000):\n            chart = create_chart(data)\n        ```\n    \"\"\"\n    # Get the current process for memory and CPU monitoring\n    process = psutil.Process()\n\n    # Record initial memory state (Resident Set Size - actual physical memory)\n    initial_memory = process.memory_info().rss\n\n    # Initialize CPU monitoring (first call returns 0, subsequent calls return actual usage)\n    process.cpu_percent()\n\n    # Take initial memory snapshot if detailed tracking is enabled\n    # This provides baseline for memory usage analysis\n    if self.enable_memory_tracking:\n        tracemalloc.take_snapshot()\n\n    # Record start time for execution time measurement\n    start_time = time.time()\n\n    try:\n        # Yield control to the code block being measured\n        # This is where the actual operation executes\n        yield\n    finally:\n        # Record end time and calculate execution duration\n        end_time = time.time()\n        execution_time = end_time - start_time\n\n        # Get final memory state after operation completion\n        final_memory = process.memory_info().rss\n        final_cpu = process.cpu_percent()\n\n        # Calculate memory delta (change in memory usage)\n        memory_delta = final_memory - initial_memory\n\n        # Get peak memory usage if detailed tracking is enabled\n        # Use final memory as fallback, or calculate peak from tracemalloc\n        memory_peak = final_memory\n        if self.enable_memory_tracking:\n            # Take final snapshot and calculate total memory used\n            snapshot = tracemalloc.take_snapshot()\n            memory_peak = sum(stat.size for stat in snapshot.statistics(\"lineno\"))\n\n        # Create comprehensive performance profile for this operation\n        profile = PerformanceProfile(\n            operation_name=operation_name,  # Operation identifier\n            execution_time=execution_time,  # Total execution time\n            memory_peak=memory_peak,  # Peak memory usage\n            memory_current=final_memory,  # Current memory usage\n            memory_delta=memory_delta,  # Change in memory usage\n            cpu_percent=final_cpu,  # CPU utilization percentage\n            data_size=data_size,  # Optional data size metadata\n        )\n\n        # Store the profile in thread-safe manner\n        # This ensures concurrent profiling doesn't corrupt the data\n        with self._lock:\n            self.profiles.append(profile)  # Add to profiles list\n            self.operation_times[operation_name].append(\n                execution_time,\n            )  # Group by operation name\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.get_operation_stats","title":"get_operation_stats","text":"<pre><code>get_operation_stats(\n    operation_name: str,\n) -&gt; Dict[str, float]\n</code></pre> <p>Get statistics for a specific operation.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_operation_stats(self, operation_name: str) -&gt; Dict[str, float]:\n    \"\"\"Get statistics for a specific operation.\"\"\"\n    times = self.operation_times.get(operation_name, [])\n    if not times:\n        return {}\n\n    return {\n        \"count\": len(times),\n        \"total_time\": sum(times),\n        \"average_time\": sum(times) / len(times),\n        \"min_time\": min(times),\n        \"max_time\": max(times),\n        \"median_time\": sorted(times)[len(times) // 2],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.identify_bottlenecks","title":"identify_bottlenecks","text":"<pre><code>identify_bottlenecks(\n    threshold_percentile: float = 95.0,\n) -&gt; List[str]\n</code></pre> <p>Identify performance bottlenecks based on execution times.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def identify_bottlenecks(self, threshold_percentile: float = 95.0) -&gt; List[str]:\n    \"\"\"Identify performance bottlenecks based on execution times.\"\"\"\n    if not self.profiles:\n        return []\n\n    # Calculate threshold\n    all_times = [p.execution_time for p in self.profiles]\n    threshold = sorted(all_times)[int(len(all_times) * threshold_percentile / 100)]\n\n    # Find operations above threshold\n    slow_operations = []\n    operation_stats = defaultdict(list)\n\n    for profile in self.profiles:\n        operation_stats[profile.operation_name].append(profile.execution_time)\n\n    for op_name, times in operation_stats.items():\n        avg_time = sum(times) / len(times)\n        if avg_time &gt; threshold:\n            slow_operations.append(f\"{op_name}: {avg_time:.4f}s average\")\n\n    return slow_operations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.generate_recommendations","title":"generate_recommendations","text":"<pre><code>generate_recommendations() -&gt; List[str]\n</code></pre> <p>Generate performance optimization recommendations.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def generate_recommendations(self) -&gt; List[str]:\n    \"\"\"Generate performance optimization recommendations.\"\"\"\n    recommendations = []\n\n    if not self.profiles:\n        return recommendations\n\n    # Analyze memory usage\n    memory_profiles = [p for p in self.profiles if p.memory_delta &gt; 0]\n    if memory_profiles:\n        avg_memory_delta = sum(p.memory_delta for p in memory_profiles) / len(memory_profiles)\n        if avg_memory_delta &gt; 100 * 1024 * 1024:  # 100MB\n            recommendations.append(\n                \"High memory usage detected. Consider using lazy loading or chunking.\",\n            )\n\n    # Analyze execution times\n    slow_operations = self.identify_bottlenecks(90.0)\n    if slow_operations:\n        recommendations.append(\n            f\"Slow operations detected: {', '.join(slow_operations[:3])}. \"\n            \"Consider optimization or caching.\",\n        )\n\n    # Analyze data size vs performance\n    large_data_ops = [p for p in self.profiles if p.data_size and p.data_size &gt; 10000]\n    if large_data_ops:\n        recommendations.append(\n            \"Large datasets detected. Consider using vectorized processing or \"\n            \"memory-efficient data classes.\",\n        )\n\n    # Check for repeated operations\n    operation_counts = defaultdict(int)\n    for profile in self.profiles:\n        operation_counts[profile.operation_name] += 1\n\n    repeated_ops = [op for op, count in operation_counts.items() if count &gt; 10]\n    if repeated_ops:\n        recommendations.append(\n            f\"Frequent operations detected: {', '.join(repeated_ops)}. \"\n            \"Consider caching or batching.\",\n        )\n\n    return recommendations\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.generate_report","title":"generate_report","text":"<pre><code>generate_report() -&gt; PerformanceReport\n</code></pre> <p>Generate comprehensive performance report.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def generate_report(self) -&gt; PerformanceReport:\n    \"\"\"Generate comprehensive performance report.\"\"\"\n    if not self.profiles:\n        return PerformanceReport(\n            total_operations=0,\n            total_execution_time=0.0,\n            average_execution_time=0.0,\n            memory_peak_total=0,\n            memory_current_total=0,\n            operations=[],\n            bottlenecks=[],\n            recommendations=[],\n        )\n\n    total_time = sum(p.execution_time for p in self.profiles)\n    avg_time = total_time / len(self.profiles)\n    memory_peak_total = max(p.memory_peak for p in self.profiles)\n    memory_current_total = max(p.memory_current for p in self.profiles)\n\n    bottlenecks = self.identify_bottlenecks()\n    recommendations = self.generate_recommendations()\n\n    return PerformanceReport(\n        total_operations=len(self.profiles),\n        total_execution_time=total_time,\n        average_execution_time=avg_time,\n        memory_peak_total=memory_peak_total,\n        memory_current_total=memory_current_total,\n        operations=self.profiles.copy(),\n        bottlenecks=bottlenecks,\n        recommendations=recommendations,\n    )\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.clear_profiles","title":"clear_profiles","text":"<pre><code>clear_profiles() -&gt; None\n</code></pre> <p>Clear all stored profiles.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def clear_profiles(self) -&gt; None:\n    \"\"\"Clear all stored profiles.\"\"\"\n    with self._lock:\n        self.profiles.clear()\n        self.operation_times.clear()\n        self.memory_snapshots.clear()\n\n    if self.enable_memory_tracking:\n        tracemalloc.stop()\n        tracemalloc.start()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.PerformanceProfiler.export_profiles","title":"export_profiles","text":"<pre><code>export_profiles(filename: str) -&gt; None\n</code></pre> <p>Export profiles to a file for analysis.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def export_profiles(self, filename: str) -&gt; None:\n    \"\"\"Export profiles to a file for analysis.\"\"\"\n    report = self.generate_report()\n\n    with Path(filename).open(\"w\") as f:\n        json.dump(report.to_dict(), f, indent=2)\n\n    logger.info(\"Performance profiles exported to %s\", filename)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor","title":"MemoryMonitor","text":"<p>Memory usage monitoring and optimization suggestions.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>class MemoryMonitor:\n    \"\"\"Memory usage monitoring and optimization suggestions.\"\"\"\n\n    def __init__(self):\n        self.memory_history: List[Dict[str, int]] = []\n        self.process = psutil.Process()\n\n    def get_memory_usage(self) -&gt; Dict[str, int]:\n        \"\"\"Get current memory usage information.\"\"\"\n        memory_info = self.process.memory_info()\n        return {\n            \"rss\": memory_info.rss,  # Resident Set Size\n            \"vms\": memory_info.vms,  # Virtual Memory Size\n            \"percent\": self.process.memory_percent(),\n        }\n\n    def record_memory_snapshot(self) -&gt; None:\n        \"\"\"Record current memory usage snapshot.\"\"\"\n        snapshot = self.get_memory_usage()\n        snapshot[\"timestamp\"] = time.time()\n        self.memory_history.append(snapshot)\n\n    def get_memory_trend(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze memory usage trend.\"\"\"\n        if len(self.memory_history) &lt; 2:\n            return {\"trend\": \"insufficient_data\"}\n\n        recent = self.memory_history[-1]\n        older = self.memory_history[0]\n\n        rss_change = recent[\"rss\"] - older[\"rss\"]\n        vms_change = recent[\"vms\"] - older[\"vms\"]\n\n        if rss_change &gt; 0:\n            trend = \"increasing\"\n        elif rss_change &lt; 0:\n            trend = \"decreasing\"\n        else:\n            trend = \"stable\"\n\n        return {\n            \"trend\": trend,\n            \"rss_change\": rss_change,\n            \"vms_change\": vms_change,\n            \"current_rss\": recent[\"rss\"],\n            \"current_vms\": recent[\"vms\"],\n        }\n\n    def suggest_optimizations(self) -&gt; List[str]:\n        \"\"\"Suggest memory optimizations based on usage patterns.\"\"\"\n        suggestions = []\n\n        if not self.memory_history:\n            return suggestions\n\n        current = self.memory_history[-1]\n        trend = self.get_memory_trend()\n\n        # Check for high memory usage\n        if current[\"percent\"] &gt; 80:\n            suggestions.append(\n                \"High memory usage detected. Consider using memory-efficient data classes.\",\n            )\n\n        # Check for memory leaks\n        if trend[\"trend\"] == \"increasing\" and trend[\"rss_change\"] &gt; 100 * 1024 * 1024:  # 100MB\n            suggestions.append(\"Potential memory leak detected. Check for unclosed resources.\")\n\n        # Check for large virtual memory usage\n        if current[\"vms\"] &gt; 2 * 1024 * 1024 * 1024:  # 2GB\n            suggestions.append(\"Large virtual memory usage. Consider using chunked processing.\")\n\n        return suggestions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.get_memory_usage","title":"get_memory_usage","text":"<pre><code>get_memory_usage() -&gt; Dict[str, int]\n</code></pre> <p>Get current memory usage information.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_usage(self) -&gt; Dict[str, int]:\n    \"\"\"Get current memory usage information.\"\"\"\n    memory_info = self.process.memory_info()\n    return {\n        \"rss\": memory_info.rss,  # Resident Set Size\n        \"vms\": memory_info.vms,  # Virtual Memory Size\n        \"percent\": self.process.memory_percent(),\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.record_memory_snapshot","title":"record_memory_snapshot","text":"<pre><code>record_memory_snapshot() -&gt; None\n</code></pre> <p>Record current memory usage snapshot.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def record_memory_snapshot(self) -&gt; None:\n    \"\"\"Record current memory usage snapshot.\"\"\"\n    snapshot = self.get_memory_usage()\n    snapshot[\"timestamp\"] = time.time()\n    self.memory_history.append(snapshot)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.get_memory_trend","title":"get_memory_trend","text":"<pre><code>get_memory_trend() -&gt; Dict[str, Any]\n</code></pre> <p>Analyze memory usage trend.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_trend(self) -&gt; Dict[str, Any]:\n    \"\"\"Analyze memory usage trend.\"\"\"\n    if len(self.memory_history) &lt; 2:\n        return {\"trend\": \"insufficient_data\"}\n\n    recent = self.memory_history[-1]\n    older = self.memory_history[0]\n\n    rss_change = recent[\"rss\"] - older[\"rss\"]\n    vms_change = recent[\"vms\"] - older[\"vms\"]\n\n    if rss_change &gt; 0:\n        trend = \"increasing\"\n    elif rss_change &lt; 0:\n        trend = \"decreasing\"\n    else:\n        trend = \"stable\"\n\n    return {\n        \"trend\": trend,\n        \"rss_change\": rss_change,\n        \"vms_change\": vms_change,\n        \"current_rss\": recent[\"rss\"],\n        \"current_vms\": recent[\"vms\"],\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.MemoryMonitor.suggest_optimizations","title":"suggest_optimizations","text":"<pre><code>suggest_optimizations() -&gt; List[str]\n</code></pre> <p>Suggest memory optimizations based on usage patterns.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def suggest_optimizations(self) -&gt; List[str]:\n    \"\"\"Suggest memory optimizations based on usage patterns.\"\"\"\n    suggestions = []\n\n    if not self.memory_history:\n        return suggestions\n\n    current = self.memory_history[-1]\n    trend = self.get_memory_trend()\n\n    # Check for high memory usage\n    if current[\"percent\"] &gt; 80:\n        suggestions.append(\n            \"High memory usage detected. Consider using memory-efficient data classes.\",\n        )\n\n    # Check for memory leaks\n    if trend[\"trend\"] == \"increasing\" and trend[\"rss_change\"] &gt; 100 * 1024 * 1024:  # 100MB\n        suggestions.append(\"Potential memory leak detected. Check for unclosed resources.\")\n\n    # Check for large virtual memory usage\n    if current[\"vms\"] &gt; 2 * 1024 * 1024 * 1024:  # 2GB\n        suggestions.append(\"Large virtual memory usage. Consider using chunked processing.\")\n\n    return suggestions\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_profiler","title":"get_profiler","text":"<pre><code>get_profiler() -&gt; PerformanceProfiler\n</code></pre> <p>Get the global profiler instance.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_profiler() -&gt; PerformanceProfiler:\n    \"\"\"Get the global profiler instance.\"\"\"\n    return _global_profiler\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_memory_monitor","title":"get_memory_monitor","text":"<pre><code>get_memory_monitor() -&gt; MemoryMonitor\n</code></pre> <p>Get the global memory monitor instance.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_memory_monitor() -&gt; MemoryMonitor:\n    \"\"\"Get the global memory monitor instance.\"\"\"\n    return _memory_monitor\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.profile_function","title":"profile_function","text":"<pre><code>profile_function(\n    operation_name: str, data_size: Optional[int] = None\n)\n</code></pre> <p>Convenience decorator for profiling functions.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def profile_function(operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Convenience decorator for profiling functions.\"\"\"\n    return _global_profiler.profile_operation(operation_name, data_size)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.profile_operation","title":"profile_operation","text":"<pre><code>profile_operation(\n    operation_name: str, data_size: Optional[int] = None\n)\n</code></pre> <p>Convenience context manager for profiling operations.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>@contextmanager\ndef profile_operation(operation_name: str, data_size: Optional[int] = None):\n    \"\"\"Convenience context manager for profiling operations.\"\"\"\n    with _global_profiler.measure_operation(operation_name, data_size):\n        yield\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/profiler.html#streamlit_lightweight_charts_pro.utils.profiler.get_performance_summary","title":"get_performance_summary","text":"<pre><code>get_performance_summary() -&gt; Dict[str, Any]\n</code></pre> <p>Get a quick performance summary.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/profiler.py</code> <pre><code>def get_performance_summary() -&gt; Dict[str, Any]:\n    \"\"\"Get a quick performance summary.\"\"\"\n    report = _global_profiler.generate_report()\n    memory_trend = _memory_monitor.get_memory_trend()\n\n    return {\n        \"operations\": report.total_operations,\n        \"total_time\": report.total_execution_time,\n        \"avg_time\": report.average_execution_time,\n        \"memory_trend\": memory_trend[\"trend\"],\n        \"current_memory_mb\": memory_trend[\"current_rss\"] / (1024 * 1024),\n        \"bottlenecks\": len(report.bottlenecks),\n        \"recommendations\": len(report.recommendations),\n    }\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html","title":"streamlit_lightweight_charts_pro.utils.serialization","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization","title":"serialization","text":"<p>Serialization utilities for Streamlit Lightweight Charts Pro.</p> <p>This module provides base classes and utilities for consistent serialization of data structures to frontend-compatible dictionary formats. It centralizes the logic for handling camelCase conversion, nested object serialization, and type-specific transformations.</p> The serialization system is designed to <ul> <li>Convert Python objects to JavaScript-compatible dictionaries</li> <li>Handle snake_case to camelCase key conversion</li> <li>Process nested objects and enums</li> <li>Provide consistent behavior across all serializable classes</li> <li>Support special field flattening and nested serialization</li> </ul> Example Usage <pre><code>from streamlit_lightweight_charts_pro.utils.serialization import SerializableMixin\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass MyDataClass(SerializableMixin):\n    title: str\n    is_visible: bool = True\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return dict(self._serialize_to_dict())\n</code></pre> Refactoring Info <p>This utility was created to consolidate serialization logic from: - streamlit_lightweight_charts_pro/data/data.py - streamlit_lightweight_charts_pro/charts/options/base_options.py - And other classes with custom asdict() implementations</p>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization-classes","title":"Classes","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SerializationConfig","title":"SerializationConfig","text":"<p>Configuration for serialization behavior.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializationConfig:\n    \"\"\"Configuration for serialization behavior.\"\"\"\n\n    def __init__(\n        self,\n        skip_none: bool = True,\n        skip_empty_strings: bool = True,\n        skip_empty_dicts: bool = True,\n        convert_nan_to_zero: bool = True,\n        convert_enums: bool = True,\n        flatten_options_fields: bool = True,\n    ):\n        \"\"\"Initialize serialization configuration.\n\n        Args:\n            skip_none: Whether to skip None values in serialization.\n            skip_empty_strings: Whether to skip empty string values.\n            skip_empty_dicts: Whether to skip empty dictionary values.\n            convert_nan_to_zero: Whether to convert NaN float values to 0.0.\n            convert_enums: Whether to convert Enum objects to their values.\n            flatten_options_fields: Whether to flatten fields ending in '_options'.\n        \"\"\"\n        self.skip_none = skip_none\n        self.skip_empty_strings = skip_empty_strings\n        self.skip_empty_dicts = skip_empty_dicts\n        self.convert_nan_to_zero = convert_nan_to_zero\n        self.convert_enums = convert_enums\n        self.flatten_options_fields = flatten_options_fields\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SerializableMixin","title":"SerializableMixin","text":"<p>Mixin class that provides standardized serialization capabilities.</p> <p>This mixin provides a consistent interface for serializing Python objects to frontend-compatible dictionaries. It handles common transformations including enum conversion, type normalization, and camelCase key conversion.</p> <p>Classes using this mixin should implement <code>asdict()</code> by calling <code>_serialize_to_dict()</code> with optional custom configuration.</p> Features <ul> <li>Automatic snake_case to camelCase conversion</li> <li>Enum value extraction</li> <li>NaN to zero conversion for numeric values</li> <li>Recursive serialization of nested objects</li> <li>Configurable filtering of None/empty values</li> <li>Support for special field names (like 'time' -&gt; ColumnNames.TIME)</li> </ul> Example <pre><code>from dataclasses import dataclass\nfrom streamlit_lightweight_charts_pro.utils.serialization import SerializableMixin\n\n\n@dataclass\nclass ChartConfig(SerializableMixin):\n    title: str = \"My Chart\"\n    is_visible: bool = True\n\n    def asdict(self) -&gt; Dict[str, Any]:\n        return self._serialize_to_dict()\n</code></pre> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SerializableMixin:\n    \"\"\"Mixin class that provides standardized serialization capabilities.\n\n    This mixin provides a consistent interface for serializing Python objects\n    to frontend-compatible dictionaries. It handles common transformations\n    including enum conversion, type normalization, and camelCase key conversion.\n\n    Classes using this mixin should implement `asdict()` by calling\n    `_serialize_to_dict()` with optional custom configuration.\n\n    Features:\n        - Automatic snake_case to camelCase conversion\n        - Enum value extraction\n        - NaN to zero conversion for numeric values\n        - Recursive serialization of nested objects\n        - Configurable filtering of None/empty values\n        - Support for special field names (like 'time' -&gt; ColumnNames.TIME)\n\n    Example:\n        ```python\n        from dataclasses import dataclass\n        from streamlit_lightweight_charts_pro.utils.serialization import SerializableMixin\n\n\n        @dataclass\n        class ChartConfig(SerializableMixin):\n            title: str = \"My Chart\"\n            is_visible: bool = True\n\n            def asdict(self) -&gt; Dict[str, Any]:\n                return self._serialize_to_dict()\n        ```\n    \"\"\"\n\n    def _serialize_to_dict(\n        self,\n        config: SerializationConfig = DEFAULT_CONFIG,\n        override_fields: dict[str, Any] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize the object to a dictionary with camelCase keys.\n\n        This method provides the core serialization logic that handles\n        type conversion, key transformation, and field filtering. It's\n        designed to be overridden or customized by subclasses with\n        specific serialization needs.\n\n        Args:\n            config: SerializationConfig instance controlling behavior.\n                Defaults to DEFAULT_CONFIG if not provided.\n            override_fields: Optional dictionary of field overrides.\n                Values in this dict will replace computed values during\n                serialization.\n\n        Returns:\n            Dict[str, Any]: Serialized data with camelCase keys ready for\n                frontend consumption.\n\n        Example:\n            ```python\n            # Basic serialization\n            data = Document(title=\"Test\", value=42, notes=\"\")\n            result = data._serialize_to_dict()\n            # Returns: {\"title\": \"Test\", \"value\": 42, \"notes\": \"\"}\n\n            # Custom config\n            config = SerializationConfig(skip_empty_strings=True)\n            result = data._serialize_to_dict(config)\n            # Returns: {\"title\": \"Test\", \"value\": 42}  # notes skipped\n\n            # With field overrides\n            result = data._serialize_to_dict(override_fields={\"value\": \"custom_value\"})\n            # Returns: {\"title\": \"Test\", \"value\": \"custom_value\", \"notes\": \"\"}\n            ```\n        \"\"\"\n        # Step 1: Initialize result dictionary and process overrides\n        result = {}\n        override_fields = override_fields or {}\n\n        # Step 2: Iterate through all dataclass fields\n        for field in fields(self):\n            field_name = field.name\n\n            # Step 3: Get field value (use override if provided, otherwise get from instance)\n            # Overrides allow callers to customize specific field values during serialization\n            value = override_fields.get(field_name, getattr(self, field_name))\n\n            # Step 4: Apply config-based filtering (skip None, empty strings, etc.)\n            # This removes unwanted values before serialization\n            if not self._should_include_value(value, config):\n                continue\n\n            # Step 5: Convert field name and value for frontend compatibility\n            # Processes both the key (field name) and the value\n            processed_value = self._process_value_for_serialization(value, config)\n            processed_field = self._process_field_name_for_serialization(field_name, config)\n\n            # Step 6: Handle special flattening rules\n            # Some fields (like background_options) should be merged into parent dict\n            if (\n                config.flatten_options_fields\n                and field_name.endswith(\"_options\")\n                and isinstance(processed_value, dict)\n                and field_name == \"background_options\"  # Only flatten specific fields\n            ):\n                # Merge flattened fields into result instead of nesting\n                result.update(processed_value)\n            else:\n                # Add normal or nested field to result\n                result[processed_field] = processed_value\n\n        # Step 7: Return the fully processed dictionary\n        return result\n\n    def _should_include_value(self, value: Any, config: SerializationConfig) -&gt; bool:\n        \"\"\"Determine if a value should be included in serialized output.\n\n        Args:\n            value: The value to check.\n            config: Serialization configuration.\n\n        Returns:\n            bool: True if the value should be included, False otherwise.\n        \"\"\"\n        # Check 1: Skip None values if configured\n        # Helps reduce payload size by omitting unset optional fields\n        if value is None and config.skip_none:\n            return False\n\n        # Check 2: Skip empty strings if configured\n        # Prevents sending empty string values to frontend\n        if value == \"\" and config.skip_empty_strings:\n            return False\n\n        # Check 3: Skip empty dictionaries if configured\n        # Returns True if value is not an empty dict, or if we should keep empty dicts\n        return not (value == {} and config.skip_empty_dicts)\n\n    def _process_value_for_serialization(\n        self,\n        value: Any,\n        config: SerializationConfig,\n    ) -&gt; Any:\n        \"\"\"Process a value during serialization with type-specific conversions.\n\n        Args:\n            value: The value to process.\n            config: Serialization configuration.\n\n        Returns:\n            Any: The processed value ready for serialization.\n        \"\"\"\n        # Step 1: Handle NaN floats - convert to zero for JSON compatibility\n        # JavaScript doesn't support NaN in JSON, so we convert to 0.0\n        if isinstance(value, float) and math.isnan(value) and config.convert_nan_to_zero:\n            return 0.0\n\n        # Step 2: Convert NumPy scalar types to Python native types\n        # NumPy types like np.int64 need conversion for JSON serialization\n        if hasattr(value, \"item\"):  # NumPy scalar types have .item() method\n            value = value.item()\n\n        # Step 3: Convert enums to their values\n        # Enums are serialized as their underlying value (int, string, etc.)\n        if config.convert_enums and isinstance(value, Enum):\n            value = value.value\n\n        # Step 4: Handle nested serializable objects\n        # Objects with asdict() method are serialized recursively\n        if hasattr(value, \"asdict\") and callable(value.asdict):\n            value = value.asdict()\n\n        # Step 5: Handle serializable lists recursively\n        # Lists may contain nested objects that also need serialization\n        elif isinstance(value, list):\n            return self._serialize_list_recursively(value, config)\n\n        # Step 6: Handle nested dictionaries recursively\n        # Dictionaries need key conversion (snake_case to camelCase)\n        elif isinstance(value, dict):\n            return self._serialize_dict_recursively(value, config)\n\n        # Step 7: Return the processed value\n        return value\n\n    def _serialize_list_recursively(\n        self,\n        items: list[Any],\n        config: SerializationConfig,\n    ) -&gt; list[Any]:\n        \"\"\"Serialize a list recursively.\n\n        Args:\n            items: List of items to serialize.\n            config: Serialization configuration.\n\n        Returns:\n            List[Any]: Recursively serialized list.\n        \"\"\"\n        # Initialize result list\n        processed_items = []\n\n        # Process each item in the list recursively\n        # This ensures nested objects are also properly serialized\n        for item in items:\n            processed_item = self._process_value_for_serialization(item, config)\n            processed_items.append(processed_item)\n\n        return processed_items\n\n    def _serialize_dict_recursively(\n        self,\n        data: dict[str, Any],\n        config: SerializationConfig,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Serialize a dictionary recursively with key conversion.\n\n        Args:\n            data: Dictionary to serialize.\n            config: Serialization configuration.\n\n        Returns:\n            Dict[str, Any]: Recursively processed dictionary with camelCase keys.\n        \"\"\"\n        # Initialize result dictionary\n        result = {}\n\n        # Process each key-value pair in the dictionary\n        for key, value in data.items():\n            # Step 1: Convert key to camelCase for JavaScript compatibility\n            # If key is not a string, convert it to string first\n            processed_key = snake_to_camel(key) if isinstance(key, str) else str(key)\n\n            # Step 2: Process value recursively\n            # Handles nested objects, enums, lists, etc.\n            processed_value = self._process_value_for_serialization(value, config)\n\n            # Step 3: Add processed key-value pair to result\n            result[processed_key] = processed_value\n\n        return result\n\n    def _process_field_name_for_serialization(\n        self,\n        field_name: str,\n        _config: SerializationConfig,\n    ) -&gt; str:\n        \"\"\"Process field name for serialization with special handling for known fields.\n\n        Args:\n            field_name: Original field name.\n            config: Serialization configuration.\n\n        Returns:\n            str: Processed field name.\n        \"\"\"\n        # Special handling for known column names to match frontend expectations\n        # Import inside function to avoid circular import issues\n        if field_name == \"time\":\n            # Case 1: \"time\" field - use ColumnNames enum for consistency\n            try:\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import ColumnNames\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                return snake_to_camel(field_name)\n            else:\n                return ColumnNames.TIME.value\n        elif field_name == \"value\":\n            # Case 2: \"value\" field - use ColumnNames enum for consistency\n            try:\n                # pylint: disable=import-outside-toplevel\n                from streamlit_lightweight_charts_pro.type_definitions.enums import ColumnNames\n            except ImportError:\n                # Fallback to standard camelCase if import fails\n                return snake_to_camel(field_name)\n            else:\n                return ColumnNames.VALUE.value\n        else:\n            # Case 3: Regular field - convert snake_case to camelCase\n            return snake_to_camel(field_name)\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin","title":"SimpleSerializableMixin","text":"<p>Simplified mixin for basic classes that need basic serialization.</p> <p>This variant provides a more straightforward serialization approach for simple data classes that don't need complex nested serialization or special field handling.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>class SimpleSerializableMixin(SerializableMixin):\n    \"\"\"Simplified mixin for basic classes that need basic serialization.\n\n    This variant provides a more straightforward serialization approach\n    for simple data classes that don't need complex nested serialization\n    or special field handling.\n    \"\"\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n        Returns:\n            Dict[str, Any]: Basic serialized representation.\n        \"\"\"\n        return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.SimpleSerializableMixin.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[str, Any]\n</code></pre> <p>Serialize to dictionary with basic camelCase conversion.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: Basic serialized representation.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize to dictionary with basic camelCase conversion.\n\n    Returns:\n        Dict[str, Any]: Basic serialized representation.\n    \"\"\"\n    return self._serialize_to_dict()\n</code></pre>"},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization-functions","title":"Functions","text":""},{"location":"api/streamlit_lightweight_charts_pro/utils/serialization.html#streamlit_lightweight_charts_pro.utils.serialization.create_serializable_mixin","title":"create_serializable_mixin","text":"<pre><code>create_serializable_mixin(\n    config_override: SerializationConfig = None,\n) -&gt; type\n</code></pre> <p>Factory function to create a configurable SerializableMixin.</p> <p>Parameters:</p> Name Type Description Default <code>config_override</code> <code>SerializationConfig</code> <p>Optional SerializationConfig to override defaults.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>type</code> <code>type</code> <p>A custom SerializableMixin class with the specified configuration.</p> Source code in <code>streamlit_lightweight_charts_pro/utils/serialization.py</code> <pre><code>def create_serializable_mixin(config_override: SerializationConfig = None) -&gt; type:\n    \"\"\"Factory function to create a configurable SerializableMixin.\n\n    Args:\n        config_override: Optional SerializationConfig to override defaults.\n\n    Returns:\n        type: A custom SerializableMixin class with the specified configuration.\n    \"\"\"\n    # Use provided config or fall back to default configuration\n    config = config_override or DEFAULT_CONFIG\n\n    class ConfigurableSerializableMixin(SerializableMixin):\n        \"\"\"Configurable serialization mixin with custom config.\n\n        This class provides a SerializableMixin variant with custom serialization\n        configuration. It's useful when different classes need different\n        serialization behaviors (e.g., some skip None, others don't).\n\n        Attributes:\n            config: The SerializationConfig instance to use for this mixin.\n        \"\"\"\n\n        def _get_serialization_config(self) -&gt; SerializationConfig:\n            \"\"\"Get the serialization configuration for this mixin.\n\n            Returns:\n                SerializationConfig: The configuration instance.\n            \"\"\"\n            return config\n\n        def asdict(self) -&gt; dict[str, Any]:\n            \"\"\"Serialize to dictionary using the custom configuration.\n\n            Returns:\n                Dict[str, Any]: Serialized representation with custom config applied.\n            \"\"\"\n            return self._serialize_to_dict(self._get_serialization_config())\n\n    return ConfigurableSerializableMixin\n</code></pre>"},{"location":"examples/overview.html","title":"Examples","text":"<p>Explore various chart types and configurations with these examples.</p>"},{"location":"examples/overview.html#chart-types","title":"Chart Types","text":"<ul> <li>Line Charts - Basic line charts with customization</li> <li>Candlestick Charts - OHLC candlestick charts</li> <li>Area Charts - Filled area charts</li> <li>Histogram Charts - Volume and distribution charts</li> </ul>"},{"location":"examples/overview.html#advanced-features","title":"Advanced Features","text":"<ul> <li>Multi-Pane Charts - Multiple chart panes</li> <li>Custom Styling - Advanced styling options</li> <li>Real-time Data - Live data updates</li> </ul>"},{"location":"examples/overview.html#integration-examples","title":"Integration Examples","text":"<ul> <li>Pandas Integration - Working with DataFrames</li> <li>Streamlit Widgets - Interactive controls</li> <li>Performance Optimization - Large dataset handling</li> </ul>"},{"location":"getting-started/basic-usage.html","title":"Basic Usage","text":"<p>Learn how to create your first chart with Streamlit Lightweight Charts Pro.</p>"},{"location":"getting-started/basic-usage.html#simple-line-chart","title":"Simple Line Chart","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart, LineSeries\nfrom streamlit_lightweight_charts_pro.data import SingleValueData\n\n# Sample data\ndata = [\n    SingleValueData(\"2024-01-01\", 100),\n    SingleValueData(\"2024-01-02\", 105),\n    SingleValueData(\"2024-01-03\", 103),\n    SingleValueData(\"2024-01-04\", 108),\n]\n\n# Create chart\nchart = Chart(series=LineSeries(data))\nchart.render(key=\"line_chart\")\n</code></pre>"},{"location":"getting-started/basic-usage.html#candlestick-chart","title":"Candlestick Chart","text":"<pre><code>from streamlit_lightweight_charts_pro import CandlestickSeries\nfrom streamlit_lightweight_charts_pro.data import CandlestickData\n\n# OHLC data\ncandle_data = [\n    CandlestickData(\"2024-01-01\", 100, 105, 98, 103),\n    CandlestickData(\"2024-01-02\", 103, 108, 102, 107),\n]\n\nchart = Chart(series=CandlestickSeries(candle_data))\nchart.render(key=\"candlestick_chart\")\n</code></pre>"},{"location":"getting-started/basic-usage.html#multiple-series","title":"Multiple Series","text":"<pre><code>from streamlit_lightweight_charts_pro import AreaSeries\n\n# Create multiple series\nline_series = LineSeries(data, color=\"#2196F3\")\narea_series = AreaSeries(data, color=\"#4CAF50\")\n\nchart = Chart(series=[line_series, area_series])\nchart.render(key=\"multi_series_chart\")\n</code></pre>"},{"location":"getting-started/installation.html","title":"Installation","text":"<p>Install Streamlit Lightweight Charts Pro using pip:</p> <pre><code>pip install streamlit-lightweight-charts-pro\n</code></pre>"},{"location":"getting-started/installation.html#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> <li>Streamlit 1.0+</li> <li>Node.js 16+ (for development)</li> </ul>"},{"location":"getting-started/installation.html#development-installation","title":"Development Installation","text":"<p>For development or to contribute:</p> <pre><code>git clone https://github.com/nandkapadia/streamlit-lightweight-charts-pro.git\ncd streamlit-lightweight-charts-pro\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation.html#verify-installation","title":"Verify Installation","text":"<pre><code>import streamlit as st\nfrom streamlit_lightweight_charts_pro import Chart\n\nst.write(\"Installation successful!\")\n</code></pre>"}]}
