[{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/LightweightCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/LightweightCharts.test.tsx","messages":[{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":106,"column":23,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":111,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":111,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":117,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":117,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":124,"column":23,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":183,"column":23,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":190,"column":24,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":195,"column":24,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":234,"column":23,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":241,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":241,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":247,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":247,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":260,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":268,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":268,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-container","severity":2,"message":"Avoid using container methods. Prefer using the methods from Testing Library, such as \"getByRole()\"","line":274,"column":9,"nodeType":"MemberExpression","messageId":"noContainer","endLine":274,"endColumn":32},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":278,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen, waitFor} from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport LightweightCharts from '../LightweightCharts'\nimport {ComponentConfig} from '../types'\n\n// Use real lightweight-charts library\n\n// Mock ResizeObserver\nglobal.ResizeObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock performance API\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: jest.fn(() => Date.now()),\n    mark: jest.fn(),\n    measure: jest.fn(),\n    getEntriesByType: jest.fn(() => [])\n  },\n  writable: true\n})\n\n// Mock requestAnimationFrame\nglobal.requestAnimationFrame = jest.fn(callback => {\n  setTimeout(callback, 0)\n  return 1\n})\n\nglobal.cancelAnimationFrame = jest.fn()\n\n// Mock DOM methods\nObject.defineProperty(window, 'getComputedStyle', {\n  value: () => ({\n    getPropertyValue: () => ''\n  })\n})\n\nElement.prototype.getBoundingClientRect = jest.fn(() => ({\n  width: 800,\n  height: 600,\n  top: 0,\n  left: 0,\n  right: 800,\n  bottom: 600\n}))\n\nObject.defineProperty(HTMLElement.prototype, 'scrollHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetWidth', {\n  configurable: true,\n  value: 800\n})\n\ndescribe('LightweightCharts Component', () => {\n  const mockConfig: ComponentConfig = {\n    charts: [\n      {\n        chartId: 'test-chart',\n        chart: {\n          height: 400,\n          autoSize: true,\n          layout: {\n            color: '#ffffff',\n            textColor: '#000000'\n          }\n        },\n        series: [],\n        annotations: {\n          layers: {}\n        }\n      }\n    ],\n    sync: {\n      enabled: false,\n      crosshair: false,\n      timeRange: false\n    }\n  }\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('Component Rendering', () => {\n    it('should render without crashing', () => {\n      render(<LightweightCharts config={mockConfig} />)\n      expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n    })\n\n    it('should render with custom height', () => {\n      render(<LightweightCharts config={mockConfig} height={600} />)\n      const container = document.querySelector('[id^=\"chart-container-\"]')\n      expect(container).toBeInTheDocument()\n    })\n\n    it('should render with custom width', () => {\n      render(<LightweightCharts config={mockConfig} width={800} />)\n      const container = document.querySelector('[id^=\"chart-container-\"]')\n      expect(container).toBeInTheDocument()\n    })\n\n    it('should render with onChartsReady callback', () => {\n      const mockCallback = jest.fn()\n      render(<LightweightCharts config={mockConfig} onChartsReady={mockCallback} />)\n      expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n    })\n  })\n\n  describe('Chart Configuration', () => {\n    it('should handle empty config', () => {\n      const emptyConfig: ComponentConfig = {\n        charts: [],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n      render(<LightweightCharts config={emptyConfig} />)\n      expect(screen.getByText('No charts configured')).toBeInTheDocument()\n    })\n\n    it('should handle config with multiple charts', () => {\n      const multiChartConfig: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'chart1',\n            chart: {\n              height: 300,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [],\n            annotations: {\n              layers: {}\n            }\n          },\n          {\n            chartId: 'chart2',\n            chart: {\n              height: 300,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: true,\n          crosshair: true,\n          timeRange: true\n        }\n      }\n      render(<LightweightCharts config={multiChartConfig} />)\n      expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle missing config gracefully', () => {\n      const {container} = render(<LightweightCharts config={{} as ComponentConfig} />)\n      expect(container.firstChild).toBeInTheDocument()\n    })\n\n    it('should handle null config gracefully', () => {\n      const {container} = render(<LightweightCharts config={null as any} />)\n      expect(container.firstChild).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('should handle large datasets', () => {\n      const largeConfig: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'large-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'line',\n                data: Array.from({length: 10000}, (_, i) => ({\n                  time: Date.now() + i * 60000,\n                  value: Math.random() * 100\n                }))\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n      render(<LightweightCharts config={largeConfig} />)\n      expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA attributes', () => {\n      render(<LightweightCharts config={mockConfig} />)\n      const container = document.querySelector('[id^=\"chart-container-\"]')\n      expect(container).toBeInTheDocument()\n    })\n\n    it('should be keyboard accessible', () => {\n      render(<LightweightCharts config={mockConfig} />)\n      const container = document.querySelector('[id^=\"chart-container-\"]')\n      expect(container).toBeInTheDocument()\n    })\n  })\n\n  describe('Responsive Design', () => {\n    it('should handle window resize', async () => {\n      render(<LightweightCharts config={mockConfig} />)\n\n      // Simulate window resize\n      window.dispatchEvent(new Event('resize'))\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle container resize', async () => {\n      render(<LightweightCharts config={mockConfig} />)\n\n      // Simulate container resize\n      const container = document.querySelector('[id^=\"chart-container-\"]')\n      if (container) {\n        Object.defineProperty(container, 'offsetWidth', {\n          configurable: true,\n          value: 1000\n        })\n        container.dispatchEvent(new Event('resize'))\n      }\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/graphics.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'screen' is defined but never used.","line":2,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":74,"column":32,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":75,"column":17,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":90,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":109,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":127,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":147,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":165,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":183,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":203,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":223,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":240,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":261,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":284,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":310,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":342,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":367,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":395,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":441,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":492,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":536,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":561,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":589,"column":26,"nodeType":"MemberExpression","messageId":"noNodeAccess"}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen, waitFor} from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport {\n  createChart,\n  LineSeries,\n  AreaSeries,\n  CandlestickSeries,\n  HistogramSeries\n} from 'lightweight-charts'\nimport LightweightCharts from '../LightweightCharts'\nimport {ComponentConfig} from '../types'\n\n// Helper function to generate test data\nfunction generateData() {\n  const res = []\n  const time = new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0))\n  for (let i = 0; i < 500; ++i) {\n    res.push({\n      time: time.getTime() / 1000,\n      value: i\n    })\n    time.setUTCDate(time.getUTCDate() + 1)\n  }\n  return res\n}\n\nfunction generateCandlestickData() {\n  const res = []\n  const time = new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0))\n  for (let i = 0; i < 100; ++i) {\n    const open = 100 + Math.random() * 20\n    const close = open + (Math.random() - 0.5) * 10\n    const high = Math.max(open, close) + Math.random() * 5\n    const low = Math.min(open, close) - Math.random() * 5\n\n    res.push({\n      time: time.getTime() / 1000,\n      open,\n      high,\n      low,\n      close\n    })\n    time.setUTCDate(time.getUTCDate() + 1)\n  }\n  return res\n}\n\nfunction generateHistogramData() {\n  const res = []\n  const time = new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0))\n  for (let i = 0; i < 100; ++i) {\n    res.push({\n      time: time.getTime() / 1000,\n      value: Math.random() * 1000000,\n      color: Math.random() > 0.5 ? '#00ff00' : '#ff0000'\n    })\n    time.setUTCDate(time.getUTCDate() + 1)\n  }\n  return res\n}\n\ndescribe('Graphics Tests', () => {\n  let container: HTMLElement\n\n  beforeEach(() => {\n    container = document.createElement('div')\n    container.style.width = '800px'\n    container.style.height = '400px'\n    document.body.appendChild(container)\n  })\n\n  afterEach(() => {\n    if (container && container.parentNode) {\n      container.parentNode.removeChild(container)\n    }\n  })\n\n  describe('Line Series Graphics', () => {\n    it('should render line series with basic data', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 1,\n        color: '#ff0000'\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render line series with custom styling', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 2,\n        color: '#00ff00',\n        lineStyle: 1, // Dashed\n        crosshairMarkerVisible: true,\n        lastValueVisible: true\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render line series with point markers', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 1,\n        color: '#ff0000',\n        pointMarkersVisible: true,\n        pointMarkersRadius: 4\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Area Series Graphics', () => {\n    it('should render area series with basic data', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(255, 0, 0, 0.4)',\n        bottomColor: 'rgba(255, 0, 0, 0.1)',\n        lineColor: '#ff0000',\n        lineWidth: 2\n      })\n\n      areaSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render area series with gradient', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 255, 0, 0.8)',\n        bottomColor: 'rgba(0, 255, 0, 0.2)',\n        lineColor: '#00ff00',\n        lineWidth: 1\n      })\n\n      areaSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render area series with inverted fill', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 255, 0, 0.4)',\n        bottomColor: 'rgba(0, 255, 0, 0.1)',\n        lineColor: '#00ff00',\n        invertFilledArea: true\n      })\n\n      areaSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Candlestick Series Graphics', () => {\n    it('should render candlestick series with OHLC data', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const candlestickSeries = chart.addSeries(CandlestickSeries, {\n        upColor: '#00ff00',\n        downColor: '#ff0000',\n        borderVisible: true,\n        wickVisible: true\n      })\n\n      candlestickSeries.setData(generateCandlestickData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render candlestick series with custom colors', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const candlestickSeries = chart.addSeries(CandlestickSeries, {\n        upColor: '#00ff00',\n        downColor: '#ff0000',\n        borderUpColor: '#008000',\n        borderDownColor: '#800000',\n        wickUpColor: '#00ff00',\n        wickDownColor: '#ff0000'\n      })\n\n      candlestickSeries.setData(generateCandlestickData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render candlestick series with thin bars', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const candlestickSeries = chart.addSeries(CandlestickSeries, {\n        upColor: '#00ff00',\n        downColor: '#ff0000',\n        thinBars: true\n      })\n\n      candlestickSeries.setData(generateCandlestickData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Histogram Series Graphics', () => {\n    it('should render histogram series with volume data', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const histogramSeries = chart.addSeries(HistogramSeries, {\n        color: '#888888',\n        priceFormat: {\n          type: 'volume'\n        },\n        priceScaleId: 'volume'\n      })\n\n      histogramSeries.setData(generateHistogramData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render histogram series with custom colors', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const histogramSeries = chart.addSeries(HistogramSeries, {\n        color: '#888888',\n        priceFormat: {\n          type: 'volume'\n        },\n        priceScaleId: 'volume',\n        scaleMargins: {\n          top: 0.8,\n          bottom: 0\n        }\n      })\n\n      histogramSeries.setData(generateHistogramData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Chart Integration Graphics', () => {\n    it('should render multiple series on same chart', async () => {\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 255, 0, 0.4)',\n        bottomColor: 'rgba(0, 255, 0, 0.1)',\n        lineColor: '#00ff00'\n      })\n\n      lineSeries.setData(generateData())\n      areaSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with custom layout', async () => {\n      const chart = createChart(container, {\n        layout: {\n          attributionLogo: false,\n          background: {color: '#f0f0f0'},\n          textColor: '#333333'\n        },\n        grid: {\n          vertLines: {color: '#e0e0e0'},\n          horzLines: {color: '#e0e0e0'}\n        },\n        crosshair: {\n          mode: 1,\n          vertLine: {color: '#666666'},\n          horzLine: {color: '#666666'}\n        }\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with time scale options', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        timeScale: {\n          timeVisible: true,\n          secondsVisible: false,\n          borderVisible: true,\n          borderColor: '#cccccc'\n        }\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with price scale options', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        rightPriceScale: {\n          visible: true,\n          borderVisible: true,\n          borderColor: '#cccccc',\n          scaleMargins: {\n            top: 0.1,\n            bottom: 0.1\n          }\n        }\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateData())\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('React Component Graphics', () => {\n    it('should render LightweightCharts component with line series', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: generateData(),\n                options: {\n                  color: '#ff0000',\n                  lineWidth: 2\n                }\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should render LightweightCharts component with multiple series', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: generateData(),\n                options: {\n                  color: '#ff0000',\n                  lineWidth: 2\n                }\n              },\n              {\n                type: 'Area',\n                data: generateData(),\n                options: {\n                  topColor: 'rgba(0, 255, 0, 0.4)',\n                  bottomColor: 'rgba(0, 255, 0, 0.1)',\n                  lineColor: '#00ff00'\n                }\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should render LightweightCharts component with candlestick series', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Candlestick',\n                data: generateCandlestickData(),\n                options: {\n                  upColor: '#00ff00',\n                  downColor: '#ff0000',\n                  borderVisible: true,\n                  wickVisible: true\n                }\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Performance Graphics', () => {\n    it('should handle large datasets efficiently', async () => {\n      const largeData = Array.from({length: 10000}, (_, i) => ({\n        time: Date.now() / 1000 + i * 60,\n        value: 100 + Math.random() * 20\n      }))\n\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 1\n      })\n\n      const startTime = performance.now()\n      lineSeries.setData(largeData)\n      const endTime = performance.now()\n\n      expect(endTime - startTime).toBeLessThan(1000) // Should complete within 1 second\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n\n    it('should handle multiple series with large datasets', async () => {\n      const largeData = Array.from({length: 5000}, (_, i) => ({\n        time: Date.now() / 1000 + i * 60,\n        value: 100 + Math.random() * 20\n      }))\n\n      const chart = createChart(container, {layout: {attributionLogo: false}})\n\n      const lineSeries = chart.addSeries(LineSeries, {color: '#ff0000'})\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 255, 0, 0.4)',\n        bottomColor: 'rgba(0, 255, 0, 0.1)'\n      })\n\n      const startTime = performance.now()\n      lineSeries.setData(largeData)\n      areaSeries.setData(largeData)\n      const endTime = performance.now()\n\n      expect(endTime - startTime).toBeLessThan(2000) // Should complete within 2 seconds\n\n      await waitFor(() => {\n        expect(container.querySelector('canvas')).toBeInTheDocument()\n      })\n\n      chart.remove()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/index.test.tsx","messages":[{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":140,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":140,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":192,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":192,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":245,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":245,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":300,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":300,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":360,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":360,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":415,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":415,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":478,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":478,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":534,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":534,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":593,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":593,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":651,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":651,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":714,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":714,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":742,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":742,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":787,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":787,"endColumn":93},{"ruleId":"testing-library/render-result-naming-convention","severity":2,"message":"`mockUseRenderData` is not a recommended name for `render` returned value. Instead, you should destructure it, or name it using one of: `view`, or `utils`","line":863,"column":13,"nodeType":"VariableDeclarator","messageId":"renderResultNamingConvention","endLine":863,"endColumn":93}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen, waitFor} from '@testing-library/react'\nimport '@testing-library/jest-dom'\n\n// Mock the components and hooks\njest.mock('streamlit-component-lib', () => ({\n  Streamlit: {\n    setComponentValue: jest.fn(),\n    setFrameHeight: jest.fn(),\n    setComponentReady: jest.fn(),\n    RENDER_EVENT: 'streamlit:render',\n    SET_FRAME_HEIGHT_EVENT: 'streamlit:setFrameHeight'\n  }\n}))\n\njest.mock('streamlit-component-lib-react-hooks', () => ({\n  useRenderData: jest.fn(() => ({\n    args: {\n      config: {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      },\n      height: 400,\n      width: null\n    },\n    disabled: false,\n    height: 400,\n    width: 800,\n    theme: {\n      base: 'light',\n      primaryColor: '#ff4b4b',\n      backgroundColor: '#ffffff',\n      secondaryBackgroundColor: '#f0f2f6',\n      textColor: '#262730'\n    }\n  })),\n  StreamlitProvider: ({children}: {children: React.ReactNode}) => <div>{children}</div>\n}))\n\njest.mock('../LightweightCharts', () => {\n  return function MockLightweightCharts({config, height, width, onChartsReady}: any) {\n    // Automatically call onChartsReady when component mounts\n    const {useEffect} = require('react')\n    useEffect(() => {\n      if (onChartsReady) {\n        onChartsReady()\n      }\n    }, [onChartsReady])\n\n    return (\n      <div className=\"chart-container\" data-testid=\"lightweight-charts\">\n        <div>Mock Chart Component</div>\n        <div>Config: {JSON.stringify(config).substring(0, 50)}...</div>\n        <div>Height: {height}</div>\n        <div>Width: {width === null ? 'null' : width === undefined ? 'undefined' : width}</div>\n        {onChartsReady && (\n          <button onClick={onChartsReady} data-testid=\"charts-ready-btn\">\n            Charts Ready\n          </button>\n        )}\n      </div>\n    )\n  }\n})\n\n// Mock ReactDOM.render\njest.mock('react-dom', () => ({\n  ...jest.requireActual('react-dom'),\n  render: jest.fn()\n}))\n\n// Mock DOM methods\nObject.defineProperty(window, 'getComputedStyle', {\n  value: () => ({\n    getPropertyValue: () => ''\n  })\n})\n\nElement.prototype.getBoundingClientRect = jest.fn(() => ({\n  width: 800,\n  height: 600,\n  top: 0,\n  left: 0,\n  right: 800,\n  bottom: 600\n}))\n\nObject.defineProperty(HTMLElement.prototype, 'scrollHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetWidth', {\n  configurable: true,\n  value: 800\n})\n\n// Mock setTimeout and clearTimeout\njest.useFakeTimers()\n\ndescribe('Index Component', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  afterEach(() => {\n    jest.clearAllTimers()\n  })\n\n  describe('Component Rendering', () => {\n    it('should render the main app component', async () => {\n      const {default: App} = await import('../index')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n      expect(screen.getByText('Mock Chart Component')).toBeInTheDocument()\n    })\n\n    it('should render with default configuration', async () => {\n      const {default: App} = await import('../index')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByText(/Config:/)).toBeInTheDocument()\n      expect(screen.getByText(/Height: 400/)).toBeInTheDocument()\n      expect(screen.getByText(/Width: null/)).toBeInTheDocument()\n    })\n\n    it('should render with custom height and width', async () => {\n      const {default: App} = await import('../index')\n\n      // Mock useRenderData to return custom dimensions\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 600,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 600,\n          width: 1000\n        },\n        disabled: false,\n        height: 600,\n        width: 1000,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByText(/Height: 600/)).toBeInTheDocument()\n      expect(screen.getByText(/Width: 1000/)).toBeInTheDocument()\n    })\n  })\n\n  describe('Component Initialization', () => {\n    it('should set component ready state', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      // Wait for component ready to be set\n      await waitFor(() => {\n        expect(Streamlit.setComponentReady).toHaveBeenCalled()\n      })\n    })\n\n    it('should handle component ready errors gracefully', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Mock setComponentReady to throw error\n      Streamlit.setComponentReady.mockImplementation(() => {\n        throw new Error('Component ready error')\n      })\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      // Should not crash\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n  })\n\n  describe('Frame Height Management', () => {\n    it('should set frame height when charts are ready', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      const chartsReadyBtn = screen.getByTestId('charts-ready-btn')\n      chartsReadyBtn.click()\n\n      // Wait for frame height to be set\n      await waitFor(() => {\n        expect(Streamlit.setFrameHeight).toHaveBeenCalled()\n      })\n    })\n\n    it('should handle frame height errors gracefully', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Mock setFrameHeight to throw error\n      Streamlit.setFrameHeight.mockImplementation(() => {\n        throw new Error('Frame height error')\n      })\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      const chartsReadyBtn = screen.getByTestId('charts-ready-btn')\n      chartsReadyBtn.click()\n\n      // Should not crash\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n\n    it('should calculate correct frame height', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      const chartsReadyBtn = screen.getByTestId('charts-ready-btn')\n      chartsReadyBtn.click()\n\n      await waitFor(() => {\n        expect(Streamlit.setFrameHeight).toHaveBeenCalledWith(600) // No padding needed\n      })\n    })\n  })\n\n  describe('Resize Handling', () => {\n    it('should handle window resize events', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      // Simulate window resize\n      window.dispatchEvent(new Event('resize'))\n\n      // Wait for resize handling\n      await waitFor(() => {\n        expect(Streamlit.setFrameHeight).toHaveBeenCalled()\n      })\n    })\n\n    it('should debounce resize events', async () => {\n      const {default: App} = await import('../index')\n      const {Streamlit} = require('streamlit-component-lib')\n\n      // Ensure the mock is properly applied\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      // Trigger multiple resize events\n      window.dispatchEvent(new Event('resize'))\n      window.dispatchEvent(new Event('resize'))\n      window.dispatchEvent(new Event('resize'))\n\n      // Fast-forward timers\n      jest.advanceTimersByTime(100)\n\n      await waitFor(() => {\n        expect(Streamlit.setFrameHeight).toHaveBeenCalled()\n      })\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle missing config gracefully', async () => {\n      const {default: App} = await import('../index')\n\n      // Mock useRenderData to return missing config\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: null,\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n\n    it('should handle disabled state', async () => {\n      const {default: App} = await import('../index')\n\n      // Mock useRenderData to return disabled state\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: true,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n  })\n\n  describe('Theme Integration', () => {\n    it('should pass theme to chart component', async () => {\n      const {default: App} = await import('../index')\n\n      const customTheme = {\n        base: 'dark',\n        primaryColor: '#00ff00',\n        backgroundColor: '#000000',\n        secondaryBackgroundColor: '#111111',\n        textColor: '#ffffff'\n      }\n\n      // Mock useRenderData to return custom theme\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: {\n            charts: [\n              {\n                chartId: 'test-chart',\n                chart: {\n                  height: 400,\n                  autoSize: true,\n                  layout: {\n                    color: '#ffffff',\n                    textColor: '#000000'\n                  }\n                },\n                series: [],\n                annotations: {\n                  layers: {}\n                }\n              }\n            ],\n            sync: {\n              enabled: false,\n              crosshair: false,\n              timeRange: false\n            }\n          },\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: customTheme\n      })\n\n      render(<App />)\n\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('should handle large configurations efficiently', async () => {\n      const {default: App} = await import('../index')\n\n      const largeConfig = {\n        charts: Array.from({length: 10}, (_, i) => ({\n          chartId: `chart-${i}`,\n          chart: {\n            height: 400,\n            autoSize: true,\n            layout: {\n              color: '#ffffff',\n              textColor: '#000000'\n            }\n          },\n          series: Array.from({length: 5}, (_, j) => ({\n            type: 'line',\n            data: Array.from({length: 1000}, (_, k) => ({\n              time: Date.now() + k * 60000,\n              value: Math.random() * 100\n            }))\n          })),\n          annotations: {\n            layers: {}\n          }\n        })),\n        sync: {\n          enabled: true,\n          crosshair: true,\n          timeRange: true\n        }\n      }\n\n      // Mock useRenderData to return large config\n      const mockUseRenderData = require('streamlit-component-lib-react-hooks').useRenderData\n      mockUseRenderData.mockReturnValue({\n        args: {\n          config: largeConfig,\n          height: 400,\n          width: null\n        },\n        disabled: false,\n        height: 400,\n        width: 800,\n        theme: {\n          base: 'light',\n          primaryColor: '#ff4b4b',\n          backgroundColor: '#ffffff',\n          secondaryBackgroundColor: '#f0f2f6',\n          textColor: '#262730'\n        }\n      })\n\n      render(<App />)\n\n      expect(screen.getByTestId('lightweight-charts')).toBeInTheDocument()\n    })\n  })\n\n  describe('Cleanup', () => {\n    it('should cleanup on unmount', async () => {\n      const {default: App} = await import('../index')\n      const {unmount} = render(<App />)\n\n      unmount()\n\n      // Should not throw any errors during cleanup\n      expect(true).toBe(true)\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/integration.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'screen' is defined but never used.","line":2,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockChart' is assigned a value but never used.","line":8,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":16},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":269,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":328,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":388,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":456,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":499,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":506,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":547,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":551,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":551,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":561,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":612,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":653,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":680,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":722,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":760,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":803,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":807,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":807,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":815,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":858,"column":25,"nodeType":"MemberExpression","messageId":"noNodeAccess"}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen, waitFor, fireEvent} from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport LightweightCharts from '../LightweightCharts'\nimport {ComponentConfig} from '../types'\n\n// Mock the lightweight-charts library\nconst mockChart = {\n  addCandlestickSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addLineSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addAreaSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addHistogramSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addBaselineSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addBandSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()}))\n  })),\n  addSeries: jest.fn(() => ({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    priceScale: jest.fn(() => ({applyOptions: jest.fn()})),\n    attachPrimitive: jest.fn(),\n    createPriceLine: jest.fn()\n  })),\n  chartElement: {\n    id: 'mock-chart-element',\n    style: {},\n    getBoundingClientRect: jest.fn(() => ({\n      width: 800,\n      height: 400,\n      top: 0,\n      left: 0,\n      right: 800,\n      bottom: 400\n    })),\n    appendChild: jest.fn(),\n    removeChild: jest.fn(),\n    querySelector: jest.fn(),\n    querySelectorAll: jest.fn(() => []),\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn()\n  },\n  setCrosshairPosition: jest.fn(),\n  panes: jest.fn(() => [\n    {id: 'pane-0', height: 200},\n    {id: 'pane-1', height: 100}\n  ]),\n  addPane: jest.fn(() => ({\n    id: 'pane-new',\n    height: 100,\n    attachPrimitive: jest.fn()\n  })),\n  timeScale: jest.fn(() => ({\n    fitContent: jest.fn(),\n    scrollToPosition: jest.fn(),\n    scrollToTime: jest.fn(),\n    setVisibleRange: jest.fn(),\n    applyOptions: jest.fn(),\n    getVisibleRange: jest.fn(() => ({\n      from: 0,\n      to: 1000\n    })),\n    subscribeVisibleTimeRangeChange: jest.fn()\n  })),\n  priceScale: jest.fn(() => ({applyOptions: jest.fn()})),\n  applyOptions: jest.fn(),\n  resize: jest.fn(),\n  remove: jest.fn(),\n  subscribeClick: jest.fn(),\n  subscribeCrosshairMove: jest.fn(),\n  unsubscribeClick: jest.fn(),\n  unsubscribeCrosshairMove: jest.fn()\n}\n\n// Mock ResizeObserver\nglobal.ResizeObserver = jest.fn().mockImplementation(callback => ({\n  observe: jest.fn(element => {\n    // Simulate a resize event\n    if (callback) {\n      setTimeout(() => {\n        callback([\n          {\n            target: element,\n            contentRect: {\n              width: 800,\n              height: 600,\n              top: 0,\n              left: 0,\n              right: 800,\n              bottom: 600\n            }\n          }\n        ])\n      }, 0)\n    }\n  }),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock performance API\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: jest.fn(() => Date.now()),\n    mark: jest.fn(),\n    measure: jest.fn(),\n    getEntriesByType: jest.fn(() => [])\n  },\n  writable: true\n})\n\n// Mock requestAnimationFrame\nglobal.requestAnimationFrame = jest.fn(callback => {\n  setTimeout(callback, 0)\n  return 1\n})\n\nglobal.cancelAnimationFrame = jest.fn()\n\n// Mock DOM methods\nObject.defineProperty(window, 'getComputedStyle', {\n  value: () => ({\n    getPropertyValue: () => ''\n  })\n})\n\nElement.prototype.getBoundingClientRect = jest.fn(\n  () =>\n    ({\n      width: 800,\n      height: 600,\n      top: 0,\n      left: 0,\n      right: 800,\n      bottom: 600,\n      x: 0,\n      y: 0,\n      toJSON: jest.fn()\n    }) as DOMRect\n)\n\nObject.defineProperty(HTMLElement.prototype, 'scrollHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetWidth', {\n  configurable: true,\n  value: 800\n})\n\ndescribe('Frontend Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('Complete Chart Workflow', () => {\n    it('should render a complete chart with multiple series', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'main-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Candlestick',\n                data: [\n                  {\n                    time: '2024-01-01',\n                    open: 100,\n                    high: 110,\n                    low: 95,\n                    close: 105\n                  },\n                  {\n                    time: '2024-01-02',\n                    open: 105,\n                    high: 115,\n                    low: 100,\n                    close: 110\n                  }\n                ],\n                options: {\n                  upColor: '#00ff00',\n                  downColor: '#ff0000'\n                }\n              },\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {\n                  color: '#0000ff',\n                  lineWidth: 2\n                }\n              }\n            ],\n            annotations: [\n              {\n                time: '2024-01-01',\n                price: 100,\n                text: 'Start',\n                type: 'text',\n                position: 'above'\n              }\n            ]\n          }\n        ],\n        syncConfig: {\n          enabled: true,\n          crosshair: true,\n          timeRange: true\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle chart with trades visualization', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'trades-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Candlestick',\n                data: [\n                  {\n                    time: '2024-01-01',\n                    open: 100,\n                    high: 110,\n                    low: 95,\n                    close: 105\n                  }\n                ],\n                options: {\n                  upColor: '#00ff00',\n                  downColor: '#ff0000'\n                }\n              }\n            ],\n            trades: [\n              {\n                entryTime: '2024-01-01',\n                entryPrice: 100,\n                exitTime: '2024-01-02',\n                exitPrice: 110,\n                quantity: 10,\n                tradeType: 'long'\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle chart with volume series', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'volume-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Candlestick',\n                data: [\n                  {\n                    time: '2024-01-01',\n                    open: 100,\n                    high: 110,\n                    low: 95,\n                    close: 105\n                  }\n                ],\n                options: {\n                  upColor: '#00ff00',\n                  downColor: '#ff0000'\n                }\n              },\n              {\n                type: 'Histogram',\n                data: [{time: '2024-01-01', value: 1000000, color: '#00ff00'}],\n                options: {\n                  color: '#888888',\n                  priceFormat: {\n                    type: 'volume'\n                  },\n                  priceScaleId: 'volume'\n                }\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Synchronization', () => {\n    it('should synchronize multiple charts', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'chart1',\n            chartGroupId: 1,\n            chart: {\n              width: 800,\n              height: 300,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          },\n          {\n            chartId: 'chart2',\n            chartGroupId: 1,\n            chart: {\n              width: 800,\n              height: 300,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 90},\n                  {time: '2024-01-02', value: 100}\n                ],\n                options: {color: '#00ff00'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: true,\n          crosshair: true,\n          timeRange: true\n        }\n      }\n\n      render(<LightweightCharts config={config} height={600} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Responsiveness', () => {\n    it('should handle window resize events', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'responsive-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n\n      // Simulate window resize\n      window.dispatchEvent(new Event('resize'))\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle container resize events', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'container-responsive-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n\n      // Simulate container resize\n      const container = document.querySelector('.chart-container')\n      if (container) {\n        Object.defineProperty(container, 'offsetWidth', {\n          configurable: true,\n          value: 1000\n        })\n        container.dispatchEvent(new Event('resize'))\n      }\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Performance', () => {\n    it('should handle large datasets efficiently', async () => {\n      const largeData = Array.from({length: 1000}, (_, i) => ({\n        time: `2024-01-${String(i + 1).padStart(2, '0')}`,\n        open: 100 + Math.random() * 20,\n        high: 110 + Math.random() * 20,\n        low: 90 + Math.random() * 20,\n        close: 100 + Math.random() * 20\n      }))\n\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'large-dataset-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Candlestick',\n                data: largeData,\n                options: {\n                  upColor: '#00ff00',\n                  downColor: '#ff0000'\n                }\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle rapid updates', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'rapid-updates-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      const {rerender} = render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n\n      // Simulate rapid config updates\n      for (let i = 0; i < 10; i++) {\n        const updatedConfig = {\n          ...config,\n          charts: [\n            {\n              ...config.charts[0],\n              series: [\n                {\n                  ...config.charts[0].series[0],\n                  data: [\n                    {time: '2024-01-01', value: 100 + i},\n                    {time: '2024-01-02', value: 110 + i}\n                  ]\n                }\n              ]\n            }\n          ]\n        }\n\n        rerender(<LightweightCharts config={updatedConfig} height={400} />)\n      }\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Error Handling', () => {\n    it('should handle invalid configuration gracefully', async () => {\n      const invalidConfig = {\n        charts: [\n          {\n            chartId: 'invalid-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'invalid-type',\n                data: [{time: '2024-01-01', value: 100}],\n                options: {}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(\n        <LightweightCharts config={invalidConfig as unknown as ComponentConfig} height={400} />\n      )\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n\n    it('should handle missing data gracefully', async () => {\n      const configWithMissingData: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'missing-data-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: null,\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={configWithMissingData} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Accessibility', () => {\n    it('should support keyboard navigation', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'accessible-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n\n      // Test keyboard navigation\n      const container = document.querySelector('.chart-container')\n      if (container) {\n        fireEvent.keyDown(container, {key: 'Tab'})\n        fireEvent.keyDown(container, {key: 'ArrowRight'})\n        fireEvent.keyDown(container, {key: 'ArrowLeft'})\n      }\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Cleanup', () => {\n    it('should cleanup resources on unmount', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'cleanup-chart',\n            chart: {\n              width: 800,\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: [\n                  {time: '2024-01-01', value: 100},\n                  {time: '2024-01-02', value: 110}\n                ],\n                options: {color: '#ff0000'}\n              }\n            ],\n            annotations: []\n          }\n        ],\n        syncConfig: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      const {unmount} = render(<LightweightCharts config={config} height={400} />)\n\n      await waitFor(() => {\n        expect(document.querySelector('[id^=\"chart-container-\"]')).toBeInTheDocument()\n      })\n\n      unmount()\n\n      // Should not throw any errors during cleanup\n      expect(true).toBe(true)\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/plugins.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'signalSeries' is assigned a value but never used.","line":219,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {RectangleOverlayPlugin} from '../plugins/overlay/rectanglePlugin'\nimport {SignalSeries} from '../plugins/series/signalSeriesPlugin'\nimport {createTradeVisualElements} from '../services/tradeVisualization'\nimport {createAnnotationVisualElements} from '../services/annotationSystem'\n\n// Mock the lightweight-charts library\nconst mockChart = {\n  addCandlestickSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}})\n  }),\n  addLineSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}})\n  }),\n  addCustomSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}})\n  }),\n  removeSeries: () => {},\n  timeScale: jest.fn(() => ({\n    fitContent: () => {},\n    scrollToPosition: () => {},\n    scrollToTime: () => {},\n    setVisibleRange: () => {},\n    applyOptions: () => {},\n    subscribeVisibleTimeRangeChange: jest.fn()\n  })),\n  chartElement: {\n    width: 800,\n    height: 600,\n    style: {\n      position: 'relative',\n      width: '800px',\n      height: '600px'\n    },\n    getBoundingClientRect: () => ({\n      width: 800,\n      height: 600,\n      top: 0,\n      left: 0,\n      right: 800,\n      bottom: 600\n    }),\n    appendChild: jest.fn(),\n    removeChild: jest.fn(),\n    querySelector: jest.fn(),\n    querySelectorAll: jest.fn(() => []),\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn()\n  },\n  addPane: () => ({\n    id: 'pane-1',\n    height: 100\n  }),\n  panes: () => [\n    {id: 'pane-0', height: 200},\n    {id: 'pane-1', height: 100}\n  ],\n  addSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}}),\n    attachPrimitive: () => {}\n  }),\n  priceScale: () => ({applyOptions: () => {}}),\n  applyOptions: () => {},\n  resize: () => {},\n  remove: () => {},\n  subscribeClick: () => {},\n  subscribeCrosshairMove: () => {},\n  subscribeDblClick: () => {},\n  unsubscribeClick: () => {},\n  unsubscribeCrosshairMove: () => {},\n  unsubscribeDblClick: () => {},\n  subscribeVisibleTimeRangeChange: () => {},\n  unsubscribeVisibleTimeRangeChange: () => {},\n  subscribeVisiblePriceRangeChange: () => {},\n  unsubscribeVisiblePriceRangeChange: () => {},\n  subscribeCrosshairMoved: () => {},\n  unsubscribeCrosshairMoved: () => {}\n} as any\n\n// Mock HTMLCanvasElement and CanvasRenderingContext2D\nconst mockCanvas = {\n  getContext: jest.fn(() => ({\n    clearRect: jest.fn(),\n    fillRect: jest.fn(),\n    strokeRect: jest.fn(),\n    beginPath: jest.fn(),\n    moveTo: jest.fn(),\n    lineTo: jest.fn(),\n    stroke: jest.fn(),\n    fill: jest.fn(),\n    save: jest.fn(),\n    restore: jest.fn(),\n    translate: jest.fn(),\n    scale: jest.fn(),\n    rotate: jest.fn(),\n    setTransform: jest.fn(),\n    drawImage: jest.fn(),\n    measureText: jest.fn(() => ({width: 100})),\n    fillText: jest.fn(),\n    strokeText: jest.fn(),\n    canvas: {\n      width: 800,\n      height: 600\n    }\n  })),\n  width: 800,\n  height: 600,\n  style: {},\n  getBoundingClientRect: jest.fn(() => ({\n    width: 800,\n    height: 600,\n    top: 0,\n    left: 0,\n    right: 800,\n    bottom: 600\n  })),\n  appendChild: jest.fn(),\n  removeChild: jest.fn(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn()\n}\n\n// Mock document.createElement\nconst originalCreateElement = document.createElement\ndocument.createElement = jest.fn(tagName => {\n  if (tagName === 'canvas') {\n    return mockCanvas\n  }\n  return originalCreateElement.call(document, tagName)\n})\n\ndescribe('Chart Plugins', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('RectangleOverlayPlugin', () => {\n    it('should create rectangle overlay plugin', () => {\n      const plugin = new RectangleOverlayPlugin()\n      expect(plugin).toBeDefined()\n    })\n\n    it('should add rectangle overlay to chart', () => {\n      const plugin = new RectangleOverlayPlugin()\n      const chart = mockChart\n\n      plugin.addToChart(chart)\n\n      expect(chart).toBeDefined()\n    })\n\n    it('should handle rectangle data', () => {\n      const plugin = new RectangleOverlayPlugin()\n      const chart = mockChart\n\n      plugin.addToChart(chart)\n\n      const rectangleData = [\n        {\n          id: 'rect-1',\n          time: '2024-01-01',\n          price: 100,\n          x1: 0,\n          y1: 0,\n          x2: 50,\n          y2: 20,\n          color: '#ff0000'\n        }\n      ]\n\n      plugin.setRectangles(rectangleData)\n\n      expect(plugin).toBeDefined()\n    })\n\n    it('should handle empty rectangle data', () => {\n      const plugin = new RectangleOverlayPlugin()\n      const chart = mockChart\n\n      plugin.addToChart(chart)\n      plugin.setRectangles([])\n\n      expect(plugin).toBeDefined()\n    })\n\n    it('should handle invalid rectangle data', () => {\n      const plugin = new RectangleOverlayPlugin()\n      const chart = mockChart\n\n      plugin.addToChart(chart)\n      plugin.setRectangles(null)\n\n      expect(plugin).toBeDefined()\n    })\n  })\n\n  describe('SignalSeries', () => {\n    it('should create signal series', () => {\n      const chart = mockChart\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n      expect(signalSeries).toBeDefined()\n    })\n\n    it('should add signal series to chart', () => {\n      const chart = mockChart\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n\n      expect(chart).toBeDefined()\n    })\n\n    it('should handle signal data', () => {\n      const chart = mockChart\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n\n      const signalData = [\n        {\n          time: '2024-01-01',\n          value: 100,\n          type: 'buy',\n          color: '#00ff00'\n        }\n      ]\n\n      signalSeries.setSignals(signalData)\n\n      expect(signalSeries).toBeDefined()\n    })\n\n    it('should handle empty signal data', () => {\n      const chart = mockChart\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n      signalSeries.setSignals([])\n\n      expect(signalSeries).toBeDefined()\n    })\n\n    it('should handle different signal types', () => {\n      const chart = mockChart\n      const config = {\n        data: [],\n        options: {visible: true},\n        paneId: 0,\n        type: 'signal' as const\n      }\n      const signalSeries = new SignalSeries(chart, config)\n\n      const signalData = [\n        {time: '2024-01-01', value: 100, type: 'buy', color: '#00ff00'},\n        {time: '2024-01-02', value: 110, type: 'sell', color: '#ff0000'},\n        {time: '2024-01-03', value: 105, type: 'hold', color: '#ffff00'}\n      ]\n\n      signalSeries.setSignals(signalData)\n\n      expect(signalSeries).toBeDefined()\n    })\n  })\n\n  describe('Trade Visualization', () => {\n    it('should create trade visual elements', () => {\n      const trades = [\n        {\n          entryTime: '2024-01-01',\n          entryPrice: 100,\n          exitTime: '2024-01-02',\n          exitPrice: 110,\n          quantity: 10,\n          tradeType: 'long' as const\n        }\n      ]\n\n      const options = {showAnnotations: true, style: 'markers' as const}\n      const elements = createTradeVisualElements(trades, options)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle empty trades', () => {\n      const options = {showAnnotations: true, style: 'markers' as const}\n      const elements = createTradeVisualElements([], options)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle null trades', () => {\n      const options = {showAnnotations: true, style: 'markers' as const}\n      const elements = createTradeVisualElements(null, options)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle different trade types', () => {\n      const trades = [\n        {\n          entryTime: '2024-01-01',\n          entryPrice: 100,\n          exitTime: '2024-01-02',\n          exitPrice: 110,\n          quantity: 10,\n          tradeType: 'long' as const\n        },\n        {\n          entryTime: '2024-01-03',\n          entryPrice: 110,\n          exitTime: '2024-01-04',\n          exitPrice: 100,\n          quantity: 5,\n          tradeType: 'short' as const\n        }\n      ]\n\n      const options = {showAnnotations: true, style: 'markers' as const}\n      const elements = createTradeVisualElements(trades, options)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle trades with missing data', () => {\n      const trades = [\n        {\n          entryTime: '2024-01-01',\n          entryPrice: 100,\n          exitTime: '2024-01-02',\n          exitPrice: 110,\n          quantity: 10,\n          tradeType: 'long' as const\n        },\n        {\n          entryTime: '2024-01-03',\n          entryPrice: 110,\n          exitTime: '2024-01-04',\n          exitPrice: 100,\n          quantity: 5,\n          tradeType: 'short' as const\n        }\n      ]\n\n      const options = {showAnnotations: true, style: 'markers' as const}\n      const elements = createTradeVisualElements(trades, options)\n      expect(elements).toBeDefined()\n    })\n  })\n\n  describe('Annotation System', () => {\n    it('should create annotation visual elements', () => {\n      const annotations = [\n        {\n          time: '2024-01-01',\n          price: 100,\n          text: 'Test annotation',\n          type: 'text' as const,\n          position: 'above' as const\n        }\n      ]\n\n      const elements = createAnnotationVisualElements(annotations)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle empty annotations', () => {\n      const elements = createAnnotationVisualElements([])\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle null annotations', () => {\n      const elements = createAnnotationVisualElements(null)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle different annotation types', () => {\n      const annotations = [\n        {\n          time: '2024-01-01',\n          price: 100,\n          text: 'Text annotation',\n          type: 'text' as const,\n          position: 'above' as const\n        },\n        {\n          time: '2024-01-02',\n          price: 110,\n          text: 'Arrow annotation',\n          type: 'arrow' as const,\n          position: 'below' as const\n        },\n        {\n          time: '2024-01-03',\n          price: 105,\n          text: 'Shape annotation',\n          type: 'shape' as const,\n          position: 'inline' as const\n        }\n      ]\n\n      const elements = createAnnotationVisualElements(annotations)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle annotations with custom styling', () => {\n      const annotations = [\n        {\n          time: '2024-01-01',\n          price: 100,\n          text: 'Styled annotation',\n          type: 'text' as const,\n          position: 'above' as const,\n          color: '#ff0000',\n          backgroundColor: '#ffff00',\n          fontSize: 14,\n          fontWeight: 'bold'\n        }\n      ]\n\n      const elements = createAnnotationVisualElements(annotations)\n      expect(elements).toBeDefined()\n    })\n\n    it('should handle annotations with missing properties', () => {\n      const annotations = [\n        {\n          time: '2024-01-01',\n          price: 100,\n          text: 'Minimal annotation',\n          type: 'text' as const,\n          position: 'above' as const\n        }\n      ]\n\n      const elements = createAnnotationVisualElements(annotations)\n      expect(elements).toBeDefined()\n    })\n  })\n\n  describe('Plugin Integration', () => {\n    it('should integrate multiple plugins with chart', () => {\n      const chart = mockChart\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n\n      rectanglePlugin.addToChart(chart)\n      signalSeries.addToChart(chart)\n\n      expect(chart).toBeDefined()\n    })\n\n    it('should handle plugin cleanup', () => {\n      const chart = mockChart\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n      rectanglePlugin.addToChart(chart)\n\n      // Simulate cleanup\n      rectanglePlugin.remove()\n\n      expect(rectanglePlugin).toBeDefined()\n    })\n\n    it('should handle plugin errors gracefully', () => {\n      const chart = null // Invalid chart\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n\n      // Should not throw error\n      expect(() => {\n        rectanglePlugin.addToChart(chart)\n      }).not.toThrow()\n    })\n  })\n\n  describe('Performance', () => {\n    it('should handle large datasets efficiently', () => {\n      const chart = mockChart\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n      rectanglePlugin.addToChart(chart)\n\n      const largeRectangleData = Array.from({length: 1000}, (_, i) => ({\n        id: `rect-${i}`,\n        time: `2024-01-${String(i + 1).padStart(2, '0')}`,\n        price: 100 + i,\n        x1: 0,\n        y1: 0,\n        x2: 50,\n        y2: 20,\n        color: '#ff0000'\n      }))\n\n      rectanglePlugin.setRectangles(largeRectangleData)\n\n      expect(rectanglePlugin).toBeDefined()\n    })\n\n    it('should handle rapid updates', () => {\n      const chart = mockChart\n      const config = {data: [], options: {visible: true}, paneId: 0, type: 'signal' as const}\n      const signalSeries = new SignalSeries(chart, config)\n\n      // Simulate rapid updates\n      for (let i = 0; i < 100; i++) {\n        const signalData = [\n          {\n            time: `2024-01-${String(i + 1).padStart(2, '0')}`,\n            value: 100 + i,\n            type: 'buy',\n            color: '#00ff00'\n          }\n        ]\n\n        signalSeries.setSignals(signalData)\n      }\n\n      expect(signalSeries).toBeDefined()\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle invalid plugin data', () => {\n      const chart = mockChart\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n      rectanglePlugin.addToChart(chart)\n\n      const invalidData = [\n        {\n          id: 'invalid-rect',\n          time: 'invalid-time',\n          price: 'invalid-price' as any,\n          x1: -50,\n          y1: -20,\n          x2: 0,\n          y2: 0,\n          color: 'invalid-color'\n        }\n      ]\n\n      rectanglePlugin.setRectangles(invalidData)\n\n      expect(rectanglePlugin).toBeDefined()\n    })\n\n    it('should handle plugin initialization errors', () => {\n      const invalidChart = {\n        // Missing required methods\n      } as any\n\n      const rectanglePlugin = new RectangleOverlayPlugin()\n\n      expect(() => {\n        rectanglePlugin.addToChart(invalidChart)\n      }).not.toThrow()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/tooltip.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":58,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'customOptions' is assigned a value but never used.","line":66,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":77,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":88,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":105,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":115,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":127,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":127,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":151,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":151,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":166,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":166,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":175,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":175,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":189,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":206,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":206,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":218,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":218,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":230,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":230,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":244,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":244,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":260,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":260,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":272,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":272,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":290,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":290,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":302,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":302,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":322,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":322,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":336,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":336,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":355,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":355,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":371,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":371,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":381,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":381,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chart' is assigned a value but never used.","line":410,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":410,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {TooltipPlugin} from '../plugins/chart/tooltipPlugin'\n\n// Mock the lightweight-charts library\nconst mockChart = {\n  addCandlestickSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}})\n  }),\n  addLineSeries: () => ({\n    setData: () => {},\n    update: () => {},\n    applyOptions: () => {},\n    priceScale: () => ({applyOptions: () => {}})\n  }),\n  timeScale: {\n    fitContent: () => {},\n    scrollToPosition: () => {},\n    scrollToTime: () => {},\n    setVisibleRange: () => {},\n    applyOptions: () => {}\n  },\n  priceScale: () => ({applyOptions: () => {}}),\n  applyOptions: () => {},\n  resize: () => {},\n  remove: () => {},\n  subscribeClick: () => {},\n  subscribeCrosshairMove: () => {},\n  unsubscribeClick: () => {},\n  unsubscribeCrosshairMove: () => {}\n}\n\n// Mock DOM elements\nconst mockContainer = document.createElement('div')\nconst mockTooltip = document.createElement('div')\n\ndescribe('Tooltip Plugin', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n    document.body.appendChild(mockContainer)\n    document.body.appendChild(mockTooltip)\n  })\n\n  afterEach(() => {\n    document.body.removeChild(mockContainer)\n    document.body.removeChild(mockTooltip)\n  })\n\n  describe('Tooltip Creation', () => {\n    it('should create tooltip plugin', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should create tooltip with default options', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should create tooltip with custom options', () => {\n      const customOptions = {\n        backgroundColor: '#ffffff',\n        textColor: '#000000',\n        borderColor: '#cccccc',\n        fontSize: '12px',\n        padding: '8px',\n        borderRadius: '4px',\n        zIndex: 1000\n      }\n\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Display', () => {\n    it('should show tooltip on crosshair move', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const mockEvent = {\n        time: 1640995200,\n        price: 100,\n        seriesData: new Map([['series1', {value: 100, color: '#ff0000'}]])\n      }\n\n      tooltipPlugin.showTooltip(mockEvent)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should hide tooltip', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n      tooltipPlugin.hideTooltip()\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should update tooltip content', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const content = '<div>Custom tooltip content</div>'\n      tooltipPlugin.updateContent(content)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should position tooltip correctly', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const position = {x: 100, y: 200}\n      tooltipPlugin.setPosition(position)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Styling', () => {\n    it('should apply custom styles', () => {\n      const customStyles = {\n        backgroundColor: '#000000',\n        textColor: '#ffffff',\n        borderColor: '#ff0000',\n        fontSize: '14px',\n        padding: '12px',\n        borderRadius: '8px',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n      }\n\n      const tooltipPlugin = new TooltipPlugin(customStyles)\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should handle theme-based styling', () => {\n      const theme = {\n        base: 'dark',\n        backgroundColor: '#1e1e1e',\n        textColor: '#ffffff'\n      }\n\n      const tooltipPlugin = new TooltipPlugin({}, theme)\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should handle responsive styling', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      // Simulate window resize\n      window.dispatchEvent(new Event('resize'))\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Content', () => {\n    it('should format series data correctly', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const seriesData = new Map([\n        ['price', {value: 100.5, color: '#ff0000'}],\n        ['volume', {value: 1000000, color: '#00ff00'}],\n        ['indicator', {value: 0.75, color: '#0000ff'}]\n      ])\n\n      const formattedContent = tooltipPlugin.formatSeriesData(seriesData)\n\n      expect(formattedContent).toBeDefined()\n    })\n\n    it('should handle empty series data', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const emptyData = new Map()\n      const formattedContent = tooltipPlugin.formatSeriesData(emptyData)\n\n      expect(formattedContent).toBeDefined()\n    })\n\n    it('should format time correctly', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const timestamp = 1640995200\n      const formattedTime = tooltipPlugin.formatTime(timestamp)\n\n      expect(formattedTime).toBeDefined()\n    })\n\n    it('should format price correctly', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const price = 100.123456\n      const formattedPrice = tooltipPlugin.formatPrice(price)\n\n      expect(formattedPrice).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Events', () => {\n    it('should handle mouse enter events', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const mouseEvent = new MouseEvent('mouseenter', {\n        clientX: 100,\n        clientY: 200\n      })\n\n      tooltipPlugin.handleMouseEnter(mouseEvent)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should handle mouse leave events', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const mouseEvent = new MouseEvent('mouseleave')\n      tooltipPlugin.handleMouseLeave(mouseEvent)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should handle mouse move events', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const mouseEvent = new MouseEvent('mousemove', {\n        clientX: 150,\n        clientY: 250\n      })\n\n      tooltipPlugin.handleMouseMove(mouseEvent)\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Positioning', () => {\n    it('should position tooltip within viewport', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const position = {x: 1000, y: 800} // Outside viewport\n      const constrainedPosition = tooltipPlugin.constrainToViewport(position)\n\n      expect(constrainedPosition).toBeDefined()\n    })\n\n    it('should handle edge positioning', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      // Test different edge cases\n      const edgePositions = [\n        {x: 0, y: 0},\n        {x: window.innerWidth, y: 0},\n        {x: 0, y: window.innerHeight},\n        {x: window.innerWidth, y: window.innerHeight}\n      ]\n\n      edgePositions.forEach(position => {\n        const constrainedPosition = tooltipPlugin.constrainToViewport(position)\n        expect(constrainedPosition).toBeDefined()\n      })\n    })\n\n    it('should handle container-relative positioning', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const containerPosition = {x: 50, y: 50}\n      const absolutePosition = tooltipPlugin.getAbsolutePosition(containerPosition)\n\n      expect(absolutePosition).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Performance', () => {\n    it('should handle rapid mouse movements', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      // Simulate rapid mouse movements\n      for (let i = 0; i < 100; i++) {\n        const mouseEvent = new MouseEvent('mousemove', {\n          clientX: 100 + i,\n          clientY: 200 + i\n        })\n\n        tooltipPlugin.handleMouseMove(mouseEvent)\n      }\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should debounce tooltip updates', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      // Simulate rapid updates\n      for (let i = 0; i < 50; i++) {\n        tooltipPlugin.updateContent(`Content ${i}`)\n      }\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Tooltip Cleanup', () => {\n    it('should cleanup event listeners', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n      tooltipPlugin.cleanup()\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n\n    it('should remove tooltip from DOM', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n      tooltipPlugin.remove()\n\n      expect(tooltipPlugin).toBeDefined()\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle missing chart gracefully', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n\n      expect(() => {\n        tooltipPlugin.addToChart(null, mockContainer)\n      }).not.toThrow()\n    })\n\n    it('should handle missing container gracefully', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      expect(() => {\n        tooltipPlugin.addToChart(chart, null)\n      }).not.toThrow()\n    })\n\n    it('should handle invalid event data', () => {\n      const tooltipPlugin = new TooltipPlugin(mockChart, mockContainer, 'test-chart')\n      const chart = mockChart\n\n      // Note: addToChart method may not exist in current API\n\n      const invalidEvent = {\n        time: 'invalid',\n        price: 'invalid',\n        seriesData: null\n      }\n\n      expect(() => {\n        tooltipPlugin.showTooltip(invalidEvent)\n      }).not.toThrow()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/__tests__/visual-regression.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'screen' is defined but never used.","line":2,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":45,"column":32,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":46,"column":17,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":69,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":69,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":71,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":71,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":95,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":95,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":97,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":97,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":121,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":121,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":123,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":123,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":148,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":148,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":150,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":150,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":174,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":174,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":176,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":176,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":200,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":200,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":202,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":202,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":231,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":231,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":233,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":233,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":257,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":257,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":259,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":259,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":295,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":295,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":297,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":297,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":331,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":331,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":333,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":333,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":362,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":362,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":364,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":364,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":394,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":394,"column":34,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":396,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":396,"endColumn":70},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":443,"column":41,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":443,"column":41,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":445,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":445,"endColumn":78},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":497,"column":41,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":497,"column":41,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":499,"column":9,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":499,"endColumn":78},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":533,"column":40,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":533,"column":40,"nodeType":"MemberExpression","messageId":"noNodeAccess"},{"ruleId":"testing-library/no-wait-for-multiple-assertions","severity":2,"message":"Avoid using multiple assertions within `waitFor` callback","line":535,"column":11,"nodeType":"ExpressionStatement","messageId":"noWaitForMultipleAssertion","endLine":538,"endColumn":13},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":542,"column":23,"nodeType":"MemberExpression","messageId":"noNodeAccess"}],"suppressedMessages":[],"errorCount":48,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen, waitFor} from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport {createChart, LineSeries, AreaSeries, CandlestickSeries} from 'lightweight-charts'\nimport LightweightCharts from '../LightweightCharts'\nimport {ComponentConfig} from '../types'\n\n// Helper function to generate consistent test data\nfunction generateTestData() {\n  return [\n    {time: '2024-01-01', value: 100},\n    {time: '2024-01-02', value: 110},\n    {time: '2024-01-03', value: 105},\n    {time: '2024-01-04', value: 115},\n    {time: '2024-01-05', value: 120},\n    {time: '2024-01-06', value: 118},\n    {time: '2024-01-07', value: 125},\n    {time: '2024-01-08', value: 130},\n    {time: '2024-01-09', value: 128},\n    {time: '2024-01-10', value: 135}\n  ]\n}\n\nfunction generateCandlestickTestData() {\n  return [\n    {time: '2024-01-01', open: 100, high: 110, low: 95, close: 105},\n    {time: '2024-01-02', open: 105, high: 115, low: 100, close: 110},\n    {time: '2024-01-03', open: 110, high: 120, low: 105, close: 115},\n    {time: '2024-01-04', open: 115, high: 125, low: 110, close: 120},\n    {time: '2024-01-05', open: 120, high: 130, low: 115, close: 125}\n  ]\n}\n\ndescribe('Visual Regression Tests', () => {\n  let container: HTMLElement\n\n  beforeEach(() => {\n    container = document.createElement('div')\n    container.style.width = '800px'\n    container.style.height = '400px'\n    document.body.appendChild(container)\n  })\n\n  afterEach(() => {\n    if (container && container.parentNode) {\n      container.parentNode.removeChild(container)\n    }\n  })\n\n  describe('Line Series Visual Consistency', () => {\n    it('should render line series with consistent styling', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 2,\n        color: '#ff0000',\n        lineStyle: 0, // Solid\n        crosshairMarkerVisible: true,\n        lastValueVisible: true\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render dashed line series consistently', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 2,\n        color: '#00ff00',\n        lineStyle: 1, // Dashed\n        crosshairMarkerVisible: false,\n        lastValueVisible: false\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render dotted line series consistently', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        lineWidth: 3,\n        color: '#0000ff',\n        lineStyle: 2, // Dotted\n        crosshairMarkerVisible: true,\n        lastValueVisible: true\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Area Series Visual Consistency', () => {\n    it('should render area series with consistent gradient', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(255, 0, 0, 0.4)',\n        bottomColor: 'rgba(255, 0, 0, 0.1)',\n        lineColor: '#ff0000',\n        lineWidth: 2\n      })\n\n      areaSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render area series with solid colors consistently', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 255, 0, 0.8)',\n        bottomColor: 'rgba(0, 255, 0, 0.2)',\n        lineColor: '#00ff00',\n        lineWidth: 1,\n        invertFilledArea: false\n      })\n\n      areaSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render inverted area series consistently', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const areaSeries = chart.addSeries(AreaSeries, {\n        topColor: 'rgba(0, 0, 255, 0.4)',\n        bottomColor: 'rgba(0, 0, 255, 0.1)',\n        lineColor: '#0000ff',\n        lineWidth: 2,\n        invertFilledArea: true\n      })\n\n      areaSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Candlestick Series Visual Consistency', () => {\n    it('should render candlestick series with consistent colors', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const candlestickSeries = chart.addSeries(CandlestickSeries, {\n        upColor: '#00ff00',\n        downColor: '#ff0000',\n        borderVisible: true,\n        wickVisible: true,\n        borderUpColor: '#008000',\n        borderDownColor: '#800000',\n        wickUpColor: '#00ff00',\n        wickDownColor: '#ff0000'\n      })\n\n      candlestickSeries.setData(generateCandlestickTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render candlestick series with thin bars consistently', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        width: 800,\n        height: 400\n      })\n\n      const candlestickSeries = chart.addSeries(CandlestickSeries, {\n        upColor: '#00ff00',\n        downColor: '#ff0000',\n        thinBars: true,\n        borderVisible: true,\n        wickVisible: true\n      })\n\n      candlestickSeries.setData(generateCandlestickTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('Chart Layout Visual Consistency', () => {\n    it('should render chart with consistent dark theme', async () => {\n      const chart = createChart(container, {\n        layout: {\n          attributionLogo: false,\n          background: {color: '#1e1e1e'},\n          textColor: '#ffffff'\n        },\n        grid: {\n          vertLines: {color: '#333333'},\n          horzLines: {color: '#333333'}\n        },\n        crosshair: {\n          mode: 1,\n          vertLine: {color: '#666666'},\n          horzLine: {color: '#666666'}\n        },\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with consistent light theme', async () => {\n      const chart = createChart(container, {\n        layout: {\n          attributionLogo: false,\n          background: {color: '#ffffff'},\n          textColor: '#000000'\n        },\n        grid: {\n          vertLines: {color: '#e0e0e0'},\n          horzLines: {color: '#e0e0e0'}\n        },\n        crosshair: {\n          mode: 1,\n          vertLine: {color: '#cccccc'},\n          horzLine: {color: '#cccccc'}\n        },\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#0000ff',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with consistent time scale', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        timeScale: {\n          timeVisible: true,\n          secondsVisible: false,\n          borderVisible: true,\n          borderColor: '#cccccc',\n          rightOffset: 10,\n          barSpacing: 6\n        },\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n\n    it('should render chart with consistent price scale', async () => {\n      const chart = createChart(container, {\n        layout: {attributionLogo: false},\n        rightPriceScale: {\n          visible: true,\n          borderVisible: true,\n          borderColor: '#cccccc',\n          scaleMargins: {\n            top: 0.1,\n            bottom: 0.1\n          }\n        },\n        width: 800,\n        height: 400\n      })\n\n      const lineSeries = chart.addSeries(LineSeries, {\n        color: '#ff0000',\n        lineWidth: 2\n      })\n\n      lineSeries.setData(generateTestData())\n\n      await waitFor(() => {\n        const canvas = container.querySelector('canvas')\n        expect(canvas).toBeInTheDocument()\n        expect(canvas).toHaveStyle({width: '800px', height: '400px'})\n      })\n\n      chart.remove()\n    })\n  })\n\n  describe('React Component Visual Consistency', () => {\n    it('should render LightweightCharts component with consistent styling', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              width: 800,\n              autoSize: false,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: generateTestData(),\n                options: {\n                  color: '#ff0000',\n                  lineWidth: 2\n                }\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} />)\n\n      await waitFor(() => {\n        const chartContainer = document.querySelector('[id^=\"chart-container-\"]')\n        expect(chartContainer).toBeInTheDocument()\n        expect(chartContainer).toHaveStyle({width: '800px', height: '400px'})\n      })\n    })\n\n    it('should render multiple series with consistent layout', async () => {\n      const config: ComponentConfig = {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              width: 800,\n              autoSize: false,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [\n              {\n                type: 'Line',\n                data: generateTestData(),\n                options: {\n                  color: '#ff0000',\n                  lineWidth: 2\n                }\n              },\n              {\n                type: 'Area',\n                data: generateTestData(),\n                options: {\n                  topColor: 'rgba(0, 255, 0, 0.4)',\n                  bottomColor: 'rgba(0, 255, 0, 0.1)',\n                  lineColor: '#00ff00'\n                }\n              }\n            ],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      }\n\n      render(<LightweightCharts config={config} />)\n\n      await waitFor(() => {\n        const chartContainer = document.querySelector('[id^=\"chart-container-\"]')\n        expect(chartContainer).toBeInTheDocument()\n        expect(chartContainer).toHaveStyle({width: '800px', height: '400px'})\n      })\n    })\n  })\n\n  describe('Responsive Design Visual Consistency', () => {\n    it('should maintain visual consistency across different sizes', async () => {\n      const sizes = [\n        {width: 400, height: 200},\n        {width: 600, height: 300},\n        {width: 800, height: 400},\n        {width: 1000, height: 500}\n      ]\n\n      for (const size of sizes) {\n        const testContainer = document.createElement('div')\n        testContainer.style.width = `${size.width}px`\n        testContainer.style.height = `${size.height}px`\n        document.body.appendChild(testContainer)\n\n        const chart = createChart(testContainer, {\n          layout: {attributionLogo: false},\n          width: size.width,\n          height: size.height\n        })\n\n        const lineSeries = chart.addSeries(LineSeries, {\n          color: '#ff0000',\n          lineWidth: 2\n        })\n\n        lineSeries.setData(generateTestData())\n\n        await waitFor(() => {\n          const canvas = testContainer.querySelector('canvas')\n          expect(canvas).toBeInTheDocument()\n          expect(canvas).toHaveStyle({\n            width: `${size.width}px`,\n            height: `${size.height}px`\n          })\n        })\n\n        chart.remove()\n        testContainer.parentNode?.removeChild(testContainer)\n      }\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/ButtonPanelComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/ChartSeriesManager.tsx","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'ISeriesApi' is defined but never used.","line":7,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ISeriesApi' is defined but never used.","line":7,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'series' is defined but never used. Allowed unused args must match /^_/u.","line":18,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":47},{"ruleId":"no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":18,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":69},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":43},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'findNearestTimeInData'. Either include it or remove the dependency array.","line":104,"column":6,"nodeType":"ArrayExpression","endLine":104,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [trades, findNearestTimeInData, onError]","fix":{"range":[3381,3398],"text":"[trades, findNearestTimeInData, onError]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chart series management component\n * Extracted from LightweightCharts.tsx for better separation of concerns\n */\n\nimport React, { useEffect, useRef, useCallback } from 'react'\nimport { IChartApi, ISeriesApi, createSeriesMarkers } from 'lightweight-charts'\nimport { SeriesConfig, TradeConfig } from '../types'\nimport { ExtendedSeriesApi, TradeData } from '../types/ChartInterfaces'\nimport { createSeries } from '../utils/seriesFactory'\nimport { cleanLineStyleOptions } from '../utils/lineStyle'\n\ninterface ChartSeriesManagerProps {\n  chart: IChartApi | null\n  chartId: string\n  seriesConfigs: SeriesConfig[]\n  trades?: TradeConfig[]\n  onSeriesCreated?: (series: ExtendedSeriesApi, config: SeriesConfig) => void\n  onError?: (error: Error, context: string) => void\n}\n\n/**\n * Manages chart series creation, updates, and lifecycle\n */\nexport const ChartSeriesManager: React.FC<ChartSeriesManagerProps> = ({\n  chart,\n  chartId,\n  seriesConfigs,\n  trades = [],\n  onSeriesCreated,\n  onError\n}) => {\n  const seriesRefsRef = useRef<Map<string, ExtendedSeriesApi>>(new Map())\n  const signalSeriesRefsRef = useRef<Map<string, ExtendedSeriesApi>>(new Map())\n\n  /**\n   * Create a single series with error handling\n   */\n  const createSeriesWithErrorHandling = useCallback((\n    seriesConfig: SeriesConfig,\n    index: number\n  ): ExtendedSeriesApi | null => {\n    if (!chart) return null\n\n    try {\n      // Clean line style options before creating series\n      const cleanedConfig = {\n        ...seriesConfig,\n        ...(('line_style' in seriesConfig && seriesConfig.line_style) ? cleanLineStyleOptions(seriesConfig.line_style as Record<string, unknown>) : {})\n      }\n\n      const series = createSeries(chart, cleanedConfig, index)\n\n      if (series) {\n        const seriesKey = `series-${chartId}-${index}`\n        seriesRefsRef.current.set(seriesKey, series)\n        onSeriesCreated?.(series, seriesConfig)\n        return series\n      }\n    } catch (error) {\n      onError?.(error as Error, `createSeries-${index}`)\n    }\n\n    return null\n  }, [chart, chartId, onSeriesCreated, onError])\n\n  /**\n   * Setup trade markers for a series\n   */\n  const setupTradeMarkers = useCallback((\n    series: ExtendedSeriesApi,\n    seriesConfig: SeriesConfig,\n    index: number\n  ) => {\n    if (!trades || trades.length === 0) return\n\n    try {\n      const seriesData = seriesConfig.data || []\n      const markers = trades\n        .filter(trade => {\n          // Filter trades relevant to this series\n          return trade.series_id === seriesConfig.name ||\n                 trade.series_index === index ||\n                 !trade.series_id // Apply to all series if no specific ID\n        })\n        .map(trade => {\n          const nearestTime = findNearestTimeInData(trade.entry_time, seriesData)\n          return {\n            time: nearestTime || trade.entry_time,\n            position: trade.side === 'long' ? 'belowBar' : 'aboveBar',\n            color: trade.side === 'long' ? '#4CAF50' : '#f44336',\n            shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',\n            text: `${trade.side.toUpperCase()} ${trade.quantity || ''}`\n          }\n        })\n\n      if (markers.length > 0) {\n        const seriesMarkers = createSeriesMarkers(markers)\n        series.setMarkers(seriesMarkers)\n      }\n    } catch (error) {\n      onError?.(error as Error, `tradeMarkers-${index}`)\n    }\n  }, [trades, onError])\n\n  /**\n   * Create all series from configurations\n   */\n  const createAllSeries = useCallback(() => {\n    if (!chart || !seriesConfigs || seriesConfigs.length === 0) return\n\n    // Clear existing series\n    seriesRefsRef.current.clear()\n    signalSeriesRefsRef.current.clear()\n\n    // Create each series\n    seriesConfigs.forEach((seriesConfig, index) => {\n      const series = createSeriesWithErrorHandling(seriesConfig, index)\n\n      if (series) {\n        // Setup trade markers if available\n        setupTradeMarkers(series, seriesConfig, index)\n\n        // Handle special series types\n        if (seriesConfig.type === 'signal') {\n          const seriesKey = `signal-${chartId}-${index}`\n          signalSeriesRefsRef.current.set(seriesKey, series)\n        }\n      }\n    })\n  }, [chart, seriesConfigs, chartId, createSeriesWithErrorHandling, setupTradeMarkers])\n\n  /**\n   * Update existing series data\n   */\n  const updateSeriesData = useCallback(() => {\n    seriesConfigs.forEach((seriesConfig, index) => {\n      const seriesKey = `series-${chartId}-${index}`\n      const series = seriesRefsRef.current.get(seriesKey)\n\n      if (series && seriesConfig.data) {\n        try {\n          series.setData(seriesConfig.data)\n        } catch (error) {\n          onError?.(error as Error, `updateSeriesData-${index}`)\n        }\n      }\n    })\n  }, [seriesConfigs, chartId, onError])\n\n  /**\n   * Find nearest time in series data\n   */\n  const findNearestTimeInData = useCallback((\n    targetTime: number,\n    data: TradeData[]\n  ): number | null => {\n    if (!data || data.length === 0) return null\n\n    let nearestTime: number | null = null\n    let minDiff = Infinity\n\n    for (const item of data) {\n      if (!item.time) continue\n\n      let itemTime: number | null = null\n      if (typeof item.time === 'number') {\n        itemTime = item.time > 1000000000000 ? Math.floor(item.time / 1000) : item.time\n      } else if (typeof item.time === 'string') {\n        itemTime = Math.floor(new Date(item.time).getTime() / 1000)\n      }\n\n      if (itemTime !== null) {\n        const diff = Math.abs(itemTime - targetTime)\n        if (diff < minDiff) {\n          minDiff = diff\n          nearestTime = itemTime\n        }\n      }\n    }\n\n    return nearestTime\n  }, [])\n\n  /**\n   * Cleanup series on unmount\n   */\n  const cleanup = useCallback(() => {\n    try {\n      // Remove all series from chart\n      for (const series of seriesRefsRef.current.values()) {\n        if (chart && series) {\n          chart.removeSeries(series)\n        }\n      }\n\n      seriesRefsRef.current.clear()\n      signalSeriesRefsRef.current.clear()\n    } catch (error) {\n      onError?.(error as Error, 'seriesCleanup')\n    }\n  }, [chart, onError])\n\n  // Create series when chart or configs change\n  useEffect(() => {\n    createAllSeries()\n    return cleanup\n  }, [createAllSeries, cleanup])\n\n  // Update series data when configs change (without recreating series)\n  useEffect(() => {\n    updateSeriesData()\n  }, [updateSeriesData])\n\n  // Expose series refs for parent component access\n  React.useImperativeHandle(React.forwardRef(() => null), () => ({\n    getSeriesRefs: () => seriesRefsRef.current,\n    getSignalSeriesRefs: () => signalSeriesRefsRef.current,\n    updateSeries: updateSeriesData,\n    recreateSeries: createAllSeries\n  }))\n\n  // This component doesn't render anything - it only manages series\n  return null\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/ChartSyncManager.tsx","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'eventType' is defined but never used. Allowed unused args must match /^_/u.","line":14,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":35},{"ruleId":"no-unused-vars","severity":1,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":14,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chart synchronization manager component\n * Extracted from LightweightCharts.tsx for better separation of concerns\n */\n\nimport React, { useEffect, useRef, useCallback } from 'react'\nimport { IChartApi } from 'lightweight-charts'\nimport { SyncConfig } from '../types'\n\ninterface ChartSyncManagerProps {\n  chart: IChartApi | null\n  chartId: string\n  syncConfig?: SyncConfig\n  onSyncEvent?: (eventType: string, data: any) => void\n}\n\n/**\n * Manages chart synchronization across multiple chart instances\n */\nexport const ChartSyncManager: React.FC<ChartSyncManagerProps> = ({\n  chart,\n  chartId,\n  syncConfig,\n  onSyncEvent\n}) => {\n  const syncStateRef = useRef({\n    isExternalSync: false,\n    isExternalTimeRangeSync: false,\n    lastSyncTimestamp: 0,\n    lastTimeRangeSyncTimestamp: 0\n  })\n\n  /**\n   * Setup crosshair synchronization\n   */\n  const setupCrosshairSync = useCallback(() => {\n    if (!chart || !syncConfig?.crosshair) return\n\n    const SYNC_DEBOUNCE_MS = 50\n\n    // Add storage listener for incoming sync events\n    if (!(chart as any)._storageListenerAdded) {\n      const handleStorageSync = (event: StorageEvent) => {\n        if (event.key === 'chart-crosshair-sync' && event.newValue) {\n          try {\n            const syncData = JSON.parse(event.newValue)\n            if (syncData.chartId !== chartId) {\n              const now = Date.now()\n              if (now - syncStateRef.current.lastSyncTimestamp < SYNC_DEBOUNCE_MS) {\n                return\n              }\n              syncStateRef.current.lastSyncTimestamp = now\n\n              if (syncData.param) {\n                ;(chart as any)._isExternalSync = true\n                chart.timeScale().scrollToPosition(syncData.param.point?.x || 0, false)\n                setTimeout(() => {\n                  ;(chart as any)._isExternalSync = false\n                }, 50)\n              }\n            }\n          } catch (error) {\n            // Ignore invalid sync data\n          }\n        }\n      }\n\n      window.addEventListener('storage', handleStorageSync)\n      ;(chart as any)._storageListenerAdded = true\n    }\n\n    // Subscribe to crosshair move events\n    const handleCrosshairMove = (param: any) => {\n      if ((chart as any)._isExternalSync) {\n        return\n      }\n\n      // Broadcast sync event\n      const syncData = {\n        chartId,\n        param,\n        timestamp: Date.now()\n      }\n\n      try {\n        localStorage.setItem('chart-crosshair-sync', JSON.stringify(syncData))\n        onSyncEvent?.('crosshairMove', syncData)\n      } catch (error) {\n        // Ignore localStorage errors\n      }\n    }\n\n    chart.subscribeCrosshairMove(handleCrosshairMove)\n\n    return () => {\n      chart.unsubscribeCrosshairMove(handleCrosshairMove)\n    }\n  }, [chart, chartId, syncConfig?.crosshair, onSyncEvent])\n\n  /**\n   * Setup time range synchronization\n   */\n  const setupTimeRangeSync = useCallback(() => {\n    if (!chart || !syncConfig?.timeRange) return\n\n    const TIME_RANGE_SYNC_DEBOUNCE_MS = 100\n\n    // Add storage listener for time range sync\n    if (!(chart as any)._timeRangeStorageListenerAdded) {\n      const handleTimeRangeSync = (event: StorageEvent) => {\n        if (event.key === 'chart-timerange-sync' && event.newValue) {\n          try {\n            const syncData = JSON.parse(event.newValue)\n            if (syncData.chartId !== chartId) {\n              const now = Date.now()\n              if (now - syncStateRef.current.lastTimeRangeSyncTimestamp < TIME_RANGE_SYNC_DEBOUNCE_MS) {\n                return\n              }\n              syncStateRef.current.lastTimeRangeSyncTimestamp = now\n\n              if (syncData.timeRange) {\n                ;(chart as any)._isExternalTimeRangeSync = true\n                chart.timeScale().setVisibleRange(syncData.timeRange)\n                setTimeout(() => {\n                  ;(chart as any)._isExternalTimeRangeSync = false\n                }, 100)\n              }\n            }\n          } catch (error) {\n            // Ignore invalid sync data\n          }\n        }\n      }\n\n      window.addEventListener('storage', handleTimeRangeSync)\n      ;(chart as any)._timeRangeStorageListenerAdded = true\n    }\n\n    // Subscribe to visible time range change\n    const handleTimeRangeChange = () => {\n      if ((chart as any)._isExternalTimeRangeSync) {\n        return\n      }\n\n      try {\n        const visibleRange = chart.timeScale().getVisibleRange()\n        const syncData = {\n          chartId,\n          timeRange: visibleRange,\n          timestamp: Date.now()\n        }\n\n        localStorage.setItem('chart-timerange-sync', JSON.stringify(syncData))\n        onSyncEvent?.('timeRangeChange', syncData)\n      } catch (error) {\n        // Ignore localStorage errors\n      }\n    }\n\n    chart.timeScale().subscribeVisibleTimeRangeChange(handleTimeRangeChange)\n\n    return () => {\n      chart.timeScale().unsubscribeVisibleTimeRangeChange(handleTimeRangeChange)\n    }\n  }, [chart, chartId, syncConfig?.timeRange, onSyncEvent])\n\n  /**\n   * Setup click synchronization\n   */\n  const setupClickSync = useCallback(() => {\n    if (!chart || !syncConfig?.click) return\n\n    const handleClick = () => {\n      const syncData = {\n        chartId,\n        event: 'click',\n        timestamp: Date.now()\n      }\n\n      try {\n        localStorage.setItem('chart-click-sync', JSON.stringify(syncData))\n        onSyncEvent?.('click', syncData)\n      } catch (error) {\n        // Ignore localStorage errors\n      }\n    }\n\n    chart.subscribeClick(handleClick)\n\n    return () => {\n      chart.unsubscribeClick(handleClick)\n    }\n  }, [chart, chartId, syncConfig?.click, onSyncEvent])\n\n  // Setup all synchronization types\n  useEffect(() => {\n    if (!chart || !syncConfig) return\n\n    const cleanupFunctions: (() => void)[] = []\n\n    if (syncConfig.crosshair) {\n      const cleanup = setupCrosshairSync()\n      if (cleanup) cleanupFunctions.push(cleanup)\n    }\n\n    if (syncConfig.timeRange) {\n      const cleanup = setupTimeRangeSync()\n      if (cleanup) cleanupFunctions.push(cleanup)\n    }\n\n    if (syncConfig.click) {\n      const cleanup = setupClickSync()\n      if (cleanup) cleanupFunctions.push(cleanup)\n    }\n\n    return () => {\n      cleanupFunctions.forEach(cleanup => cleanup())\n    }\n  }, [chart, syncConfig, setupCrosshairSync, setupTimeRangeSync, setupClickSync])\n\n  // This component doesn't render anything - it only manages synchronization\n  return null\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/ErrorBoundary.tsx","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'errorInfo' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {Component, ErrorInfo, ReactNode} from 'react'\n\ninterface Props {\n  children: ReactNode\n  fallback?: ReactNode\n  onError?: (error: Error, errorInfo: ErrorInfo) => void\n}\n\ninterface State {\n  hasError: boolean\n  error?: Error\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props)\n    this.state = {hasError: false}\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return {hasError: true, error}\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n\n\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo)\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback\n      }\n\n      return (\n        <div\n          style={{\n            padding: '20px',\n            border: '1px solid #ff6b6b',\n            borderRadius: '8px',\n            backgroundColor: '#fff5f5',\n            color: '#d63031',\n            textAlign: 'center',\n            margin: '10px 0'\n          }}\n        >\n          <h3>Chart Error</h3>\n          <p>Something went wrong while rendering the chart.</p>\n          <button\n            onClick={() => this.setState({hasError: false, error: undefined})}\n            style={{\n              padding: '8px 16px',\n              backgroundColor: '#ff6b6b',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n              marginTop: '10px'\n            }}\n          >\n            Try Again\n          </button>\n        </div>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n// Hook for functional components\nexport function useErrorHandler() {\n  const [error, setError] = React.useState<Error | null>(null)\n\n  const handleError = React.useCallback((error: Error) => {\n\n    setError(error)\n  }, [])\n\n  const clearError = React.useCallback(() => {\n    setError(null)\n  }, [])\n\n  return {error, handleError, clearError}\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog/ColorPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog/LineStyleSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog/OpacitySlider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog/SeriesConfigDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/SeriesConfigDialog/ThicknessSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/components/__tests__/ErrorBoundary.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalConsole' is assigned a value but never used.","line":7,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"testing-library/no-node-access","severity":2,"message":"Avoid direct Node access. Prefer using the methods from Testing Library.","line":227,"column":24,"nodeType":"MemberExpression","messageId":"noNodeAccess"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport {render, screen} from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport {ErrorBoundary} from '../ErrorBoundary'\n\n// Mock console methods\nconst originalConsole = {...console}\nbeforeEach(() => {\n\n\n})\n\nafterEach(() => {\n\n\n})\n\n// Component that throws an error\nconst ThrowError = ({shouldThrow}: {shouldThrow: boolean}) => {\n  if (shouldThrow) {\n    throw new Error('Test error')\n  }\n  return <div>Normal component</div>\n}\n\ndescribe('ErrorBoundary Component', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('Normal Rendering', () => {\n    it('should render children when no error occurs', () => {\n      render(\n        <ErrorBoundary>\n          <div>Test content</div>\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Test content')).toBeInTheDocument()\n    })\n\n    it('should render multiple children when no error occurs', () => {\n      render(\n        <ErrorBoundary>\n          <div>First child</div>\n          <div>Second child</div>\n          <span>Third child</span>\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('First child')).toBeInTheDocument()\n      expect(screen.getByText('Second child')).toBeInTheDocument()\n      expect(screen.getByText('Third child')).toBeInTheDocument()\n    })\n\n    it('should render complex nested components', () => {\n      const NestedComponent = () => (\n        <div>\n          <h1>Title</h1>\n          <p>Description</p>\n          <button>Click me</button>\n        </div>\n      )\n\n      render(\n        <ErrorBoundary>\n          <NestedComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Title')).toBeInTheDocument()\n      expect(screen.getByText('Description')).toBeInTheDocument()\n      expect(screen.getByText('Click me')).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should catch and display error when child throws', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n\n    })\n\n    it('should display custom error message', () => {\n      const customErrorBoundary = (\n        <ErrorBoundary fallback={<div>Custom error message</div>}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      render(customErrorBoundary)\n\n      expect(screen.getByText('Custom error message')).toBeInTheDocument()\n    })\n\n    it('should handle different types of errors', () => {\n      const TypeErrorComponent = () => {\n        throw new TypeError('Type error occurred')\n      }\n\n      render(\n        <ErrorBoundary>\n          <TypeErrorComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle reference errors', () => {\n      const ReferenceErrorComponent = () => {\n        throw new ReferenceError('Reference error occurred')\n      }\n\n      render(\n        <ErrorBoundary>\n          <ReferenceErrorComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle syntax errors', () => {\n      const SyntaxErrorComponent = () => {\n        throw new SyntaxError('Syntax error occurred')\n      }\n\n      render(\n        <ErrorBoundary>\n          <SyntaxErrorComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Recovery', () => {\n    it('should recover when error is resolved', () => {\n      const {rerender} = render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n\n      // Re-render without error\n      rerender(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Normal component')).toBeInTheDocument()\n      expect(screen.queryByText(/Something went wrong/i)).not.toBeInTheDocument()\n    })\n\n    it('should handle multiple error-recovery cycles', () => {\n      const {rerender} = render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Normal component')).toBeInTheDocument()\n\n      // Throw error\n      rerender(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n\n      // Recover\n      rerender(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Normal component')).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Boundary Lifecycle', () => {\n    it('should call componentDidCatch when error occurs', () => {\n      const mockComponentDidCatch = jest.fn()\n\n      class TestErrorBoundary extends ErrorBoundary {\n        componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n          mockComponentDidCatch(error, errorInfo)\n          super.componentDidCatch(error, errorInfo)\n        }\n      }\n\n      render(\n        <TestErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </TestErrorBoundary>\n      )\n\n      expect(mockComponentDidCatch).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.objectContaining({\n          componentStack: expect.any(String)\n        })\n      )\n    })\n\n    it('should update state when error occurs', () => {\n      const {container} = render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      // The error boundary should have error state\n      expect(container.firstChild).toBeInTheDocument()\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA attributes in error state', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      const errorElement = screen.getByText(/Something went wrong/i)\n      expect(errorElement).toBeInTheDocument()\n    })\n\n    it('should be keyboard accessible', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      const errorElement = screen.getByText(/Something went wrong/i)\n      expect(errorElement).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('should not cause performance issues with large component trees', () => {\n      const LargeComponent = () => (\n        <div>\n          {Array.from({length: 1000}, (_, i) => (\n            <div key={i}>Item {i}</div>\n          ))}\n        </div>\n      )\n\n      render(\n        <ErrorBoundary>\n          <LargeComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Item 0')).toBeInTheDocument()\n      expect(screen.getByText('Item 999')).toBeInTheDocument()\n    })\n\n    it('should handle rapid error-recovery cycles', () => {\n      const {rerender} = render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      // Rapidly toggle between error and normal states\n      for (let i = 0; i < 10; i++) {\n        rerender(\n          <ErrorBoundary>\n            <ThrowError shouldThrow={i % 2 === 0} />\n          </ErrorBoundary>\n        )\n      }\n\n      // Should still work correctly\n      expect(screen.getByText('Normal component')).toBeInTheDocument()\n    })\n  })\n\n  describe('Edge Cases', () => {\n    it('should handle null children', () => {\n      render(<ErrorBoundary>{null}</ErrorBoundary>)\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle undefined children', () => {\n      render(<ErrorBoundary>{undefined}</ErrorBoundary>)\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle empty children', () => {\n      render(<ErrorBoundary>{}</ErrorBoundary>)\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle children that return null', () => {\n      const NullComponent = () => null\n\n      render(\n        <ErrorBoundary>\n          <NullComponent />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument()\n    })\n\n    it('should handle async errors', async () => {\n      const AsyncErrorComponent = () => {\n        React.useEffect(() => {\n          throw new Error('Async error')\n        }, [])\n        return <div>Async component</div>\n      }\n\n      render(\n        <ErrorBoundary>\n          <AsyncErrorComponent />\n        </ErrorBoundary>\n      )\n\n      // Should initially render the component\n      expect(screen.getByText('Async component')).toBeInTheDocument()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/config/positioningConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/hooks/__tests__/useOptimizedChart.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'act' is defined but never used.","line":1,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {renderHook, act} from '@testing-library/react'\nimport {useOptimizedChart} from '../useOptimizedChart'\n\n// Simple mock for lightweight-charts\njest.mock('lightweight-charts', () => ({\n  createChart: jest.fn(() => ({\n    addSeries: jest.fn(() => ({\n      setData: jest.fn(),\n      update: jest.fn(),\n      applyOptions: jest.fn(),\n      priceScale: jest.fn(() => ({\n        applyOptions: jest.fn()\n      }))\n    })),\n    remove: jest.fn(),\n    resize: jest.fn(),\n    applyOptions: jest.fn(),\n    unsubscribeCrosshairMove: jest.fn()\n  })),\n  CandlestickSeries: 'CandlestickSeries',\n  LineSeries: 'LineSeries',\n  AreaSeries: 'AreaSeries',\n  HistogramSeries: 'HistogramSeries',\n  BarSeries: 'BarSeries',\n  BaselineSeries: 'BaselineSeries'\n}))\n\ndescribe('useOptimizedChart', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('should initialize with default values', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    expect(result.current.getChart()).toBeNull()\n    expect(result.current.isReady()).toBe(false)\n    expect(result.current.getAllSeries()).toEqual([])\n  })\n\n  it('should handle error cases gracefully', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test adding series without chart\n    const series = result.current.addSeries('LineSeries', {color: 'blue'})\n    expect(series).toBeNull()\n\n    // Test getting series without chart\n    const allSeries = result.current.getAllSeries()\n    expect(allSeries).toEqual([])\n  })\n\n  it('should handle container operations', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test container operations without chart\n    expect(result.current.getContainer()).toBeNull()\n  })\n\n  it('should handle performance timing', () => {\n    const options = {chartId: 'test-chart', enablePerformanceMonitoring: true}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test performance timing without chart\n    const startTime = performance.now()\n    result.current.addSeries('LineSeries', {color: 'blue'})\n    const endTime = performance.now()\n\n    expect(endTime - startTime).toBeGreaterThanOrEqual(0)\n  })\n\n  it('should handle chart ready detection', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test chart ready detection without chart\n    expect(result.current.isChartReadySync()).toBe(false)\n    expect(result.current.isReady()).toBe(false)\n  })\n\n  it('should handle series retrieval by index', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test series retrieval without chart\n    expect(result.current.getSeries(0)).toBeNull()\n    expect(result.current.getSeries(1)).toBeNull()\n    expect(result.current.getSeries(2)).toBeNull()\n  })\n\n  it('should handle resize operations', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test resize without chart - should not throw\n    expect(() => {\n      result.current.resize(1000, 800)\n    }).not.toThrow()\n  })\n\n  it('should handle cleanup operations', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test cleanup without chart - should not throw\n    expect(() => {\n      result.current.cleanup()\n    }).not.toThrow()\n  })\n\n  it('should support different series types', () => {\n    const options = {chartId: 'test-chart'}\n    const {result} = renderHook(() => useOptimizedChart(options))\n\n    // Test different series types without chart\n    const candlestickSeries = result.current.addSeries('CandlestickSeries', {})\n    const lineSeries = result.current.addSeries('LineSeries', {})\n    const areaSeries = result.current.addSeries('AreaSeries', {})\n    const histogramSeries = result.current.addSeries('HistogramSeries', {})\n    const barSeries = result.current.addSeries('BarSeries', {})\n    const baselineSeries = result.current.addSeries('BaselineSeries', {})\n\n    expect(candlestickSeries).toBeNull()\n    expect(lineSeries).toBeNull()\n    expect(areaSeries).toBeNull()\n    expect(histogramSeries).toBeNull()\n    expect(barSeries).toBeNull()\n    expect(baselineSeries).toBeNull()\n\n    expect(result.current.getAllSeries()).toEqual([])\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/hooks/useOptimizedChart.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'chartId'. Either exclude it or remove the dependency array.","line":107,"column":6,"nodeType":"ArrayExpression","endLine":107,"endColumn":60,"suggestions":[{"desc":"Update the dependencies array to be: [autoResize, debounceMs, minWidth, minHeight]","fix":{"range":[3072,3126],"text":"[autoResize, debounceMs, minWidth, minHeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'chartId'. Either exclude it or remove the dependency array.","line":190,"column":5,"nodeType":"ArrayExpression","endLine":190,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [waitForChartReady, setupResizeObserver]","fix":{"range":[5530,5579],"text":"[waitForChartReady, setupResizeObserver]"}}]},{"ruleId":"no-unused-vars","severity":1,"message":"'paneId' is defined but never used. Allowed unused args must match /^_/u.","line":195,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":195,"endColumn":57},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'chartId'. Either exclude it or remove the dependency array.","line":224,"column":5,"nodeType":"ArrayExpression","endLine":224,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: []","fix":{"range":[6472,6481],"text":"[]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'chartId'. Either exclude it or remove the dependency array.","line":275,"column":5,"nodeType":"ArrayExpression","endLine":275,"endColumn":35,"suggestions":[{"desc":"Update the dependencies array to be: [minWidth, minHeight]","fix":{"range":[7976,8006],"text":"[minWidth, minHeight]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'chartId'. Either exclude it or remove the dependency array.","line":300,"column":6,"nodeType":"ArrayExpression","endLine":300,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: []","fix":{"range":[8568,8577],"text":"[]"}}]},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":349,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":349,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":352,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":352,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":361,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":361,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":364,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":364,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {useCallback, useEffect, useLayoutEffect, useMemo, useRef} from 'react'\nimport {IChartApi, ISeriesApi, createChart} from 'lightweight-charts'\nimport {ChartReadyDetector} from '../utils/chartReadyDetection'\nimport {ResizeObserverManager} from '../utils/resizeObserverManager'\n\nexport interface UseOptimizedChartOptions {\n  chartId: string\n  autoResize?: boolean\n  debounceMs?: number\n  throttleMs?: number\n  enablePerformanceMonitoring?: boolean\n  minWidth?: number\n  minHeight?: number\n  maxReadyAttempts?: number\n  baseReadyDelay?: number\n}\n\nexport interface ChartRefs {\n  chart: IChartApi | null\n  container: HTMLElement | null\n  series: ISeriesApi<any>[]\n  isInitialized: boolean\n  isDisposed: boolean\n}\n\nexport function useOptimizedChart(options: UseOptimizedChartOptions) {\n  const {\n    chartId,\n    autoResize = true,\n    debounceMs = 100,\n    throttleMs = 50,\n    enablePerformanceMonitoring = false,\n    minWidth = 200,\n    minHeight = 200,\n    maxReadyAttempts = 15,\n    baseReadyDelay = 200\n  } = options\n\n  const chartRefs = useRef<ChartRefs>({\n    chart: null,\n    container: null,\n    series: [],\n    isInitialized: false,\n    isDisposed: false\n  })\n\n  const resizeObserverManager = useRef<ResizeObserverManager>(new ResizeObserverManager())\n  const performanceTimer = useRef<{start: () => void; end: () => void} | null>(null)\n\n  // Performance monitoring setup\n  useEffect(() => {\n    if (enablePerformanceMonitoring) {\n      performanceTimer.current = {\n        start: () => performance.mark(`chart-${chartId}-start`),\n        end: () => {\n          performance.mark(`chart-${chartId}-end`)\n          performance.measure(`chart-${chartId}`, `chart-${chartId}-start`, `chart-${chartId}-end`)\n        }\n      }\n    }\n  }, [chartId, enablePerformanceMonitoring])\n\n  // Chart ready detection\n  const waitForChartReady = useCallback(async (): Promise<boolean> => {\n    if (!chartRefs.current.chart || !chartRefs.current.container) {\n      return false\n    }\n\n    return ChartReadyDetector.waitForChartReady(\n      chartRefs.current.chart,\n      chartRefs.current.container,\n      {\n        minWidth,\n        minHeight,\n        maxAttempts: maxReadyAttempts,\n        baseDelay: baseReadyDelay\n      }\n    )\n  }, [minWidth, minHeight, maxReadyAttempts, baseReadyDelay])\n\n  // Check if chart is ready synchronously\n  const isChartReadySync = useCallback((): boolean => {\n    return ChartReadyDetector.isChartReadySync(\n      chartRefs.current.chart,\n      chartRefs.current.container,\n      minWidth,\n      minHeight\n    )\n  }, [minWidth, minHeight])\n\n  // Enhanced resize handler with validation\n  const handleResize = useMemo(() => {\n    if (!autoResize) return null\n\n    return debounce((width: number, height: number) => {\n      if (chartRefs.current.chart && !chartRefs.current.isDisposed) {\n        try {\n          // Validate dimensions before resizing\n          if (width >= minWidth && height >= minHeight) {\n            chartRefs.current.chart.resize(width, height)\n          }\n        } catch (error) {\n\n        }\n      }\n    }, debounceMs)\n  }, [autoResize, debounceMs, chartId, minWidth, minHeight])\n\n  // Enhanced resize observer callback with better coordinate handling\n  const enhancedResizeObserverCallback = useMemo(() => {\n    if (!autoResize) return null\n\n    return throttle((entries: ResizeObserverEntry[]) => {\n      entries.forEach(entry => {\n        if (entry.target === chartRefs.current.container) {\n          const {width, height} = entry.contentRect\n\n          // Check if dimensions are valid before resizing\n          if (width >= minWidth && height >= minHeight) {\n            if (handleResize) {\n              handleResize(width, height)\n            }\n          }\n        }\n      })\n    }, throttleMs)\n  }, [autoResize, throttleMs, handleResize, minWidth, minHeight])\n\n  // Setup resize observer with better error handling\n  const setupResizeObserver = useCallback(() => {\n    if (!autoResize || !chartRefs.current.container || !enhancedResizeObserverCallback) {\n      return\n    }\n\n    try {\n      resizeObserverManager.current.addObserver(\n        `chart-${chartId}`,\n        chartRefs.current.container,\n        enhancedResizeObserverCallback,\n        {throttleMs, debounceMs}\n      )\n\n      // ResizeObserver set up successfully\n    } catch (error) {\n\n    }\n  }, [autoResize, enhancedResizeObserverCallback, chartId, throttleMs, debounceMs])\n\n  // Enhanced chart creation with ready detection\n  const createChart = useCallback(\n    async (container: HTMLElement, chartOptions: any): Promise<IChartApi | null> => {\n      if (performanceTimer.current) {\n        performanceTimer.current.start()\n      }\n\n      try {\n        // Store container reference\n        chartRefs.current.container = container\n\n        // Create chart\n        const chart = createChartFromOptions(container, chartOptions)\n        if (!chart) {\n          throw new Error('Failed to create chart')\n        }\n\n        // Store chart reference\n        chartRefs.current.chart = chart\n        chartRefs.current.isInitialized = true\n\n        // Wait for chart to be ready\n        const isReady = await waitForChartReady()\n        if (isReady) {\n          // Setup resize observer after chart is ready\n          setupResizeObserver()\n        }\n\n        if (performanceTimer.current) {\n          performanceTimer.current.end()\n        }\n\n        return chart\n      } catch (error) {\n\n        if (performanceTimer.current) {\n          performanceTimer.current.end()\n        }\n        return null\n      }\n    },\n    [chartId, waitForChartReady, setupResizeObserver]\n  )\n\n  // Enhanced series addition with ready detection\n  const addSeries = useCallback(\n    (seriesType: any, options: any = {}, paneId?: number): ISeriesApi<any> | null => {\n      if (performanceTimer.current) {\n        performanceTimer.current.start()\n      }\n\n      try {\n        if (!chartRefs.current.chart || !chartRefs.current.isInitialized) {\n          return null\n        }\n\n        // Use the seriesType parameter instead of hardcoded CandlestickSeries\n        const series = chartRefs.current.chart.addSeries(seriesType, options)\n        if (series) {\n          chartRefs.current.series.push(series)\n        }\n\n        if (performanceTimer.current) {\n          performanceTimer.current.end()\n        }\n\n        return series\n      } catch (error) {\n\n        if (performanceTimer.current) {\n          performanceTimer.current.end()\n        }\n        return null\n      }\n    },\n    [chartId]\n  )\n\n  // Get series by index with validation\n  const getSeries = useCallback((index: number): ISeriesApi<any> | null => {\n    if (index >= 0 && index < chartRefs.current.series.length) {\n      return chartRefs.current.series[index]\n    }\n    return null\n  }, [])\n\n  // Get all series\n  const getAllSeries = useCallback((): ISeriesApi<any>[] => {\n    return [...chartRefs.current.series]\n  }, [])\n\n  // Enhanced ready check\n  const isReady = useCallback((): boolean => {\n    return chartRefs.current.isInitialized && !chartRefs.current.isDisposed && isChartReadySync()\n  }, [isChartReadySync])\n\n  // Get chart instance with validation\n  const getChart = useCallback((): IChartApi | null => {\n    if (chartRefs.current.chart && !chartRefs.current.isDisposed) {\n      return chartRefs.current.chart\n    }\n    return null\n  }, [])\n\n  // Get container with validation\n  const getContainer = useCallback((): HTMLElement | null => {\n    if (chartRefs.current.container && !chartRefs.current.isDisposed) {\n      return chartRefs.current.container\n    }\n    return null\n  }, [])\n\n  // Enhanced manual resize with validation\n  const resize = useCallback(\n    async (width: number, height: number) => {\n      if (chartRefs.current.chart && !chartRefs.current.isDisposed) {\n        try {\n          // Validate dimensions\n          if (width >= minWidth && height >= minHeight) {\n            chartRefs.current.chart.resize(width, height)\n          }\n        } catch (error) {\n\n        }\n      }\n    },\n    [chartId, minWidth, minHeight]\n  )\n\n  // Enhanced cleanup with observer management\n  const cleanup = useCallback(() => {\n    // Mark as disposed\n    chartRefs.current.isDisposed = true\n\n    // Cleanup resize observers\n    resizeObserverManager.current.cleanup()\n\n    // Remove chart\n    if (chartRefs.current.chart) {\n      try {\n        chartRefs.current.chart.remove()\n      } catch (error) {\n\n      }\n    }\n\n    // Clear references\n    chartRefs.current.chart = null\n    chartRefs.current.container = null\n    chartRefs.current.series = []\n    chartRefs.current.isInitialized = false\n  }, [chartId])\n\n  // Setup resize observer when chart is created\n  useEffect(() => {\n    if (chartRefs.current.isInitialized && !chartRefs.current.isDisposed) {\n      setupResizeObserver()\n    }\n  }, [setupResizeObserver])\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanup()\n    }\n  }, [cleanup])\n\n  // Use layout effect for immediate cleanup when dependencies change\n  useLayoutEffect(() => {\n    const manager = resizeObserverManager.current\n    return () => {\n      // Immediate cleanup for layout changes\n      manager.cleanup()\n    }\n  }, [])\n\n  return {\n    createChart,\n    addSeries,\n    getSeries,\n    getAllSeries,\n    getChart,\n    getContainer,\n    isReady,\n    resize,\n    cleanup,\n    chartId,\n    waitForChartReady,\n    isChartReadySync\n  }\n}\n\n/**\n * Hook for comparing chart configurations efficiently\n */\nexport function useChartConfigComparison<T>(config: T): T {\n  return useMemo(() => config, [config])\n}\n\n// Utility functions\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null\n\n  return (...args: Parameters<T>) => {\n    if (timeout) clearTimeout(timeout)\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}\n\nfunction throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean = false\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args)\n      inThrottle = true\n      setTimeout(() => (inThrottle = false), limit)\n    }\n  }\n}\n\nfunction createChartFromOptions(container: HTMLElement, options: any): IChartApi | null {\n  try {\n    const chart = createChart(container, options)\n    return chart\n  } catch (error) {\n\n    return null\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/index.tsx","messages":[{"ruleId":"prefer-const","severity":1,"message":"'finalHeight' is never reassigned. Use 'const' instead.","line":81,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":81,"endColumn":22,"fix":{"range":[2921,2950],"text":"const finalHeight = totalHeight"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import React, {useEffect, useRef, useCallback} from 'react'\nimport ReactDOM from 'react-dom'\nimport {Streamlit} from 'streamlit-component-lib'\nimport {StreamlitProvider, useRenderData} from 'streamlit-component-lib-react-hooks'\nimport LightweightCharts from './LightweightCharts'\nimport {ComponentConfig} from './types'\nimport {ResizeObserverManager} from './utils/resizeObserverManager'\n\nconst App: React.FC = () => {\n  const renderData = useRenderData()\n  const containerRef = useRef<HTMLDivElement>(null)\n  const isReadyRef = useRef(false)\n  const isMountedRef = useRef(false)\n  const resizeObserverManager = useRef<ResizeObserverManager>(new ResizeObserverManager())\n  const heightReportTimeout = useRef<NodeJS.Timeout | null>(null)\n  const lastReportTime = useRef(0)\n  const isReportingHeight = useRef(false) // Prevent recursive height reporting\n  const lastReportedHeight = useRef(0) // Track last reported height to prevent unnecessary reports\n  const pendingHeightReport = useRef<number | null>(null) // Track pending height to prevent loops\n\n  const handleChartsReady = () => {\n    isReadyRef.current = true\n    // Notify Streamlit that the component is ready\n    if (typeof Streamlit !== 'undefined' && Streamlit.setComponentReady) {\n      try {\n        Streamlit.setComponentReady()\n      } catch (error) {}\n    }\n  }\n\n  // Enhanced height reporting with multiple detection methods and loop prevention\n  const reportHeightWithFallback = useCallback(async () => {\n    if (\n      !containerRef.current ||\n      !isReadyRef.current ||\n      !isMountedRef.current ||\n      isReportingHeight.current\n    ) {\n      return\n    }\n\n    // Set reporting flag to prevent recursive calls\n    isReportingHeight.current = true\n\n    try {\n      // Method 1: Try container dimensions first\n      let containerHeight = 0\n      const config = renderData?.args?.config as ComponentConfig\n      const chartHeight = renderData?.args?.height || config?.charts?.[0]?.chart?.height || 400\n\n      try {\n        containerHeight = containerRef.current.scrollHeight\n      } catch (error) {}\n\n      // Method 2: Try computed styles\n      if (!containerHeight) {\n        try {\n          const computedStyle = window.getComputedStyle(containerRef.current)\n          containerHeight = parseInt(computedStyle.height) || 0\n        } catch (error) {}\n      }\n\n      // Method 3: Try offset dimensions\n      if (!containerHeight) {\n        try {\n          containerHeight = containerRef.current.offsetHeight\n        } catch (error) {}\n      }\n\n      // Method 4: Try client dimensions\n      if (!containerHeight) {\n        try {\n          containerHeight = containerRef.current.clientHeight\n        } catch (error) {}\n      }\n\n      // Calculate total height with improved logic to prevent loops\n      const totalHeight = Math.max(containerHeight, chartHeight)\n\n      // Use the calculated height directly without adding arbitrary padding\n      let finalHeight = totalHeight\n\n      // Check if this height is different from what we last reported\n      const heightDifference = Math.abs(finalHeight - lastReportedHeight.current)\n\n      // Only report if height has changed significantly (more than 5px to account for small variations)\n      if (heightDifference > 5 && pendingHeightReport.current !== finalHeight) {\n        // No padding needed - use the actual calculated height\n\n        // Store the height we're about to report to prevent loops\n        pendingHeightReport.current = finalHeight\n        lastReportedHeight.current = finalHeight\n\n        // Report height to Streamlit only if component is still mounted\n        if (isMountedRef.current && typeof Streamlit !== 'undefined' && Streamlit.setFrameHeight) {\n          try {\n            Streamlit.setFrameHeight(finalHeight)\n          } catch (error) {}\n        }\n      }\n    } catch (error) {\n    } finally {\n      // Clear reporting flag after a short delay\n      setTimeout(() => {\n        isReportingHeight.current = false\n        if (pendingHeightReport.current !== null) {\n          pendingHeightReport.current = null\n        }\n      }, 200)\n    }\n  }, [renderData?.args?.height, renderData?.args?.config])\n\n  // Debounced height reporting with improved loop prevention\n  const debouncedReportHeight = useCallback(() => {\n    // Don't schedule height reporting if component is not mounted or already reporting\n    if (!isMountedRef.current || isReportingHeight.current) {\n      return\n    }\n\n    const now = Date.now()\n    if (now - lastReportTime.current < 1000) {\n      // Increased to 1000ms to reduce frequency\n      // Throttle to max once every 1000ms to prevent rapid-fire updates\n      return\n    }\n\n    if (heightReportTimeout.current) {\n      clearTimeout(heightReportTimeout.current)\n    }\n\n    heightReportTimeout.current = setTimeout(() => {\n      // Check again if component is still mounted before reporting\n      if (isMountedRef.current && !isReportingHeight.current) {\n        lastReportTime.current = Date.now()\n        reportHeightWithFallback()\n      }\n    }, 1000) // Increased to 1000ms to reduce frequency\n  }, [reportHeightWithFallback])\n\n  // Enhanced height reporting with ResizeObserver\n  useEffect(() => {\n    if (!containerRef.current) return\n\n    // Report height immediately\n    reportHeightWithFallback()\n\n    // Set up ResizeObserver for height changes\n    resizeObserverManager.current.addObserver(\n      'streamlit-container',\n      containerRef.current,\n      entry => {\n        // Don't process resize events if component is not mounted or if we're currently reporting height\n        if (!isMountedRef.current || isReportingHeight.current) {\n          return\n        }\n\n        // Handle both single entry and array of entries\n        const entries = Array.isArray(entry) ? entry : [entry]\n\n        entries.forEach(singleEntry => {\n          if (singleEntry.target === containerRef.current) {\n            const {width, height} = singleEntry.contentRect\n\n            // Check if dimensions are valid and have actually changed significantly\n            if (width > 0 && height > 0) {\n              const currentHeight = lastReportedHeight.current\n              const heightDiff = Math.abs(height - currentHeight)\n\n              // Only report if height has changed significantly (more than 20px difference)\n              // and we're not already in a reporting cycle\n              if (\n                heightDiff > 20 &&\n                !isReportingHeight.current &&\n                pendingHeightReport.current !== height\n              ) {\n                debouncedReportHeight()\n              }\n            }\n          }\n        })\n      },\n      {throttleMs: 500, debounceMs: 300} // Much higher throttling to prevent infinite loops\n    )\n\n    return () => {\n      if (heightReportTimeout.current) {\n        clearTimeout(heightReportTimeout.current)\n      }\n    }\n  }, [reportHeightWithFallback, debouncedReportHeight])\n\n  // Enhanced height reporting with window resize\n  useEffect(() => {\n    const handleWindowResize = () => {\n      debouncedReportHeight()\n    }\n\n    window.addEventListener('resize', handleWindowResize)\n\n    return () => {\n      window.removeEventListener('resize', handleWindowResize)\n    }\n  }, [debouncedReportHeight])\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true\n\n    // Capture the current ref value to avoid stale closure issues\n    const currentResizeObserverManager = resizeObserverManager.current\n\n    return () => {\n      isMountedRef.current = false\n      isReadyRef.current = false\n\n      // Reset height reporting state to prevent lingering issues\n      isReportingHeight.current = false\n      lastReportedHeight.current = 0\n      pendingHeightReport.current = null\n      lastReportTime.current = 0\n\n      // Cleanup resize observers using captured reference\n      if (currentResizeObserverManager) {\n        currentResizeObserverManager.cleanup()\n      }\n\n      // Clear timeout\n      if (heightReportTimeout.current) {\n        clearTimeout(heightReportTimeout.current)\n        heightReportTimeout.current = null\n      }\n    }\n  }, [])\n\n  // Report height when height prop changes (with more conservative approach)\n  useEffect(() => {\n    if (isReadyRef.current && isMountedRef.current && !isReportingHeight.current) {\n      // Only report if height has actually changed significantly\n      const newHeight = renderData?.args?.height || 400\n      if (Math.abs(newHeight - lastReportedHeight.current) > 20) {\n        debouncedReportHeight()\n      }\n    }\n  }, [renderData?.args?.height, debouncedReportHeight])\n\n  // Report height when config changes (with more conservative approach)\n  useEffect(() => {\n    if (isReadyRef.current && isMountedRef.current && !isReportingHeight.current) {\n      // Longer delay to ensure charts have rendered and prevent immediate loops\n      setTimeout(() => {\n        if (!isReportingHeight.current) {\n          debouncedReportHeight()\n        }\n      }, 1500) // Much longer delay to prevent conflicts\n    }\n  }, [renderData, debouncedReportHeight])\n\n  if (!renderData) {\n    return <div>Loading...</div>\n  }\n\n  const config = renderData.args?.config as ComponentConfig\n\n  // Extract height and width from JSON config instead of separate parameters\n  const height = (renderData.args?.height as number) || config?.charts?.[0]?.chart?.height || 400\n  const width = (renderData.args?.width as number) || config?.charts?.[0]?.chart?.width || null\n\n  return (\n    <div ref={containerRef} style={{width: '100%', minHeight: height}}>\n      <LightweightCharts\n        config={config}\n        height={height}\n        width={width}\n        onChartsReady={handleChartsReady}\n      />\n    </div>\n  )\n}\n\n// Export App component for testing\nexport default App\n\nReactDOM.render(\n  <React.StrictMode>\n    <StreamlitProvider>\n      <App />\n    </StreamlitProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/chart/paneButtonPanelPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/chart/tooltipPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":130,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":44},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":134,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":134,"endColumn":44},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":43},{"ruleId":"no-unused-vars","severity":1,"message":"'chart' is defined but never used. Allowed unused args must match /^_/u.","line":173,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":173,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'container' is defined but never used. Allowed unused args must match /^_/u.","line":173,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":173,"endColumn":61},{"ruleId":"no-unused-vars","severity":1,"message":"'coordinates' is defined but never used. Allowed unused args must match /^_/u.","line":346,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":346,"endColumn":76},{"ruleId":"no-unused-vars","severity":1,"message":"'trade' is defined but never used. Allowed unused args must match /^_/u.","line":420,"column":63,"nodeType":"Identifier","messageId":"unusedVar","endLine":420,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tooltip Plugin for Lightweight Charts\n *\n * This plugin provides comprehensive tooltip functionality with support for:\n * - Dynamic content using placeholders\n * - Multiple tooltip types (OHLC, single, multi, custom, trade, marker)\n * - Flexible positioning and styling\n * - Real-time data substitution\n * - Integration with ChartCoordinateService for positioning\n */\n\nimport {IChartApi, ISeriesApi, SeriesType, Time} from 'lightweight-charts'\nimport {ChartCoordinateService} from '../../services/ChartCoordinateService'\nimport {UniversalSpacing} from '../../primitives/PrimitiveDefaults'\n\nexport interface TooltipField {\n  label: string\n  valueKey: string\n  color?: string\n  fontSize?: number\n  fontWeight?: string\n  prefix?: string\n  suffix?: string\n  precision?: number\n}\n\nexport interface TooltipStyle {\n  backgroundColor?: string\n  borderColor?: string\n  borderWidth?: number\n  borderRadius?: number\n  padding?: number\n  fontSize?: number\n  fontFamily?: string\n  color?: string\n  boxShadow?: string\n  zIndex?: number\n}\n\nexport interface TooltipConfig {\n  enabled: boolean\n  type: 'ohlc' | 'single' | 'multi' | 'custom' | 'trade' | 'marker'\n  template?: string\n  fields: TooltipField[]\n  position?: 'cursor' | 'fixed' | 'auto'\n  offset?: {x: number; y: number}\n  style?: TooltipStyle\n  showDate?: boolean\n  dateFormat?: string\n  showTime?: boolean\n  timeFormat?: string\n  // Add trade-specific configuration\n  tradeData?: {\n    entryPrice: string\n    exitPrice: string\n    size: string\n    pnl: string\n    side: string\n  }\n}\n\nexport interface TooltipData {\n  time: Time\n  series: ISeriesApi<SeriesType>\n  data: any\n  price: number\n  index: number\n  // Add trade-specific data\n  trade?: {\n    entryPrice: number\n    exitPrice: number\n    size: number\n    pnl: number\n    side: 'long' | 'short'\n    entryTime: Time\n    exitTime: Time\n  }\n}\n\nexport class TooltipPlugin {\n  private chart: IChartApi\n  private container: HTMLElement\n  private tooltipElement: HTMLElement | null = null\n  private configs: Map<string, TooltipConfig> = new Map()\n  private currentData: TooltipData | null = null\n  private isVisible = false\n  private chartId: string\n  private coordinateService: ChartCoordinateService\n  private tradeData: Map<string, any> = new Map() // Store trade data for detection\n\n  constructor(chart: IChartApi, container: HTMLElement, chartId: string) {\n    this.chart = chart\n    this.container = container\n    this.chartId = chartId\n    this.coordinateService = ChartCoordinateService.getInstance()\n\n    // Register chart with coordinate service\n    this.coordinateService.registerChart(this.chartId, this.chart)\n\n    this.setupEventListeners()\n  }\n\n  // Public methods for testing and external use\n  public updateContent(content: string): void {\n    if (this.tooltipElement) {\n      this.tooltipElement.innerHTML = content\n    }\n  }\n\n  public setPosition(position: {x: number; y: number}): void {\n    this.positionTooltip(position)\n  }\n\n  public formatSeriesData(seriesData: Map<string, any>): string {\n    if (!seriesData || seriesData.size === 0) {\n      return ''\n    }\n\n    let content = ''\n    seriesData.forEach((data, seriesName) => {\n      content += `<div>${seriesName}: ${JSON.stringify(data)}</div>`\n    })\n    return content\n  }\n\n  public formatPrice(price: number): string {\n    return price.toFixed(2)\n  }\n\n  public handleMouseEnter(event: MouseEvent): void {\n    // Handle mouse enter events\n  }\n\n  public handleMouseLeave(event: MouseEvent): void {\n    this.hideTooltip()\n  }\n\n  public handleMouseMove(event: MouseEvent): void {\n    // Handle mouse move events\n  }\n\n  public constrainToViewport(position: {x: number; y: number}): {x: number; y: number} {\n    const viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    }\n\n    return {\n      x: Math.min(Math.max(position.x, 0), viewport.width - 200),\n      y: Math.min(Math.max(position.y, 0), viewport.height - 100)\n    }\n  }\n\n  public getAbsolutePosition(containerPosition: {x: number; y: number}): {x: number; y: number} {\n    const containerRect = this.container.getBoundingClientRect()\n    return {\n      x: containerRect.left + containerPosition.x,\n      y: containerRect.top + containerPosition.y\n    }\n  }\n\n  public cleanup(): void {\n    this.hideTooltip()\n    if (this.tooltipElement && this.tooltipElement.parentNode) {\n      this.tooltipElement.parentNode.removeChild(this.tooltipElement)\n    }\n  }\n\n  public remove(): void {\n    this.cleanup()\n  }\n\n  public addToChart(chart: IChartApi, container: HTMLElement): void {\n    // This method exists for compatibility with tests\n    // The actual setup is done in the constructor\n  }\n\n  /**\n   * Add tooltip configuration\n   */\n  addConfig(name: string, config: TooltipConfig): void {\n    this.configs.set(name, config)\n  }\n\n  /**\n   * Remove tooltip configuration\n   */\n  removeConfig(name: string): boolean {\n    return this.configs.delete(name)\n  }\n\n  /**\n   * Get tooltip configuration\n   */\n  getConfig(name: string): TooltipConfig | undefined {\n    return this.configs.get(name)\n  }\n\n  /**\n   * Add trade data for tooltip detection\n   */\n  addTradeData(tradeId: string, tradeInfo: any): void {\n    this.tradeData.set(tradeId, tradeInfo)\n  }\n\n  /**\n   * Remove trade data\n   */\n  removeTradeData(tradeId: string): boolean {\n    return this.tradeData.delete(tradeId)\n  }\n\n  /**\n   * Setup event listeners for tooltip functionality\n   */\n  private setupEventListeners(): void {\n    // Subscribe to crosshair move events with throttling to prevent performance issues\n    if (this.chart && typeof this.chart.subscribeCrosshairMove === 'function') {\n      let lastTooltipUpdate = 0\n      const tooltipThrottleDelay = 16 // ~60fps max update rate\n      this.chart.subscribeCrosshairMove(param => {\n        const now = Date.now()\n        if (now - lastTooltipUpdate >= tooltipThrottleDelay) {\n          lastTooltipUpdate = now\n          if (param.time && param.seriesData.size > 0) {\n            this.handleCrosshairMove(param)\n          } else {\n            this.hideTooltip()\n          }\n        }\n      })\n    }\n\n    // Subscribe to chart click events to hide tooltip\n    if (this.chart && typeof this.chart.subscribeClick === 'function') {\n      this.chart.subscribeClick(() => {\n        this.hideTooltip()\n      })\n    }\n  }\n\n  /**\n   * Enhanced crosshair move handler with trade detection\n   */\n  private handleCrosshairMove(param: any): void {\n    if (!this.isVisible) {\n      return\n    }\n\n    // Check if we have valid series data (mouse is over a candle)\n    const [series, data] = param.seriesData.entries().next().value\n    if (!series || !data) {\n      // No series data means mouse is not over a candle - hide tooltip\n      this.hideTooltip()\n      return\n    }\n\n    // Check if the data actually contains valid OHLC values\n    if (!this.isValidOHLCData(data)) {\n      // Data exists but doesn't contain valid OHLC - hide tooltip\n      this.hideTooltip()\n      return\n    }\n\n    // Check if mouse is over a trade rectangle\n    const trade = this.detectTradeAtPosition(param)\n    if (trade) {\n      this.showTradeTooltip(trade, param)\n      return\n    }\n\n    // Mouse is over a candle with valid OHLC data and not over a trade - show OHLC tooltip\n    this.showTooltip(param)\n  }\n\n  /**\n   * Detect if mouse is over a trade using coordinate service\n   */\n  private detectTradeAtPosition(param: any): any {\n    if (!param.point || !param.time) {\n      return null\n    }\n\n    const mouseX = param.point.x\n    const mouseY = param.point.y\n\n    // Check if we have any trade data\n    if (this.tradeData.size === 0) {\n      return null\n    }\n\n    // For now, use a simpler approach - check if mouse is over any trade\n    // We'll improve this later with proper coordinate conversion\n    const trade = this.findTradeAtCoordinates(mouseX, mouseY, {})\n\n    return trade\n  }\n\n  /**\n   * Find trade at specific coordinates\n   */\n  private findTradeAtCoordinates(x: number, y: number, coordinates: any): any {\n    // Iterate through trade data to find matches\n    for (const [, trade] of this.tradeData.entries()) {\n      if (this.isPointInTrade(x, y, trade, coordinates)) {\n        return trade\n      }\n    }\n    return null\n  }\n\n  /**\n   * Check if data contains valid OHLC values\n   */\n  private isValidOHLCData(data: any): boolean {\n    // Check if data has the required OHLC properties\n    const hasOHLC =\n      data.open !== undefined &&\n      data.high !== undefined &&\n      data.low !== undefined &&\n      data.close !== undefined\n\n    // Check if values are valid numbers\n    const hasValidValues =\n      hasOHLC &&\n      typeof data.open === 'number' &&\n      typeof data.high === 'number' &&\n      typeof data.low === 'number' &&\n      typeof data.close === 'number'\n\n    // Check if values make logical sense (high >= low, etc.)\n    const hasLogicalValues =\n      hasValidValues &&\n      data.high >= data.low &&\n      data.high >= data.open &&\n      data.high >= data.close &&\n      data.low <= data.open &&\n      data.low <= data.close\n\n    return hasLogicalValues\n  }\n\n  /**\n   * Check if point is within trade bounds\n   */\n  private isPointInTrade(x: number, y: number, trade: any, coordinates: any): boolean {\n    try {\n      // Convert trade time/price to chart coordinates\n      const timeScale = this.chart.timeScale()\n\n      // Check if the mouse is within the time range of the trade\n      const entryX = timeScale.timeToCoordinate(trade.entryTime)\n      const exitX = timeScale.timeToCoordinate(trade.exitTime)\n\n      if (entryX === null || exitX === null) {\n        return false\n      }\n\n      // Check if mouse X is within trade time range\n      const timeInRange = x >= Math.min(entryX, exitX) && x <= Math.max(entryX, exitX)\n\n      if (!timeInRange) {\n        return false\n      }\n\n      // For Y coordinate, we need to be more precise\n      // Since we can't easily convert prices to coordinates without series access,\n      // we'll use a reasonable tolerance around the middle of the chart\n      const chartHeight = this.container.clientHeight\n      const chartMiddle = chartHeight / 2\n      const tolerance = chartHeight * 0.4 // 40% of chart height tolerance\n\n      // Check if mouse Y is within the middle area of the chart (where trades are likely to be)\n      const yInRange = y >= chartMiddle - tolerance && y <= chartMiddle + tolerance\n\n      if (!yInRange) {\n        return false\n      }\n\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Show trade-specific tooltip\n   */\n  private showTradeTooltip(trade: any, param: any): void {\n    if (!this.tooltipElement) {\n      this.ensureTooltipElement()\n    }\n\n    // Create trade tooltip data\n    const tooltipData: TooltipData = {\n      time: param.time,\n      series: param.seriesData.entries().next().value[0],\n      data: param.seriesData.entries().next().value[1],\n      price: param.price || trade.exitPrice || 0,\n      index: param.index || 0,\n      trade: {\n        entryPrice: trade.entryPrice,\n        exitPrice: trade.exitPrice,\n        size: trade.size,\n        pnl: trade.pnl,\n        side: trade.side,\n        entryTime: trade.entryTime,\n        exitTime: trade.exitTime\n      }\n    }\n\n    this.currentData = tooltipData\n    this.updateTooltipContent()\n    this.positionTradeTooltip(param.point, trade)\n  }\n\n  /**\n   * Position trade tooltip using ChartCoordinateService\n   */\n  private positionTradeTooltip(point: {x: number; y: number}, trade: any): void {\n    if (!this.tooltipElement || !point) {\n      return\n    }\n\n    const config = this.getDefaultConfig()\n    if (!config) {\n      return\n    }\n\n    // Get container bounds using coordinate service\n    const containerBounds = this.container.getBoundingClientRect()\n    const tooltipWidth = this.tooltipElement.offsetWidth || 200\n    const tooltipHeight = this.tooltipElement.offsetHeight || 100\n\n    // Use ChartCoordinateService for optimal positioning\n    const position = this.coordinateService.calculateTooltipPosition(\n      point.x,\n      point.y,\n      tooltipWidth,\n      tooltipHeight,\n      {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        right: containerBounds.width,\n        bottom: containerBounds.height,\n        width: containerBounds.width,\n        height: containerBounds.height\n      },\n      'top' // Preferred anchor for trade tooltips\n    )\n\n    // Apply position using ChartCoordinateService\n    this.coordinateService.applyPositionToElement(this.tooltipElement, {\n      top: position.y,\n      left: position.x\n    })\n\n    // Show tooltip\n    this.tooltipElement.style.display = 'block'\n  }\n\n  /**\n   * Show tooltip with data (existing method, enhanced)\n   */\n  private showTooltip(param: any): void {\n    if (!this.isVisible || !param.time || param.seriesData.size === 0) {\n      return\n    }\n\n    // Get the first series data\n    const [series, data] = param.seriesData.entries().next().value\n    if (!series || !data) {\n      return\n    }\n\n    // Create tooltip data\n    const tooltipData: TooltipData = {\n      time: param.time,\n      series,\n      data,\n      price: param.price || data.value || data.close || 0,\n      index: param.index || 0\n    }\n\n    this.currentData = tooltipData\n    this.updateTooltipContent()\n    this.positionTooltip(param.point)\n  }\n\n  /**\n   * Hide tooltip\n   */\n  private hideTooltip(): void {\n    if (this.tooltipElement) {\n      this.tooltipElement.style.display = 'none'\n    }\n    this.currentData = null\n  }\n\n  /**\n   * Create tooltip element if it doesn't exist\n   */\n  private ensureTooltipElement(): HTMLElement {\n    if (!this.tooltipElement) {\n      this.tooltipElement = document.createElement('div')\n      this.tooltipElement.className = 'chart-tooltip'\n      this.tooltipElement.style.cssText = `\n        position: absolute;\n        z-index: 1000;\n        background-color: rgba(255, 255, 255, 0.95);\n        border: 1px solid #e1e3e6;\n        border-radius: 4px;\n        padding: ${UniversalSpacing.DEFAULT_PADDING}px;\n        font-family: sans-serif;\n        font-size: 12px;\n        color: #131722;\n        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        pointer-events: none;\n        user-select: none;\n        white-space: nowrap;\n        display: none;\n      `\n      this.container.appendChild(this.tooltipElement)\n    }\n    return this.tooltipElement\n  }\n\n  /**\n   * Enhanced tooltip content formatting with trade support\n   */\n  private updateTooltipContent(): void {\n    if (!this.currentData) {\n      return\n    }\n\n    const tooltipElement = this.ensureTooltipElement()\n    const config = this.getDefaultConfig()\n\n    if (!config || !config.enabled) {\n      return\n    }\n\n    const content = this.formatTooltipContent(config, this.currentData)\n    tooltipElement.innerHTML = content\n\n    // Apply custom styling\n    if (config.style) {\n      this.applyTooltipStyle(tooltipElement, config.style)\n    }\n  }\n\n  /**\n   * Format tooltip content using configuration\n   */\n  private formatTooltipContent(config: TooltipConfig, data: TooltipData): string {\n    // Handle trade tooltips specially - if we have trade data, use trade config\n    if (data.trade) {\n      // Try to get the trade config specifically\n      const tradeConfig = this.configs.get('trade')\n      if (tradeConfig) {\n        return this.formatTradeTooltip(tradeConfig, data)\n      }\n    }\n\n    // Use existing formatting for other types\n    if (config.template) {\n      return this.formatWithTemplate(config, data)\n    } else {\n      return this.formatWithFields(config, data)\n    }\n  }\n\n  /**\n   * Format trade-specific tooltip content\n   */\n  private formatTradeTooltip(config: TooltipConfig, data: TooltipData): string {\n    if (!data.trade) {\n      return ''\n    }\n\n    const trade = data.trade\n    const sideColor = trade.side === 'long' ? '#00ff88' : '#ff4444'\n    const pnlColor = trade.pnl >= 0 ? '#00ff88' : '#ff4444'\n\n    return `\n      <div class=\"trade-tooltip\">\n        <div class=\"trade-header\" style=\"color: ${sideColor}; font-weight: 600; margin-bottom: 8px;\">\n          ${trade.side.toUpperCase()} TRADE\n        </div>\n        <div class=\"trade-details\" style=\"line-height: 1.4;\">\n          <div>Entry: $${trade.entryPrice?.toFixed(2)}</div>\n          <div>Exit: $${trade.exitPrice?.toFixed(2)}</div>\n          <div>Size: ${trade.size}</div>\n          <div style=\"color: ${pnlColor}; font-weight: 600;\">\n            P&L: $${trade.pnl?.toFixed(2)}\n          </div>\n        </div>\n      </div>\n    `\n  }\n\n  /**\n   * Format tooltip using template with placeholders\n   */\n  private formatWithTemplate(config: TooltipConfig, data: TooltipData): string {\n    if (!config.template) {\n      return ''\n    }\n\n    let result = config.template\n\n    // Replace placeholders with actual values\n    const dataObj = this.extractDataObject(data)\n    const keys = Object.keys(dataObj)\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const value = dataObj[key]\n      const placeholder = `{${key}}`\n      if (result.includes(placeholder)) {\n        const formattedValue = this.formatValue(key, value, config)\n        result = result.replace(new RegExp(placeholder, 'g'), formattedValue)\n      }\n    }\n\n    // Add date/time if configured\n    if ((config.showDate || config.showTime) && data.time) {\n      const timeStr = this.formatTime(data.time, config)\n      if (timeStr) {\n        result = `${timeStr}<br>${result}`\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Format tooltip using field configuration\n   */\n  private formatWithFields(config: TooltipConfig, data: TooltipData): string {\n    const lines: string[] = []\n\n    // Add date/time if configured\n    if ((config.showDate || config.showTime) && data.time) {\n      const timeStr = this.formatTime(data.time, config)\n      if (timeStr) {\n        lines.push(timeStr)\n      }\n    }\n\n    // Add field values\n    const dataObj = this.extractDataObject(data)\n    for (const field of config.fields) {\n      if (dataObj[field.valueKey] !== undefined) {\n        const value = dataObj[field.valueKey]\n        const formattedValue = this.formatFieldValue(field, value)\n        lines.push(`${field.label}: ${formattedValue}`)\n      }\n    }\n\n    return lines.join('<br>')\n  }\n\n  /**\n   * Extract data object from tooltip data\n   */\n  private extractDataObject(data: TooltipData): any {\n    const result: any = {\n      time: data.time,\n      price: data.price,\n      value: data.data.value,\n      open: data.data.open,\n      high: data.data.high,\n      low: data.data.low,\n      close: data.data.close,\n      volume: data.data.volume,\n      index: data.index\n    }\n\n    // Add all properties from the data object\n    Object.assign(result, data.data)\n\n    return result\n  }\n\n  /**\n   * Format a single value\n   */\n  private formatValue(key: string, value: any, config: TooltipConfig): string {\n    const field = config.fields.find(f => f.valueKey === key)\n    if (field) {\n      return this.formatFieldValue(field, value)\n    }\n    return String(value)\n  }\n\n  /**\n   * Format field value according to field configuration\n   */\n  private formatFieldValue(field: TooltipField, value: any): string {\n    let result = String(value)\n\n    // Apply precision for numeric values\n    if (field.precision !== undefined && typeof value === 'number') {\n      result = value.toFixed(field.precision)\n    }\n\n    // Add prefix and suffix\n    if (field.prefix) {\n      result = `${field.prefix}${result}`\n    }\n    if (field.suffix) {\n      result = `${result}${field.suffix}`\n    }\n\n    return result\n  }\n\n  /**\n   * Format time value according to configuration\n   */\n  private formatTime(time: Time, config: TooltipConfig): string {\n    try {\n      const date = new Date((time as number) * 1000)\n      const parts: string[] = []\n\n      if (config.showDate) {\n        const dateFormat = config.dateFormat || '%Y-%m-%d'\n        parts.push(this.formatDate(date, dateFormat))\n      }\n\n      if (config.showTime) {\n        const timeFormat = config.timeFormat || '%H:%M:%S'\n        parts.push(this.formatTimeString(date, timeFormat))\n      }\n\n      return parts.join(' ')\n    } catch (error) {\n      return String(time)\n    }\n  }\n\n  /**\n   * Format date according to format string\n   */\n  private formatDate(date: Date, format: string): string {\n    // Simple date formatting - can be enhanced with a proper date library\n    const year = date.getFullYear()\n    const month = String(date.getMonth() + 1).padStart(2, '0')\n    const day = String(date.getDate()).padStart(2, '0')\n\n    return format.replace('%Y', String(year)).replace('%m', month).replace('%d', day)\n  }\n\n  /**\n   * Format time according to format string\n   */\n  private formatTimeString(date: Date, format: string): string {\n    const hours = String(date.getHours()).padStart(2, '0')\n    const minutes = String(date.getMinutes()).padStart(2, '0')\n    const seconds = String(date.getSeconds()).padStart(2, '0')\n\n    return format.replace('%H', hours).replace('%M', minutes).replace('%S', seconds)\n  }\n\n  /**\n   * Enhanced tooltip positioning using ChartCoordinateService\n   */\n  private positionTooltip(point: {x: number; y: number}): void {\n    if (!this.tooltipElement || !point) {\n      return\n    }\n\n    const config = this.getDefaultConfig()\n    if (!config) {\n      return\n    }\n\n    // Get container bounds using coordinate service\n    const containerBounds = this.container.getBoundingClientRect()\n    const tooltipWidth = this.tooltipElement.offsetWidth || 200\n    const tooltipHeight = this.tooltipElement.offsetHeight || 100\n\n    // Use ChartCoordinateService for optimal positioning\n    const position = this.coordinateService.calculateTooltipPosition(\n      point.x,\n      point.y,\n      tooltipWidth,\n      tooltipHeight,\n      {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        right: containerBounds.width,\n        bottom: containerBounds.height,\n        width: containerBounds.width,\n        height: containerBounds.height\n      },\n      'top'\n    )\n\n    // Apply position using ChartCoordinateService\n    this.coordinateService.applyPositionToElement(this.tooltipElement, {\n      top: position.y,\n      left: position.x\n    })\n\n    // Show tooltip\n    this.tooltipElement.style.display = 'block'\n  }\n\n  /**\n   * Apply custom styling to tooltip element\n   */\n  private applyTooltipStyle(element: HTMLElement, style: TooltipStyle): void {\n    if (style.backgroundColor) {\n      element.style.backgroundColor = style.backgroundColor\n    }\n    if (style.borderColor) {\n      element.style.borderColor = style.borderColor\n    }\n    if (style.borderWidth !== undefined) {\n      element.style.borderWidth = `${style.borderWidth}px`\n    }\n    if (style.borderRadius !== undefined) {\n      element.style.borderRadius = `${style.borderRadius}px`\n    }\n    if (style.padding !== undefined) {\n      element.style.padding = `${style.padding}px`\n    }\n    if (style.fontSize !== undefined) {\n      element.style.fontSize = `${style.fontSize}px`\n    }\n    if (style.fontFamily) {\n      element.style.fontFamily = style.fontFamily\n    }\n    if (style.color) {\n      element.style.color = style.color\n    }\n    if (style.boxShadow) {\n      element.style.boxShadow = style.boxShadow\n    }\n    if (style.zIndex !== undefined) {\n      element.style.zIndex = String(style.zIndex)\n    }\n  }\n\n  /**\n   * Get default tooltip configuration\n   */\n  private getDefaultConfig(): TooltipConfig | undefined {\n    return this.configs.get('default') || this.configs.values().next().value\n  }\n\n  /**\n   * Enable tooltip\n   */\n  enable(): void {\n    this.isVisible = true\n  }\n\n  /**\n   * Disable tooltip\n   */\n  disable(): void {\n    this.isVisible = false\n    this.hideTooltip()\n  }\n\n  /**\n   * Enhanced destroy method with coordinate service cleanup\n   */\n  destroy(): void {\n    if (this.tooltipElement) {\n      this.container.removeChild(this.tooltipElement)\n      this.tooltipElement = null\n    }\n\n    // Unregister from coordinate service\n    this.coordinateService.unregisterChart(this.chartId)\n\n    this.configs.clear()\n    this.currentData = null\n    this.tradeData.clear()\n  }\n}\n\n/**\n * Create and configure tooltip plugin with chart ID\n */\nexport function createTooltipPlugin(\n  chart: IChartApi,\n  container: HTMLElement,\n  chartId: string,\n  configs: Record<string, TooltipConfig> = {},\n  chartConfig?: any\n): TooltipPlugin {\n  const plugin = new TooltipPlugin(chart, container, chartId)\n\n  // Add configurations\n  for (const [name, config] of Object.entries(configs)) {\n    plugin.addConfig(name, config)\n  }\n\n  // Extract trade data from chart configuration if provided\n  if (chartConfig && chartConfig.trades && Array.isArray(chartConfig.trades)) {\n    // Add each trade to the tooltip plugin\n    chartConfig.trades.forEach((trade: any, index: number) => {\n      const tradeId = `trade_${index}`\n      plugin.addTradeData(tradeId, {\n        entryTime: trade.entry_time || trade.entryTime,\n        exitTime: trade.exit_time || trade.exitTime,\n        entryPrice: trade.entry_price || trade.entryPrice,\n        exitPrice: trade.exit_price || trade.exitPrice,\n        size: trade.quantity || trade.size,\n        pnl: (trade.exit_price || trade.exitPrice) - (trade.entry_price || trade.entryPrice),\n        side: trade.trade_type === 'LONG' ? 'long' : 'short'\n      })\n    })\n  }\n\n  return plugin\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/overlay/rectanglePlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":84,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":84,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {IChartApi} from 'lightweight-charts'\nimport {ChartReadyDetector} from '../../utils/chartReadyDetection'\nimport {ResizeObserverManager} from '../../utils/resizeObserverManager'\nimport {ChartCoordinateService} from '../../services/ChartCoordinateService'\nimport {UniversalSpacing} from '../../primitives/PrimitiveDefaults'\n\nexport interface RectangleConfig {\n  id: string\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n  color: string\n  borderColor?: string\n  borderWidth?: number\n  fillOpacity?: number\n  borderOpacity?: number\n  label?: string\n  labelColor?: string\n  labelFontSize?: number\n  labelBackground?: string\n  labelPadding?: number\n  zIndex?: number\n}\n\nexport class RectangleOverlayPlugin {\n  private rectangles: RectangleConfig[] = []\n  private chart: IChartApi | null = null\n  private container: HTMLElement | null = null\n  private canvas: HTMLCanvasElement | null = null\n  private ctx: CanvasRenderingContext2D | null = null\n  private series: any = null\n  private isDisposed: boolean = false\n  private isInitialized: boolean = false\n  private resizeObserverManager: ResizeObserverManager\n  private redrawTimeout: NodeJS.Timeout | null = null\n  private lastCanvasSize = {width: 0, height: 0}\n\n  constructor() {\n    this.resizeObserverManager = new ResizeObserverManager()\n  }\n\n  setChart(chart: IChartApi, series?: any) {\n    this.chart = chart\n    this.series = series\n    this.init()\n  }\n\n  // Public method for testing compatibility\n  public addToChart(chart: IChartApi): void {\n    this.setChart(chart)\n  }\n\n  public remove(): void {\n    if (this.canvas && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas)\n    }\n    this.canvas = null\n    this.container = null\n    this.chart = null\n    this.isInitialized = false\n  }\n\n  public setRectangles(rectangles: RectangleConfig[]): void {\n    this.rectangles = rectangles\n    if (this.isInitialized) {\n      this.render()\n    } else {\n\n      // Store rectangles and they will be rendered once the plugin is initialized\n    }\n  }\n\n  private render(): void {\n    if (!this.canvas || !this.ctx) {\n\n      return\n    }\n\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    // Draw rectangles\n    this.rectangles.forEach((rect, index) => {\n      this.ctx!.fillStyle = rect.color || '#000000'\n\n      // Ensure proper rectangle dimensions (handle inverted Y coordinates)\n      const x = Math.min(rect.x1, rect.x2)\n      const y = Math.min(rect.y1, rect.y2)\n      const width = Math.abs(rect.x2 - rect.x1)\n      const height = Math.abs(rect.y2 - rect.y1)\n\n      this.ctx!.fillRect(x, y, width, height)\n    })\n  }\n\n  private async init() {\n    if (!this.chart) return\n\n    try {\n      // Wait for chart to be ready before initializing\n      const container = this.chart.chartElement()\n      if (!container) {\n        return\n      }\n\n      // Wait for chart to be fully ready\n      const isReady = await ChartReadyDetector.waitForChartReady(this.chart, container, {\n        minWidth: 200,\n        minHeight: 200\n      })\n\n      if (!isReady) {\n\n      }\n\n      this.container = container\n      this.createCanvas()\n      this.setupResizeObserver()\n      this.setupEventListeners()\n      this.isInitialized = true\n\n      // Render any rectangles that were set before initialization\n      if (this.rectangles.length > 0) {\n        this.render()\n      }\n    } catch (error) {\n\n    }\n  }\n\n  private createCanvas() {\n    if (!this.container) return\n\n    try {\n      // Create canvas overlay\n      this.canvas = document.createElement('canvas')\n      this.canvas.style.position = 'absolute'\n      this.canvas.style.top = '0'\n      this.canvas.style.left = '0'\n      this.canvas.style.pointerEvents = 'none'\n\n      // Set Z-index from config or use default of 20\n      const defaultZIndex = 20\n      this.canvas.style.zIndex = defaultZIndex.toString()\n\n      if (this.container && this.container.style) {\n        this.container.style.position = 'relative'\n        this.container.appendChild(this.canvas)\n      }\n\n      // Get canvas context\n      this.ctx = this.canvas.getContext('2d')\n      if (!this.ctx) {\n        throw new Error('Failed to get canvas context')\n      }\n\n      // Set initial canvas size\n      this.resizeCanvas()\n    } catch (error) {\n\n    }\n  }\n\n  private setupResizeObserver() {\n    if (!this.container || !this.canvas) return\n\n    // Use our ResizeObserverManager for better handling\n    this.resizeObserverManager.addObserver(\n      'rectangle-plugin',\n      this.container,\n      entry => {\n        if (this.isDisposed) return\n\n        // Handle both single entry and array of entries\n        const entries = Array.isArray(entry) ? entry : [entry]\n\n        entries.forEach(singleEntry => {\n          const {width, height} = singleEntry.contentRect\n\n          // Check if dimensions are valid before resizing\n          if (width > 100 && height > 100) {\n            this.handleResize()\n          }\n        })\n      },\n      {throttleMs: 100, debounceMs: 50}\n    )\n  }\n\n  private setupEventListeners() {\n    if (!this.chart) return\n\n    try {\n      // Listen for chart updates (time scale changes, panning, zooming) with throttling\n      let lastRedrawSchedule = 0\n      const redrawThrottleDelay = 16 // ~60fps max\n      this.chart.timeScale().subscribeVisibleTimeRangeChange(() => {\n        if (!this.isDisposed) {\n          const now = Date.now()\n          if (now - lastRedrawSchedule >= redrawThrottleDelay) {\n            lastRedrawSchedule = now\n            this.scheduleRedraw()\n          }\n        }\n      })\n\n      // Listen for crosshair movement (includes price scale changes)\n      this.chart.subscribeCrosshairMove(() => {\n        if (!this.isDisposed) {\n          this.scheduleRedraw()\n        }\n      })\n    } catch (error) {\n\n    }\n  }\n\n  private async resizeCanvas() {\n    if (!this.canvas || !this.container || !this.chart) return\n\n    try {\n      // Use consolidated service for chart dimensions\n      const coordinateService = ChartCoordinateService.getInstance()\n      const dimensions = await coordinateService.getChartDimensionsWithFallback(\n        this.chart,\n        this.container,\n        {minWidth: 200, minHeight: 200}\n      )\n\n      const {width, height} = dimensions.container\n\n      // Only resize if dimensions actually changed\n      if (width !== this.lastCanvasSize.width || height !== this.lastCanvasSize.height) {\n        this.canvas.width = width\n        this.canvas.height = height\n        this.lastCanvasSize = {width, height}\n\n        // Canvas resized successfully\n\n        // Redraw after resize\n        this.scheduleRedraw()\n      }\n    } catch (error) {\n\n\n      // Fallback to manual dimension calculation\n      this.fallbackResizeCanvas()\n    }\n  }\n\n  private fallbackResizeCanvas() {\n    if (!this.canvas || !this.container) return\n\n    try {\n      // Method 1: Try container dimensions first\n      let width = 0\n      let height = 0\n\n      try {\n        const rect = this.container.getBoundingClientRect()\n        width = rect.width\n        height = rect.height\n      } catch (error) {\n        width = this.container.offsetWidth\n        height = this.container.offsetHeight\n      }\n\n      // Method 2: Fallback to offset dimensions\n      if (!width || !height) {\n        width = this.container.offsetWidth || 800\n        height = this.container.offsetHeight || 600\n      }\n\n      // Method 3: Use chart element dimensions if available\n      if ((!width || !height) && this.chart) {\n        try {\n          const chartElement = this.chart.chartElement()\n          if (chartElement) {\n            const chartRect = chartElement.getBoundingClientRect()\n            if (chartRect.width > 0 && chartRect.height > 0) {\n              width = chartRect.width\n              height = chartRect.height\n            }\n          }\n        } catch (error) {\n          // Ignore error\n        }\n      }\n\n      // Ensure minimum dimensions\n      width = Math.max(width, 200)\n      height = Math.max(height, 200)\n\n      // Only resize if dimensions actually changed\n      if (width !== this.lastCanvasSize.width || height !== this.lastCanvasSize.height) {\n        this.canvas.width = width\n        this.canvas.height = height\n        this.lastCanvasSize = {width, height}\n\n        // Fallback canvas resize successful\n\n        // Redraw after resize\n        this.scheduleRedraw()\n      }\n    } catch (error) {\n\n    }\n  }\n\n  private async handleResize() {\n    if (this.isDisposed) return\n\n    try {\n      await this.resizeCanvas()\n    } catch (error) {\n\n    }\n  }\n\n  private scheduleRedraw() {\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout)\n    }\n\n    this.redrawTimeout = setTimeout(() => {\n      if (!this.isDisposed) {\n        this.redraw()\n      }\n    }, 16) // ~60fps\n  }\n\n  private redraw() {\n    if (!this.ctx || !this.canvas || this.isDisposed) return\n\n    try {\n      // Clear canvas\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      // Draw all rectangles\n      this.rectangles.forEach(rect => {\n        this.drawRectangle(rect)\n      })\n    } catch (error) {\n\n    }\n  }\n\n  private drawRectangle(rect: RectangleConfig) {\n    if (!this.ctx || !this.canvas) return\n\n    try {\n      const {x1, y1, x2, y2, color, borderColor, borderWidth, fillOpacity, borderOpacity} = rect\n\n      // Calculate actual coordinates based on chart scale\n      const actualCoords = this.calculateActualCoordinates(x1, y1, x2, y2)\n      if (!actualCoords) return\n\n      const {ax1, ay1, ax2, ay2} = actualCoords\n\n      // Ensure proper rectangle dimensions (handle inverted Y coordinates)\n      const rectX = Math.min(ax1, ax2)\n      const rectY = Math.min(ay1, ay2)\n      const rectWidth = Math.abs(ax2 - ax1)\n      const rectHeight = Math.abs(ay2 - ay1)\n\n      // Set fill style\n      this.ctx.fillStyle = color\n      if (fillOpacity !== undefined) {\n        this.ctx.globalAlpha = fillOpacity\n      }\n\n      // Draw filled rectangle\n      this.ctx.fillRect(rectX, rectY, rectWidth, rectHeight)\n\n      // Reset alpha for border\n      this.ctx.globalAlpha = 1.0\n\n      // Draw border if specified\n      if (borderColor && borderWidth) {\n        this.ctx.strokeStyle = borderColor\n        this.ctx.lineWidth = borderWidth\n        if (borderOpacity !== undefined) {\n          this.ctx.globalAlpha = borderOpacity\n        }\n        this.ctx.strokeRect(rectX, rectY, rectWidth, rectHeight)\n        this.ctx.globalAlpha = 1.0\n      }\n\n      // Draw label if specified\n      if (rect.label) {\n        this.drawLabel(rect, rectX, rectY, rectX + rectWidth, rectY + rectHeight)\n      }\n    } catch (error) {\n\n    }\n  }\n\n  private calculateActualCoordinates(x1: number, y1: number, x2: number, y2: number) {\n    if (!this.chart || !this.canvas) return null\n\n    try {\n      // Method 1: Try to use chart's coordinate system (simplified for now)\n      try {\n        // For now, just use pixel coordinates directly\n      } catch (error) {}\n\n      // Method 2: Use pixel coordinates directly\n      return {\n        ax1: x1,\n        ay1: y1,\n        ax2: x2,\n        ay2: y2\n      }\n    } catch (error) {\n\n      return null\n    }\n  }\n\n  private drawLabel(rect: RectangleConfig, x1: number, y1: number, x2: number, y2: number) {\n    if (!this.ctx || !rect.label) return\n\n    try {\n      const labelX = (x1 + x2) / 2\n      const labelY = Math.min(y1, y2) - 10\n\n      // Set label style\n      this.ctx.font = `${rect.labelFontSize || 12}px Arial`\n      this.ctx.fillStyle = rect.labelColor || '#000000'\n      this.ctx.textAlign = 'center'\n      this.ctx.textBaseline = 'bottom'\n\n      // Draw label background if specified\n      if (rect.labelBackground) {\n        const textMetrics = this.ctx.measureText(rect.label)\n        const padding = rect.labelPadding || UniversalSpacing.DEFAULT_PADDING\n        const bgWidth = textMetrics.width + padding * 2\n        const bgHeight = (rect.labelFontSize || 12) + padding * 2\n\n        this.ctx.fillStyle = rect.labelBackground\n        this.ctx.fillRect(labelX - bgWidth / 2, labelY - bgHeight + padding, bgWidth, bgHeight)\n\n        // Reset text color\n        this.ctx.fillStyle = rect.labelColor || '#000000'\n      }\n\n      // Draw label text\n      this.ctx.fillText(rect.label, labelX, labelY)\n    } catch (error) {\n\n    }\n  }\n\n  /**\n   * Update canvas Z-index based on the highest Z-index of all rectangles\n   * Default Z-index is 20 if no rectangles have Z-index specified\n   */\n  private updateCanvasZIndex() {\n    if (!this.canvas) return\n\n    const defaultZIndex = 20\n    let maxZIndex = defaultZIndex\n\n    // Find the highest Z-index among all rectangles\n    for (const rect of this.rectangles) {\n      if (rect.zIndex !== undefined && rect.zIndex > maxZIndex) {\n        maxZIndex = rect.zIndex\n      }\n    }\n\n    // Update canvas Z-index\n    this.canvas.style.zIndex = maxZIndex.toString()\n\n    if (maxZIndex !== defaultZIndex) {\n    }\n  }\n\n  addRectangle(rect: RectangleConfig) {\n    this.rectangles.push(rect)\n    this.updateCanvasZIndex()\n    this.scheduleRedraw()\n  }\n\n  removeRectangle(id: string) {\n    const index = this.rectangles.findIndex(r => r.id === id)\n    if (index !== -1) {\n      this.rectangles.splice(index, 1)\n      this.updateCanvasZIndex()\n      this.scheduleRedraw()\n    }\n  }\n\n  updateRectangle(id: string, updates: Partial<RectangleConfig>) {\n    const rect = this.rectangles.find(r => r.id === id)\n    if (rect) {\n      Object.assign(rect, updates)\n      this.updateCanvasZIndex()\n      this.scheduleRedraw()\n    }\n  }\n\n  clearRectangles() {\n    this.rectangles = []\n    this.updateCanvasZIndex()\n    this.scheduleRedraw()\n  }\n\n  getRectangles(): RectangleConfig[] {\n    return [...this.rectangles]\n  }\n\n  dispose() {\n    this.isDisposed = true\n\n    // Cleanup resize observers\n    this.resizeObserverManager.cleanup()\n\n    // Clear timeout\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout)\n      this.redrawTimeout = null\n    }\n\n    // Remove canvas\n    if (this.canvas && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas)\n    }\n\n    // Clear references\n    this.chart = null\n    this.container = null\n    this.canvas = null\n    this.ctx = null\n    this.series = null\n    this.rectangles = []\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/series/bandSeriesPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'param' is defined but never used. Allowed unused args must match /^_/u.","line":394,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":394,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IChartApi,\n  ISeriesApi,\n  LineData,\n  Time,\n  LineSeries,\n  ISeriesPrimitive,\n  SeriesAttachedParameter,\n  IPrimitivePaneView,\n  IPrimitivePaneRenderer,\n  Coordinate\n} from 'lightweight-charts'\n\n// Band data interface\nexport interface BandData extends LineData {\n  upper: number\n  middle: number\n  lower: number\n}\n\n// Line style options interface\nexport interface LineStyleOptions {\n  color?: string\n  lineStyle?: number\n  lineWidth?: number\n  lineVisible?: boolean\n  lineType?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  lastPriceAnimation?: number\n}\n\n// Band series options\nexport interface BandSeriesOptions {\n  // Z-index for proper layering\n  zIndex?: number\n\n  // Line style options\n  upperLine?: LineStyleOptions\n  middleLine?: LineStyleOptions\n  lowerLine?: LineStyleOptions\n\n  // Fill colors\n  upperFillColor: string\n  lowerFillColor: string\n\n  // Fill visibility\n  upperFill: boolean\n  lowerFill: boolean\n\n  // Base options\n  visible: boolean\n  priceScaleId: string\n  lastValueVisible: boolean\n  priceLineVisible: boolean\n  priceLineSource: string\n  priceLineWidth: number\n  priceLineColor: string\n  priceLineStyle: number\n  baseLineVisible: boolean\n  baseLineWidth: number\n  baseLineColor: string\n  baseLineStyle: string\n  priceFormat: any\n}\n\n// Default options\nconst defaultOptions: BandSeriesOptions = {\n  // Line style options\n  upperLine: {\n    color: '#4CAF50',\n    lineStyle: 0, // SOLID\n    lineWidth: 2,\n    lineVisible: true,\n    lineType: 0, // SIMPLE\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBackgroundColor: '',\n    crosshairMarkerBorderWidth: 2,\n    lastPriceAnimation: 0 // DISABLED\n  },\n  middleLine: {\n    color: '#2196F3',\n    lineStyle: 0, // SOLID\n    lineWidth: 2,\n    lineVisible: true,\n    lineType: 0, // SIMPLE\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBackgroundColor: '',\n    crosshairMarkerBorderWidth: 2,\n    lastPriceAnimation: 0 // DISABLED\n  },\n  lowerLine: {\n    color: '#F44336',\n    lineStyle: 0, // SOLID\n    lineWidth: 2,\n    lineVisible: true,\n    lineType: 0, // SIMPLE\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBackgroundColor: '',\n    crosshairMarkerBorderWidth: 2,\n    lastPriceAnimation: 0 // DISABLED\n  },\n\n  // Fill colors\n  upperFillColor: 'rgba(76, 175, 80, 0.1)',\n  lowerFillColor: 'rgba(244, 67, 54, 0.1)',\n\n  // Fill visibility\n  upperFill: true,\n  lowerFill: true,\n\n  // Base options\n  visible: true,\n  priceScaleId: 'right',\n  lastValueVisible: false,\n  priceLineVisible: true,\n  priceLineSource: 'lastBar',\n  priceLineWidth: 1,\n  priceLineColor: '#2196F3',\n  priceLineStyle: 2, // DASHED\n  baseLineVisible: false,\n  baseLineWidth: 1,\n  baseLineColor: '#FF9800',\n  baseLineStyle: 'solid',\n  priceFormat: {type: 'price', precision: 2}\n}\n\n// Band renderer data interface\ninterface BandRendererData {\n  x: Coordinate | number\n  upper: Coordinate | number\n  middle: Coordinate | number\n  lower: Coordinate | number\n}\n\n// Band view data interface\ninterface BandViewData {\n  data: BandRendererData[]\n  options: BandSeriesOptions\n}\n\n// Band primitive pane renderer\nclass BandPrimitivePaneRenderer implements IPrimitivePaneRenderer {\n  _viewData: BandViewData\n\n  constructor(data: BandViewData) {\n    this._viewData = data\n  }\n\n  draw() {}\n\n  drawBackground(target: any) {\n    // Apply Z-index context for proper layering\n    const zIndex = this._viewData.options.zIndex || 0\n    const points: BandRendererData[] = this._viewData.data\n    if (points.length === 0) return\n\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n\n      // Set Z-index context for proper layering\n      if (zIndex > 0) {\n        // Apply Z-index through canvas context properties\n        // This ensures the primitive renders at the correct layer\n        ctx.globalCompositeOperation = 'source-over'\n        ctx.globalAlpha = 1.0\n\n        // Store Z-index in canvas context for potential use by other renderers\n        ;(ctx as any).__zIndex = zIndex\n      }\n\n      // Draw upper fill area (between upper and middle) only if enabled\n      if (\n        this._viewData.options.upperFill &&\n        this._viewData.options.upperFillColor !== 'rgba(0, 0, 0, 0)'\n      ) {\n        ctx.fillStyle = this._viewData.options.upperFillColor\n        ctx.beginPath()\n        ctx.moveTo(points[0].x, points[0].upper)\n        for (const point of points) {\n          ctx.lineTo(point.x, point.upper)\n        }\n        for (let i = points.length - 1; i >= 0; i--) {\n          ctx.lineTo(points[i].x, points[i].middle)\n        }\n        ctx.closePath()\n        ctx.fill()\n      }\n\n      // Draw lower fill area (between middle and lower) only if enabled\n      if (\n        this._viewData.options.lowerFill &&\n        this._viewData.options.lowerFillColor !== 'rgba(0, 0, 0, 0)'\n      ) {\n        ctx.fillStyle = this._viewData.options.lowerFillColor\n        ctx.beginPath()\n        ctx.moveTo(points[0].x, points[0].middle)\n        for (const point of points) {\n          ctx.lineTo(point.x, point.middle)\n        }\n        for (let i = points.length - 1; i >= 0; i--) {\n          ctx.lineTo(points[i].x, points[i].lower)\n        }\n        ctx.closePath()\n        ctx.fill()\n      }\n    })\n  }\n}\n\n// Band primitive pane view\nclass BandPrimitivePaneView implements IPrimitivePaneView {\n  _source: BandSeries\n  _data: BandViewData\n\n  constructor(source: BandSeries) {\n    this._source = source\n    this._data = {\n      data: [],\n      options: this._source.getOptions()\n    }\n  }\n\n  update() {\n    const timeScale = this._source.getChart().timeScale()\n    this._data.data = this._source.getData().map(d => {\n      return {\n        x: timeScale.timeToCoordinate(d.time) ?? -100,\n        upper: this._source.getUpperSeries().priceToCoordinate(d.upper) ?? -100,\n        middle: this._source.getMiddleSeries().priceToCoordinate(d.middle) ?? -100,\n        lower: this._source.getLowerSeries().priceToCoordinate(d.lower) ?? -100\n      }\n    })\n  }\n\n  renderer() {\n    return new BandPrimitivePaneRenderer(this._data)\n  }\n\n  // Z-index support: Return the Z-index for proper layering\n  zIndex(): number {\n    const sourceZIndex = this._source.getOptions().zIndex\n    // Validate Z-index is a positive number\n    if (typeof sourceZIndex === 'number' && sourceZIndex >= 0) {\n      return sourceZIndex\n    }\n    // Return default Z-index for band series\n    return 100\n  }\n}\n\n// Band series class\nexport class BandSeries implements ISeriesPrimitive<Time> {\n  private chart: IChartApi\n  private upperSeries: ISeriesApi<'Line'>\n  private middleSeries: ISeriesApi<'Line'>\n  private lowerSeries: ISeriesApi<'Line'>\n  private options: BandSeriesOptions\n  private data: BandData[] = []\n  private _paneViews: BandPrimitivePaneView[]\n\n  constructor(chart: IChartApi, options: Partial<BandSeriesOptions> = {}) {\n    this.chart = chart\n    this.options = {...defaultOptions, ...options}\n    this._paneViews = [new BandPrimitivePaneView(this)]\n\n    // Create the three line series\n    this.upperSeries = chart.addSeries(LineSeries, {\n      color: this.options.upperLine?.color || '#4CAF50',\n      lineStyle: this.options.upperLine?.lineStyle || 0,\n      lineWidth: (this.options.upperLine?.lineWidth || 2) as any,\n      visible: this.options.upperLine?.lineVisible !== false,\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: this.options.lastValueVisible,\n      priceLineVisible: this.options.priceLineVisible,\n      priceLineSource: this.options.priceLineSource as any,\n      priceLineWidth: this.options.priceLineWidth as any,\n      priceLineColor: this.options.priceLineColor,\n      priceLineStyle: this.options.priceLineStyle as any,\n      baseLineVisible: this.options.baseLineVisible,\n      baseLineWidth: this.options.baseLineWidth as any,\n      baseLineColor: this.options.baseLineColor,\n      baseLineStyle: this.options.baseLineStyle as any,\n      priceFormat: this.options.priceFormat,\n      crosshairMarkerVisible: this.options.upperLine?.crosshairMarkerVisible !== false,\n      crosshairMarkerRadius: this.options.upperLine?.crosshairMarkerRadius || 4,\n      crosshairMarkerBorderColor: this.options.upperLine?.crosshairMarkerBorderColor || '',\n      crosshairMarkerBackgroundColor: this.options.upperLine?.crosshairMarkerBackgroundColor || '',\n      crosshairMarkerBorderWidth: this.options.upperLine?.crosshairMarkerBorderWidth || 2,\n      lastPriceAnimation: this.options.upperLine?.lastPriceAnimation || 0,\n      lineType: this.options.upperLine?.lineType || 0\n    })\n\n    this.middleSeries = chart.addSeries(LineSeries, {\n      color: this.options.middleLine?.color || '#2196F3',\n      lineStyle: this.options.middleLine?.lineStyle || 0,\n      lineWidth: (this.options.middleLine?.lineWidth || 2) as any,\n      visible: this.options.middleLine?.lineVisible !== false,\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: this.options.lastValueVisible,\n      priceLineVisible: this.options.priceLineVisible,\n      priceLineSource: this.options.priceLineSource as any,\n      priceLineWidth: this.options.priceLineWidth as any,\n      priceLineColor: this.options.priceLineColor,\n      priceLineStyle: this.options.priceLineStyle as any,\n      baseLineVisible: this.options.baseLineVisible,\n      baseLineWidth: this.options.baseLineWidth as any,\n      baseLineColor: this.options.baseLineColor,\n      baseLineStyle: this.options.baseLineStyle as any,\n      priceFormat: this.options.priceFormat,\n      crosshairMarkerVisible: this.options.middleLine?.crosshairMarkerVisible !== false,\n      crosshairMarkerRadius: this.options.middleLine?.crosshairMarkerRadius || 4,\n      crosshairMarkerBorderColor: this.options.middleLine?.crosshairMarkerBorderColor || '',\n      crosshairMarkerBackgroundColor: this.options.middleLine?.crosshairMarkerBackgroundColor || '',\n      crosshairMarkerBorderWidth: this.options.middleLine?.crosshairMarkerBorderWidth || 2,\n      lastPriceAnimation: this.options.middleLine?.lastPriceAnimation || 0,\n      lineType: this.options.middleLine?.lineType || 0\n    })\n\n    this.lowerSeries = chart.addSeries(LineSeries, {\n      color: this.options.lowerLine?.color || '#F44336',\n      lineStyle: this.options.lowerLine?.lineStyle || 0,\n      lineWidth: (this.options.lowerLine?.lineWidth || 2) as any,\n      visible: this.options.lowerLine?.lineVisible !== false,\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: this.options.lastValueVisible,\n      priceLineVisible: this.options.priceLineVisible,\n      priceLineSource: this.options.priceLineSource as any,\n      priceLineWidth: this.options.priceLineWidth as any,\n      priceLineColor: this.options.priceLineColor,\n      priceLineStyle: this.options.priceLineStyle as any,\n      baseLineVisible: this.options.baseLineVisible,\n      baseLineWidth: this.options.baseLineWidth as any,\n      baseLineColor: this.options.baseLineColor,\n      baseLineStyle: this.options.baseLineStyle as any,\n      priceFormat: this.options.priceFormat,\n      crosshairMarkerVisible: this.options.lowerLine?.crosshairMarkerVisible !== false,\n      crosshairMarkerRadius: this.options.lowerLine?.crosshairMarkerRadius || 4,\n      crosshairMarkerBorderColor: this.options.lowerLine?.crosshairMarkerBorderColor || '',\n      crosshairMarkerBackgroundColor: this.options.lowerLine?.crosshairMarkerBackgroundColor || '',\n      crosshairMarkerBorderWidth: this.options.lowerLine?.crosshairMarkerBorderWidth || 2,\n      lastPriceAnimation: this.options.lowerLine?.lastPriceAnimation || 0,\n      lineType: this.options.lowerLine?.lineType || 0\n    })\n\n    // Attach the primitive to the middle series for rendering\n    this.middleSeries.attachPrimitive(this)\n\n    // Z-index is handled through the primitive system\n    // The primitive's zIndex() method will return the configured Z-index\n    if (this.options.zIndex !== undefined) {\n    }\n  }\n\n  // Getter for options\n  getOptions(): BandSeriesOptions {\n    return this.options\n  }\n\n  // Getter for data\n  getData(): BandData[] {\n    return this.data\n  }\n\n  // Getter for chart\n  getChart(): IChartApi {\n    return this.chart\n  }\n\n  // Getter for series\n  getUpperSeries(): ISeriesApi<'Line'> {\n    return this.upperSeries\n  }\n\n  getMiddleSeries(): ISeriesApi<'Line'> {\n    return this.middleSeries\n  }\n\n  getLowerSeries(): ISeriesApi<'Line'> {\n    return this.lowerSeries\n  }\n\n  // ISeriesPrimitive implementation\n  attached(param: SeriesAttachedParameter<Time>): void {\n    // Primitive is attached to the series\n  }\n\n  detached(): void {\n    // Primitive is detached from the series\n  }\n\n  updateAllViews(): void {\n    this._paneViews.forEach(pv => pv.update())\n  }\n\n  paneViews(): IPrimitivePaneView[] {\n    return this._paneViews\n  }\n\n  setData(data: BandData[]): void {\n    this.data = data\n\n    // Extract individual series data\n    const upperData: LineData[] = data.map(item => ({\n      time: item.time,\n      value: item.upper\n    }))\n\n    const middleData: LineData[] = data.map(item => ({\n      time: item.time,\n      value: item.middle\n    }))\n\n    const lowerData: LineData[] = data.map(item => ({\n      time: item.time,\n      value: item.lower\n    }))\n\n    // Set data for each series\n    this.upperSeries.setData(upperData)\n    this.middleSeries.setData(middleData)\n    this.lowerSeries.setData(lowerData)\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  update(data: BandData): void {\n    // Update individual series\n    this.upperSeries.update({time: data.time, value: data.upper})\n    this.middleSeries.update({time: data.time, value: data.middle})\n    this.lowerSeries.update({time: data.time, value: data.lower})\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  setVisible(visible: boolean): void {\n    this.upperSeries.applyOptions({visible})\n    this.middleSeries.applyOptions({visible})\n    this.lowerSeries.applyOptions({visible})\n  }\n\n  setOptions(options: Partial<BandSeriesOptions>): void {\n    this.options = {...this.options, ...options}\n\n    // Z-index updates are handled through the primitive system\n    if (options.zIndex !== undefined) {\n    }\n\n    // Update line series options\n    if (options.upperLine !== undefined) {\n      this.upperSeries.applyOptions({\n        color: options.upperLine.color,\n        lineStyle: options.upperLine.lineStyle,\n        lineWidth: options.upperLine.lineWidth as any,\n        visible: options.upperLine.lineVisible,\n        lineType: options.upperLine.lineType,\n        crosshairMarkerVisible: options.upperLine.crosshairMarkerVisible,\n        crosshairMarkerRadius: options.upperLine.crosshairMarkerRadius,\n        crosshairMarkerBorderColor: options.upperLine.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor: options.upperLine.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth: options.upperLine.crosshairMarkerBorderWidth,\n        lastPriceAnimation: options.upperLine.lastPriceAnimation\n      })\n    }\n\n    if (options.middleLine !== undefined) {\n      this.middleSeries.applyOptions({\n        color: options.middleLine.color,\n        lineStyle: options.middleLine.lineStyle,\n        lineWidth: options.middleLine.lineWidth as any,\n        visible: options.middleLine.lineVisible,\n        lineType: options.middleLine.lineType,\n        crosshairMarkerVisible: options.middleLine.crosshairMarkerVisible,\n        crosshairMarkerRadius: options.middleLine.crosshairMarkerRadius,\n        crosshairMarkerBorderColor: options.middleLine.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor: options.middleLine.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth: options.middleLine.crosshairMarkerBorderWidth,\n        lastPriceAnimation: options.middleLine.lastPriceAnimation\n      })\n    }\n\n    if (options.lowerLine !== undefined) {\n      this.lowerSeries.applyOptions({\n        color: options.lowerLine.color,\n        lineStyle: options.lowerLine.lineStyle,\n        lineWidth: options.lowerLine.lineWidth as any,\n        visible: options.lowerLine.lineVisible,\n        lineType: options.lowerLine.lineType,\n        crosshairMarkerVisible: options.lowerLine.crosshairMarkerVisible,\n        crosshairMarkerRadius: options.lowerLine.crosshairMarkerRadius,\n        crosshairMarkerBorderColor: options.lowerLine.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor: options.lowerLine.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth: options.lowerLine.crosshairMarkerBorderWidth,\n        lastPriceAnimation: options.lowerLine.lastPriceAnimation\n      })\n    }\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  remove(): void {\n    this.chart.removeSeries(this.upperSeries)\n    this.chart.removeSeries(this.middleSeries)\n    this.chart.removeSeries(this.lowerSeries)\n  }\n\n  to_frontend_config(): any {\n    return {\n      type: 'band',\n      data: this.data,\n      options: this.options\n    }\n  }\n}\n\n// Plugin factory function\nexport function createBandSeries(\n  chart: IChartApi,\n  options: Partial<BandSeriesOptions> = {}\n): BandSeries {\n  return new BandSeries(chart, options)\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/series/gradientRibbonSeriesPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'scope' is defined but never used. Allowed unused args must match /^_/u.","line":150,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":71},{"ruleId":"no-unused-vars","severity":1,"message":"'scope' is defined but never used. Allowed unused args must match /^_/u.","line":234,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":234,"endColumn":71},{"ruleId":"no-unused-vars","severity":1,"message":"'series' is defined but never used. Allowed unused args must match /^_/u.","line":318,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":318,"endColumn":54},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":454,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":454,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[13197,13248],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ISeriesPrimitive,\n  IPrimitivePaneView,\n  IPrimitivePaneRenderer,\n  IChartApi,\n  ISeriesApi,\n  LineSeries,\n  Time,\n  UTCTimestamp\n} from 'lightweight-charts'\n\nexport interface GradientRibbonData {\n  time: string | number\n  upper: number\n  lower: number\n  fillColor?: string\n}\n\nexport interface GradientRibbonOptions {\n  upperLine: {\n    color: string\n    lineWidth: number\n    lineStyle: number\n    visible: boolean\n  }\n  lowerLine: {\n    color: string\n    lineWidth: number\n    lineStyle: number\n    visible: boolean\n  }\n  fill: string\n  fillVisible: boolean\n  gradientStartColor: string\n  gradientEndColor: string\n  normalizeGradients: boolean\n  priceScaleId: string\n  visible: boolean\n  zIndex: number\n}\n\ninterface GradientRibbonRenderData {\n  x: number | null\n  upperY: number | null\n  lowerY: number | null\n  fillColor: string\n}\n\ninterface GradientRibbonViewData {\n  items: GradientRibbonRenderData[]\n  visibleRange: {from: number; to: number} | null\n  options: GradientRibbonOptions\n  data: {\n    chartWidth: number\n    barWidth: number\n    timeScale: any\n    priceScale: any\n  }\n}\n\nfunction interpolateColor(startColor: string, endColor: string, factor: number): string {\n  // Clamp factor to 0-1 range\n  factor = Math.max(0, Math.min(1, factor))\n\n  // Parse hex colors\n  const parseHex = (hex: string) => {\n    const clean = hex.replace('#', '')\n    return {\n      r: parseInt(clean.substr(0, 2), 16),\n      g: parseInt(clean.substr(2, 2), 16),\n      b: parseInt(clean.substr(4, 2), 16)\n    }\n  }\n\n  try {\n    const start = parseHex(startColor)\n    const end = parseHex(endColor)\n\n    const r = Math.round(start.r + (end.r - start.r) * factor)\n    const g = Math.round(start.g + (end.g - start.g) * factor)\n    const b = Math.round(start.b + (end.b - start.b) * factor)\n\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`\n  } catch {\n    return startColor\n  }\n}\n\nfunction parseTime(time: string | number): UTCTimestamp {\n  try {\n    if (typeof time === 'number') {\n      if (time > 1000000000000) {\n        return Math.floor(time / 1000) as UTCTimestamp\n      }\n      return Math.floor(time) as UTCTimestamp\n    }\n\n    if (typeof time === 'string') {\n      const timestamp = parseInt(time, 10)\n      if (!isNaN(timestamp)) {\n        if (timestamp > 1000000000000) {\n          return Math.floor(timestamp / 1000) as UTCTimestamp\n        }\n        return Math.floor(timestamp) as UTCTimestamp\n      }\n\n      const date = new Date(time)\n      if (isNaN(date.getTime())) {\n        return 0 as UTCTimestamp\n      }\n      return Math.floor(date.getTime() / 1000) as UTCTimestamp\n    }\n\n    return 0 as UTCTimestamp\n  } catch {\n    return 0 as UTCTimestamp\n  }\n}\n\nclass GradientRibbonPrimitivePaneRenderer implements IPrimitivePaneRenderer {\n  _viewData: GradientRibbonViewData\n  constructor(data: GradientRibbonViewData) {\n    this._viewData = data\n  }\n  draw(target: any) {\n    if (!this._viewData.options.upperLine.visible && !this._viewData.options.lowerLine.visible) return\n\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      if (!ctx) return\n\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n      this._drawExtendedLines(ctx, scope)\n    })\n  }\n  drawBackground(target: any) {\n    if (!this._viewData.options.fillVisible) return\n\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      if (!ctx) {\n        return\n      }\n\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n      this._drawGradientFills(ctx, scope)\n    })\n  }\n\n  private _drawGradientFills(ctx: CanvasRenderingContext2D, scope: any): void {\n    const {items, visibleRange} = this._viewData\n\n    if (items.length === 0 || visibleRange === null || visibleRange.to <= visibleRange.from) {\n      return\n    }\n\n    // First draw a smooth gradient path between data points\n    this._drawSmoothGradientPath(ctx, items, visibleRange)\n  }\n\n  private _drawSmoothGradientPath(\n    ctx: CanvasRenderingContext2D,\n    items: GradientRibbonRenderData[],\n    visibleRange: {from: number; to: number}\n  ): void {\n    const validItems = []\n    const searchStart = Math.max(0, visibleRange.from - 1)\n    const searchEnd = Math.min(items.length, visibleRange.to + 1)\n\n    for (let i = searchStart; i < searchEnd; i++) {\n      const item = items[i]\n      if (this._isValidCoordinates(item)) {\n        validItems.push(item)\n      }\n    }\n\n    if (validItems.length < 1) {\n      return\n    }\n\n    const barWidth = this._viewData.data.barWidth || 6\n    const halfBarWidth = barWidth / 2\n\n    if (validItems.length >= 2) {\n      ctx.beginPath()\n\n      const firstItem = validItems[0]\n      const lastItem = validItems[validItems.length - 1]\n\n      const fillStartX = firstItem.x! - halfBarWidth - 50\n      const fillEndX = lastItem.x! + halfBarWidth + 50\n\n      ctx.moveTo(fillStartX, firstItem.upperY!)\n\n      for (let i = 0; i < validItems.length; i++) {\n        ctx.lineTo(validItems[i].x!, validItems[i].upperY!)\n      }\n\n      ctx.lineTo(fillEndX, lastItem.upperY!)\n      ctx.lineTo(fillEndX, lastItem.lowerY!)\n\n      for (let i = validItems.length - 1; i >= 0; i--) {\n        ctx.lineTo(validItems[i].x!, validItems[i].lowerY!)\n      }\n\n      ctx.lineTo(fillStartX, firstItem.lowerY!)\n      ctx.closePath()\n\n      const gradient = ctx.createLinearGradient(fillStartX, 0, fillEndX, 0)\n      const sortedItems = [...validItems].sort((a, b) => a.x! - b.x!)\n\n      for (let i = 0; i < sortedItems.length; i++) {\n        const item = sortedItems[i]\n        const position = (item.x! - fillStartX) / (fillEndX - fillStartX)\n        const clampedPosition = Math.max(0, Math.min(1, position))\n        gradient.addColorStop(clampedPosition, item.fillColor)\n      }\n\n      if (sortedItems.length > 0) {\n        gradient.addColorStop(0, sortedItems[0].fillColor)\n        gradient.addColorStop(1, sortedItems[sortedItems.length - 1].fillColor)\n      }\n\n      ctx.fillStyle = gradient\n      ctx.fill()\n    } else if (validItems.length === 1) {\n      const item = validItems[0]\n      const singleStartX = item.x! - halfBarWidth - 50\n      ctx.fillStyle = item.fillColor\n      ctx.fillRect(singleStartX, Math.min(item.upperY!, item.lowerY!), barWidth + 100, Math.abs(item.upperY! - item.lowerY!))\n    }\n  }\n\n  private _drawExtendedLines(ctx: CanvasRenderingContext2D, scope: any): void {\n    const {items, visibleRange, options} = this._viewData\n\n    if (items.length === 0 || visibleRange === null || visibleRange.to <= visibleRange.from) {\n      return\n    }\n\n    const validItems = []\n    const searchStart = Math.max(0, visibleRange.from - 1)\n    const searchEnd = Math.min(items.length, visibleRange.to + 1)\n\n    for (let i = searchStart; i < searchEnd; i++) {\n      const item = items[i]\n      if (this._isValidCoordinates(item)) {\n        validItems.push(item)\n      }\n    }\n\n    if (validItems.length === 0) return\n\n    const barWidth = this._viewData.data.barWidth || 6\n    const halfBarWidth = barWidth / 2\n\n    const firstItem = validItems[0]\n    const lastItem = validItems[validItems.length - 1]\n\n    const lineStartX = firstItem.x! - halfBarWidth - 50\n    const lineEndX = lastItem.x! + halfBarWidth + 50\n\n    if (options.upperLine.visible) {\n      ctx.beginPath()\n      ctx.moveTo(lineStartX, firstItem.upperY!)\n\n      for (const item of validItems) {\n        ctx.lineTo(item.x!, item.upperY!)\n      }\n\n      ctx.lineTo(lineEndX, lastItem.upperY!)\n      ctx.strokeStyle = options.upperLine.color\n      ctx.lineWidth = options.upperLine.lineWidth\n      ctx.stroke()\n    }\n\n    if (options.lowerLine.visible) {\n      ctx.beginPath()\n      ctx.moveTo(lineStartX, firstItem.lowerY!)\n\n      for (const item of validItems) {\n        ctx.lineTo(item.x!, item.lowerY!)\n      }\n\n      ctx.lineTo(lineEndX, lastItem.lowerY!)\n      ctx.strokeStyle = options.lowerLine.color\n      ctx.lineWidth = options.lowerLine.lineWidth\n      ctx.stroke()\n    }\n  }\n\n  private _isValidCoordinates(item: GradientRibbonRenderData): boolean {\n    return item.x !== null && item.upperY !== null && item.lowerY !== null\n  }\n}\n\nclass GradientRibbonPrimitivePaneView implements IPrimitivePaneView {\n  _renderer: GradientRibbonPrimitivePaneRenderer\n  _data: GradientRibbonViewData\n  _source: GradientRibbonSeries\n\n  constructor(source: GradientRibbonSeries) {\n    this._source = source\n    this._data = {\n      items: [],\n      visibleRange: null,\n      options: source._options,\n      data: {\n        chartWidth: 800,\n        barWidth: 6,\n        timeScale: null,\n        priceScale: null\n      }\n    }\n    this._renderer = new GradientRibbonPrimitivePaneRenderer(this._data)\n  }\n\n  update(chart: IChartApi, series: ISeriesApi<'Line'>) {\n    const timeScale = chart.timeScale()\n    const upperLineSeries = this._source._upperLineSeries\n    const lowerLineSeries = this._source._lowerLineSeries\n\n\n    if (!timeScale || !upperLineSeries || !lowerLineSeries) {\n      return\n    }\n\n    const chartElement = (chart as any)._chartWidget?._element\n    this._data.data.timeScale = timeScale\n    this._data.data.priceScale = upperLineSeries\n    this._data.data.chartWidth = chartElement?.clientWidth || 800\n\n    try {\n      let barSpacing = 6 // default\n\n      if (timeScale && typeof timeScale.options === 'function') {\n        const options = timeScale.options()\n        barSpacing = options.barSpacing || 6\n      } else {\n        // Fallback to chart model approach\n        const chartModel = (chart as any)._model\n        if (chartModel && chartModel.timeScale) {\n          const chartTimeScale = chartModel.timeScale\n          if (typeof chartTimeScale.options === 'function') {\n            const options = chartTimeScale.options()\n            barSpacing = options.barSpacing || 6\n          } else if (typeof chartTimeScale.barSpacing === 'function') {\n            barSpacing = chartTimeScale.barSpacing() || 6\n          }\n        }\n      }\n\n      this._data.data.barWidth = Math.max(6, barSpacing)\n    } catch (error) {\n      this._data.data.barWidth = 10 // fallback\n    }\n\n    const items = this._source.getProcessedData()\n    const convertedItems = this._batchConvertCoordinates(items, timeScale, upperLineSeries, lowerLineSeries)\n\n    this._data.items = convertedItems\n    this._data.visibleRange = this._calculateVisibleRange(convertedItems)\n  }\n\n  private _batchConvertCoordinates(\n    items: GradientRibbonData[],\n    timeScale: any,\n    upperSeries: ISeriesApi<'Line'>,\n    lowerSeries: ISeriesApi<'Line'>\n  ): GradientRibbonRenderData[] {\n    return items.map(item => {\n      const time = parseTime(item.time)\n      const x = timeScale.timeToCoordinate(time)\n      const upperY = upperSeries.priceToCoordinate(item.upper)\n      const lowerY = lowerSeries.priceToCoordinate(item.lower)\n\n      return {\n        x,\n        upperY,\n        lowerY,\n        fillColor: item.fillColor || this._data.options.fill\n      }\n    })\n  }\n\n  private _calculateVisibleRange(items: GradientRibbonRenderData[]): {from: number; to: number} | null {\n    if (items.length === 0) return null\n\n    let from = 0\n    let to = items.length\n\n    // Find visible range based on x coordinates\n    for (let i = 0; i < items.length; i++) {\n      if (items[i].x !== null && items[i].x! >= 0) {\n        from = i\n        break\n      }\n    }\n\n    for (let i = items.length - 1; i >= 0; i--) {\n      if (items[i].x !== null) {\n        to = i + 1\n        break\n      }\n    }\n\n    return {from, to}\n  }\n\n  renderer() {\n    return this._renderer\n  }\n}\n\nexport class GradientRibbonSeries implements ISeriesPrimitive<Time> {\n  private _chart: IChartApi\n  public _options: GradientRibbonOptions\n  private _data: GradientRibbonData[] = []\n  private _paneViews: GradientRibbonPrimitivePaneView[]\n  public _upperLineSeries: ISeriesApi<'Line'> | null = null\n  public _lowerLineSeries: ISeriesApi<'Line'> | null = null\n  private _source: any\n\n  constructor(chart: IChartApi, options: GradientRibbonOptions) {\n    this._chart = chart\n    this._options = options\n    this._paneViews = [new GradientRibbonPrimitivePaneView(this)]\n\n    // Create hidden line series for coordinate conversion\n    this._createLineSeries()\n  }\n\n  private _createLineSeries() {\n    try {\n      this._upperLineSeries = this._chart.addSeries(LineSeries, {\n        color: 'transparent', // Make line transparent but keep series visible for price scale\n        lineWidth: 0 as any, // Zero width so line is invisible\n        lineStyle: this._options.upperLine.lineStyle,\n        visible: true, // Keep visible for price scale calculation\n        priceScaleId: this._options.priceScaleId || 'right'\n      })\n\n      this._lowerLineSeries = this._chart.addSeries(LineSeries, {\n        color: 'transparent', // Make line transparent but keep series visible for price scale\n        lineWidth: 0 as any, // Zero width so line is invisible\n        lineStyle: this._options.lowerLine.lineStyle,\n        visible: true, // Keep visible for price scale calculation\n        priceScaleId: this._options.priceScaleId || 'right'\n      })\n\n      // Attach primitive to upper line series\n      this._upperLineSeries.attachPrimitive(this)\n    } catch (error) {\n      console.error('Error creating line series:', error)\n    }\n  }\n\n  getProcessedData(): GradientRibbonData[] {\n    const processed = this._data.map(item => ({\n      ...item,\n      fillColor: item.fillColor || this._getColorForValue(item.upper, item.lower)\n    }))\n\n    return processed\n  }\n\n  private _getColorForValue(upper: number, lower: number): string {\n    // Always use gradient colors - the normalizeGradients is a backend setting\n    // Calculate gradient factor based on the spread (upper - lower)\n    // Wider spreads get more intense colors\n    const spread = Math.abs(upper - lower)\n    const maxSpread = Math.max(...this._data.map(item => Math.abs(item.upper - item.lower)))\n    const factor = maxSpread > 0 ? Math.min(spread / maxSpread, 1) : 0\n\n    return interpolateColor(this._options.gradientStartColor, this._options.gradientEndColor, factor)\n  }\n\n  private _createExtendedLineData(data: GradientRibbonData[], field: 'upper' | 'lower'): Array<{time: UTCTimestamp, value: number}> {\n    // Simply return the original data - the line extension will be handled\n    // by using a different approach since time-based extension doesn't align well\n    // with pixel-based bar width calculations\n    return data.map(item => ({\n      time: parseTime(item.time),\n      value: item[field]\n    }))\n  }\n\n  setData(data: GradientRibbonData[]) {\n    this._data = data\n\n    if (this._upperLineSeries && this._lowerLineSeries) {\n      // Create extended line data to match fill boundaries\n      const extendedUpperData = this._createExtendedLineData(data, 'upper')\n      const extendedLowerData = this._createExtendedLineData(data, 'lower')\n\n      this._upperLineSeries.setData(extendedUpperData)\n      this._lowerLineSeries.setData(extendedLowerData)\n\n      // Force update all views after setting data\n      this.updateAllViews()\n    }\n  }\n\n  updateData(data: GradientRibbonData[]) {\n    this.setData(data)\n  }\n\n  applyOptions(options: Partial<GradientRibbonOptions>) {\n    this._options = {...this._options, ...options}\n\n    if (this._upperLineSeries && options.upperLine) {\n      this._upperLineSeries.applyOptions({\n        ...options.upperLine,\n        lineWidth: options.upperLine.lineWidth as any\n      })\n    }\n    if (this._lowerLineSeries && options.lowerLine) {\n      this._lowerLineSeries.applyOptions({\n        ...options.lowerLine,\n        lineWidth: options.lowerLine.lineWidth as any\n      })\n    }\n  }\n\n  destroy() {\n    if (this._upperLineSeries) {\n      this._chart.removeSeries(this._upperLineSeries)\n    }\n    if (this._lowerLineSeries) {\n      this._chart.removeSeries(this._lowerLineSeries)\n    }\n  }\n\n  paneViews(): readonly IPrimitivePaneView[] {\n    return this._paneViews\n  }\n\n  updateAllViews() {\n    this._paneViews.forEach(paneView => {\n      if (this._upperLineSeries) {\n        paneView.update(this._chart, this._upperLineSeries)\n      }\n    })\n  }\n\n  priceAxisViews() {\n    return []\n  }\n\n  timeAxisViews() {\n    return []\n  }\n\n  hitTest(): null {\n    return null\n  }\n}\n\nexport function createGradientRibbonSeries(chart: IChartApi, options: GradientRibbonOptions): GradientRibbonSeries {\n  return new GradientRibbonSeries(chart, options)\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/series/ribbonSeriesPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'param' is defined but never used. Allowed unused args must match /^_/u.","line":317,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":317,"endColumn":48},{"ruleId":"no-unused-vars","severity":1,"message":"'chart' is defined but never used. Allowed unused args must match /^_/u.","line":424,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":424,"endColumn":56},{"ruleId":"no-unused-vars","severity":1,"message":"'chart' is defined but never used. Allowed unused args must match /^_/u.","line":425,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":425,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IChartApi,\n  ISeriesApi,\n  LineData,\n  Time,\n  LineSeries,\n  ISeriesPrimitive,\n  SeriesAttachedParameter,\n  IPrimitivePaneView,\n  IPrimitivePaneRenderer,\n  Coordinate\n} from 'lightweight-charts'\n\n// Ribbon data interface\nexport interface RibbonData extends LineData {\n  upper: number\n  lower: number\n}\n\n// Line style options interface\nexport interface LineStyleOptions {\n  color?: string\n  lineStyle?: number\n  lineWidth?: number\n  lineVisible?: boolean\n  lineType?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  lastPriceAnimation?: number\n}\n\n// Ribbon series options\nexport interface RibbonSeriesOptions {\n  // Z-index for proper layering\n  zIndex?: number\n\n  // Line style options\n  upperLine?: LineStyleOptions\n  lowerLine?: LineStyleOptions\n\n  // Fill options\n  fill: string\n  fillVisible: boolean\n\n  // Base options\n  visible: boolean\n  priceScaleId: string\n  lastValueVisible: boolean\n  priceLineVisible: boolean\n  priceLineSource: string\n  priceLineWidth: number\n  priceLineColor: string\n  priceLineStyle: number\n  baseLineVisible: boolean\n  baseLineWidth: number\n  baseLineColor: string\n  baseLineStyle: string\n  priceFormat: any\n}\n\n// Default options\nconst defaultOptions: RibbonSeriesOptions = {\n  // Line style options\n  upperLine: {\n    color: '#4CAF50',\n    lineStyle: 0, // SOLID\n    lineWidth: 2,\n    lineVisible: true,\n    lineType: 0, // SIMPLE\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBackgroundColor: '',\n    crosshairMarkerBorderWidth: 2,\n    lastPriceAnimation: 0 // DISABLED\n  },\n  lowerLine: {\n    color: '#F44336',\n    lineStyle: 0, // SOLID\n    lineWidth: 2,\n    lineVisible: true,\n    lineType: 0, // SIMPLE\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBackgroundColor: '',\n    crosshairMarkerBorderWidth: 2,\n    lastPriceAnimation: 0 // DISABLED\n  },\n\n  // Fill options\n  fill: 'rgba(76, 175, 80, 0.1)',\n  fillVisible: true,\n\n  // Base options\n  visible: true,\n  priceScaleId: 'right',\n  lastValueVisible: false,\n  priceLineVisible: true,\n  priceLineSource: 'lastBar',\n  priceLineWidth: 1,\n  priceLineColor: '#2196F3',\n  priceLineStyle: 2, // DASHED\n  baseLineVisible: false,\n  baseLineWidth: 1,\n  baseLineColor: '#FF9800',\n  baseLineStyle: 'solid',\n  priceFormat: {type: 'price', precision: 2}\n}\n\n// Ribbon renderer data interface\ninterface RibbonRendererData {\n  x: Coordinate | number\n  upper: Coordinate | number\n  lower: Coordinate | number\n}\n\n// Ribbon view data interface\ninterface RibbonViewData {\n  data: RibbonRendererData[]\n  options: RibbonSeriesOptions\n}\n\n// Ribbon primitive pane renderer\nclass RibbonPrimitivePaneRenderer implements IPrimitivePaneRenderer {\n  _viewData: RibbonViewData\n\n  constructor(data: RibbonViewData) {\n    this._viewData = data\n  }\n\n  draw() {}\n\n  drawBackground(target: any) {\n    const points: RibbonRendererData[] = this._viewData.data\n\n    if (points.length === 0) {\n      return\n    }\n\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n\n      // Draw fill area between upper and lower bands only if enabled\n      if (this._viewData.options.fillVisible) {\n        ctx.fillStyle = this._viewData.options.fill\n        ctx.beginPath()\n\n        // Draw upper line forward\n        ctx.moveTo(points[0].x, points[0].upper)\n        for (const point of points) {\n          if (point.upper !== null && point.lower !== null) {\n            ctx.lineTo(point.x, point.upper)\n          }\n        }\n\n        // Draw lower line backward\n        for (let i = points.length - 1; i >= 0; i--) {\n          const point = points[i]\n          if (point.upper !== null && point.lower !== null) {\n            ctx.lineTo(point.x, point.lower)\n          }\n        }\n\n        ctx.closePath()\n        ctx.fill()\n      } else {\n      }\n    })\n  }\n}\n\n// Ribbon primitive pane view\nclass RibbonPrimitivePaneView implements IPrimitivePaneView {\n  _source: RibbonSeries\n  _data: RibbonViewData\n\n  constructor(source: RibbonSeries) {\n    this._source = source\n    this._data = {\n      data: [],\n      options: this._source.getOptions()\n    }\n  }\n\n  update() {\n    const timeScale = this._source.getChart().timeScale()\n\n    // Get the actual rendered coordinates from the series\n    // This ensures compatibility with all line types (SIMPLE, STEPPED, CURVED)\n    this._data.data = this._source.getData().map(d => {\n      return {\n        x: timeScale.timeToCoordinate(d.time) ?? -100,\n        // Use the series' actual rendered coordinates for proper line type support\n        upper: this._source.getUpperSeries().priceToCoordinate(d.upper) ?? -100,\n        lower: this._source.getLowerSeries().priceToCoordinate(d.lower) ?? -100\n      }\n    })\n  }\n\n  renderer() {\n    return new RibbonPrimitivePaneRenderer(this._data)\n  }\n\n  // Z-index support: Return the Z-index for proper layering\n  zIndex(): number {\n    const sourceZIndex = this._source.getOptions().zIndex\n    // Validate Z-index is a positive number\n    if (typeof sourceZIndex === 'number' && sourceZIndex >= 0) {\n      return sourceZIndex\n    }\n    // Return default Z-index for ribbon series\n    return 100\n  }\n}\n\n// Ribbon series class - follows working band series pattern\nexport class RibbonSeries implements ISeriesPrimitive<Time> {\n  private chart: IChartApi\n  private upperSeries: ISeriesApi<'Line'>\n  private lowerSeries: ISeriesApi<'Line'>\n  private options: RibbonSeriesOptions\n  private data: RibbonData[] = []\n  private _paneViews: RibbonPrimitivePaneView[]\n\n  constructor(chart: IChartApi, options: Partial<RibbonSeriesOptions> = {}) {\n    this.chart = chart\n    this.options = {...defaultOptions, ...options}\n    this._paneViews = [new RibbonPrimitivePaneView(this)]\n\n    // Create the two line series (upper and lower)\n    this.upperSeries = chart.addSeries(LineSeries, {\n      color: this.options.upperLine?.color || '#4CAF50',\n      lineStyle: this.options.upperLine?.lineStyle || 0,\n      lineWidth: (this.options.upperLine?.lineWidth || 2) as any,\n      visible: this.options.upperLine?.lineVisible !== false,\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: this.options.lastValueVisible,\n      priceLineVisible: this.options.priceLineVisible,\n      priceLineSource: this.options.priceLineSource as any,\n      priceLineWidth: (this.options.priceLineWidth || 1) as any,\n      priceLineColor: this.options.priceLineColor,\n      priceLineStyle: (this.options.priceLineStyle || 2) as any,\n      baseLineVisible: this.options.baseLineVisible,\n      baseLineWidth: (this.options.baseLineWidth || 1) as any,\n      baseLineColor: this.options.baseLineColor,\n      baseLineStyle: (this.options.baseLineStyle || 'solid') as any,\n      priceFormat: this.options.priceFormat,\n      crosshairMarkerVisible: this.options.upperLine?.crosshairMarkerVisible !== false,\n      crosshairMarkerRadius: this.options.upperLine?.crosshairMarkerRadius || 4,\n      crosshairMarkerBorderColor: this.options.upperLine?.crosshairMarkerBorderColor || '',\n      crosshairMarkerBackgroundColor: this.options.upperLine?.crosshairMarkerBackgroundColor || '',\n      crosshairMarkerBorderWidth: this.options.upperLine?.crosshairMarkerBorderWidth || 2,\n      lastPriceAnimation: this.options.upperLine?.lastPriceAnimation || 0,\n      lineType: this.options.upperLine?.lineType || 0\n    })\n\n    this.lowerSeries = chart.addSeries(LineSeries, {\n      color: this.options.lowerLine?.color || '#F44336',\n      lineStyle: this.options.lowerLine?.lineStyle || 0,\n      lineWidth: (this.options.lowerLine?.lineWidth || 2) as any,\n      visible: this.options.lowerLine?.lineVisible !== false,\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: this.options.lastValueVisible,\n      priceLineVisible: this.options.priceLineVisible,\n      priceLineSource: this.options.priceLineSource as any,\n      priceLineWidth: (this.options.priceLineWidth || 1) as any,\n      priceLineColor: this.options.priceLineColor,\n      priceLineStyle: (this.options.priceLineStyle || 2) as any,\n      baseLineVisible: this.options.baseLineVisible,\n      baseLineWidth: (this.options.baseLineWidth || 1) as any,\n      baseLineColor: this.options.baseLineColor,\n      baseLineStyle: (this.options.baseLineStyle || 'solid') as any,\n      priceFormat: this.options.priceFormat,\n      crosshairMarkerVisible: this.options.lowerLine?.crosshairMarkerVisible !== false,\n      crosshairMarkerRadius: this.options.lowerLine?.crosshairMarkerRadius || 4,\n      crosshairMarkerBorderColor: this.options.lowerLine?.crosshairMarkerBorderColor || '',\n      crosshairMarkerBackgroundColor: this.options.lowerLine?.crosshairMarkerBackgroundColor || '',\n      crosshairMarkerBorderWidth: this.options.lowerLine?.crosshairMarkerBorderWidth || 2,\n      lastPriceAnimation: this.options.lowerLine?.lastPriceAnimation || 0,\n      lineType: this.options.lowerLine?.lineType || 0\n    })\n\n    // Attach the primitive to the upper series for rendering\n    this.upperSeries.attachPrimitive(this)\n  }\n\n  // Getter for options\n  getOptions(): RibbonSeriesOptions {\n    return this.options\n  }\n\n  // Getter for data\n  getData(): RibbonData[] {\n    return this.data\n  }\n\n  // Getter for chart\n  getChart(): IChartApi {\n    return this.chart\n  }\n\n  // Getter for series\n  getUpperSeries(): ISeriesApi<'Line'> {\n    return this.upperSeries\n  }\n\n  getLowerSeries(): ISeriesApi<'Line'> {\n    return this.lowerSeries\n  }\n\n  // ISeriesPrimitive implementation\n  attached(param: SeriesAttachedParameter<Time>): void {\n    // Primitive is attached to the series\n  }\n\n  detached(): void {\n    // Primitive is detached from the series\n  }\n\n  updateAllViews(): void {\n    this._paneViews.forEach(pv => pv.update())\n  }\n\n  paneViews(): IPrimitivePaneView[] {\n    return this._paneViews\n  }\n\n  setData(data: RibbonData[]): void {\n    this.data = data\n\n    // Extract individual series data\n    const upperData: LineData[] = data.map(item => ({\n      time: item.time,\n      value: item.upper\n    }))\n\n    const lowerData: LineData[] = data.map(item => ({\n      time: item.time,\n      value: item.lower\n    }))\n\n    // Set data for each series\n    this.upperSeries.setData(upperData)\n    this.lowerSeries.setData(lowerData)\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  update(data: RibbonData): void {\n    // Update individual series\n    this.upperSeries.update({time: data.time, value: data.upper})\n    this.lowerSeries.update({time: data.time, value: data.lower})\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  setVisible(visible: boolean): void {\n    this.upperSeries.applyOptions({visible})\n    this.lowerSeries.applyOptions({visible})\n  }\n\n  setOptions(options: Partial<RibbonSeriesOptions>): void {\n    this.options = {...this.options, ...options}\n\n    // Update line series options\n    if (options.upperLine !== undefined) {\n      this.upperSeries.applyOptions({\n        color: options.upperLine.color,\n        lineStyle: options.upperLine.lineStyle,\n        lineWidth: options.upperLine.lineWidth as any,\n        visible: options.upperLine.lineVisible,\n        lineType: options.upperLine.lineType,\n        crosshairMarkerVisible: options.upperLine.crosshairMarkerVisible,\n        crosshairMarkerRadius: options.upperLine.crosshairMarkerRadius,\n        crosshairMarkerBorderColor: options.upperLine.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor: options.upperLine.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth: options.upperLine.crosshairMarkerBorderWidth,\n        lastPriceAnimation: options.upperLine.lastPriceAnimation\n      })\n    }\n\n    if (options.lowerLine !== undefined) {\n      this.lowerSeries.applyOptions({\n        color: options.lowerLine.color,\n        lineStyle: options.lowerLine.lineStyle,\n        lineWidth: options.lowerLine.lineWidth as any,\n        visible: options.lowerLine.lineVisible,\n        lineType: 0, // Always force SIMPLE for fill compatibility\n        crosshairMarkerVisible: options.lowerLine.crosshairMarkerVisible,\n        crosshairMarkerRadius: options.lowerLine.crosshairMarkerRadius,\n        crosshairMarkerBorderColor: options.lowerLine.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor: options.lowerLine.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth: options.lowerLine.crosshairMarkerBorderWidth,\n        lastPriceAnimation: options.lowerLine.lastPriceAnimation\n      })\n    }\n\n    // Update the primitive view\n    this.updateAllViews()\n  }\n\n  remove(): void {\n    this.chart.removeSeries(this.upperSeries)\n    this.chart.removeSeries(this.lowerSeries)\n  }\n}\n\n// Plugin factory function\nexport function createRibbonSeries(\n  chart: IChartApi,\n  options: Partial<RibbonSeriesOptions> = {}\n): RibbonSeries {\n  return new RibbonSeries(chart, options)\n}\n\n// Plugin function\nexport function ribbonSeriesPlugin(): (chart: IChartApi) => void {\n  return (chart: IChartApi) => {\n    // Plugin initialization if needed\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/series/signalSeriesPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":167,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":167,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'chart' is defined but never used. Allowed unused args must match /^_/u.","line":323,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":323,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'param' is defined but never used. Allowed unused args must match /^_/u.","line":479,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":479,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Signal Series Plugin for Lightweight Charts\n *\n * This plugin renders background bands based on signal data, creating\n * vertical colored bands that span the entire chart height for specific\n * time periods.\n */\n\nimport {\n  IChartApi,\n  ISeriesApi,\n  ISeriesPrimitive,\n  SeriesAttachedParameter,\n  IPrimitivePaneView,\n  IPrimitivePaneRenderer,\n  Coordinate,\n  Time,\n  UTCTimestamp,\n  LineSeries,\n  PrimitivePaneViewZOrder\n} from 'lightweight-charts'\n\nexport interface SignalData {\n  time: string | number\n  value: number\n  color?: string\n}\n\nexport interface SignalOptions {\n  neutralColor?: string\n  signalColor?: string\n  alertColor?: string\n  visible: boolean\n}\n\nexport interface SignalSeriesConfig {\n  type: 'signal'\n  data: SignalData[]\n  options: SignalOptions\n  paneId?: number\n}\n\n// Signal renderer data interface\ninterface SignalRendererData {\n  x: Coordinate | number\n  y1: Coordinate | number\n  y2: Coordinate | number\n  color: string\n}\n\n// Signal view data interface\ninterface SignalViewData {\n  data: SignalRendererData[]\n  options: SignalOptions\n}\n\n/**\n * Check if a color is transparent or effectively invisible\n */\nfunction isTransparent(color: string): boolean {\n  if (!color) return true\n\n  // Check for fully transparent colors\n  if (color === 'transparent') return true\n\n  // Check for rgba with alpha = 0\n  if (color.startsWith('rgba(')) {\n    const match = color.match(/rgba\\([^)]+,\\s*([^)]+)\\)/)\n    if (match && parseFloat(match[1]) === 0) return true\n  }\n\n  // Check for hex with alpha = 00 (8-digit hex)\n  if (color.startsWith('#') && color.length === 9) {\n    const alpha = color.substring(7, 9)\n    if (alpha === '00') return true\n  }\n\n  // Check for hex with alpha = 00 (4-digit hex)\n  if (color.startsWith('#') && color.length === 5) {\n    const alpha = color.substring(4, 5)\n    if (alpha === '0') return true\n  }\n\n  return false\n}\n\n// Signal primitive pane renderer\nclass SignalPrimitivePaneRenderer implements IPrimitivePaneRenderer {\n  _viewData: SignalViewData\n\n  constructor(data: SignalViewData) {\n    this._viewData = data\n  }\n\n  draw(target: any) {\n    this.drawBackground(target)\n  }\n\n  drawBackground(target: any) {\n    const points: SignalRendererData[] = this._viewData.data\n\n    if (points.length === 0) {\n      return\n    }\n\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n\n      // Draw background bands - following TradingView's approach\n      for (let i = 0; i < points.length; i += 2) {\n        if (i + 1 < points.length) {\n          const startPoint = points[i]\n          const endPoint = points[i + 1]\n\n          // Skip rendering if color is transparent or effectively invisible\n          if (isTransparent(startPoint.color)) {\n            continue\n          }\n\n          // Use the color exactly as provided by the backend\n          const fillStyle = startPoint.color\n\n          ctx.fillStyle = fillStyle\n\n          // FIX: Ensure bands don't overlap by using exact coordinates\n          // Draw the background rectangle with precise boundaries to prevent color blending\n          const width = Math.max(1, endPoint.x - startPoint.x) // Use exact coordinate difference\n          const height = startPoint.y2 - startPoint.y1\n\n          ctx.fillRect(startPoint.x, startPoint.y1, width, height)\n        }\n      }\n    })\n  }\n}\n\n// Signal primitive pane view\nclass SignalPrimitivePaneView implements IPrimitivePaneView {\n  _source: SignalSeries\n  _data: SignalViewData\n\n  constructor(source: SignalSeries) {\n    this._source = source\n    this._data = {\n      data: [],\n      options: this._source.getOptions()\n    }\n  }\n\n  update() {\n    const timeScale = this._source.getChart().timeScale()\n    const priceScale = this._source.getChart().priceScale('left')\n\n    if (!timeScale || !priceScale) {\n      return\n    }\n\n    const bands = this._source.getBackgroundBands()\n\n    const renderData: SignalRendererData[] = []\n\n    // Get bar spacing to properly align with bars\n    const barSpacing = timeScale.options().barSpacing || 6\n    const halfBarSpacing = barSpacing / 2\n\n    bands.forEach((band, index) => {\n      const startX = timeScale.timeToCoordinate(band.startTime)\n      const endX = timeScale.timeToCoordinate(band.endTime)\n\n      // Handle cases where coordinates are null (outside visible range)\n      if (startX !== null && endX !== null) {\n        // Both coordinates are valid - adjust for bar alignment\n        const chartHeight = this._source.getChart().chartElement()?.clientHeight || 400\n\n        // FIX: Use proper full bar width calculation following TradingView guidelines\n        // Start: x - halfBarSpacing (bar start boundary)\n        // End: x + halfBarSpacing (bar end boundary)\n        // This ensures each band fills its complete space without gaps\n        const adjustedStartX = Math.floor(startX - halfBarSpacing)\n        const adjustedEndX = Math.floor(endX + halfBarSpacing)\n\n        renderData.push({\n          x: adjustedStartX,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n\n        renderData.push({\n          x: adjustedEndX,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n      } else if (startX !== null && endX === null) {\n        // Start is visible but end is outside - extend to chart edge\n        const chartHeight = this._source.getChart().chartElement()?.clientHeight || 400\n        const chartWidth = this._source.getChart().chartElement()?.clientWidth || 800\n\n        // Use proper full bar width calculation for start boundary\n        const adjustedStartX = Math.floor(startX - halfBarSpacing)\n\n        renderData.push({\n          x: adjustedStartX,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n\n        renderData.push({\n          x: chartWidth,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n      } else if (startX === null && endX !== null) {\n        // End is visible but start is outside - extend from chart edge\n        const chartHeight = this._source.getChart().chartElement()?.clientHeight || 400\n\n        // Use proper full bar width calculation for end boundary\n        const adjustedEndX = Math.floor(endX + halfBarSpacing)\n\n        renderData.push({\n          x: 0,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n\n        renderData.push({\n          x: adjustedEndX,\n          y1: 0,\n          y2: chartHeight,\n          color: band.color\n        })\n      } else {\n        // Both coordinates are null - band is completely outside visible range\n      }\n    })\n\n    this._data.data = renderData\n  }\n\n  renderer() {\n    return new SignalPrimitivePaneRenderer(this._data)\n  }\n\n  // Z-order support: Signal series renders at normal layer for visibility\n  zOrder(): PrimitivePaneViewZOrder {\n    return 'bottom' as PrimitivePaneViewZOrder\n  }\n}\n\n// Background band interface\ninterface BackgroundBand {\n  startTime: UTCTimestamp\n  endTime: UTCTimestamp\n  value: number | boolean\n  color: string\n}\n\n// Signal series class\nexport class SignalSeries implements ISeriesPrimitive<Time> {\n  private chart: IChartApi\n  private dummySeries: ISeriesApi<'Line'>\n  private options: SignalOptions\n  private signalData: SignalData[] = []\n  private backgroundBands: BackgroundBand[] = []\n  private _paneViews: SignalPrimitivePaneView[]\n  private paneId: number\n\n  constructor(chart: IChartApi, config: SignalSeriesConfig) {\n    this.chart = chart\n    this.options = config.options || {visible: true}\n    this.signalData = config.data || []\n    this.paneId = config.paneId || 0\n    this._paneViews = [new SignalPrimitivePaneView(this)]\n\n    // Create a dummy line series to attach the primitive to\n    this.dummySeries = chart.addSeries(\n      LineSeries,\n      {\n        color: 'transparent',\n        lineWidth: 0 as any,\n        visible: false, // Hide the dummy series completely\n        priceScaleId: 'right',\n        lastValueVisible: false, // Hide last value\n        priceLineVisible: false, // Hide price line\n        crosshairMarkerVisible: false, // Disable crosshair for dummy series\n        lineVisible: false // Hide the line itself\n      },\n      this.paneId\n    )\n\n    // Add some dummy data to ensure the time scale is properly initialized\n    if (this.signalData.length > 0) {\n      const dummyData = this.signalData.map(signal => ({\n        time: this.parseTime(signal.time),\n        value: 0\n      }))\n      this.dummySeries.setData(dummyData)\n    }\n\n    // Process signal data to create background bands\n    this.processSignalData()\n\n    // Attach the primitive to the dummy series for rendering\n    this.dummySeries.attachPrimitive(this)\n  }\n\n  /**\n   * Public method for setting signal data\n   */\n  public setSignals(signals: SignalData[]): void {\n    this.signalData = signals\n    this.processSignalData()\n  }\n\n  /**\n   * Public method for adding to chart (for testing compatibility)\n   */\n  public addToChart(chart: IChartApi): void {\n    // Already initialized in constructor, this is just for test compatibility\n  }\n\n  /**\n   * Process signal data to create background bands\n   */\n  private processSignalData(): void {\n    this.backgroundBands = []\n\n    if (this.signalData.length === 0) {\n      return\n    }\n\n    // Sort signals by time to ensure proper ordering\n    const sortedSignals = [...this.signalData].sort((a, b) => {\n      const timeA = this.parseTime(a.time)\n      const timeB = this.parseTime(b.time)\n      return timeA - timeB\n    })\n\n    // Process each signal separately - create one band per signal\n    for (let i = 0; i < sortedSignals.length; i++) {\n      const signal = sortedSignals[i]\n      const signalTime = this.parseTime(signal.time)\n\n      // Create a band for this signal\n      // Each signal gets its own band covering its individual time period\n      const band = {\n        value: signal.value,\n        startTime: signalTime,\n        endTime: signalTime, // Each band covers just its own signal time\n        individualColor: signal.color || this.getColorForValue(signal.value) || undefined\n      }\n\n      this.addBackgroundBand(band)\n    }\n  }\n\n  /**\n   * Add a background band\n   */\n  private addBackgroundBand(band: {\n    value: number | boolean\n    startTime: UTCTimestamp\n    endTime: UTCTimestamp\n    individualColor?: string\n  }): void {\n    // Use individual color if available, otherwise fall back to series-level colors\n    let color = band.individualColor\n    if (!color) {\n      const seriesColor = this.getColorForValue(band.value)\n      if (seriesColor) {\n        color = seriesColor\n      }\n    }\n\n    // Skip adding bands with no color or transparent colors\n    if (!color || isTransparent(color)) {\n      return\n    }\n\n    const backgroundBand = {\n      startTime: band.startTime,\n      endTime: band.endTime,\n      value: typeof band.value === 'boolean' ? (band.value ? 1 : 0) : band.value,\n      color: color\n    }\n\n    this.backgroundBands.push(backgroundBand)\n  }\n\n  /**\n   * Get color for a signal value\n   */\n  private getColorForValue(value: number | boolean): string | null {\n    // Handle boolean values\n    if (typeof value === 'boolean') {\n      if (value === true) {\n        return this.options.signalColor || null\n      } else {\n        // For false values, always return neutral color if available\n        return this.options.neutralColor || null\n      }\n    }\n\n    // Handle numeric values with range-based comparisons\n    if (value === 0) {\n      // For value 0, always return neutral color if available\n      return this.options.neutralColor || null\n    } else if (value > 0) {\n      // For positive values, use signal color\n      return this.options.signalColor || null\n    } else if (value < 0) {\n      // For negative values, try alertColor first, then fall back to signalColor if alertColor is not set\n      return this.options.alertColor || this.options.signalColor || null\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Parse time value to timestamp\n   * Handles both string dates and numeric timestamps\n   */\n  private parseTime(time: string | number): UTCTimestamp {\n    try {\n      // If it's already a number (Unix timestamp), convert to seconds if needed\n      if (typeof time === 'number') {\n        // If timestamp is in milliseconds, convert to seconds\n        if (time > 1000000000000) {\n          return Math.floor(time / 1000) as UTCTimestamp\n        }\n        return Math.floor(time) as UTCTimestamp\n      }\n\n      // If it's a string, try to parse as date\n      if (typeof time === 'string') {\n        // First try to parse as Unix timestamp string\n        const timestamp = parseInt(time, 10)\n        if (!isNaN(timestamp)) {\n          // It's a numeric string (Unix timestamp)\n          if (timestamp > 1000000000000) {\n            return Math.floor(timestamp / 1000) as UTCTimestamp\n          }\n          return Math.floor(timestamp) as UTCTimestamp\n        }\n\n        // Try to parse as date string\n        const date = new Date(time)\n        if (isNaN(date.getTime())) {\n          return 0 as UTCTimestamp\n        }\n        return Math.floor(date.getTime() / 1000) as UTCTimestamp\n      }\n\n      return 0 as UTCTimestamp\n    } catch (error) {\n      return 0 as UTCTimestamp\n    }\n  }\n\n  // Getter methods\n  getOptions(): SignalOptions {\n    return this.options\n  }\n\n  getChart(): IChartApi {\n    return this.chart\n  }\n\n  getBackgroundBands(): BackgroundBand[] {\n    return this.backgroundBands\n  }\n\n  // ISeriesPrimitive implementation\n  attached(param: SeriesAttachedParameter<Time>): void {\n    // Primitive is attached to the series\n  }\n\n  detached(): void {\n    // Primitive is detached from the series\n  }\n\n  updateAllViews(): void {\n    this._paneViews.forEach(pv => pv.update())\n  }\n\n  paneViews(): IPrimitivePaneView[] {\n    return this._paneViews\n  }\n\n  /**\n   * Update signal data and re-render\n   */\n  updateData(newData: SignalData[]): void {\n    this.signalData = newData\n    this.processSignalData()\n    this.updateAllViews()\n  }\n\n  /**\n   * Update options and re-render\n   */\n  updateOptions(newOptions: SignalOptions): void {\n    this.options = newOptions\n    this.processSignalData()\n    this.updateAllViews()\n  }\n\n  /**\n   * Set data (for compatibility with ISeriesApi interface)\n   */\n  setData(data: SignalData[]): void {\n    this.updateData(data)\n  }\n\n  /**\n   * Update single data point (for compatibility with ISeriesApi interface)\n   */\n  update(data: SignalData): void {\n    // For signal series, we need to update the entire dataset\n    const newData = [...this.signalData]\n    const existingIndex = newData.findIndex(item => item.time === data.time)\n\n    if (existingIndex >= 0) {\n      newData[existingIndex] = data\n    } else {\n      newData.push(data)\n    }\n\n    this.updateData(newData)\n  }\n\n  /**\n   * Apply options (for compatibility with ISeriesApi interface)\n   */\n  applyOptions(options: Partial<SignalOptions>): void {\n    this.updateOptions({...this.options, ...options})\n  }\n\n  /**\n   * Get price scale (for compatibility with ISeriesApi interface)\n   */\n  priceScale(): any {\n    return this.chart.priceScale('left')\n  }\n\n  /**\n   * Remove the series (for compatibility with ISeriesApi interface)\n   */\n  remove(): void {\n    this.destroy()\n  }\n\n  /**\n   * Destroy the plugin and clean up resources\n   */\n  destroy(): void {\n    try {\n      this.chart.removeSeries(this.dummySeries)\n    } catch (error) {\n      // Series already removed\n    }\n  }\n}\n\n/**\n * Factory function to create signal series plugin\n */\nexport function createSignalSeriesPlugin(\n  chart: IChartApi,\n  config: SignalSeriesConfig\n): SignalSeries {\n  return new SignalSeries(chart, config)\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/series/trendFillSeriesPlugin.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'hRatio' is defined but never used. Allowed unused args must match /^_/u.","line":239,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":239,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'vRatio' is defined but never used. Allowed unused args must match /^_/u.","line":240,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":240,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":530,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":530,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'series' is defined but never used. Allowed unused args must match /^_/u.","line":653,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":653,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":706,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":706,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'param' is defined but never used. Allowed unused args must match /^_/u.","line":826,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":826,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Trend Fill Series Plugin for Lightweight Charts\n *\n * This plugin renders trend lines with fill areas between trend line and base line,\n * creating a visual representation of trend direction and strength.\n *\n * Features:\n * - Dynamic baseline filling (similar to BaseLineSeries but with variable baseline)\n * - Band filling between trend line and base line\n * - Dynamic color changes based on trend direction\n * - Base line support for reference\n * - Optimized rendering using BaseLineSeries patterns\n */\n\nimport {\n  IChartApi,\n  ISeriesApi,\n  ISeriesPrimitive,\n  SeriesAttachedParameter,\n  IPrimitivePaneView,\n  IPrimitivePaneRenderer,\n  Time,\n  UTCTimestamp,\n  LineSeries\n} from 'lightweight-charts'\n\n// Data structure for trend fill series (matching Python snake_case fields)\nexport interface TrendFillData {\n  time: number | string\n  // Support both snake_case (Python) and camelCase (JavaScript) field names\n  base_line?: number | null\n  trend_line?: number | null\n  trend_direction?: number | null\n  baseLine?: number | null  // camelCase fallback\n  trendLine?: number | null  // camelCase fallback\n  trendDirection?: number | null  // camelCase fallback\n}\n\n// Options for trend fill series\nexport interface TrendFillOptions {\n  zIndex?: number\n  uptrendFillColor: string\n  downtrendFillColor: string\n  trendLine: {\n    color: string\n    lineWidth: 1 | 2 | 3 | 4\n    lineStyle: 0 | 1 | 2\n    visible: boolean\n  }\n  baseLine: {\n    color: string\n    lineWidth: 1 | 2 | 3 | 4\n    lineStyle: 0 | 1 | 2\n    visible: boolean\n  }\n  visible: boolean\n  priceScaleId?: string // Added for price scale ID\n}\n\n// Internal data structures for rendering (following BaseLineSeries pattern)\ninterface TrendFillItem {\n  time: UTCTimestamp\n  baseLine: number\n  trendLine: number\n  trendDirection: number\n  fillColor: string\n  lineColor: string\n  lineWidth: number\n  lineStyle: number\n}\n\n// Pre-converted coordinates for rendering (like BaseLineSeries)\ninterface TrendFillRenderData {\n  x: number | null\n  baseLineY: number | null\n  trendLineY: number | null\n  fillColor: string\n  lineColor: string\n  lineWidth: number\n  lineStyle: number\n  trendDirection: number\n}\n\n// Renderer data interface (following BaseLineSeries pattern)\ninterface TrendFillRendererData {\n  items: TrendFillRenderData[]\n  timeScale: any\n  priceScale: any\n  chartWidth: number\n  // BaseLineSeries-style data\n  lineWidth: number\n  lineStyle: number\n  visibleRange: {from: number; to: number} | null\n  barWidth: number\n}\n\n// View data interface\ninterface TrendFillViewData {\n  data: TrendFillRendererData\n  options: TrendFillOptions\n}\n\n/**\n * Parse time value to timestamp\n * Handles both string dates and numeric timestamps\n */\nfunction parseTime(time: string | number): UTCTimestamp {\n  try {\n    // If it's already a number (Unix timestamp), convert to seconds if needed\n    if (typeof time === 'number') {\n      // If timestamp is in milliseconds, convert to seconds\n      if (time > 1000000000000) {\n        return Math.floor(time / 1000) as UTCTimestamp\n      }\n      return Math.floor(time) as UTCTimestamp\n    }\n\n    // If it's a string, try to parse as date\n    if (typeof time === 'string') {\n      // First try to parse as Unix timestamp string\n      const timestamp = parseInt(time, 10)\n      if (!isNaN(timestamp)) {\n        // It's a numeric string (Unix timestamp)\n        if (timestamp > 1000000000000) {\n          return Math.floor(timestamp / 1000) as UTCTimestamp\n        }\n        return Math.floor(timestamp) as UTCTimestamp\n      }\n\n      // Try to parse as date string\n      const date = new Date(time)\n      if (isNaN(date.getTime())) {\n        return 0 as UTCTimestamp\n      }\n      return Math.floor(date.getTime() / 1000) as UTCTimestamp\n    }\n\n    return 0 as UTCTimestamp\n  } catch (error) {\n    return 0 as UTCTimestamp\n  }\n}\n\n// Optimized Trend Fill Pane Renderer (following BaseLineSeries pattern)\nclass TrendFillPrimitivePaneRenderer implements IPrimitivePaneRenderer {\n  _viewData: TrendFillViewData\n\n  constructor(data: TrendFillViewData) {\n    this._viewData = data\n  }\n\n  draw() {}\n\n  drawBackground(target: any) {\n    // Batch all rendering operations (following band series pattern)\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n      ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio)\n\n      // Save context state once\n      ctx.save()\n\n      // Draw all elements efficiently - fills in background, lines in foreground\n      this._drawTrendFills(ctx, scope)\n      this._drawTrendLines(ctx, scope) // Re-enabled with proper color handling\n\n      // Restore context state once\n      ctx.restore()\n    })\n  }\n\n  private _drawTrendFills(ctx: CanvasRenderingContext2D, scope: any): void {\n    const {items, visibleRange} = this._viewData.data\n\n    if (items.length === 0 || visibleRange === null) {\n      return\n    }\n\n    // Group consecutive items by trend direction and fill color to draw continuous fills\n    this._drawContinuousFills(ctx, items, visibleRange, scope.horizontalPixelRatio, scope.verticalPixelRatio)\n  }\n\n  private _drawTrendLines(ctx: CanvasRenderingContext2D, scope: any): void {\n    const {items, visibleRange, lineWidth, lineStyle} = this._viewData.data\n\n    if (items.length === 0 || visibleRange === null) return\n\n    // Set line style once (like BaseLineSeries)\n    ctx.lineCap = 'butt'\n    ctx.lineJoin = 'round'\n    ctx.lineWidth = lineWidth\n    this._setLineStyle(ctx, lineStyle)\n\n    // Group consecutive items by trend direction to draw continuous lines\n    this._drawContinuousTrendLines(ctx, items, visibleRange, scope.horizontalPixelRatio, scope.verticalPixelRatio)\n  }\n\n  private _drawContinuousFills(\n    ctx: CanvasRenderingContext2D,\n    items: TrendFillRenderData[],\n    visibleRange: {from: number; to: number},\n    hRatio: number,\n    vRatio: number\n  ): void {\n    if (visibleRange.to <= visibleRange.from) {\n      return\n    }\n\n    // Draw individual fills between consecutive points only\n    for (let i = visibleRange.from; i < visibleRange.to - 1; i++) {\n      const currentItem = items[i]\n      const nextItem = items[i + 1]\n\n      // Skip if either point has invalid coordinates\n      if (!this._isValidCoordinates(currentItem) || !this._isValidCoordinates(nextItem)) {\n        continue\n      }\n\n      // Only draw fill if both points have the same trend direction and fill color\n      if (currentItem.trendDirection === nextItem.trendDirection &&\n          currentItem.fillColor === nextItem.fillColor &&\n          currentItem.trendDirection !== 0) {\n\n        // Check if points are reasonably close (no huge gaps)\n        const xDistance = Math.abs(nextItem.x! - currentItem.x!)\n        const maxGap = 100 // Maximum pixel gap to consider \"consecutive\"\n\n        if (xDistance <= maxGap) {\n          this._drawFillBetweenTwoPoints(ctx, currentItem, nextItem, hRatio, vRatio)\n        }\n      }\n    }\n  }\n\n  private _drawFillBetweenTwoPoints(\n    ctx: CanvasRenderingContext2D,\n    point1: TrendFillRenderData,\n    point2: TrendFillRenderData,\n    hRatio: number,\n    vRatio: number\n  ): void {\n    ctx.fillStyle = point1.fillColor\n\n    // Create a trapezoid fill between the two points\n    ctx.beginPath()\n\n    // Start from point1's baseline\n    ctx.moveTo(point1.x!, point1.baseLineY!)\n\n    // Go to point2's baseline\n    ctx.lineTo(point2.x!, point2.baseLineY!)\n\n    // Go to point2's trend line\n    ctx.lineTo(point2.x!, point2.trendLineY!)\n\n    // Go to point1's trend line\n    ctx.lineTo(point1.x!, point1.trendLineY!)\n\n    // Close back to point1's baseline\n    ctx.closePath()\n    ctx.fill()\n  }\n\n  private _drawFillGroup(\n    ctx: CanvasRenderingContext2D,\n    group: TrendFillRenderData[],\n    hRatio: number,\n    vRatio: number,\n    fillColor: string\n  ): void {\n    if (group.length === 0) {\n      return\n    }\n\n    ctx.fillStyle = fillColor\n\n    // NOW THAT WE KNOW COORDINATES WORK: Create smooth continuous fills\n    if (group.length === 1) {\n      // Single point - draw a small rectangle fill\n      const item = group[0]\n      const x = item.x!\n      const baseLineY = item.baseLineY!\n      const trendLineY = item.trendLineY!\n\n      const rectX = Math.max(0, x - 1)\n      const rectY = Math.min(baseLineY, trendLineY)\n      const rectWidth = 2\n      const rectHeight = Math.abs(baseLineY - trendLineY)\n\n      ctx.fillRect(rectX, rectY, rectWidth, rectHeight)\n    } else {\n      // Multiple points - draw continuous fill area using path\n      ctx.beginPath()\n\n      // Start from the first point's baseline\n      const firstItem = group[0]\n      ctx.moveTo(firstItem.x!, firstItem.baseLineY!)\n\n      // Draw along the baseline to all points\n      for (let i = 1; i < group.length; i++) {\n        const item = group[i]\n        ctx.lineTo(item.x!, item.baseLineY!)\n      }\n\n      // Connect to the last point's trend line\n      const lastItem = group[group.length - 1]\n      ctx.lineTo(lastItem.x!, lastItem.trendLineY!)\n\n      // Draw along the trend line back to start (reverse order)\n      for (let i = group.length - 2; i >= 0; i--) {\n        const item = group[i]\n        ctx.lineTo(item.x!, item.trendLineY!)\n      }\n\n      // Connect back to the first point's trend line and then to baseline\n      ctx.lineTo(firstItem.x!, firstItem.trendLineY!)\n      ctx.lineTo(firstItem.x!, firstItem.baseLineY!)\n\n      ctx.fill()\n    }\n\n    // Smooth fills drawn\n  }\n\n  private _drawContinuousTrendLines(\n    ctx: CanvasRenderingContext2D,\n    items: TrendFillRenderData[],\n    visibleRange: {from: number; to: number},\n    hRatio: number,\n    vRatio: number\n  ): void {\n    if (visibleRange.to <= visibleRange.from) return\n\n    // Group consecutive points by trend direction and color\n    let currentGroup: TrendFillRenderData[] = []\n    let currentTrendDirection: number | null = null\n    let currentColor: string | null = null\n\n    for (let i = visibleRange.from; i < visibleRange.to; i++) {\n      const item = items[i]\n      if (!this._isValidCoordinates(item)) continue\n\n      const itemColor = item.lineColor\n      const itemTrendDirection = item.trendDirection\n\n      // Start new group if trend direction or color changes\n      if (currentTrendDirection !== itemTrendDirection || currentColor !== itemColor) {\n        // Draw the current group before starting new one\n        if (currentGroup.length > 0) {\n          this._drawLineGroup(ctx, currentGroup, hRatio, vRatio, currentColor!)\n        }\n\n        // Start new group\n        currentGroup = [item]\n        currentTrendDirection = itemTrendDirection\n        currentColor = itemColor\n      } else {\n        // Add to current group\n        currentGroup.push(item)\n      }\n    }\n\n    // Draw the final group\n    if (currentGroup.length > 0 && currentColor) {\n      this._drawLineGroup(ctx, currentGroup, hRatio, vRatio, currentColor)\n    }\n  }\n\n  private _drawLineGroup(\n    ctx: CanvasRenderingContext2D,\n    group: TrendFillRenderData[],\n    hRatio: number,\n    vRatio: number,\n    color: string\n  ): void {\n    if (group.length === 0) return\n\n\n    ctx.strokeStyle = color\n    ctx.lineWidth = group[0].lineWidth || 2\n    this._setLineStyle(ctx, group[0].lineStyle || 0)\n\n    if (group.length === 1) {\n      // Single point - draw a small circle\n      const item = group[0]\n      const trendLineY = item.trendLineY!\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(item.x!, trendLineY, 1.5, 0, 2 * Math.PI)\n      ctx.fill()\n    } else {\n      // Multiple points - draw continuous line\n      ctx.beginPath()\n      const firstItem = group[0]\n      ctx.moveTo(firstItem.x!, firstItem.trendLineY!)\n\n      for (let i = 1; i < group.length; i++) {\n        const item = group[i]\n        ctx.lineTo(item.x!, item.trendLineY!)\n      }\n\n      ctx.stroke()\n    }\n  }\n\n  private _setLineStyle(ctx: CanvasRenderingContext2D, lineStyle: number): void {\n    switch (lineStyle) {\n      case 0:\n        ctx.setLineDash([]) // Solid\n        break\n      case 1:\n        ctx.setLineDash([5, 5]) // Dotted\n        break\n      case 2:\n        ctx.setLineDash([10, 5]) // Dashed\n        break\n      default:\n        ctx.setLineDash([])\n    }\n  }\n\n  private _isValidCoordinates(item: TrendFillRenderData): boolean {\n    // Strict coordinate validation (like BaseLineSeries)\n    if (item.x === null || item.baseLineY === null || item.trendLineY === null) {\n      return false\n    }\n\n    // Check bounds with tolerance\n    const chartWidth = this._viewData.data.chartWidth || 800\n    const tolerance = 100\n\n    if (item.x < -tolerance || item.x > chartWidth + tolerance) {\n      return false\n    }\n\n    // Check for extreme Y values\n    if (Math.abs(item.baseLineY) > 10000 || Math.abs(item.trendLineY) > 10000) {\n      return false\n    }\n\n    return true\n  }\n}\n\n// Optimized Trend Fill Pane View (following BaseLineSeries pattern)\nclass TrendFillPrimitivePaneView implements IPrimitivePaneView {\n  _source: TrendFillSeries\n  _data: TrendFillViewData\n\n  constructor(source: TrendFillSeries) {\n    this._source = source\n    this._data = {\n      data: {\n        items: [],\n        timeScale: null,\n        priceScale: null,\n        chartWidth: 0,\n        lineWidth: 1,\n        lineStyle: 0,\n        visibleRange: null,\n        barWidth: 1\n      },\n      options: this._source.getOptions()\n    }\n  }\n\n  update() {\n    const chart = this._source.getChart()\n    const timeScale = chart.timeScale()\n    const chartElement = chart.chartElement()\n\n    if (!timeScale || !chartElement) {\n      return\n    }\n\n    // Get the price scales using the real line series (following band series pattern)\n    const baseLineSeries = this._source.getBaseLineSeries()\n    const trendLineSeries = this._source.getTrendLineSeries()\n    if (!baseLineSeries || !trendLineSeries) {\n      return\n    }\n\n    // Update view data with the real line series which have the correct price scale\n    this._data.data.timeScale = timeScale\n    this._data.data.priceScale = baseLineSeries\n\n    // Get chart dimensions\n    this._data.data.chartWidth = chartElement?.clientWidth || 800\n\n    // Get bar spacing (like BaseLineSeries)\n    try {\n      // Try to get bar spacing from chart model\n      const chartModel = (chart as any)._model\n      if (chartModel && chartModel.timeScale && chartModel.timeScale.barSpacing) {\n        this._data.data.barWidth = chartModel.timeScale.barSpacing()\n      } else {\n        this._data.data.barWidth = 1 // Default fallback\n      }\n    } catch (error) {\n      this._data.data.barWidth = 1 // Default fallback\n    }\n\n    // Batch coordinate conversion (like BaseLineSeries)\n    const items = this._source.getProcessedData()\n    const convertedItems = this._batchConvertCoordinates(items, timeScale, baseLineSeries, trendLineSeries)\n\n    // Set visible range (like BaseLineSeries)\n    this._data.data.visibleRange = this._calculateVisibleRange(convertedItems)\n\n    // Update renderer data efficiently\n    this._data.data.items = convertedItems\n    this._data.data.lineWidth = this._source.getOptions().trendLine.lineWidth\n    this._data.data.lineStyle = this._source.getOptions().trendLine.lineStyle\n\n  }\n\n  // Batch coordinate conversion (following band series pattern)\n  private _batchConvertCoordinates(\n    items: TrendFillItem[],\n    timeScale: any,\n    baseLineSeries: any,\n    trendLineSeries: any\n  ): TrendFillRenderData[] {\n\n    if (!timeScale || !baseLineSeries || !trendLineSeries) {\n      return []\n    }\n\n    return items\n      .map((item, index) => {\n        try {\n          // Convert coordinates using the real line series (following band series pattern)\n          const x = timeScale.timeToCoordinate(item.time)\n\n\n          // Use the real line series for coordinate conversion (following band series approach)\n          const baseLineY = baseLineSeries.priceToCoordinate(item.baseLine)\n          const trendLineY = trendLineSeries.priceToCoordinate(item.trendLine)\n\n\n          // Validate coordinates\n          if (x === null || baseLineY === null || trendLineY === null) {\n            return null\n          }\n\n          return {\n            x,\n            baseLineY,\n            trendLineY,\n            fillColor: item.fillColor,\n            lineColor: item.lineColor,\n            lineWidth: item.lineWidth,\n            lineStyle: item.lineStyle,\n            trendDirection: item.trendDirection\n          }\n        } catch (error) {\n          return null\n        }\n      })\n      .filter(item => item !== null) as TrendFillRenderData[]\n  }\n\n  // Calculate visible range (like BaseLineSeries)\n  private _calculateVisibleRange(items: TrendFillRenderData[]): {from: number; to: number} | null {\n    if (items.length === 0) return null\n\n    // Simple visible range calculation\n    // In a real implementation, this would consider chart viewport\n    return {from: 0, to: items.length}\n  }\n\n  renderer() {\n    return new TrendFillPrimitivePaneRenderer(this._data)\n  }\n\n  // Z-index support: Return the Z-index for proper layering\n  zIndex(): number {\n    const zIndex = this._source.getOptions().zIndex\n    // Validate Z-index is a positive number\n    if (typeof zIndex === 'number' && zIndex >= 0) {\n      return zIndex\n    }\n    // Return default Z-index for trend fill series\n    return 100\n  }\n}\n\n// Trend Fill Series Class (following BandSeries pattern)\nexport class TrendFillSeries implements ISeriesPrimitive<Time> {\n  private chart: IChartApi\n  private baseLineSeries: ISeriesApi<'Line'>\n  private trendLineSeries: ISeriesApi<'Line'>\n  private options: TrendFillOptions\n  private data: TrendFillData[] = []\n  private _paneViews: TrendFillPrimitivePaneView[]\n  private paneId: number\n\n  // Processed data for rendering\n  private trendFillItems: TrendFillItem[] = []\n\n  constructor(\n    chart: IChartApi,\n    options: TrendFillOptions = {\n      uptrendFillColor: 'rgba(76, 175, 80, 0.3)', // Green with transparency for uptrend fill\n      downtrendFillColor: 'rgba(244, 67, 54, 0.3)', // Red with transparency for downtrend fill\n      trendLine: {\n        color: '#4CAF50', // Default green (will be overridden by trend direction)\n        lineWidth: 2,\n        lineStyle: 0,\n        visible: true\n      },\n      baseLine: {\n        color: '#666666',\n        lineWidth: 1,\n        lineStyle: 1,\n        visible: false\n      },\n      visible: true,\n      priceScaleId: 'right' // Default priceScaleId\n    },\n    paneId: number = 0\n  ) {\n    this.chart = chart\n    this.options = {...options}\n    this.paneId = paneId\n    this._paneViews = [new TrendFillPrimitivePaneView(this)]\n\n    // Create the two line series (following band series pattern) - make them transparent for coordinate conversion only\n    this.baseLineSeries = chart.addSeries(LineSeries, {\n      color: 'rgba(0,0,0,0)', // Fully transparent\n      lineStyle: 0,\n      lineWidth: 1,\n      visible: true, // Must be visible for primitive to render and coordinate conversion\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: false,\n      priceLineVisible: false\n    })\n\n    this.trendLineSeries = chart.addSeries(LineSeries, {\n      color: 'rgba(0,0,0,0)', // Fully transparent\n      lineStyle: 0,\n      lineWidth: 1,\n      visible: true, // Must be visible for coordinate conversion\n      priceScaleId: this.options.priceScaleId,\n      lastValueVisible: false,\n      priceLineVisible: false\n    })\n\n    // Attach the primitive to the base line series for rendering\n    this.baseLineSeries.attachPrimitive(this)\n  }\n\n  public setDummySeries(series: any): void {\n    // No longer needed - we have real line series\n  }\n\n  public setData(data: TrendFillData[]): void {\n    this.data = data\n    this.processData()\n\n    // Extract baseline and trendline data for the real line series\n    if (this.data.length > 0) {\n      const baseLineData = this.data.map(item => ({\n        time: parseTime(item.time),\n        value: (item.base_line ?? item.baseLine) || 0\n      })).filter(item => item.time > 0)\n\n      const trendLineData = this.data.map(item => ({\n        time: parseTime(item.time),\n        value: (item.trend_line ?? item.trendLine) || 0\n      })).filter(item => item.time > 0 && item.value !== 0)\n\n      // Set data for the real line series\n      if (baseLineData.length > 0) {\n        this.baseLineSeries.setData(baseLineData)\n      }\n      if (trendLineData.length > 0) {\n        this.trendLineSeries.setData(trendLineData)\n      }\n    }\n\n    this.updateAllViews()\n  }\n\n  public updateData(data: TrendFillData[]): void {\n    this.setData(data)\n  }\n\n  private processData(): void {\n    this.trendFillItems = []\n\n    if (!this.data || this.data.length === 0) {\n      return\n    }\n\n\n    // Sort data by time\n    const sortedData = [...this.data].sort((a, b) => {\n      const timeA = parseTime(a.time)\n      const timeB = parseTime(b.time)\n      return timeA - timeB\n    })\n\n    // Count trend directions in raw data\n    const trendDirectionCounts = { '-1': 0, '0': 0, '1': 0, 'null': 0, 'undefined': 0 }\n    sortedData.forEach((item, i) => {\n      const trendDirection = item.trend_direction ?? item.trendDirection\n      const key = trendDirection === null ? 'null' : trendDirection === undefined ? 'undefined' : String(trendDirection)\n      trendDirectionCounts[key] = (trendDirectionCounts[key] || 0) + 1\n    })\n\n    // Process each data point\n    for (let i = 0; i < sortedData.length; i++) {\n      const item = sortedData[i]\n      const time = parseTime(item.time)\n      // Handle both camelCase and snake_case field names for backwards compatibility\n      const baseLine = item.base_line ?? item.baseLine\n      const trendLine = item.trend_line ?? item.trendLine\n      const trendDirection = item.trend_direction ?? item.trendDirection\n\n\n      if (\n        baseLine === null ||\n        baseLine === undefined ||\n        trendDirection === null ||\n        trendDirection === undefined\n      ) {\n        continue\n      }\n\n      // Skip neutral trends (they don't have trend lines to draw)\n      if (trendDirection === 0 || trendLine === null || trendLine === undefined) {\n        continue\n      }\n\n      // Determine colors and styles based on trend direction\n      const isUptrend = trendDirection > 0\n\n      // Use different colors for uptrend and downtrend\n      const fillColor = isUptrend ? this.options.uptrendFillColor : this.options.downtrendFillColor\n\n      // Use different line colors for uptrend (green) and downtrend (red) - matching the image\n      const lineColor = isUptrend\n        ? this._getSolidColorFromFill(this.options.uptrendFillColor) // Green line for uptrend\n        : this._getSolidColorFromFill(this.options.downtrendFillColor) // Red line for downtrend\n\n\n      const lineWidth = this.options.trendLine.lineWidth\n      const lineStyle = this.options.trendLine.lineStyle\n\n      // Create trend fill item (like BaseLineSeries data structure)\n      this.trendFillItems.push({\n        time,\n        baseLine,\n        trendLine,\n        trendDirection,\n        fillColor,\n        lineColor,\n        lineWidth,\n        lineStyle\n      })\n    }\n\n  }\n\n  public applyOptions(options: Partial<TrendFillOptions>): void {\n    this.options = {...this.options, ...options}\n    this.processData()\n    this.updateAllViews()\n  }\n\n  private _getSolidColorFromFill(fillColor: string): string {\n    // Convert fill colors (which may have transparency) to solid line colors\n    if (fillColor.includes('rgba')) {\n      // Convert rgba to solid color by setting alpha to 1\n      return fillColor.replace(/,\\s*[0-9.]+\\s*\\)/, ', 1)')\n    } else if (fillColor.includes('rgb')) {\n      // Already solid rgb\n      return fillColor\n    } else if (fillColor.startsWith('#')) {\n      // Hex color - already solid\n      return fillColor\n    } else {\n      // Named color or other format - return as is\n      return fillColor\n    }\n  }\n\n  public setVisible(visible: boolean): void {\n    this.options.visible = visible\n    this.processData()\n    this.updateAllViews()\n  }\n\n  public destroy(): void {\n    try {\n      this.chart.removeSeries(this.baseLineSeries)\n      this.chart.removeSeries(this.trendLineSeries)\n    } catch (error) {\n      // Ignore errors during cleanup\n    }\n  }\n\n  // Getter methods\n  getOptions(): TrendFillOptions {\n    return this.options\n  }\n\n  getChart(): IChartApi {\n    return this.chart\n  }\n\n  getProcessedData(): TrendFillItem[] {\n    return this.trendFillItems\n  }\n\n  getBaseLineSeries(): ISeriesApi<'Line'> {\n    return this.baseLineSeries\n  }\n\n  getTrendLineSeries(): ISeriesApi<'Line'> {\n    return this.trendLineSeries\n  }\n\n  // ISeriesPrimitive implementation\n  attached(param: SeriesAttachedParameter<Time>): void {\n    // Primitive is attached to the series\n  }\n\n  detached(): void {\n    // Primitive is detached from the series\n  }\n\n  updateAllViews(): void {\n    this._paneViews.forEach(pv => pv.update())\n  }\n\n  paneViews(): IPrimitivePaneView[] {\n    return this._paneViews\n  }\n}\n\n// Custom Series View for compatibility with series factory\nclass TrendFillSeriesView {\n  private _data: TrendFillData[] = []\n  private _options: TrendFillOptions\n  private _trendFillSeries: TrendFillSeries | null = null\n\n  constructor(data: TrendFillData[], options: TrendFillOptions) {\n    this._data = data\n    this._options = options\n  }\n\n  processData() {\n    return this._data\n  }\n\n  setData(newData: TrendFillData[]) {\n    this._data = newData\n    if (this._trendFillSeries) {\n      this._trendFillSeries.setData(newData)\n    }\n  }\n\n  getData() {\n    return this._data\n  }\n\n  getOptions() {\n    return this._options\n  }\n\n  // This method will be called by addCustomSeries\n  createSeries(chart: IChartApi, paneId?: number) {\n    this._trendFillSeries = new TrendFillSeries(chart, this._options, paneId || 0)\n    this._trendFillSeries.setData(this._data)\n    return this._trendFillSeries\n  }\n}\n\n// Factory function to create trend fill series (matching the series factory call pattern)\nexport function createTrendFillSeriesPlugin(\n  data: TrendFillData[],\n  options: TrendFillOptions\n): TrendFillSeriesView {\n  return new TrendFillSeriesView(data, options)\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/plugins/trade/TradeRectanglePrimitive.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":77,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":19},{"ruleId":"prefer-const","severity":1,"message":"'textX' is never reassigned. Use 'const' instead.","line":141,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":141,"endColumn":20,"fix":{"range":[3876,3904],"text":"const textX = left + width / 2"}},{"ruleId":"prefer-const","severity":1,"message":"'showBackground' is never reassigned. Use 'const' instead.","line":143,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":143,"endColumn":29,"fix":{"range":[3943,3968],"text":"const showBackground = true"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import {\n  IPrimitivePaneRenderer,\n  IPrimitivePaneView,\n  ISeriesPrimitive,\n  IChartApi,\n  ISeriesApi,\n  Coordinate,\n  UTCTimestamp\n} from 'lightweight-charts'\nimport {ChartCoordinateService} from '../../services/ChartCoordinateService'\nimport {createBoundingBox} from '../../utils/coordinateValidation'\n\ninterface TradeRectangleData {\n  time1: UTCTimestamp\n  time2: UTCTimestamp\n  price1: number\n  price2: number\n  fillColor: string\n  borderColor: string\n  borderWidth: number\n  opacity: number\n  label?: string\n  textPosition?: 'inside' | 'above' | 'below'\n  textFontSize?: number\n  textColor?: string\n  textBackground?: string\n}\n\n/**\n * Trade Rectangle Renderer following official TradingView patterns\n */\nclass TradeRectangleRenderer implements IPrimitivePaneRenderer {\n  private _x1: Coordinate\n  private _y1: Coordinate\n  private _x2: Coordinate\n  private _y2: Coordinate\n  private _fillColor: string\n  private _borderColor: string\n  private _borderWidth: number\n  private _opacity: number\n  private _label: string\n  private _textPosition: 'inside' | 'above' | 'below'\n  private _textFontSize: number\n  private _textColor: string\n  private _textBackground: string\n\n  constructor(\n    x1: Coordinate,\n    y1: Coordinate,\n    x2: Coordinate,\n    y2: Coordinate,\n    fillColor: string,\n    borderColor: string,\n    borderWidth: number,\n    opacity: number,\n    label: string = '',\n    textPosition: 'inside' | 'above' | 'below' = 'inside',\n    textFontSize: number = 10,\n    textColor: string = '#FFFFFF',\n    textBackground: string = 'rgba(0, 0, 0, 0.7)'\n  ) {\n    this._x1 = x1\n    this._y1 = y1\n    this._x2 = x2\n    this._y2 = y2\n    this._fillColor = fillColor\n    this._borderColor = borderColor\n    this._borderWidth = borderWidth\n    this._opacity = opacity\n    this._label = label\n    this._textPosition = textPosition\n    this._textFontSize = textFontSize\n    this._textColor = textColor\n    this._textBackground = textBackground\n  }\n\n  draw(target: any) {\n    // We use drawBackground for rectangles\n  }\n\n  drawBackground(target: any) {\n    // Early return if coordinates are invalid\n    if (\n      this._x1 === null ||\n      this._y1 === null ||\n      this._x2 === null ||\n      this._y2 === null ||\n      this._x1 === undefined ||\n      this._y1 === undefined ||\n      this._x2 === undefined ||\n      this._y2 === undefined ||\n      this._x1 === 0 ||\n      this._y1 === 0 ||\n      this._x2 === 0 ||\n      this._y2 === 0\n    ) {\n      return\n    }\n\n    // Use bitmap coordinate space for pixel-perfect rendering\n    target.useBitmapCoordinateSpace((scope: any) => {\n      const ctx = scope.context\n\n      // Convert to bitmap coordinates\n      const x1 = this._x1 * scope.horizontalPixelRatio\n      const y1 = this._y1 * scope.verticalPixelRatio\n      const x2 = this._x2 * scope.horizontalPixelRatio\n      const y2 = this._y2 * scope.verticalPixelRatio\n\n      // Calculate rectangle bounds\n      const left = Math.min(x1, x2)\n      const top = Math.min(y1, y2)\n      const width = Math.abs(x2 - x1)\n      const height = Math.abs(y2 - y1)\n\n      if (width < 1 || height < 1) {\n        return\n      }\n\n      try {\n        // Draw filled rectangle\n        ctx.globalAlpha = this._opacity\n        ctx.fillStyle = this._fillColor\n        ctx.fillRect(left, top, width, height)\n\n        // Draw border\n        if (this._borderWidth > 0) {\n          ctx.globalAlpha = 1.0\n          ctx.strokeStyle = this._borderColor\n          ctx.lineWidth = this._borderWidth * scope.horizontalPixelRatio\n          ctx.strokeRect(left, top, width, height)\n        }\n\n        // Draw label with configurable position and styling\n        if (this._label) {\n          ctx.globalAlpha = 1.0\n          ctx.font = `${this._textFontSize * scope.verticalPixelRatio}px Arial`\n          ctx.textAlign = 'center'\n\n          // Calculate text position based on textPosition setting\n          let textX = left + width / 2\n          let textY: number\n          let showBackground = true\n\n          switch (this._textPosition) {\n            case 'above':\n              textY = top - 5 * scope.verticalPixelRatio // 5px above rectangle\n              ctx.textBaseline = 'bottom'\n              break\n            case 'below':\n              textY = top + height + 5 * scope.verticalPixelRatio // 5px below rectangle\n              ctx.textBaseline = 'top'\n              break\n            case 'inside':\n            default:\n              textY = top + height / 2\n              ctx.textBaseline = 'middle'\n              break\n          }\n\n          // Measure text dimensions for background\n          const textMetrics = ctx.measureText(this._label)\n          const textWidth = textMetrics.width\n          const textHeight = this._textFontSize * scope.verticalPixelRatio\n\n          // Draw text background if configured\n          if (showBackground && this._textBackground && this._textBackground !== 'transparent') {\n            ctx.fillStyle = this._textBackground\n            const bgPadding = 2 * scope.horizontalPixelRatio\n            ctx.fillRect(\n              textX - textWidth / 2 - bgPadding,\n              textY - textHeight / 2 - bgPadding,\n              textWidth + 2 * bgPadding,\n              textHeight + 2 * bgPadding\n            )\n          }\n\n          // Draw text\n          ctx.fillStyle = this._textColor\n          ctx.fillText(this._label, textX, textY)\n        }\n      } finally {\n        ctx.globalAlpha = 1.0\n      }\n    })\n  }\n}\n\n/**\n * Trade Rectangle View following official TradingView patterns\n */\nclass TradeRectangleView implements IPrimitivePaneView {\n  private _source: TradeRectanglePrimitive\n  private _x1: Coordinate = 0 as Coordinate\n  private _y1: Coordinate = 0 as Coordinate\n  private _x2: Coordinate = 0 as Coordinate\n  private _y2: Coordinate = 0 as Coordinate\n\n  constructor(source: TradeRectanglePrimitive) {\n    this._source = source\n  }\n\n  update() {\n    const data = this._source.data()\n    const chart = this._source.chart()\n    const series = this._source.series()\n\n    if (!chart || !series || !data) {\n      return\n    }\n\n    try {\n      // Use our coordinate services and utilities for consistency across the codebase:\n      // - Chart registration is handled via ChartCoordinateService\n      // - Coordinate validation uses our centralized validation utilities\n      // - Direct coordinate conversion follows official TradingView patterns\n      const timeScale = chart.timeScale()\n\n      // Get time scale state for coordinate conversion\n\n      const x1 = timeScale.timeToCoordinate(data.time1)\n      const x2 = timeScale.timeToCoordinate(data.time2)\n\n      // Convert price coordinates using series coordinate conversion\n      const y1 = series.priceToCoordinate(data.price1)\n      const y2 = series.priceToCoordinate(data.price2)\n\n      // CRITICAL FIX: Graceful failure handling identical to the old working canvas overlay approach\n      // If coordinate conversion fails, silently return and let automatic retry mechanism handle it\n      if (x1 === null || x2 === null || y1 === null || y2 === null) {\n        return // Silent failure - just like old canvas overlay approach\n      }\n\n      // Validate coordinates are finite\n      if (\n        !isFinite(x1) ||\n        isNaN(x1) ||\n        !isFinite(x2) ||\n        isNaN(x2) ||\n        !isFinite(y1) ||\n        isNaN(y1) ||\n        !isFinite(y2) ||\n        isNaN(y2)\n      ) {\n        return // Silent failure - automatic retry will occur\n      }\n\n      // Create bounding box for validation\n      const boundingBox = createBoundingBox(\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.abs(x2 - x1),\n        Math.abs(y2 - y1)\n      )\n\n      // Ensure non-zero dimensions\n      if (boundingBox.width <= 0 || boundingBox.height <= 0) {\n        return // Silent failure - automatic retry will occur\n      }\n\n      // SUCCESS: Set coordinates (same as old approach when coordinates are valid)\n      this._x1 = x1\n      this._y1 = y1\n      this._x2 = x2\n      this._y2 = y2\n    } catch (error) {\n      // CRITICAL FIX: Graceful error handling like old canvas overlay approach\n      // Don't log errors prominently - just let automatic retry handle it\n\n      return // Silent failure with automatic retry via event listeners\n    }\n  }\n\n  renderer() {\n    const data = this._source.data()\n    return new TradeRectangleRenderer(\n      this._x1,\n      this._y1,\n      this._x2,\n      this._y2,\n      data.fillColor,\n      data.borderColor,\n      data.borderWidth,\n      data.opacity,\n      data.label || '',\n      data.textPosition || 'inside',\n      data.textFontSize || 10,\n      data.textColor || '#FFFFFF',\n      data.textBackground || 'rgba(0, 0, 0, 0.7)'\n    )\n  }\n}\n\n/**\n * Trade Rectangle Primitive following official TradingView patterns\n *\n * This primitive provides:\n * - Event-driven automatic retry logic for coordinate conversion\n * - Graceful failure handling when chart isn't ready\n * - Integration with ChartCoordinateService for consistency\n * - Proper cleanup of event listeners to prevent memory leaks\n * - Support for findNearestTime timestamp adjustment\n */\nexport class TradeRectanglePrimitive implements ISeriesPrimitive {\n  private _data: TradeRectangleData\n  private _chart: IChartApi | null = null\n  private _series: ISeriesApi<any> | null = null\n  private _paneView: TradeRectangleView\n  private _requestUpdate?: () => void\n  private _timeScaleCallback?: (() => void) | null\n  private _crosshairCallback?: (() => void) | null\n  private _updateThrottled: boolean = false\n\n  constructor(data: TradeRectangleData) {\n    this._data = data\n    this._paneView = new TradeRectangleView(this)\n  }\n\n  // Required by ISeriesPrimitive interface\n  updateAllViews() {\n    this._paneView.update()\n  }\n\n  paneViews() {\n    return [this._paneView]\n  }\n\n  // Lifecycle methods following official patterns\n  attached({\n    chart,\n    series,\n    requestUpdate\n  }: {\n    chart: IChartApi\n    series: ISeriesApi<any>\n    requestUpdate: () => void\n  }) {\n    this._chart = chart\n    this._series = series\n    this._requestUpdate = requestUpdate\n\n    // Ensure chart is registered with our coordinate service for consistency\n    const coordinateService = ChartCoordinateService.getInstance()\n    const chartId = chart.chartElement()?.id || 'default'\n    coordinateService.registerChart(chartId, chart)\n\n    // CRITICAL FIX: Add event-driven retry logic identical to the old working canvas overlay approach\n    // This ensures coordinate conversion is automatically retried when the chart becomes ready\n    try {\n      // Create callback functions and store them for cleanup\n      this._timeScaleCallback = () => {\n        this._requestUpdate()\n      }\n\n      this._crosshairCallback = () => {\n        // Throttle crosshair updates to avoid performance issues\n        if (!this._updateThrottled) {\n          this._updateThrottled = true\n          setTimeout(() => {\n            this._updateThrottled = false\n            this._requestUpdate()\n          }, 100) // Throttle to 10fps for crosshair updates\n        }\n      }\n\n      // Subscribe to events (Lightweight Charts pattern: returns void, store callbacks for cleanup)\n      chart.timeScale().subscribeVisibleTimeRangeChange(this._timeScaleCallback)\n      chart.subscribeCrosshairMove(this._crosshairCallback)\n    } catch (error) {\n\n    }\n\n    // Request initial update\n    this._requestUpdate()\n  }\n\n  detached() {\n    // Clean up event subscriptions to prevent memory leaks\n    if (this._chart && this._timeScaleCallback) {\n      try {\n        this._chart.timeScale().unsubscribeVisibleTimeRangeChange(this._timeScaleCallback)\n        this._timeScaleCallback = null\n      } catch (error) {\n\n      }\n    }\n\n    if (this._chart && this._crosshairCallback) {\n      try {\n        this._chart.unsubscribeCrosshairMove(this._crosshairCallback)\n        this._crosshairCallback = null\n      } catch (error) {\n\n      }\n    }\n\n    this._chart = null\n    this._series = null\n    this._requestUpdate = undefined\n    this._updateThrottled = false\n  }\n\n  // Getter methods\n  data(): TradeRectangleData {\n    return this._data\n  }\n\n  chart(): IChartApi | null {\n    return this._chart\n  }\n\n  series(): ISeriesApi<any> | null {\n    return this._series\n  }\n\n  // Update rectangle data and request redraw\n  updateData(newData: Partial<TradeRectangleData>) {\n    this._data = {...this._data, ...newData}\n    if (this._requestUpdate) {\n      this._requestUpdate()\n    }\n  }\n}\n\n// Factory function for creating trade rectangle primitives\nexport function createTradeRectanglePrimitives(\n  trades: Array<{\n    entryTime: string | UTCTimestamp\n    exitTime?: string | UTCTimestamp\n    entryPrice: number\n    exitPrice: number\n    fillColor?: string\n    borderColor?: string\n    borderWidth?: number\n    opacity?: number\n    label?: string\n  }>,\n  chartData?: any[]\n): TradeRectanglePrimitive[] {\n  const primitives: TradeRectanglePrimitive[] = []\n\n  trades.forEach(trade => {\n    // Parse times\n    let time1: UTCTimestamp\n    let time2: UTCTimestamp\n\n    if (typeof trade.entryTime === 'string') {\n      time1 = Math.floor(new Date(trade.entryTime).getTime() / 1000) as UTCTimestamp\n    } else {\n      time1 = trade.entryTime\n    }\n\n    if (trade.exitTime) {\n      if (typeof trade.exitTime === 'string') {\n        time2 = Math.floor(new Date(trade.exitTime).getTime() / 1000) as UTCTimestamp\n      } else {\n        time2 = trade.exitTime\n      }\n    } else if (chartData && chartData.length > 0) {\n      // Use last available time for open trades\n      const lastTime = chartData[chartData.length - 1]?.time\n      if (lastTime) {\n        time2 =\n          typeof lastTime === 'string'\n            ? (Math.floor(new Date(lastTime).getTime() / 1000) as UTCTimestamp)\n            : lastTime\n      } else {\n        return // Skip if no exit time available\n      }\n    } else {\n      return // Skip if no exit time available\n    }\n\n    const rectangleData: TradeRectangleData = {\n      time1,\n      time2,\n      price1: trade.entryPrice,\n      price2: trade.exitPrice,\n      fillColor: trade.fillColor || 'rgba(0, 150, 136, 0.2)',\n      borderColor: trade.borderColor || 'rgb(0, 150, 136)',\n      borderWidth: trade.borderWidth || 1,\n      opacity: trade.opacity || 0.2,\n      label: trade.label\n    }\n\n    primitives.push(new TradeRectanglePrimitive(rectangleData))\n  })\n\n  return primitives\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/BasePanePrimitive.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":463,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":463,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[13250,13339],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":648,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":648,"endColumn":104},{"ruleId":"no-unused-vars","severity":1,"message":"'position' is defined but never used. Allowed unused args must match /^_/u.","line":669,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":669,"endColumn":48},{"ruleId":"no-unused-vars","severity":1,"message":"'container' is defined but never used. Allowed unused args must match /^_/u.","line":676,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":676,"endColumn":54},{"ruleId":"no-unused-vars","severity":1,"message":"'visible' is defined but never used. Allowed unused args must match /^_/u.","line":683,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":683,"endColumn":49},{"ruleId":"no-unused-vars","severity":1,"message":"'newConfig' is defined but never used. Allowed unused args must match /^_/u.","line":690,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":690,"endColumn":55},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":697,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":697,"endColumn":116},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":704,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":704,"endColumn":67}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IChartApi, ISeriesApi, IPanePrimitive, Time } from 'lightweight-charts'\nimport { CornerLayoutManager } from '../services/CornerLayoutManager'\nimport { ChartCoordinateService } from '../services/ChartCoordinateService'\nimport { TemplateEngine, TemplateContext, TemplateResult } from '../services/TemplateEngine'\nimport { PrimitiveEventManager, EventSubscription } from '../services/PrimitiveEventManager'\nimport { Corner, Position, IPositionableWidget, WidgetDimensions } from '../types/layout'\n\n/**\n * Base configuration for all pane primitives\n */\nexport interface BasePrimitiveConfig {\n  /**\n   * Position in chart corner\n   */\n  corner: Corner\n\n  /**\n   * Priority for stacking order (lower = higher priority)\n   */\n  priority: number\n\n\n  /**\n   * Whether the primitive is visible\n   */\n  visible?: boolean\n\n  /**\n   * Styling configuration\n   */\n  style?: {\n    backgroundColor?: string\n    color?: string\n    fontSize?: number\n    fontFamily?: string\n    borderRadius?: number\n    padding?: number\n    margin?: number\n    zIndex?: number\n  }\n}\n\n/**\n * Interface for template data used in primitives\n */\nexport interface TemplateData {\n  [key: string]: any\n}\n\n/**\n * Abstract base class for all pane primitives\n *\n * This class provides:\n * - Layout Management System - built-in positioning and stacking\n * - React Integration Layer - hybrid primitives that can render React components\n * - Event System Integration - built-in event handling\n * - Template processing system for dynamic content\n *\n * Following DRY principles with single source of truth architecture\n */\nexport abstract class BasePanePrimitive<TConfig extends BasePrimitiveConfig = BasePrimitiveConfig>\n  implements IPanePrimitive<Time>, IPositionableWidget {\n\n  // IPanePrimitive implementation\n  public readonly id: string\n\n  // IPositionableWidget implementation\n  public readonly corner: Corner\n  public readonly priority: number\n  public visible: boolean = true\n\n  // Core services\n  protected config: TConfig\n  protected chart: IChartApi | null = null\n  protected series: ISeriesApi<any> | null = null\n  protected requestUpdate: (() => void) | null = null\n  protected layoutManager: CornerLayoutManager | null = null\n  protected coordinateService: ChartCoordinateService\n  protected templateEngine: TemplateEngine\n  protected eventManager: PrimitiveEventManager | null = null\n\n  // Layout state\n  protected currentPosition: Position | null = null\n  protected containerElement: HTMLElement | null = null\n  protected mounted: boolean = false\n\n  // Event handling\n  protected eventSubscriptions: EventSubscription[] = []\n\n  // Template processing\n  protected templateData: TemplateData = {}\n  protected templateContext: TemplateContext = {}\n  protected lastTemplateResult: TemplateResult | null = null\n\n  constructor(id: string, config: TConfig) {\n    this.id = id\n    this.config = { ...config }\n    this.corner = config.corner\n    this.priority = config.priority\n    this.visible = config.visible !== false\n    this.coordinateService = ChartCoordinateService.getInstance()\n    this.templateEngine = TemplateEngine.getInstance()\n  }\n\n  // ===== IPanePrimitive Interface =====\n\n  /**\n   * Called when primitive is attached to a pane\n   */\n  public attached(params: {\n    chart: IChartApi\n    series: ISeriesApi<any>\n    requestUpdate: () => void\n  }): void {\n    this.chart = params.chart\n    this.series = params.series\n    this.requestUpdate = params.requestUpdate\n\n    // Initialize layout management\n    this.initializeLayoutManagement()\n\n    // Initialize event management\n    this.initializeEventManagement()\n\n    // Setup default event subscriptions\n    this.setupDefaultEventSubscriptions()\n\n    // Call lifecycle hook\n    this.onAttached(params)\n\n    // Mark as mounted\n    this.mounted = true\n\n    // Register with layout manager\n    if (this.layoutManager) {\n      this.layoutManager.registerWidget(this)\n    }\n\n    // Trigger initial render\n    this.updateAllViews()\n  }\n\n  /**\n   * Called when primitive is detached from a pane\n   */\n  public detached(): void {\n    // Unregister from layout manager\n    if (this.layoutManager) {\n      this.layoutManager.unregisterWidget(this.id)\n    }\n\n    // Cleanup event subscriptions\n    this.cleanupEventSubscriptions()\n\n    // Cleanup container\n    this.destroyContainer()\n\n    // Call lifecycle hook\n    this.onDetached()\n\n    // Clear references\n    this.chart = null\n    this.series = null\n    this.layoutManager = null\n    this.eventManager = null\n    this.mounted = false\n  }\n\n  /**\n   * Required IPanePrimitive method - provides pane views for rendering\n   * This enables immediate response to pane resize/redraw events\n   */\n  public paneViews(): any[] {\n    return [\n      {\n        renderer: () => ({\n          draw: () => {\n            // Empty draw method - layout updates should only happen on actual resize events\n            // not on every frame to avoid performance issues during pan/zoom operations\n          }\n        })\n      }\n    ]\n  }\n\n  /**\n   * Main primitive update method - handles rendering\n   */\n  public updateAllViews(): void {\n    if (!this.mounted || !this.visible) {\n      return\n    }\n\n    // Process template data\n    this.processTemplate()\n\n    // Ensure container exists\n    this.ensureContainer()\n\n    // Update content\n    this.renderContent()\n\n    // Call lifecycle hook\n    this.onUpdate()\n  }\n\n  // ===== IPositionableWidget Interface =====\n\n  /**\n   * Get current dimensions of the primitive's container\n   */\n  public getDimensions(): WidgetDimensions {\n    if (!this.containerElement) {\n      return { width: 0, height: 0 }\n    }\n\n    // Get actual dimensions\n    let width = this.containerElement.offsetWidth || 0\n    let height = this.containerElement.offsetHeight || 0\n\n    // Fallback for cases where element hasn't been rendered yet\n    if ((width === 0 || height === 0) && this.containerElement) {\n      // Force measurement by temporarily making element visible\n      const originalDisplay = this.containerElement.style.display\n      const originalVisibility = this.containerElement.style.visibility\n      const originalPosition = this.containerElement.style.position\n\n      this.containerElement.style.display = 'block'\n      this.containerElement.style.visibility = 'hidden'\n      this.containerElement.style.position = 'absolute'\n\n      width = this.containerElement.offsetWidth || width\n      height = this.containerElement.offsetHeight || height\n\n      // Restore original styles\n      this.containerElement.style.display = originalDisplay\n      this.containerElement.style.visibility = originalVisibility\n      this.containerElement.style.position = originalPosition\n\n      // If still zero, provide reasonable defaults based on content\n      if (width === 0) {\n        const textLength = this.containerElement.textContent?.length || 50\n        width = Math.max(100, textLength * 8) // Approximate character width\n      }\n      if (height === 0) {\n        height = 24 // Default height for one line of text with padding\n      }\n    }\n\n    return { width, height }\n  }\n\n  /**\n   * Called by layout manager to update position\n   * Now properly integrates with lightweight-charts coordinate updates\n   */\n  public updatePosition(position: Position): void {\n    this.currentPosition = position\n\n    if (this.containerElement) {\n      // Apply position immediately for instant response\n      this.applyPositionToContainer(position)\n    }\n\n    // Call lifecycle hook\n    this.onPositionUpdate(position)\n  }\n\n  // ===== Layout Management System =====\n\n  /**\n   * Initialize layout management integration\n   */\n  private initializeLayoutManagement(): void {\n    if (!this.chart) return\n\n    // Get chart-level layout manager (for chart-level widgets like range switcher)\n    // or pane-specific layout manager (for pane-level widgets like legends)\n    const paneId = this.getPaneId()\n    const chartId = this.getChartId()\n\n    this.layoutManager = CornerLayoutManager.getInstance(chartId, paneId)\n    this.layoutManager.setChartApi(this.chart)\n\n    // Setup coordinate service integration\n    this.coordinateService.setupLayoutManagerIntegration(this.chart, this.layoutManager)\n  }\n\n  /**\n   * Get the pane ID for this primitive\n   * Defaults to 0 (main pane) - can be overridden by subclasses if needed\n   */\n  protected getPaneId(): number {\n    return 0\n  }\n\n  /**\n   * Get the chart ID for this primitive\n   */\n  protected getChartId(): string {\n    return this.chart?.chartElement()?.id || 'default'\n  }\n\n  // ===== Container Management =====\n\n  /**\n   * Ensure container element exists\n   */\n  private ensureContainer(): void {\n    if (this.containerElement) {\n      return\n    }\n\n    if (!this.chart) {\n      return\n    }\n\n    const chartElement = this.chart.chartElement()\n    if (!chartElement) {\n      return\n    }\n\n    // Create container\n    this.containerElement = document.createElement('div')\n    this.containerElement.id = `${this.id}-container`\n    this.containerElement.className = `primitive-container ${this.getContainerClassName()}`\n\n    // Apply base styling\n    this.applyBaseContainerStyling()\n\n    // Apply position if available\n    if (this.currentPosition) {\n      this.applyPositionToContainer(this.currentPosition)\n    }\n\n    // Attach to chart\n    chartElement.appendChild(this.containerElement)\n\n    // Call lifecycle hook\n    this.onContainerCreated(this.containerElement)\n  }\n\n  /**\n   * Apply position to container element using lightweight-charts coordinate system\n   */\n  private applyPositionToContainer(position: Position): void {\n    if (!this.containerElement) return\n\n    const style = this.containerElement.style\n\n    // Use lightweight-charts coordinate system for positioning\n    style.position = 'absolute'\n    style.top = ''\n    style.right = ''\n    style.bottom = ''\n    style.left = ''\n\n    // Apply coordinates that will be managed by lightweight-charts coordinate transforms\n    if (position.top !== undefined) style.top = `${position.top}px`\n    if (position.right !== undefined) style.right = `${position.right}px`\n    if (position.bottom !== undefined) style.bottom = `${position.bottom}px`\n    if (position.left !== undefined) style.left = `${position.left}px`\n    if (position.zIndex !== undefined) style.zIndex = position.zIndex.toString()\n\n    // Request chart update to synchronize with lightweight-charts coordinate system\n    if (this.requestUpdate) {\n      this.requestUpdate()\n    }\n  }\n\n  /**\n   * Apply base container styling\n   */\n  private applyBaseContainerStyling(): void {\n    if (!this.containerElement) return\n\n    const style = this.containerElement.style\n    style.position = 'absolute'\n    style.pointerEvents = 'auto'\n    style.userSelect = 'none'\n\n    // Apply config styling\n    if (this.config.style) {\n      const configStyle = this.config.style\n      const isLegend = this.id.includes('legend')\n\n      // For legends, don't apply background to container - let content handle it\n      if (configStyle.backgroundColor && !isLegend) {\n        style.backgroundColor = configStyle.backgroundColor\n      }\n      if (configStyle.color && !isLegend) style.color = configStyle.color\n      if (configStyle.fontSize) style.fontSize = `${configStyle.fontSize}px`\n      if (configStyle.fontFamily) style.fontFamily = configStyle.fontFamily\n      if (configStyle.borderRadius && !isLegend) style.borderRadius = `${configStyle.borderRadius}px`\n      if (configStyle.padding && !isLegend) style.padding = `${configStyle.padding}px`\n\n      // For legends, force margin to 0 since spacing is handled by layout manager\n      if (isLegend) {\n        style.margin = '0'\n      } else if (configStyle.margin) {\n        style.margin = `${configStyle.margin}px`\n      }\n      if (configStyle.zIndex) style.zIndex = configStyle.zIndex.toString()\n\n      // Ensure container is transparent for legends\n      if (isLegend) {\n        style.backgroundColor = 'transparent'\n        style.color = 'inherit'\n      }\n    }\n  }\n\n  /**\n   * Destroy container element\n   */\n  private destroyContainer(): void {\n    if (this.containerElement && this.containerElement.parentNode) {\n      this.containerElement.parentNode.removeChild(this.containerElement)\n    }\n    this.containerElement = null\n  }\n\n  // ===== Template Processing System =====\n\n  /**\n   * Set template data for processing\n   */\n  public setTemplateData(data: TemplateData): void {\n    this.templateData = { ...this.templateData, ...data }\n\n    if (this.mounted) {\n      this.processTemplate()\n      this.renderContent()\n    }\n  }\n\n  /**\n   * Update template context for processing\n   */\n  public updateTemplateContext(context: Partial<TemplateContext>): void {\n    this.templateContext = { ...this.templateContext, ...context }\n\n    if (this.mounted) {\n      this.processTemplate()\n      this.renderContent()\n    }\n  }\n\n  /**\n   * Process template with current data using TemplateEngine\n   */\n  protected processTemplate(): void {\n    const template = this.getTemplate()\n    const context: TemplateContext = {\n      ...this.templateContext,\n      customData: this.templateData\n    }\n\n    this.lastTemplateResult = this.templateEngine.processTemplate(template, context)\n\n    // Log any errors for debugging\n    if (this.lastTemplateResult.hasErrors) {\n      console.warn(`Template processing errors in ${this.id}:`, this.lastTemplateResult.errors)\n    }\n  }\n\n  /**\n   * Get processed template content\n   */\n  protected getProcessedContent(): string {\n    return this.lastTemplateResult?.content || this.getTemplate()\n  }\n\n  /**\n   * Get template processing result for debugging\n   */\n  public getTemplateResult(): TemplateResult | null {\n    return this.lastTemplateResult\n  }\n\n  // ===== Event System Integration =====\n\n  /**\n   * Initialize event management\n   */\n  private initializeEventManagement(): void {\n    if (!this.chart) return\n\n    const chartId = this.getChartId()\n    this.eventManager = PrimitiveEventManager.getInstance(chartId)\n    this.eventManager.initialize(this.chart)\n  }\n\n  /**\n   * Setup default event subscriptions\n   */\n  private setupDefaultEventSubscriptions(): void {\n    if (!this.eventManager) return\n\n    // Subscribe to crosshair moves for template data updates\n    const crosshairSub = this.eventManager.subscribe('crosshairMove', (event) => {\n      this.handleCrosshairMove(event)\n    })\n    this.eventSubscriptions.push(crosshairSub)\n\n    // Subscribe to chart resize for layout updates\n    const resizeSub = this.eventManager.subscribe('resize', (event) => {\n      this.handleChartResize(event)\n    })\n    this.eventSubscriptions.push(resizeSub)\n\n    // Call subclass hook for additional subscriptions\n    this.setupCustomEventSubscriptions()\n  }\n\n  /**\n   * Cleanup event subscriptions\n   */\n  private cleanupEventSubscriptions(): void {\n    this.eventSubscriptions.forEach(sub => sub.unsubscribe())\n    this.eventSubscriptions = []\n  }\n\n  /**\n   * Handle crosshair move events\n   */\n  protected handleCrosshairMove(event: { time: any; point: { x: number; y: number } | null; seriesData: Map<any, any> }): void {\n    // Update template context with series data\n    if (event.seriesData.size > 0 && this.series) {\n      const seriesValue = event.seriesData.get(this.series)\n      if (seriesValue) {\n        this.updateTemplateContext({\n          seriesData: seriesValue,\n          formatting: this.config.style ? {\n            valueFormat: '.2f', // Default format, can be overridden\n            timeFormat: 'YYYY-MM-DD HH:mm:ss'\n          } : undefined\n        })\n      }\n    }\n\n    // Call subclass hook\n    this.onCrosshairMove(event)\n  }\n\n  /**\n   * Handle chart resize events\n   */\n  protected handleChartResize(event: { width: number; height: number }): void {\n    // Trigger layout recalculation\n    if (this.layoutManager) {\n      this.layoutManager.updateChartDimensions(event)\n    }\n\n    // Call subclass hook\n    this.onChartResize(event)\n  }\n\n  /**\n   * Get event manager instance\n   */\n  public getEventManager(): PrimitiveEventManager | null {\n    return this.eventManager\n  }\n\n  // ===== Visibility Management =====\n\n  /**\n   * Set primitive visibility\n   */\n  public setVisible(visible: boolean): void {\n    if (this.visible !== visible) {\n      this.visible = visible\n\n      // Update container visibility\n      if (this.containerElement) {\n        this.containerElement.style.display = visible ? 'block' : 'none'\n      }\n\n      // Update layout manager\n      if (this.layoutManager) {\n        this.layoutManager.updateWidgetVisibility(this.id, visible)\n      }\n\n      // Call lifecycle hook\n      this.onVisibilityChanged(visible)\n    }\n  }\n\n  /**\n   * Toggle primitive visibility\n   */\n  public toggle(): void {\n    this.setVisible(!this.visible)\n  }\n\n  // ===== Configuration Management =====\n\n  /**\n   * Update primitive configuration\n   */\n  public updateConfig(newConfig: Partial<TConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n\n    // Re-apply styling if container exists\n    if (this.containerElement) {\n      this.applyBaseContainerStyling()\n    }\n\n    // Trigger update\n    if (this.mounted) {\n      this.updateAllViews()\n    }\n\n    // Call lifecycle hook\n    this.onConfigUpdate(newConfig)\n  }\n\n  /**\n   * Get current configuration\n   */\n  public getConfig(): TConfig {\n    return { ...this.config }\n  }\n\n  // ===== Abstract Methods (to be implemented by subclasses) =====\n\n  /**\n   * Get the template string for this primitive\n   */\n  protected abstract getTemplate(): string\n\n  /**\n   * Render content to the container\n   */\n  protected abstract renderContent(): void\n\n  /**\n   * Get CSS class name for the container\n   */\n  protected abstract getContainerClassName(): string\n\n  // ===== Lifecycle Hooks (optional overrides) =====\n\n  /**\n   * Called when primitive is attached to chart\n   */\n  protected onAttached(params: { chart: IChartApi; series: ISeriesApi<any>; requestUpdate: () => void }): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when primitive is detached from chart\n   */\n  protected onDetached(): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called during each update cycle\n   */\n  protected onUpdate(): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when position is updated by layout manager\n   */\n  protected onPositionUpdate(position: Position): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when container element is created\n   */\n  protected onContainerCreated(container: HTMLElement): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when visibility changes\n   */\n  protected onVisibilityChanged(visible: boolean): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when configuration is updated\n   */\n  protected onConfigUpdate(newConfig: Partial<TConfig>): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when crosshair moves over the chart\n   */\n  protected onCrosshairMove(event: { time: any; point: { x: number; y: number } | null; seriesData: Map<any, any> }): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Called when chart is resized\n   */\n  protected onChartResize(event: { width: number; height: number }): void {\n    // Override in subclasses\n  }\n\n  /**\n   * Setup custom event subscriptions - override in subclasses\n   */\n  protected setupCustomEventSubscriptions(): void {\n    // Override in subclasses to add custom event subscriptions\n  }\n\n  // ===== Utility Methods =====\n\n  /**\n   * Get current position\n   */\n  public getPosition(): Position | null {\n    return this.currentPosition\n  }\n\n  /**\n   * Get container element\n   */\n  public getContainer(): HTMLElement | null {\n    return this.containerElement\n  }\n\n  /**\n   * Check if primitive is mounted\n   */\n  public isMounted(): boolean {\n    return this.mounted\n  }\n\n  /**\n   * Get chart API reference\n   */\n  public getChart(): IChartApi | null {\n    return this.chart\n  }\n\n  /**\n   * Get series API reference\n   */\n  public getSeries(): ISeriesApi<any> | null {\n    return this.series\n  }\n}\n\n/**\n * Priority levels for common primitives\n */\nexport const PrimitivePriority = {\n  RANGE_SWITCHER: 1,     // Highest priority - navigation aid\n  MINIMIZE_BUTTON: 2,    // High priority - always visible after range switcher\n  LEGEND: 3,             // Medium priority - important for data understanding\n  CUSTOM: 10,            // Default for custom primitives\n  DEBUG: 999             // Lowest priority - debug/development primitives\n} as const\n\n/**\n * Primitive type identifiers\n */\nexport const PrimitiveType = {\n  LEGEND: 'legend',\n  RANGE_SWITCHER: 'range-switcher',\n  BUTTON: 'button',\n  CUSTOM: 'custom'\n} as const","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/ButtonPrimitive.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":67,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'primitive' is defined but never used. Allowed unused args must match /^_/u.","line":67,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":60},{"ruleId":"no-unused-vars","severity":1,"message":"'newState' is defined but never used. Allowed unused args must match /^_/u.","line":72,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":41},{"ruleId":"no-unused-vars","severity":1,"message":"'oldState' is defined but never used. Allowed unused args must match /^_/u.","line":72,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":64},{"ruleId":"no-unused-vars","severity":1,"message":"'primitive' is defined but never used. Allowed unused args must match /^_/u.","line":72,"column":66,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":92}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BasePanePrimitive, BasePrimitiveConfig, PrimitivePriority } from './BasePanePrimitive'\nimport {\n  ButtonColors,\n  ButtonDimensions,\n  ButtonEffects,\n  ButtonSpacing\n} from './PrimitiveDefaults'\nimport { PrimitiveStylingUtils, BaseStyleConfig } from './PrimitiveStylingUtils'\n\n/**\n * Button types for different behaviors\n */\nexport type ButtonType = 'collapse' | 'toggle' | 'action' | 'custom'\n\n/**\n * Button states\n */\nexport interface ButtonState {\n  /**\n   * Whether button is pressed/active\n   */\n  pressed?: boolean\n\n  /**\n   * Whether button is disabled\n   */\n  disabled?: boolean\n\n  /**\n   * Custom state data\n   */\n  customData?: any\n}\n\n/**\n * Configuration for ButtonPrimitive\n */\nexport interface ButtonPrimitiveConfig extends BasePrimitiveConfig {\n  /**\n   * Button type\n   */\n  buttonType: ButtonType\n\n  /**\n   * Button text or HTML content\n   */\n  content: string\n\n  /**\n   * Initial button state\n   */\n  initialState?: ButtonState\n\n  /**\n   * Whether this is a pane-specific button (vs chart-level)\n   */\n  isPanePrimitive?: boolean\n\n  /**\n   * Pane ID for pane-specific buttons\n   */\n  paneId?: number\n\n  /**\n   * Click handler\n   */\n  onClick?: (state: ButtonState, primitive: ButtonPrimitive) => void\n\n  /**\n   * State change handler\n   */\n  onStateChange?: (newState: ButtonState, oldState: ButtonState, primitive: ButtonPrimitive) => void\n\n  /**\n   * Button styling\n   */\n  style?: BasePrimitiveConfig['style'] & {\n    /**\n     * Button-specific styling\n     */\n    button?: {\n      width?: number\n      height?: number\n      backgroundColor?: string\n      color?: string\n      hoverBackgroundColor?: string\n      hoverColor?: string\n      pressedBackgroundColor?: string\n      pressedColor?: string\n      disabledBackgroundColor?: string\n      disabledColor?: string\n      border?: string\n      borderRadius?: number\n      fontSize?: number\n      fontWeight?: string | number\n      cursor?: string\n      transition?: string\n      boxShadow?: string\n      hoverBoxShadow?: string\n      pressedBoxShadow?: string\n    }\n\n    /**\n     * Icon styling (if using icons)\n     */\n    icon?: {\n      size?: number\n      color?: string\n      hoverColor?: string\n      pressedColor?: string\n      disabledColor?: string\n    }\n  }\n}\n\n/**\n * ButtonPrimitive - A lightweight-charts pane primitive for interactive buttons\n *\n * This primitive provides:\n * - Interactive buttons with state management\n * - Collapse/expand functionality for panes\n * - Toggle buttons for features\n * - Action buttons for custom operations\n * - Full styling control and state feedback\n * - Pane-specific or chart-level positioning\n *\n * Example usage:\n * ```typescript\n * // Collapse button for a pane\n * const collapseButton = new ButtonPrimitive('collapse-btn', {\n *   corner: 'top-right',\n *   priority: PrimitivePriority.MINIMIZE_BUTTON,\n *   buttonType: 'collapse',\n *   content: '−',\n *   isPanePrimitive: true,\n *   paneId: 1,\n *   onClick: (state, primitive) => {\n *     // Toggle pane visibility\n *     const newState = { pressed: !state.pressed }\n *     primitive.setState(newState)\n *     // Handle pane collapse logic\n *   }\n * })\n *\n * // Toggle button for a feature\n * const toggleButton = new ButtonPrimitive('toggle-btn', {\n *   corner: 'top-left',\n *   buttonType: 'toggle',\n *   content: '📊',\n *   onClick: (state, primitive) => {\n *     primitive.setState({ pressed: !state.pressed })\n *   }\n * })\n * ```\n */\nexport class ButtonPrimitive extends BasePanePrimitive<ButtonPrimitiveConfig> {\n\n  private currentState: ButtonState = {}\n  private buttonElement: HTMLElement | null = null\n\n  constructor(id: string, config: ButtonPrimitiveConfig) {\n    // Set default priority and configuration for buttons\n    const configWithDefaults: ButtonPrimitiveConfig = {\n      priority: config.buttonType === 'collapse' ? PrimitivePriority.MINIMIZE_BUTTON : PrimitivePriority.CUSTOM,\n      visible: true,\n      isPanePrimitive: config.buttonType === 'collapse',\n      paneId: 0,\n      initialState: { pressed: false, disabled: false },\n      style: {\n        backgroundColor: 'transparent',\n        padding: ButtonSpacing.CONTAINER_PADDING,\n        button: {\n          width: ButtonDimensions.DEFAULT_WIDTH,\n          height: ButtonDimensions.DEFAULT_HEIGHT,\n          backgroundColor: ButtonColors.DEFAULT_BACKGROUND,\n          color: ButtonColors.DEFAULT_COLOR,\n          hoverBackgroundColor: ButtonColors.HOVER_BACKGROUND,\n          hoverColor: ButtonColors.HOVER_COLOR,\n          pressedBackgroundColor: ButtonColors.PRESSED_BACKGROUND,\n          pressedColor: ButtonColors.PRESSED_COLOR,\n          disabledBackgroundColor: ButtonColors.DISABLED_BACKGROUND,\n          disabledColor: ButtonColors.DISABLED_COLOR,\n          border: ButtonEffects.DEFAULT_BORDER,\n          borderRadius: ButtonDimensions.BORDER_RADIUS,\n          fontSize: ButtonDimensions.FONT_SIZE,\n          fontWeight: 'bold',\n          cursor: 'pointer',\n          transition: ButtonEffects.DEFAULT_TRANSITION,\n          boxShadow: 'none',\n          hoverBoxShadow: ButtonEffects.HOVER_BOX_SHADOW,\n          pressedBoxShadow: ButtonEffects.PRESSED_BOX_SHADOW\n        },\n        ...config.style\n      },\n      ...config\n    }\n\n    super(id, configWithDefaults)\n    this.currentState = { ...configWithDefaults.initialState }\n  }\n\n  // ===== BasePanePrimitive Implementation =====\n\n  /**\n   * Get the template string (not used for interactive elements)\n   */\n  protected getTemplate(): string {\n    return '' // Button is fully interactive, no template needed\n  }\n\n  /**\n   * Render the button element\n   */\n  protected renderContent(): void {\n    if (!this.containerElement) return\n\n    // Clear existing content\n    this.containerElement.innerHTML = ''\n\n    // Create button element\n    this.buttonElement = document.createElement('button')\n    this.buttonElement.className = 'primitive-button'\n    this.buttonElement.innerHTML = this.config.content\n    this.buttonElement.setAttribute('aria-label', this.getAriaLabel())\n\n    // Apply styling\n    this.updateButtonStyling()\n\n    // Update content based on state (for collapse buttons)\n    this.updateContentBasedOnState()\n\n    // Update CSS classes based on state (for collapse buttons)\n    this.updateCSSClassesBasedOnState()\n\n    // Add event handlers\n    this.setupButtonEventHandlers()\n\n    this.containerElement.appendChild(this.buttonElement)\n  }\n\n  /**\n   * Get aria label for accessibility\n   */\n  private getAriaLabel(): string {\n    switch (this.config.buttonType) {\n      case 'collapse':\n        return this.currentState.pressed ? 'Expand pane' : 'Collapse pane'\n      case 'toggle':\n        return this.currentState.pressed ? 'Disable feature' : 'Enable feature'\n      case 'action':\n        return 'Execute action'\n      default:\n        return 'Button'\n    }\n  }\n\n  /**\n   * Setup button event handlers\n   */\n  private setupButtonEventHandlers(): void {\n    if (!this.buttonElement) return\n\n    this.attachClickHandlers()\n    this.attachMouseInteractionHandlers()\n    this.attachKeyboardHandlers()\n    this.attachFocusHandlers()\n  }\n\n  /**\n   * Attach click event handlers\n   */\n  private attachClickHandlers(): void {\n    if (!this.buttonElement) return\n\n    this.buttonElement.addEventListener('click', (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n      this.handleClick()\n    })\n  }\n\n  /**\n   * Attach mouse interaction handlers (hover, press)\n   */\n  private attachMouseInteractionHandlers(): void {\n    if (!this.buttonElement) return\n\n    // Hover handlers\n    this.buttonElement.addEventListener('mouseenter', () => {\n      this.updateButtonStyling(true, false)\n    })\n\n    this.buttonElement.addEventListener('mouseleave', () => {\n      this.updateButtonStyling(false, false)\n    })\n\n    // Mouse down/up for pressed effect\n    this.buttonElement.addEventListener('mousedown', () => {\n      this.updateButtonStyling(false, true)\n    })\n\n    this.buttonElement.addEventListener('mouseup', () => {\n      this.updateButtonStyling(false, false)\n    })\n  }\n\n  /**\n   * Attach keyboard interaction handlers\n   */\n  private attachKeyboardHandlers(): void {\n    if (!this.buttonElement) return\n\n    this.buttonElement.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter' || e.key === ' ') {\n        e.preventDefault()\n        this.handleClick()\n      }\n    })\n  }\n\n  /**\n   * Attach focus/blur handlers for accessibility\n   */\n  private attachFocusHandlers(): void {\n    if (!this.buttonElement) return\n\n    this.buttonElement.addEventListener('focus', () => {\n      this.buttonElement!.style.outline = ButtonEffects.FOCUS_OUTLINE\n    })\n\n    this.buttonElement.addEventListener('blur', () => {\n      this.buttonElement!.style.outline = 'none'\n    })\n  }\n\n  /**\n   * Handle button click\n   */\n  private handleClick(): void {\n    if (this.currentState.disabled) return\n\n    // For toggle and collapse buttons, automatically toggle pressed state\n    if (this.config.buttonType === 'toggle' || this.config.buttonType === 'collapse') {\n      this.setState({ pressed: !this.currentState.pressed })\n    }\n\n    // Call onClick handler\n    if (this.config.onClick) {\n      this.config.onClick(this.currentState, this)\n    }\n\n    // Emit custom event\n    if (this.eventManager) {\n      this.eventManager.emitCustomEvent('buttonClick', {\n        buttonId: this.id,\n        buttonType: this.config.buttonType,\n        state: this.currentState\n      })\n    }\n  }\n\n  /**\n   * Update button styling based on state\n   */\n  private updateButtonStyling(isHover: boolean = false, isMouseDown: boolean = false): void {\n    if (!this.buttonElement) return\n\n    const buttonConfig = this.config.style?.button\n    if (!buttonConfig) return\n\n    this.applyBaseButtonStyling(buttonConfig)\n    this.applyButtonStateStyles(buttonConfig, isHover, isMouseDown)\n  }\n\n  /**\n   * Apply base button styling (dimensions, layout, transitions)\n   */\n  private applyBaseButtonStyling(buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button']): void {\n    if (!this.buttonElement || !buttonConfig) return\n\n    // Create standardized style configuration\n    const baseStyles: BaseStyleConfig = {\n      fontSize: buttonConfig.fontSize || ButtonDimensions.FONT_SIZE,\n      fontWeight: buttonConfig.fontWeight || 'bold',\n      border: buttonConfig.border || 'none',\n      borderRadius: buttonConfig.borderRadius || ButtonDimensions.BORDER_RADIUS,\n      transition: buttonConfig.transition || ButtonEffects.DEFAULT_TRANSITION\n    }\n\n    // Apply standardized base styles\n    PrimitiveStylingUtils.applyBaseStyles(this.buttonElement, baseStyles)\n\n    // Apply layout using standardized utilities\n    PrimitiveStylingUtils.applyLayout(this.buttonElement, {\n      width: buttonConfig.width || ButtonDimensions.DEFAULT_WIDTH,\n      height: buttonConfig.height || ButtonDimensions.DEFAULT_HEIGHT\n    })\n\n    // Create flex container with standardized utilities\n    PrimitiveStylingUtils.createFlexContainer(this.buttonElement, 'row', 'center', 'center')\n\n    // Apply specific padding for collapse buttons (pane action buttons need zero padding)\n    if (this.config.buttonType === 'collapse') {\n      this.buttonElement.style.padding = ButtonSpacing.PANE_ACTION_PADDING\n    }\n  }\n\n  /**\n   * Apply state-specific button styling (colors, shadows, cursor)\n   */\n  private applyButtonStateStyles(\n    buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button'],\n    isHover: boolean,\n    isMouseDown: boolean\n  ): void {\n    if (!this.buttonElement || !buttonConfig) return\n\n    const style = this.buttonElement.style\n\n    if (this.currentState.disabled) {\n      this.applyDisabledButtonStyle(style, buttonConfig)\n    } else if (this.currentState.pressed || isMouseDown) {\n      this.applyPressedButtonStyle(style, buttonConfig)\n    } else if (isHover) {\n      this.applyHoverButtonStyle(style, buttonConfig)\n    } else {\n      this.applyDefaultButtonStyle(style, buttonConfig)\n    }\n  }\n\n  /**\n   * Apply disabled button styling\n   */\n  private applyDisabledButtonStyle(\n    style: CSSStyleDeclaration,\n    buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button']\n  ): void {\n    if (!buttonConfig || !this.buttonElement) return\n\n    const baseStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.backgroundColor || ButtonColors.DEFAULT_BACKGROUND,\n      color: buttonConfig.color || ButtonColors.DEFAULT_COLOR\n    }\n\n    const disabledStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.disabledBackgroundColor || ButtonColors.DISABLED_BACKGROUND,\n      color: buttonConfig.disabledColor || ButtonColors.DISABLED_COLOR,\n      boxShadow: 'none'\n    }\n\n    PrimitiveStylingUtils.applyInteractionState(this.buttonElement, baseStyles, disabledStyles, 'disabled')\n  }\n\n  /**\n   * Apply pressed/active button styling\n   */\n  private applyPressedButtonStyle(\n    style: CSSStyleDeclaration,\n    buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button']\n  ): void {\n    if (!buttonConfig || !this.buttonElement) return\n\n    const baseStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.backgroundColor || ButtonColors.DEFAULT_BACKGROUND,\n      color: buttonConfig.color || ButtonColors.DEFAULT_COLOR,\n      cursor: buttonConfig.cursor || 'pointer'\n    }\n\n    const pressedStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.pressedBackgroundColor || ButtonColors.PRESSED_BACKGROUND,\n      color: buttonConfig.pressedColor || ButtonColors.PRESSED_COLOR\n    }\n\n    PrimitiveStylingUtils.applyInteractionState(this.buttonElement, baseStyles, pressedStyles, 'active')\n    PrimitiveStylingUtils.applyShadow(this.buttonElement, {\n      boxShadow: buttonConfig.pressedBoxShadow || ButtonEffects.PRESSED_BOX_SHADOW\n    })\n  }\n\n  /**\n   * Apply hover button styling\n   */\n  private applyHoverButtonStyle(\n    style: CSSStyleDeclaration,\n    buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button']\n  ): void {\n    if (!buttonConfig || !this.buttonElement) return\n\n    const baseStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.backgroundColor || ButtonColors.DEFAULT_BACKGROUND,\n      color: buttonConfig.color || ButtonColors.DEFAULT_COLOR,\n      cursor: buttonConfig.cursor || 'pointer'\n    }\n\n    const hoverStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.hoverBackgroundColor || ButtonColors.HOVER_BACKGROUND,\n      color: buttonConfig.hoverColor || ButtonColors.HOVER_COLOR\n    }\n\n    PrimitiveStylingUtils.applyInteractionState(this.buttonElement, baseStyles, hoverStyles, 'hover')\n    PrimitiveStylingUtils.applyShadow(this.buttonElement, {\n      boxShadow: buttonConfig.hoverBoxShadow || ButtonEffects.HOVER_BOX_SHADOW\n    })\n  }\n\n  /**\n   * Apply default button styling\n   */\n  private applyDefaultButtonStyle(\n    style: CSSStyleDeclaration,\n    buttonConfig: NonNullable<ButtonPrimitiveConfig['style']>['button']\n  ): void {\n    if (!buttonConfig || !this.buttonElement) return\n\n    const baseStyles: BaseStyleConfig = {\n      backgroundColor: buttonConfig.backgroundColor || ButtonColors.DEFAULT_BACKGROUND,\n      color: buttonConfig.color || ButtonColors.DEFAULT_COLOR,\n      cursor: buttonConfig.cursor || 'pointer'\n    }\n\n    PrimitiveStylingUtils.applyInteractionState(this.buttonElement, baseStyles, {}, 'default')\n    PrimitiveStylingUtils.applyShadow(this.buttonElement, {\n      boxShadow: buttonConfig.boxShadow || 'none'\n    })\n  }\n\n  /**\n   * Get CSS class name for the container\n   */\n  protected getContainerClassName(): string {\n    return `button-primitive button-${this.config.buttonType}`\n  }\n\n  /**\n   * Override pane ID for pane-specific buttons\n   */\n  protected getPaneId(): number {\n    if (this.config.isPanePrimitive && this.config.paneId !== undefined) {\n      return this.config.paneId\n    }\n    return 0 // Default to chart-level\n  }\n\n  // ===== Lifecycle Hooks =====\n\n  /**\n   * Called when container is created\n   */\n  protected onContainerCreated(container: HTMLElement): void {\n    // Ensure container allows pointer events for button\n    container.style.pointerEvents = 'auto'\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Set button state\n   */\n  public setState(newState: Partial<ButtonState>): void {\n    const oldState = { ...this.currentState }\n    this.currentState = { ...this.currentState, ...newState }\n\n    // Update styling\n    this.updateButtonStyling()\n\n    // Update content based on state (for collapse buttons)\n    this.updateContentBasedOnState()\n\n    // Update CSS classes based on state (for collapse buttons)\n    this.updateCSSClassesBasedOnState()\n\n    // Update aria label\n    if (this.buttonElement) {\n      this.buttonElement.setAttribute('aria-label', this.getAriaLabel())\n    }\n\n    // Call state change handler\n    if (this.config.onStateChange) {\n      this.config.onStateChange(this.currentState, oldState, this)\n    }\n\n    // Emit state change event\n    if (this.eventManager) {\n      this.eventManager.emitCustomEvent('buttonStateChange', {\n        buttonId: this.id,\n        buttonType: this.config.buttonType,\n        newState: this.currentState,\n        oldState: oldState\n      })\n    }\n  }\n\n  /**\n   * Get current button state\n   */\n  public getState(): ButtonState {\n    return { ...this.currentState }\n  }\n\n  /**\n   * Set button content\n   */\n  public setContent(content: string): void {\n    this.config.content = content\n    if (this.buttonElement) {\n      this.buttonElement.innerHTML = content\n    }\n  }\n\n  /**\n   * Update button content based on state (for collapse buttons)\n   */\n  private updateContentBasedOnState(): void {\n    if (this.config.buttonType === 'collapse' && this.buttonElement) {\n      // SVG for uncollapsed state (showing both brackets)\n      const uncollapseIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 15 15\" width=\"15\" height=\"15\" fill=\"none\"><path stroke=\"currentColor\" d=\"m4 5 3.5-3L11 5\" class=\"bracket-up\"></path><path stroke=\"currentColor\" d=\"M11 10l-3.5 3L4 10\" class=\"bracket-down\"></path></svg>'\n\n      // SVG for collapsed state (showing single bracket pointing down)\n      const collapseIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 15 15\" width=\"15\" height=\"15\" fill=\"none\"><path stroke=\"currentColor\" d=\"M11 10l-3.5 3L4 10\" class=\"bracket-down\"></path></svg>'\n\n      // Update content based on pressed state\n      this.buttonElement.innerHTML = this.currentState.pressed ? collapseIcon : uncollapseIcon\n    }\n  }\n\n  /**\n   * Update CSS classes based on button state (for collapse buttons)\n   */\n  private updateCSSClassesBasedOnState(): void {\n    if (this.config.buttonType === 'collapse' && this.buttonElement) {\n      // Add or remove 'collapsed' class based on pressed state\n      if (this.currentState.pressed) {\n        this.buttonElement.classList.add('collapsed')\n      } else {\n        this.buttonElement.classList.remove('collapsed')\n      }\n    }\n  }\n\n  /**\n   * Enable/disable button\n   */\n  public setEnabled(enabled: boolean): void {\n    this.setState({ disabled: !enabled })\n  }\n\n  /**\n   * Check if button is pressed\n   */\n  public isPressed(): boolean {\n    return this.currentState.pressed || false\n  }\n\n  /**\n   * Check if button is disabled\n   */\n  public isDisabled(): boolean {\n    return this.currentState.disabled || false\n  }\n\n  /**\n   * Programmatically trigger click\n   */\n  public click(): void {\n    this.handleClick()\n  }\n\n  /**\n   * Set pressed state (for toggle/collapse buttons)\n   */\n  public setPressed(pressed: boolean): void {\n    this.setState({ pressed })\n  }\n}\n\n/**\n * Factory function to create button primitives\n */\nexport function createButtonPrimitive(\n  id: string,\n  config: Partial<ButtonPrimitiveConfig> & { buttonType: ButtonType; content: string; corner: any }\n): ButtonPrimitive {\n  return new ButtonPrimitive(id, config as ButtonPrimitiveConfig)\n}\n\n/**\n * Convenience factory functions for common button types\n */\nexport const ButtonFactories = {\n  /**\n   * Create a collapse button for pane minimization\n   */\n  collapse: (id: string, paneId: number, corner: any, onClick?: ButtonPrimitiveConfig['onClick']) =>\n    new ButtonPrimitive(id, {\n      buttonType: 'collapse',\n      content: '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 15 15\" width=\"15\" height=\"15\" fill=\"none\"><path stroke=\"currentColor\" d=\"m4 5 3.5-3L11 5\" class=\"bracket-up\"></path><path stroke=\"currentColor\" d=\"M11 10l-3.5 3L4 10\" class=\"bracket-down\"></path></svg>',\n      corner,\n      priority: PrimitivePriority.MINIMIZE_BUTTON,\n      isPanePrimitive: true,\n      paneId,\n      onClick,\n      style: {\n        button: {\n          backgroundColor: ButtonColors.PANE_ACTION_BACKGROUND,\n          width: ButtonDimensions.PANE_ACTION_WIDTH,\n          height: ButtonDimensions.PANE_ACTION_HEIGHT,\n          color: ButtonColors.PANE_ACTION_COLOR,\n          hoverBackgroundColor: ButtonColors.PANE_ACTION_HOVER_BACKGROUND,\n          pressedBackgroundColor: ButtonColors.PANE_ACTION_PRESSED_BACKGROUND,\n          border: `1px solid ${ButtonColors.PANE_ACTION_BORDER}`,\n          borderRadius: ButtonDimensions.PANE_ACTION_BORDER_RADIUS\n        }\n      }\n    }),\n\n  /**\n   * Create a toggle button for feature switching\n   */\n  toggle: (id: string, content: string, corner: any, onClick?: ButtonPrimitiveConfig['onClick']) =>\n    new ButtonPrimitive(id, {\n      buttonType: 'toggle',\n      content,\n      corner,\n      priority: PrimitivePriority.CUSTOM,\n      onClick\n    }),\n\n  /**\n   * Create an action button for one-time operations\n   */\n  action: (id: string, content: string, corner: any, onClick?: ButtonPrimitiveConfig['onClick']) =>\n    new ButtonPrimitive(id, {\n      buttonType: 'action',\n      content,\n      corner,\n      priority: PrimitivePriority.CUSTOM,\n      onClick,\n      style: {\n        button: {\n          backgroundColor: ButtonColors.ACTION_BACKGROUND,\n          color: ButtonColors.PRESSED_COLOR,\n          hoverBackgroundColor: ButtonColors.ACTION_HOVER_BACKGROUND\n        }\n      }\n    })\n} as const","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/LegendPrimitive.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'container' is defined but never used. Allowed unused args must match /^_/u.","line":349,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":349,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BasePanePrimitive, BasePrimitiveConfig, PrimitivePriority } from './BasePanePrimitive'\nimport {\n  LegendColors,\n  LegendDimensions,\n  FormatDefaults,\n  ContainerDefaults,\n  CommonValues\n} from './PrimitiveDefaults'\nimport { PrimitiveStylingUtils, BaseStyleConfig, TypographyConfig, BorderConfig } from './PrimitiveStylingUtils'\n\n/**\n * Configuration for LegendPrimitive\n */\nexport interface LegendPrimitiveConfig extends BasePrimitiveConfig {\n  /**\n   * Legend text template (supports placeholders like $$value$$, $$open$$, etc.)\n   */\n  text: string\n\n  /**\n   * Value formatting configuration\n   */\n  valueFormat?: string\n\n  /**\n   * Whether this is a pane-specific primitive (vs chart-level)\n   */\n  isPanePrimitive?: boolean\n\n  /**\n   * Pane ID for pane-specific legends\n   */\n  paneId?: number\n\n  /**\n   * Legend styling\n   */\n  style?: BasePrimitiveConfig['style'] & {\n    /**\n     * Text alignment\n     */\n    textAlign?: 'left' | 'center' | 'right'\n\n    /**\n     * Font weight\n     */\n    fontWeight?: 'normal' | 'bold' | 'lighter' | number\n\n    /**\n     * Text shadow\n     */\n    textShadow?: string\n\n    /**\n     * Background opacity\n     */\n    backgroundOpacity?: number\n\n    /**\n     * Border configuration\n     */\n    border?: {\n      width?: number\n      color?: string\n      style?: 'solid' | 'dashed' | 'dotted'\n    }\n  }\n}\n\n/**\n * LegendPrimitive - A lightweight-charts pane primitive for displaying legends\n *\n * This primitive provides:\n * - Smart template processing with $$value$$, $$open$$, $$close$$, etc. placeholders\n * - Automatic crosshair value updates\n * - Corner-based positioning with layout management\n * - Pane-specific or chart-level positioning\n * - Configurable styling and formatting\n *\n * Example usage:\n * ```typescript\n * const legend = new LegendPrimitive('my-legend', {\n *   corner: 'top-left',\n *   priority: PrimitivePriority.LEGEND,\n *   text: 'Price: $$value$$',\n *   valueFormat: '.2f',\n *   style: {\n *     backgroundColor: 'rgba(0, 0, 0, 0.8)',\n *     color: 'white',\n *     padding: 8\n *   }\n * })\n *\n * // Add to pane\n * pane.attachPrimitive(legend)\n * ```\n */\nexport class LegendPrimitive extends BasePanePrimitive<LegendPrimitiveConfig> {\n\n  constructor(id: string, config: LegendPrimitiveConfig) {\n\n    // Set default priority for legends\n    const configWithDefaults: LegendPrimitiveConfig = {\n      priority: PrimitivePriority.LEGEND,\n      visible: true,\n      isPanePrimitive: true,\n      paneId: config.paneId !== undefined ? config.paneId : 0, // Use provided paneId or default to 0\n      valueFormat: FormatDefaults.VALUE_FORMAT,\n      style: {\n        backgroundColor: LegendColors.DEFAULT_BACKGROUND,\n        color: LegendColors.DEFAULT_COLOR,\n        fontSize: LegendDimensions.FONT_SIZE,\n        fontFamily: ContainerDefaults.FONT_FAMILY,\n        padding: LegendDimensions.DEFAULT_PADDING,\n        borderRadius: LegendDimensions.BORDER_RADIUS,\n        textAlign: ContainerDefaults.TEXT_ALIGN,\n        fontWeight: ContainerDefaults.FONT_WEIGHT,\n        backgroundOpacity: LegendColors.DEFAULT_OPACITY,\n        ...config.style\n      },\n      ...config\n    }\n\n\n    super(id, configWithDefaults)\n  }\n\n  // ===== BasePanePrimitive Implementation =====\n\n  /**\n   * Get the template string for this legend\n   */\n  protected getTemplate(): string {\n    return this.config.text || '$$value$$'\n  }\n\n  /**\n   * Render the legend content to the container\n   */\n  protected renderContent(): void {\n    if (!this.containerElement) return\n\n    const content = this.getProcessedContent()\n\n    // Create or update legend element\n    let legendElement = this.containerElement.querySelector('.legend-content') as HTMLElement\n    if (!legendElement) {\n      legendElement = document.createElement('div')\n      legendElement.className = 'legend-content'\n      legendElement.setAttribute('role', 'img')\n      legendElement.setAttribute('aria-label', 'Chart legend')\n      this.containerElement.appendChild(legendElement)\n    }\n\n    // Update content (use innerHTML to allow HTML markup)\n    legendElement.innerHTML = content\n\n    // Apply styling\n    this.applyLegendStyling(legendElement)\n\n    // Trigger layout recalculation after content is rendered to ensure proper stacking\n    // Use setTimeout to allow DOM to update dimensions first\n    setTimeout(() => {\n      if (this.layoutManager) {\n        this.layoutManager.recalculateAllLayouts()\n      }\n    }, 0)\n  }\n\n  /**\n   * Apply legend-specific styling using standardized utilities\n   */\n  private applyLegendStyling(element: HTMLElement): void {\n    const config = this.config.style\n\n    if (config) {\n      // Prepare typography styles\n      const typography: TypographyConfig = {\n        textAlign: config.textAlign,\n        fontWeight: config.fontWeight\n      }\n\n      // Prepare border styles if configured\n      const borderStyles: BorderConfig = {}\n      if (config.border) {\n        borderStyles.borderWidth = config.border.width\n        borderStyles.borderColor = config.border.color\n        borderStyles.borderStyle = config.border.style\n      }\n\n      // Prepare base styles with background and color\n      const baseStyles: BaseStyleConfig = {\n        cursor: CommonValues.DEFAULT_CURSOR\n      }\n\n      // Handle background with opacity\n      if (config.backgroundColor) {\n        if (config.backgroundOpacity !== undefined) {\n          baseStyles.backgroundColor = this.adjustColorOpacity(config.backgroundColor, config.backgroundOpacity)\n        } else {\n          baseStyles.backgroundColor = config.backgroundColor\n        }\n      }\n\n      // Handle text color\n      if (config.color) {\n        baseStyles.color = config.color\n      }\n\n      // Apply text shadow if specified\n      if (config.textShadow) {\n        baseStyles.boxShadow = config.textShadow // Note: textShadow will be handled by PrimitiveStylingUtils\n      }\n\n      // Apply standardized styling\n      PrimitiveStylingUtils.applyTypography(element, typography)\n      PrimitiveStylingUtils.applyBorder(element, borderStyles)\n      PrimitiveStylingUtils.applyBaseStyles(element, baseStyles)\n\n      // Force background and text color with !important to override any external styles\n      if (baseStyles.backgroundColor) {\n        element.style.setProperty('background-color', baseStyles.backgroundColor, 'important')\n      }\n      if (baseStyles.color) {\n        element.style.setProperty('color', baseStyles.color, 'important')\n      }\n\n      // Remove padding since inner content (span) handles its own padding\n      element.style.setProperty('padding', '0', 'important')\n      // Explicitly remove any margins since spacing is handled by layout manager\n      element.style.setProperty('margin', '0', 'important')\n\n      // Apply legend-specific layout constraints\n      const style = element.style\n      style.userSelect = CommonValues.NONE\n      style.pointerEvents = CommonValues.NONE\n      style.whiteSpace = CommonValues.NOWRAP\n      style.overflow = CommonValues.HIDDEN\n      style.textOverflow = CommonValues.ELLIPSIS\n      style.maxWidth = `${LegendDimensions.MAX_WIDTH}px`\n\n      // Ensure no browser defaults add extra spacing\n      style.lineHeight = '1'\n      style.boxSizing = 'border-box'\n\n      // Apply text shadow directly since it's not handled by baseStyles\n      if (config.textShadow) {\n        style.textShadow = config.textShadow\n      }\n    }\n  }\n\n  /**\n   * Adjust color opacity\n   */\n  private adjustColorOpacity(color: string, opacity: number): string {\n    // Simple rgba conversion for common color formats\n    if (color.startsWith('rgba(')) {\n      return color.replace(/rgba\\(([^)]+)\\)/, (match, values) => {\n        const parts = values.split(',').map((s: string) => s.trim())\n        return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${opacity})`\n      })\n    } else if (color.startsWith('rgb(')) {\n      return color.replace(/rgb\\(([^)]+)\\)/, (match, values) => {\n        return `rgba(${values}, ${opacity})`\n      })\n    } else if (color.startsWith('#')) {\n      // Convert hex to rgba\n      const r = parseInt(color.slice(1, 3), 16)\n      const g = parseInt(color.slice(3, 5), 16)\n      const b = parseInt(color.slice(5, 7), 16)\n      return `rgba(${r}, ${g}, ${b}, ${opacity})`\n    }\n\n    // Fallback: return original color\n    return color\n  }\n\n  /**\n   * Get CSS class name for the container\n   */\n  protected getContainerClassName(): string {\n    return 'legend-primitive'\n  }\n\n  /**\n   * Override pane ID for pane-specific legends\n   */\n  protected getPaneId(): number {\n    if (this.config.isPanePrimitive && this.config.paneId !== undefined) {\n      return this.config.paneId\n    }\n    return 0 // Default to chart-level\n  }\n\n  // ===== Lifecycle Hooks =====\n\n  /**\n   * Setup custom event subscriptions for legend updates\n   */\n  protected setupCustomEventSubscriptions(): void {\n    if (!this.eventManager) return\n\n    // Subscribe to crosshair moves for real-time value updates\n    const crosshairSub = this.eventManager.subscribe('crosshairMove', (event) => {\n      this.updateLegendFromCrosshair(event)\n    })\n    this.eventSubscriptions.push(crosshairSub)\n  }\n\n  /**\n   * Handle crosshair move for legend value updates\n   */\n  protected onCrosshairMove(event: { time: any; point: { x: number; y: number } | null; seriesData: Map<any, any> }): void {\n    this.updateLegendFromCrosshair(event)\n  }\n\n  /**\n   * Update legend content from crosshair data\n   */\n  private updateLegendFromCrosshair(event: { time: any; point: { x: number; y: number } | null; seriesData: Map<any, any> }): void {\n    if (!event.time || !this.series || event.seriesData.size === 0) {\n      // Clear legend when no crosshair data\n      this.updateTemplateContext({\n        seriesData: undefined,\n        formatting: {\n          valueFormat: this.config.valueFormat || FormatDefaults.VALUE_FORMAT\n        }\n      })\n      return\n    }\n\n    // Get series data for this legend's series\n    const seriesValue = event.seriesData.get(this.series)\n    if (seriesValue) {\n      this.updateTemplateContext({\n        seriesData: seriesValue,\n        formatting: {\n          valueFormat: this.config.valueFormat || FormatDefaults.VALUE_FORMAT,\n          timeFormat: FormatDefaults.TIME_FORMAT\n        }\n      })\n    }\n  }\n\n  /**\n   * Called when container is created\n   */\n  protected onContainerCreated(container: HTMLElement): void {\n    // Container is ready for use\n  }\n\n\n  // ===== Public API =====\n\n  /**\n   * Update legend text template\n   */\n  public updateText(text: string): void {\n    this.updateConfig({ text })\n  }\n\n  /**\n   * Update value format\n   */\n  public updateValueFormat(format: string): void {\n    this.updateConfig({ valueFormat: format })\n  }\n\n  /**\n   * Get current legend content\n   */\n  public getCurrentContent(): string {\n    return this.getProcessedContent()\n  }\n\n  /**\n   * Force update legend content\n   */\n  public forceUpdate(): void {\n    if (this.mounted) {\n      this.processTemplate()\n      this.renderContent()\n    }\n  }\n}\n\n/**\n * Factory function to create legend primitives\n */\nexport function createLegendPrimitive(\n  id: string,\n  config: Partial<LegendPrimitiveConfig> & { text: string; corner: any }\n): LegendPrimitive {\n  return new LegendPrimitive(id, config as LegendPrimitiveConfig)\n}\n\n/**\n * Default legend configurations\n */\nexport const DefaultLegendConfigs = {\n  /**\n   * Simple value legend\n   */\n  simple: {\n    text: '$$value$$',\n    valueFormat: FormatDefaults.VALUE_FORMAT,\n    style: {\n      backgroundColor: LegendColors.DEFAULT_BACKGROUND,\n      color: LegendColors.DEFAULT_COLOR,\n      padding: LegendDimensions.DEFAULT_PADDING,\n      borderRadius: LegendDimensions.BORDER_RADIUS\n    }\n  },\n\n  /**\n   * OHLC candlestick legend\n   */\n  ohlc: {\n    text: 'O: $$open$$ H: $$high$$ L: $$low$$ C: $$close$$',\n    valueFormat: FormatDefaults.VALUE_FORMAT,\n    style: {\n      backgroundColor: LegendColors.DEFAULT_BACKGROUND,\n      color: LegendColors.DEFAULT_COLOR,\n      padding: LegendDimensions.OHLC_PADDING,\n      borderRadius: LegendDimensions.BORDER_RADIUS,\n      fontSize: LegendDimensions.OHLC_FONT_SIZE\n    }\n  },\n\n  /**\n   * Volume legend\n   */\n  volume: {\n    text: 'Vol: $$volume$$',\n    valueFormat: FormatDefaults.VOLUME_FORMAT,\n    style: {\n      backgroundColor: LegendColors.VOLUME_BACKGROUND,\n      color: LegendColors.DEFAULT_COLOR,\n      padding: LegendDimensions.DEFAULT_PADDING,\n      borderRadius: LegendDimensions.BORDER_RADIUS\n    }\n  },\n\n  /**\n   * Band/ribbon legend\n   */\n  band: {\n    text: 'U: $$upper$$ M: $$middle$$ L: $$lower$$',\n    valueFormat: FormatDefaults.BAND_FORMAT,\n    style: {\n      backgroundColor: LegendColors.BAND_BACKGROUND,\n      color: LegendColors.DEFAULT_COLOR,\n      padding: LegendDimensions.BAND_PADDING,\n      borderRadius: LegendDimensions.BORDER_RADIUS,\n      fontSize: LegendDimensions.BAND_FONT_SIZE\n    }\n  }\n} as const","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/PrimitiveArchitectureValidator.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'WARNING' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":10},{"ruleId":"no-unused-vars","severity":1,"message":"'ERROR' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":8},{"ruleId":"no-unused-vars","severity":1,"message":"'CRITICAL' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'primitive' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":54},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is assigned a value but never used.","line":96,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used.","line":96,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":135,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":160,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":160,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":199,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":199,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":235,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":235,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'services' is assigned a value but never used.","line":239,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":239,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'services' is assigned a value but never used.","line":239,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":239,"endColumn":23},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":256,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":288,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":288,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Architecture Validation Framework for Primitives\n *\n * Validates architectural constraints and patterns at runtime\n * to ensure compliance with design principles.\n */\n\nexport enum ValidationSeverity {\n  WARNING = 'warning',\n  ERROR = 'error',\n  CRITICAL = 'critical'\n}\n\nexport interface ValidationResult {\n  valid: boolean\n  violations: ValidationViolation[]\n  score: number // 0-100\n}\n\nexport interface ValidationViolation {\n  rule: string\n  severity: ValidationSeverity\n  message: string\n  context: Record<string, any>\n  suggestion?: string\n}\n\nexport interface ArchitecturalRule {\n  name: string\n  description: string\n  severity: ValidationSeverity\n  validate(primitive: any, context: ValidationContext): ValidationViolation[]\n}\n\nexport interface ValidationContext {\n  allPrimitives: Map<string, any>\n  serviceRegistry: any\n  chartInstance: any\n}\n\n/**\n * Validates architectural compliance of primitives\n */\nexport class PrimitiveArchitectureValidator {\n  private static instance: PrimitiveArchitectureValidator\n  private rules: ArchitecturalRule[] = []\n\n  static getInstance(): PrimitiveArchitectureValidator {\n    if (!this.instance) {\n      this.instance = new PrimitiveArchitectureValidator()\n      this.instance.registerDefaultRules()\n    }\n    return this.instance\n  }\n\n  /**\n   * Register a new architectural rule\n   */\n  registerRule(rule: ArchitecturalRule): void {\n    this.rules.push(rule)\n  }\n\n  /**\n   * Validate a single primitive\n   */\n  validatePrimitive(primitive: any, context: ValidationContext): ValidationResult {\n    const violations: ValidationViolation[] = []\n\n    for (const rule of this.rules) {\n      try {\n        const ruleViolations = rule.validate(primitive, context)\n        violations.push(...ruleViolations)\n      } catch (error) {\n        violations.push({\n          rule: rule.name,\n          severity: ValidationSeverity.ERROR,\n          message: `Rule validation failed: ${error.message}`,\n          context: { error: error.message }\n        })\n      }\n    }\n\n    return {\n      valid: violations.length === 0,\n      violations,\n      score: this.calculateScore(violations)\n    }\n  }\n\n  /**\n   * Validate all primitives in a system\n   */\n  validateSystem(context: ValidationContext): ValidationResult {\n    const allViolations: ValidationViolation[] = []\n\n    for (const [id, primitive] of context.allPrimitives) {\n      const result = this.validatePrimitive(primitive, context)\n      allViolations.push(...result.violations)\n    }\n\n    return {\n      valid: allViolations.length === 0,\n      violations: allViolations,\n      score: this.calculateScore(allViolations)\n    }\n  }\n\n  /**\n   * Calculate compliance score based on violations\n   */\n  private calculateScore(violations: ValidationViolation[]): number {\n    if (violations.length === 0) return 100\n\n    const severityWeights = {\n      [ValidationSeverity.WARNING]: 1,\n      [ValidationSeverity.ERROR]: 3,\n      [ValidationSeverity.CRITICAL]: 5\n    }\n\n    const totalPenalty = violations.reduce((sum, v) => sum + severityWeights[v.severity], 0)\n    const maxPenalty = violations.length * severityWeights[ValidationSeverity.CRITICAL]\n\n    return Math.max(0, 100 - (totalPenalty / maxPenalty) * 100)\n  }\n\n  /**\n   * Register default architectural rules\n   */\n  private registerDefaultRules(): void {\n    // Rule 1: Single Responsibility - Primitives should have one clear purpose\n    this.registerRule({\n      name: 'single-responsibility',\n      description: 'Primitives should have a single, well-defined responsibility',\n      severity: ValidationSeverity.ERROR,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check if primitive has too many public methods (indication of multiple responsibilities)\n        const publicMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(primitive))\n          .filter(name => !name.startsWith('_') && typeof primitive[name] === 'function')\n\n        if (publicMethods.length > 15) {\n          violations.push({\n            rule: 'single-responsibility',\n            severity: ValidationSeverity.WARNING,\n            message: `Primitive has ${publicMethods.length} public methods, consider decomposition`,\n            context: { methodCount: publicMethods.length, methods: publicMethods }\n          })\n        }\n\n        return violations\n      }\n    })\n\n    // Rule 2: Configuration Consistency\n    this.registerRule({\n      name: 'configuration-consistency',\n      description: 'Primitives should use standardized configuration patterns',\n      severity: ValidationSeverity.ERROR,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check if primitive has proper configuration interface\n        if (!primitive.config || typeof primitive.config !== 'object') {\n          violations.push({\n            rule: 'configuration-consistency',\n            severity: ValidationSeverity.CRITICAL,\n            message: 'Primitive missing configuration object',\n            context: { primitiveId: primitive.id },\n            suggestion: 'Implement proper configuration interface extending BasePrimitiveConfig'\n          })\n        }\n\n        // Check if configuration uses standardized constants\n        if (primitive.config?.style) {\n          const style = primitive.config.style\n          const hardcodedValues = this.findHardcodedValues(style)\n\n          if (hardcodedValues.length > 0) {\n            violations.push({\n              rule: 'configuration-consistency',\n              severity: ValidationSeverity.WARNING,\n              message: 'Configuration contains hardcoded values',\n              context: { hardcodedValues },\n              suggestion: 'Replace hardcoded values with constants from PrimitiveDefaults'\n            })\n          }\n        }\n\n        return violations\n      }\n    })\n\n    // Rule 3: Memory Management\n    this.registerRule({\n      name: 'memory-management',\n      description: 'Primitives should properly manage memory and cleanup resources',\n      severity: ValidationSeverity.CRITICAL,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check for cleanup methods\n        if (typeof primitive.detached !== 'function') {\n          violations.push({\n            rule: 'memory-management',\n            severity: ValidationSeverity.CRITICAL,\n            message: 'Primitive missing detached() cleanup method',\n            context: { primitiveId: primitive.id },\n            suggestion: 'Implement detached() method to cleanup resources'\n          })\n        }\n\n        // Check for event cleanup\n        if (primitive.eventSubscriptions && Array.isArray(primitive.eventSubscriptions)) {\n          if (primitive.eventSubscriptions.length > 0 && typeof primitive.cleanupEventSubscriptions !== 'function') {\n            violations.push({\n              rule: 'memory-management',\n              severity: ValidationSeverity.ERROR,\n              message: 'Primitive has event subscriptions but no cleanup method',\n              context: { subscriptionCount: primitive.eventSubscriptions.length },\n              suggestion: 'Implement cleanupEventSubscriptions() method'\n            })\n          }\n        }\n\n        return violations\n      }\n    })\n\n    // Rule 4: Service Dependency Management\n    this.registerRule({\n      name: 'service-dependencies',\n      description: 'Primitives should properly manage service dependencies',\n      severity: ValidationSeverity.ERROR,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check service initialization order\n        const services = ['layoutManager', 'coordinateService', 'templateEngine', 'eventManager']\n        const initializeServices = primitive.initializeServices\n\n        if (typeof initializeServices === 'function') {\n          // Services should be initialized in dependency order\n          // This is a simplified check - in practice you'd analyze the actual dependencies\n        }\n\n        return violations\n      }\n    })\n\n    // Rule 5: Error Handling Coverage\n    this.registerRule({\n      name: 'error-handling',\n      description: 'Primitives should have comprehensive error handling',\n      severity: ValidationSeverity.WARNING,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check critical methods have error handling\n        const criticalMethods = ['attached', 'detached', 'renderContent', 'updateConfig']\n\n        for (const methodName of criticalMethods) {\n          if (typeof primitive[methodName] === 'function') {\n            const methodSource = primitive[methodName].toString()\n\n            // Simple check for try-catch blocks\n            if (!methodSource.includes('try') || !methodSource.includes('catch')) {\n              violations.push({\n                rule: 'error-handling',\n                severity: ValidationSeverity.WARNING,\n                message: `Critical method ${methodName} lacks error handling`,\n                context: { method: methodName },\n                suggestion: 'Add try-catch blocks or use @withErrorBoundary decorator'\n              })\n            }\n          }\n        }\n\n        return violations\n      }\n    })\n\n    // Rule 6: Styling Standardization\n    this.registerRule({\n      name: 'styling-standardization',\n      description: 'Primitives should use standardized styling utilities',\n      severity: ValidationSeverity.ERROR,\n      validate: (primitive, context) => {\n        const violations: ValidationViolation[] = []\n\n        // Check if primitive uses PrimitiveStylingUtils\n        const className = primitive.constructor.name\n        const source = primitive.constructor.toString()\n\n        if (!source.includes('PrimitiveStylingUtils')) {\n          violations.push({\n            rule: 'styling-standardization',\n            severity: ValidationSeverity.ERROR,\n            message: 'Primitive not using standardized styling utilities',\n            context: { className },\n            suggestion: 'Migrate to use PrimitiveStylingUtils for consistent styling'\n          })\n        }\n\n        return violations\n      }\n    })\n  }\n\n  /**\n   * Find hardcoded values in configuration\n   */\n  private findHardcodedValues(obj: any, path: string = ''): string[] {\n    const hardcoded: string[] = []\n\n    if (typeof obj === 'string') {\n      // Check for common hardcoded patterns\n      const patterns = [\n        /^\\d+px$/,           // \"12px\"\n        /^rgba?\\([^)]+\\)$/,  // \"rgb(255,0,0)\"\n        /^#[0-9a-f]{3,6}$/i, // \"#fff\" or \"#ffffff\"\n        /^(none|auto|pointer|default)$/ // Common CSS values\n      ]\n\n      for (const pattern of patterns) {\n        if (pattern.test(obj)) {\n          hardcoded.push(`${path}: \"${obj}\"`)\n          break\n        }\n      }\n    } else if (typeof obj === 'object' && obj !== null) {\n      for (const [key, value] of Object.entries(obj)) {\n        const newPath = path ? `${path}.${key}` : key\n        hardcoded.push(...this.findHardcodedValues(value, newPath))\n      }\n    }\n\n    return hardcoded\n  }\n}\n\n/**\n * Validation utilities\n */\nexport const ArchitectureValidator = {\n  /**\n   * Quick validation of a primitive\n   */\n  validate: (primitive: any, context?: Partial<ValidationContext>): ValidationResult => {\n    const validator = PrimitiveArchitectureValidator.getInstance()\n    const fullContext: ValidationContext = {\n      allPrimitives: new Map([[primitive.id, primitive]]),\n      serviceRegistry: null,\n      chartInstance: null,\n      ...context\n    }\n    return validator.validatePrimitive(primitive, fullContext)\n  },\n\n  /**\n   * Generate compliance report\n   */\n  generateReport: (result: ValidationResult): string => {\n    const { valid, violations, score } = result\n\n    let report = `Architecture Compliance Report\\n`\n    report += `Score: ${score}/100\\n`\n    report += `Status: ${valid ? 'PASS' : 'FAIL'}\\n\\n`\n\n    if (violations.length > 0) {\n      report += `Violations (${violations.length}):\\n`\n      violations.forEach((v, i) => {\n        report += `${i + 1}. [${v.severity.toUpperCase()}] ${v.rule}: ${v.message}\\n`\n        if (v.suggestion) {\n          report += `   Suggestion: ${v.suggestion}\\n`\n        }\n      })\n    } else {\n      report += `No violations found. Excellent architectural compliance!\\n`\n    }\n\n    return report\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/PrimitiveDefaults.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/PrimitiveErrorBoundary.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'LOW' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":6},{"ruleId":"no-unused-vars","severity":1,"message":"'MEDIUM' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":9},{"ruleId":"no-unused-vars","severity":1,"message":"'HIGH' is defined but never used.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":7},{"ruleId":"no-unused-vars","severity":1,"message":"'CRITICAL' is defined but never used.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'INITIALIZATION' is defined but never used.","line":16,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'RENDERING' is defined but never used.","line":17,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'EVENT_HANDLING' is defined but never used.","line":18,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'SERVICE_COMMUNICATION' is defined but never used.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'CONFIGURATION' is defined but never used.","line":20,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'LIFECYCLE' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":38,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":35},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":39,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'primitive' is defined but never used. Allowed unused args must match /^_/u.","line":39,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":48},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":49,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":50},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":69,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":43},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used. Allowed unused args must match /^_/u.","line":173,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":173,"endColumn":64},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":219,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":219,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5739,5771],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":222,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":222,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5825,5865],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5921,5960],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":228,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":228,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[6013,6037],"text":""},"desc":"Remove the console.info()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Error Boundary System for Primitives\n *\n * Provides centralized error handling, recovery mechanisms,\n * and error reporting for the primitive system.\n */\n\nexport enum ErrorSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical'\n}\n\nexport enum ErrorCategory {\n  INITIALIZATION = 'initialization',\n  RENDERING = 'rendering',\n  EVENT_HANDLING = 'event_handling',\n  SERVICE_COMMUNICATION = 'service_communication',\n  CONFIGURATION = 'configuration',\n  LIFECYCLE = 'lifecycle'\n}\n\nexport interface PrimitiveError {\n  id: string\n  primitiveId: string\n  primitiveType: string\n  category: ErrorCategory\n  severity: ErrorSeverity\n  message: string\n  stack?: string\n  context?: Record<string, any>\n  timestamp: number\n  recoverable: boolean\n}\n\nexport interface ErrorRecoveryStrategy {\n  canRecover(error: PrimitiveError): boolean\n  recover(error: PrimitiveError, primitive: any): Promise<boolean>\n}\n\n/**\n * Centralized error boundary for primitive operations\n */\nexport class PrimitiveErrorBoundary {\n  private static instance: PrimitiveErrorBoundary\n  private errors: Map<string, PrimitiveError> = new Map()\n  private recoveryStrategies: ErrorRecoveryStrategy[] = []\n  private errorListeners: ((error: PrimitiveError) => void)[] = []\n\n  static getInstance(): PrimitiveErrorBoundary {\n    if (!this.instance) {\n      this.instance = new PrimitiveErrorBoundary()\n      this.instance.registerDefaultRecoveryStrategies()\n    }\n    return this.instance\n  }\n\n  /**\n   * Register an error recovery strategy\n   */\n  registerRecoveryStrategy(strategy: ErrorRecoveryStrategy): void {\n    this.recoveryStrategies.push(strategy)\n  }\n\n  /**\n   * Listen for errors\n   */\n  onError(listener: (error: PrimitiveError) => void): () => void {\n    this.errorListeners.push(listener)\n    return () => {\n      const index = this.errorListeners.indexOf(listener)\n      if (index > -1) {\n        this.errorListeners.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Safely execute an operation with error boundary\n   */\n  async safeExecute<T>(\n    primitiveId: string,\n    primitiveType: string,\n    operation: () => T | Promise<T>,\n    category: ErrorCategory,\n    context?: Record<string, any>\n  ): Promise<T | null> {\n    try {\n      const result = await operation()\n      return result\n    } catch (error) {\n      const primitiveError = this.createError(\n        primitiveId,\n        primitiveType,\n        category,\n        error,\n        context\n      )\n\n      return this.handleError(primitiveError, operation)\n    }\n  }\n\n  /**\n   * Handle an error with recovery attempts\n   */\n  private async handleError(\n    error: PrimitiveError,\n    operation?: any\n  ): Promise<any> {\n    // Store error\n    this.errors.set(error.id, error)\n\n    // Notify listeners\n    this.errorListeners.forEach(listener => listener(error))\n\n    // Log error based on severity\n    this.logError(error)\n\n    // Attempt recovery if possible\n    if (error.recoverable) {\n      for (const strategy of this.recoveryStrategies) {\n        if (strategy.canRecover(error)) {\n          const recovered = await strategy.recover(error, operation)\n          if (recovered) {\n            // Mark error as recovered\n            error.context = { ...error.context, recovered: true }\n            return null // Recovery successful, return null to indicate handled\n          }\n        }\n      }\n    }\n\n    // If critical and not recoverable, re-throw\n    if (error.severity === ErrorSeverity.CRITICAL && !error.recoverable) {\n      throw new Error(`Critical primitive error: ${error.message}`)\n    }\n\n    return null\n  }\n\n  /**\n   * Create a primitive error object\n   */\n  private createError(\n    primitiveId: string,\n    primitiveType: string,\n    category: ErrorCategory,\n    originalError: any,\n    context?: Record<string, any>\n  ): PrimitiveError {\n    const severity = this.determineSeverity(category, originalError)\n    const recoverable = this.isRecoverable(category, severity)\n\n    return {\n      id: `${primitiveId}_${Date.now()}_${Math.random().toString(36).slice(2)}`,\n      primitiveId,\n      primitiveType,\n      category,\n      severity,\n      message: originalError?.message || String(originalError),\n      stack: originalError?.stack,\n      context: context || {},\n      timestamp: Date.now(),\n      recoverable\n    }\n  }\n\n  /**\n   * Determine error severity based on category and error type\n   */\n  private determineSeverity(category: ErrorCategory, error: any): ErrorSeverity {\n    // Critical errors that break functionality\n    if (category === ErrorCategory.INITIALIZATION) {\n      return ErrorSeverity.CRITICAL\n    }\n\n    // High priority errors\n    if (category === ErrorCategory.RENDERING || category === ErrorCategory.LIFECYCLE) {\n      return ErrorSeverity.HIGH\n    }\n\n    // Medium priority errors\n    if (category === ErrorCategory.SERVICE_COMMUNICATION) {\n      return ErrorSeverity.MEDIUM\n    }\n\n    // Low priority errors (can be ignored)\n    return ErrorSeverity.LOW\n  }\n\n  /**\n   * Determine if an error is recoverable\n   */\n  private isRecoverable(category: ErrorCategory, severity: ErrorSeverity): boolean {\n    // Initialization errors are typically not recoverable\n    if (category === ErrorCategory.INITIALIZATION) {\n      return false\n    }\n\n    // Critical errors are typically not recoverable\n    if (severity === ErrorSeverity.CRITICAL) {\n      return false\n    }\n\n    // Most other errors can be recovered from\n    return true\n  }\n\n  /**\n   * Log error with appropriate level\n   */\n  private logError(error: PrimitiveError): void {\n    const logMessage = `[${error.severity.toUpperCase()}] ${error.primitiveType}(${error.primitiveId}): ${error.message}`\n\n    switch (error.severity) {\n      case ErrorSeverity.CRITICAL:\n        console.error(logMessage, error)\n        break\n      case ErrorSeverity.HIGH:\n        console.error(logMessage, error.context)\n        break\n      case ErrorSeverity.MEDIUM:\n        console.warn(logMessage, error.context)\n        break\n      case ErrorSeverity.LOW:\n        console.info(logMessage)\n        break\n    }\n  }\n\n  /**\n   * Register default recovery strategies\n   */\n  private registerDefaultRecoveryStrategies(): void {\n    // DOM recreation strategy\n    this.registerRecoveryStrategy({\n      canRecover: (error) => error.category === ErrorCategory.RENDERING,\n      recover: async (error, primitive) => {\n        try {\n          // Attempt to recreate container element\n          if (primitive && typeof primitive.recreateContainer === 'function') {\n            await primitive.recreateContainer()\n            return true\n          }\n        } catch {\n          return false\n        }\n        return false\n      }\n    })\n\n    // Event handler reset strategy\n    this.registerRecoveryStrategy({\n      canRecover: (error) => error.category === ErrorCategory.EVENT_HANDLING,\n      recover: async (error, primitive) => {\n        try {\n          // Reset event handlers\n          if (primitive && typeof primitive.resetEventHandlers === 'function') {\n            await primitive.resetEventHandlers()\n            return true\n          }\n        } catch {\n          return false\n        }\n        return false\n      }\n    })\n\n    // Service reconnection strategy\n    this.registerRecoveryStrategy({\n      canRecover: (error) => error.category === ErrorCategory.SERVICE_COMMUNICATION,\n      recover: async (error, primitive) => {\n        try {\n          // Attempt service reconnection\n          if (primitive && typeof primitive.reconnectServices === 'function') {\n            await primitive.reconnectServices()\n            return true\n          }\n        } catch {\n          return false\n        }\n        return false\n      }\n    })\n  }\n\n  /**\n   * Get error statistics\n   */\n  getErrorStats(): {\n    total: number\n    bySeverity: Record<ErrorSeverity, number>\n    byCategory: Record<ErrorCategory, number>\n    recovered: number\n  } {\n    const errors = Array.from(this.errors.values())\n\n    return {\n      total: errors.length,\n      bySeverity: Object.values(ErrorSeverity).reduce((acc, severity) => {\n        acc[severity] = errors.filter(e => e.severity === severity).length\n        return acc\n      }, {} as Record<ErrorSeverity, number>),\n      byCategory: Object.values(ErrorCategory).reduce((acc, category) => {\n        acc[category] = errors.filter(e => e.category === category).length\n        return acc\n      }, {} as Record<ErrorCategory, number>),\n      recovered: errors.filter(e => e.context?.recovered).length\n    }\n  }\n}\n\n/**\n * Decorator for automatic error boundary wrapping\n */\nexport function withErrorBoundary(\n  category: ErrorCategory,\n  context?: Record<string, any>\n) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value\n\n    descriptor.value = async function (...args: any[]) {\n      const boundary = PrimitiveErrorBoundary.getInstance()\n      const primitiveId = this.id || 'unknown'\n      const primitiveType = this.constructor.name\n\n      return boundary.safeExecute(\n        primitiveId,\n        primitiveType,\n        () => originalMethod.apply(this, args),\n        category,\n        context\n      )\n    }\n\n    return descriptor\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/PrimitiveServiceRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/PrimitiveStylingUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/RangeSwitcherPrimitive.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'FIVE_MINUTES' is defined but never used.","line":18,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'FIFTEEN_MINUTES' is defined but never used.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":18},{"ruleId":"no-unused-vars","severity":1,"message":"'THIRTY_MINUTES' is defined but never used.","line":20,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'ONE_HOUR' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'FOUR_HOURS' is defined but never used.","line":22,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":13},{"ruleId":"no-unused-vars","severity":1,"message":"'ONE_DAY' is defined but never used.","line":23,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":10},{"ruleId":"no-unused-vars","severity":1,"message":"'ONE_WEEK' is defined but never used.","line":24,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'TWO_WEEKS' is defined but never used.","line":25,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'ONE_MONTH' is defined but never used.","line":26,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'THREE_MONTHS' is defined but never used.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'SIX_MONTHS' is defined but never used.","line":28,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":13},{"ruleId":"no-unused-vars","severity":1,"message":"'ONE_YEAR' is defined but never used.","line":29,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'TWO_YEARS' is defined but never used.","line":30,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'FIVE_YEARS' is defined but never used.","line":31,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":13},{"ruleId":"no-unused-vars","severity":1,"message":"'ALL' is defined but never used.","line":32,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":6},{"ruleId":"no-unused-vars","severity":1,"message":"'range' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":38},{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":53},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused args must match /^_/u.","line":352,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":352,"endColumn":21},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":625,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":625,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BasePanePrimitive, BasePrimitiveConfig, PrimitivePriority } from './BasePanePrimitive'\nimport { Time } from 'lightweight-charts'\nimport {\n  TimeRangeSeconds,\n  DefaultRangeSwitcherConfig,\n  ButtonColors,\n  ButtonDimensions,\n  ButtonEffects,\n  ButtonSpacing,\n  CommonValues\n} from './PrimitiveDefaults'\nimport { PrimitiveStylingUtils, BaseStyleConfig } from './PrimitiveStylingUtils'\n\n/**\n * Predefined time range values for easy configuration\n */\nexport enum TimeRange {\n  FIVE_MINUTES = 'FIVE_MINUTES',\n  FIFTEEN_MINUTES = 'FIFTEEN_MINUTES',\n  THIRTY_MINUTES = 'THIRTY_MINUTES',\n  ONE_HOUR = 'ONE_HOUR',\n  FOUR_HOURS = 'FOUR_HOURS',\n  ONE_DAY = 'ONE_DAY',\n  ONE_WEEK = 'ONE_WEEK',\n  TWO_WEEKS = 'TWO_WEEKS',\n  ONE_MONTH = 'ONE_MONTH',\n  THREE_MONTHS = 'THREE_MONTHS',\n  SIX_MONTHS = 'SIX_MONTHS',\n  ONE_YEAR = 'ONE_YEAR',\n  TWO_YEARS = 'TWO_YEARS',\n  FIVE_YEARS = 'FIVE_YEARS',\n  ALL = 'ALL'\n}\n\n/**\n * Range configuration for time switching\n * Supports both enum values and custom seconds for flexibility\n */\nexport interface RangeConfig {\n  /**\n   * Display text for the range\n   */\n  text: string\n\n  /**\n   * Time range - can be enum value or custom seconds\n   * Use TimeRange enum for predefined ranges, or number for custom seconds\n   * Use null or TimeRange.ALL for \"All\" range\n   */\n  range: TimeRange | number | null\n\n  /**\n   * @deprecated Use 'range' instead. This is kept for backwards compatibility.\n   */\n  seconds?: number | null\n\n}\n\n/**\n * Get the range value from a RangeConfig, supporting both new and legacy formats\n */\nexport function getRangeValue(rangeConfig: RangeConfig): TimeRange | number | null {\n  // Support new 'range' property first\n  if (rangeConfig.range !== undefined) {\n    return rangeConfig.range\n  }\n  // Fall back to legacy 'seconds' property for backwards compatibility\n  return rangeConfig.seconds || null\n}\n\n/**\n * Check if a range represents \"All\" (show all data)\n */\nexport function isAllRange(rangeConfig: RangeConfig): boolean {\n  const range = getRangeValue(rangeConfig)\n  return range === null || range === TimeRange.ALL\n}\n\n/**\n * Convert TimeRange enum or value to seconds\n */\nexport function getSecondsFromRange(range: TimeRange | number | null): number | null {\n  if (range === null || range === TimeRange.ALL) {\n    return null\n  }\n\n  if (typeof range === 'number') {\n    return range\n  }\n\n  // Map enum values to seconds using the existing TimeRangeSeconds constants\n  switch (range) {\n    case TimeRange.FIVE_MINUTES:\n      return TimeRangeSeconds.FIVE_MINUTES\n    case TimeRange.FIFTEEN_MINUTES:\n      return TimeRangeSeconds.FIFTEEN_MINUTES\n    case TimeRange.THIRTY_MINUTES:\n      return 1800 // 30 minutes\n    case TimeRange.ONE_HOUR:\n      return TimeRangeSeconds.ONE_HOUR\n    case TimeRange.FOUR_HOURS:\n      return TimeRangeSeconds.FOUR_HOURS\n    case TimeRange.ONE_DAY:\n      return TimeRangeSeconds.ONE_DAY\n    case TimeRange.ONE_WEEK:\n      return TimeRangeSeconds.ONE_WEEK\n    case TimeRange.TWO_WEEKS:\n      return TimeRangeSeconds.ONE_WEEK * 2\n    case TimeRange.ONE_MONTH:\n      return TimeRangeSeconds.ONE_MONTH\n    case TimeRange.THREE_MONTHS:\n      return TimeRangeSeconds.THREE_MONTHS\n    case TimeRange.SIX_MONTHS:\n      return TimeRangeSeconds.SIX_MONTHS\n    case TimeRange.ONE_YEAR:\n      return TimeRangeSeconds.ONE_YEAR\n    case TimeRange.TWO_YEARS:\n      return TimeRangeSeconds.ONE_YEAR * 2\n    case TimeRange.FIVE_YEARS:\n      return TimeRangeSeconds.FIVE_YEARS\n    default:\n      return null\n  }\n}\n\n/**\n * Configuration for RangeSwitcherPrimitive\n */\nexport interface RangeSwitcherPrimitiveConfig extends BasePrimitiveConfig {\n  /**\n   * Available time ranges\n   */\n  ranges: RangeConfig[]\n\n  /**\n   * Callback when range changes\n   */\n  onRangeChange?: (range: RangeConfig, index: number) => void\n\n  /**\n   * Range switcher styling\n   */\n  style?: BasePrimitiveConfig['style'] & {\n    /**\n     * Button styling\n     */\n    button?: {\n      backgroundColor?: string\n      color?: string\n      hoverBackgroundColor?: string\n      hoverColor?: string\n      border?: string\n      borderRadius?: number\n      padding?: string\n      margin?: string\n      fontSize?: number\n      fontWeight?: string | number\n      minWidth?: number\n    }\n\n    /**\n     * Container styling\n     */\n    container?: {\n      display?: 'flex' | 'block'\n      flexDirection?: 'row' | 'column'\n      gap?: number\n      alignItems?: string\n      justifyContent?: string\n    }\n  }\n}\n\n/**\n * RangeSwitcherPrimitive - A lightweight-charts pane primitive for time range switching\n *\n * This primitive provides:\n * - Interactive time range buttons (1D, 7D, 1M, 3M, 1Y, All)\n * - Chart-level positioning (typically top-right corner)\n * - Automatic chart time scale updates\n * - Configurable styling and ranges\n * - Event integration for range changes\n *\n * Example usage:\n * ```typescript\n * const rangeSwitcher = new RangeSwitcherPrimitive('range-switcher', {\n *   corner: 'top-right',\n *   priority: PrimitivePriority.RANGE_SWITCHER,\n *   ranges: [\n *     { text: '1D', seconds: 86400 },\n *     { text: '7D', seconds: 604800 },\n *     { text: '1M', seconds: 2592000 },\n *     { text: 'All', seconds: null }\n *   ],\n *   onRangeChange: (range) => {\n *     // Range changed to: range.text\n *   }\n * })\n *\n * // Add to chart (chart-level, not pane-specific)\n * chart.attachPrimitive(rangeSwitcher)\n * ```\n */\nexport class RangeSwitcherPrimitive extends BasePanePrimitive<RangeSwitcherPrimitiveConfig> {\n\n  private buttonElements: HTMLElement[] = []\n  private buttonEventCleanupFunctions: (() => void)[] = []\n  private dataTimespan: number | null = null // Cached data timespan in seconds\n  private initialVisibilitySetupComplete: boolean = false // Track if initial setup is done\n  private dataChangeIntervalId: NodeJS.Timeout | null = null // Store interval ID for cleanup\n\n  constructor(id: string, config: RangeSwitcherPrimitiveConfig) {\n    // Set default priority and configuration for range switchers\n    const configWithDefaults: RangeSwitcherPrimitiveConfig = {\n      priority: PrimitivePriority.RANGE_SWITCHER,\n      visible: true,\n      style: {\n        backgroundColor: 'transparent',\n        padding: DefaultRangeSwitcherConfig.layout.CONTAINER_PADDING,\n        container: {\n          display: 'flex',\n          flexDirection: DefaultRangeSwitcherConfig.layout.FLEX_DIRECTION,\n          gap: DefaultRangeSwitcherConfig.layout.CONTAINER_GAP,\n          alignItems: DefaultRangeSwitcherConfig.layout.ALIGN_ITEMS,\n          justifyContent: DefaultRangeSwitcherConfig.layout.JUSTIFY_CONTENT\n        },\n        button: {\n          backgroundColor: ButtonColors.DEFAULT_BACKGROUND,\n          color: ButtonColors.DEFAULT_COLOR,\n          hoverBackgroundColor: ButtonColors.HOVER_BACKGROUND,\n          hoverColor: ButtonColors.HOVER_COLOR,\n          border: ButtonEffects.DEFAULT_BORDER,\n          borderRadius: ButtonDimensions.BORDER_RADIUS,\n          padding: ButtonSpacing.RANGE_BUTTON_PADDING,\n          margin: '0 2px',\n          fontSize: ButtonDimensions.RANGE_FONT_SIZE,\n          fontWeight: 500,\n          minWidth: ButtonDimensions.MIN_WIDTH_RANGE\n        },\n        ...config.style\n      },\n      ...config\n    }\n\n    super(id, configWithDefaults)\n  }\n\n  // ===== BasePanePrimitive Implementation =====\n\n  /**\n   * Get the template string (not used for interactive elements)\n   */\n  protected getTemplate(): string {\n    return '' // Range switcher is fully interactive, no template needed\n  }\n\n  /**\n   * Render the range switcher buttons\n   */\n  protected renderContent(): void {\n    if (!this.containerElement) return\n\n    // If buttons are already rendered, don't recreate them\n    if (this.buttonElements.length > 0) {\n      return\n    }\n\n    // Clean up existing event listeners\n    this.cleanupButtonEventListeners()\n\n    // Clear existing content\n    this.containerElement.innerHTML = ''\n    this.buttonElements = []\n\n    // Create container for buttons\n    const buttonContainer = document.createElement('div')\n    buttonContainer.className = 'range-switcher-container'\n    this.applyContainerStyling(buttonContainer)\n\n    // Create buttons for each range (filtering is now done server-side)\n    this.config.ranges.forEach((range, index) => {\n      const button = this.createRangeButton(range, index)\n      buttonContainer.appendChild(button)\n      this.buttonElements.push(button)\n    })\n\n    this.containerElement.appendChild(buttonContainer)\n\n    // Trigger layout recalculation after content is rendered to ensure proper positioning\n    // Use setTimeout to allow DOM to update dimensions first\n    setTimeout(() => {\n      if (this.layoutManager) {\n        this.layoutManager.recalculateAllLayouts()\n      }\n    }, 0)\n  }\n\n  /**\n   * Create a single range button\n   */\n  private createRangeButton(range: RangeConfig, index: number): HTMLElement {\n    const button = this.createButtonElement(range, index)\n    this.applyButtonStyling(button, false)\n    this.attachButtonEventHandlers(button, index)\n    return button\n  }\n\n  /**\n   * Create the basic button element with attributes\n   */\n  private createButtonElement(range: RangeConfig, index: number): HTMLElement {\n    const button = document.createElement('button')\n    button.className = 'range-button'\n    button.textContent = range.text\n    button.setAttribute('data-range-index', index.toString())\n    button.setAttribute('aria-label', `Switch to ${range.text} time range`)\n\n    // Add data attributes for debugging and testing\n    const rangeValue = getRangeValue(range)\n    const seconds = getSecondsFromRange(rangeValue)\n    if (seconds !== null) {\n      button.setAttribute('data-range-seconds', seconds.toString())\n    }\n\n    return button\n  }\n\n  /**\n   * Attach event handlers to range button\n   */\n  private attachButtonEventHandlers(button: HTMLElement, index: number): void {\n    const eventHandlers = this.createButtonEventHandlers(button, index)\n\n    // Add event listeners\n    button.addEventListener('click', eventHandlers.click)\n    button.addEventListener('mouseenter', eventHandlers.mouseEnter)\n    button.addEventListener('mouseleave', eventHandlers.mouseLeave)\n\n    // Store cleanup function\n    const cleanup = () => {\n      button.removeEventListener('click', eventHandlers.click)\n      button.removeEventListener('mouseenter', eventHandlers.mouseEnter)\n      button.removeEventListener('mouseleave', eventHandlers.mouseLeave)\n    }\n    this.buttonEventCleanupFunctions.push(cleanup)\n  }\n\n  /**\n   * Create event handler functions for range button\n   */\n  private createButtonEventHandlers(button: HTMLElement, index: number): {\n    click: (e: Event) => void;\n    mouseEnter: () => void;\n    mouseLeave: () => void;\n  } {\n    return {\n      click: (e: Event) => {\n        e.preventDefault()\n        e.stopPropagation()\n        this.handleRangeClick(index)\n      },\n      mouseEnter: () => {\n        this.applyButtonStyling(button, false, true)\n      },\n      mouseLeave: () => {\n        this.applyButtonStyling(button, false, false)\n      }\n    }\n  }\n\n  /**\n   * Clean up button event listeners\n   */\n  private cleanupButtonEventListeners(): void {\n    this.buttonEventCleanupFunctions.forEach(cleanup => cleanup())\n    this.buttonEventCleanupFunctions = []\n  }\n\n  /**\n   * Apply container styling\n   */\n  private applyContainerStyling(container: HTMLElement): void {\n    const style = container.style\n    const containerConfig = this.config.style?.container\n\n    if (containerConfig) {\n      if (containerConfig.display) style.display = containerConfig.display\n      if (containerConfig.flexDirection) style.flexDirection = containerConfig.flexDirection\n      if (containerConfig.gap) style.gap = `${containerConfig.gap}px`\n      if (containerConfig.alignItems) style.alignItems = containerConfig.alignItems\n      if (containerConfig.justifyContent) style.justifyContent = containerConfig.justifyContent\n    }\n\n    // Ensure interactive elements can receive events\n    style.pointerEvents = 'auto'\n  }\n\n  /**\n   * Apply button styling using standardized utilities\n   */\n  private applyButtonStyling(button: HTMLElement, isActive: boolean, isHover: boolean = false): void {\n    const buttonConfig = this.config.style?.button\n\n    if (buttonConfig) {\n      // Prepare base styles with compact, professional appearance\n      const baseStyles: BaseStyleConfig = {\n        border: buttonConfig.border || ButtonEffects.RANGE_BORDER,\n        borderRadius: buttonConfig.borderRadius || 4, // Rounded corners for modern look\n        padding: buttonConfig.padding || ButtonSpacing.RANGE_BUTTON_PADDING,\n        margin: buttonConfig.margin || ButtonSpacing.RANGE_BUTTON_MARGIN,\n        fontSize: buttonConfig.fontSize || 11, // Slightly smaller font for compactness\n        fontWeight: buttonConfig.fontWeight || CommonValues.FONT_WEIGHT_MEDIUM,\n        backgroundColor: buttonConfig.backgroundColor || 'rgba(255, 255, 255, 0.9)',\n        color: buttonConfig.color || '#666',\n        cursor: CommonValues.POINTER,\n        transition: ButtonEffects.DEFAULT_TRANSITION,\n        boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)' // Subtle shadow for depth\n      }\n\n      // Prepare state-specific styles\n      const stateStyles: BaseStyleConfig = {}\n\n      if (isHover) {\n        stateStyles.backgroundColor = buttonConfig.hoverBackgroundColor || 'rgba(255, 255, 255, 1)'\n        stateStyles.color = buttonConfig.hoverColor || '#333'\n        stateStyles.boxShadow = ButtonEffects.RANGE_HOVER_BOX_SHADOW\n        stateStyles.transform = 'translateY(-1px)' // Subtle lift effect\n      }\n\n      // Determine state for styling utils\n      const state = isHover ? 'hover' : 'default'\n\n      // Apply styles using standardized utilities\n      PrimitiveStylingUtils.applyInteractionState(button, baseStyles, stateStyles, state)\n\n      // Set minimum width if specified\n      if (buttonConfig.minWidth) {\n        button.style.minWidth = `${buttonConfig.minWidth}px`\n      }\n    }\n  }\n\n  /**\n   * Handle range button click\n   */\n  private handleRangeClick(index: number): void {\n\n    // Apply range to chart\n    this.applyRangeToChart(this.config.ranges[index])\n\n    // Emit range change event\n    if (this.config.onRangeChange) {\n      this.config.onRangeChange(this.config.ranges[index], index)\n    }\n\n    // Emit custom event through event manager\n    if (this.eventManager) {\n      this.eventManager.emitCustomEvent('rangeChange', {\n        range: this.config.ranges[index],\n        index: index\n      })\n    }\n  }\n\n\n  /**\n   * Apply range to chart time scale\n   */\n  private applyRangeToChart(range: RangeConfig): void {\n    if (!this.chart) return\n\n    try {\n      const timeScale = this.chart.timeScale()\n\n      const rangeValue = getRangeValue(range)\n      const seconds = getSecondsFromRange(rangeValue)\n\n      if (seconds === null) {\n        // \"All\" range - fit all content\n        timeScale.fitContent()\n      } else {\n        // Specific time range - use current visible range or current time\n        const currentRange = timeScale.getVisibleRange()\n        let endTime: number\n\n        if (currentRange && currentRange.to) {\n          // Use the current visible end time as reference\n          endTime = currentRange.to as number\n        } else {\n          // Fallback to current time\n          endTime = Date.now() / 1000\n        }\n\n        const fromTime = endTime - seconds\n\n        timeScale.setVisibleRange({\n          from: fromTime as Time,\n          to: endTime as Time\n        })\n      }\n    } catch (error) {\n      // Silently handle chart range application errors\n    }\n  }\n\n  /**\n   * Get the timespan of available data in seconds\n   */\n  private getDataTimespan(): number | null {\n    if (!this.chart) return null\n\n    try {\n      const timeScale = this.chart.timeScale()\n\n      // Store current visible range to restore it later\n      const currentRange = timeScale.getVisibleRange()\n\n      // Always use fitContent to get the full data range for button visibility decisions\n      // This ensures buttons are hidden based on total data availability, not current zoom level\n      timeScale.fitContent()\n      const fullRange = timeScale.getVisibleRange()\n\n      // Restore the original range immediately to avoid interfering with user view\n      if (currentRange) {\n        timeScale.setVisibleRange(currentRange)\n      }\n\n      if (!fullRange || !fullRange.from || !fullRange.to) return null\n\n      // Calculate timespan in seconds\n      const timespanSeconds = (fullRange.to as number) - (fullRange.from as number)\n\n      // Cache the result for performance\n      this.dataTimespan = timespanSeconds\n\n      return timespanSeconds\n    } catch (error) {\n      // Return null if we can't determine data timespan\n      return null\n    }\n  }\n\n  /**\n   * Check if a range is valid for the current data\n   */\n  private isRangeValidForData(range: RangeConfig): boolean {\n    const rangeValue = getRangeValue(range)\n\n    // \"All\" range is always valid\n    if (isAllRange(range)) {\n      return true\n    }\n\n    const rangeSeconds = getSecondsFromRange(rangeValue)\n    if (rangeSeconds === null) {\n      return true // Unknown ranges are considered valid\n    }\n\n    const dataTimespan = this.getDataTimespan()\n    if (dataTimespan === null) {\n      return true // If we can't determine data timespan, show all ranges\n    }\n\n    // Hide ranges that are significantly larger than available data\n    // Add a 10% buffer to account for minor timing differences\n    const bufferMultiplier = 1.1\n    return rangeSeconds <= (dataTimespan * bufferMultiplier)\n  }\n\n  /**\n   * Get visible ranges based on data availability\n   */\n  private getVisibleRanges(): Array<{ range: RangeConfig; originalIndex: number }> {\n    return this.config.ranges\n      .map((range, index) => ({ range, originalIndex: index }))\n      .filter(({ range }) => this.isRangeValidForData(range))\n  }\n\n  /**\n   * Get CSS class name for the container\n   */\n  protected getContainerClassName(): string {\n    return 'range-switcher-primitive'\n  }\n\n  /**\n   * Override pane ID - range switcher is chart-level (pane 0)\n   */\n  protected getPaneId(): number {\n    return 0 // Always chart-level\n  }\n\n  // ===== Lifecycle Hooks =====\n\n  /**\n   * Override detached to ensure proper cleanup\n   */\n  public detached(): void {\n    this.cleanupButtonEventListeners()\n    super.detached()\n  }\n\n  /**\n   * Setup custom event subscriptions\n   */\n  protected setupCustomEventSubscriptions(): void {\n    if (!this.eventManager) return\n\n    // REMOVED: timeScale subscription that was hiding buttons on every zoom\n    // const timeScaleSub = this.eventManager.subscribe('timeScaleChange', (event) => {\n    //   this.handleTimeScaleChange(event)\n    // })\n    // this.eventSubscriptions.push(timeScaleSub)\n\n    // Subscribe to data updates to refresh range visibility (but not timeScale changes)\n    const dataUpdateSub = this.eventManager.subscribe('dataUpdate', () => {\n      this.handleDataUpdate()\n    })\n    this.eventSubscriptions.push(dataUpdateSub)\n  }\n\n  /**\n   * Handle external time scale changes\n   */\n  private handleTimeScaleChange(event: { from: any; to: any }): void {\n    // Optionally sync active range when time scale changes externally\n    // This could be used to highlight which range matches the current view\n  }\n\n  /**\n   * Handle data updates that might affect range visibility\n   * Only processes during initial setup, not after user interactions\n   */\n  private handleDataUpdate(): void {\n    if (this.mounted && !this.initialVisibilitySetupComplete) {\n      this.invalidateDataTimespan()\n      // Update button visibility without full re-render\n      this.updateRangeButtonVisibility()\n    }\n  }\n\n  /**\n   * Update range button visibility based on current data\n   * Only hides buttons during initial setup, not after user interactions\n   */\n  private updateRangeButtonVisibility(): void {\n    // Only hide buttons during initial setup, not after user interactions\n    if (this.initialVisibilitySetupComplete) {\n      return\n    }\n\n    // Check each range and update button visibility\n    this.config.ranges.forEach((range, index) => {\n      const button = this.buttonElements[index]\n      if (button) {\n        if (this.isRangeValidForData(range)) {\n          button.style.display = '' // Show the button\n          button.removeAttribute('data-hidden-reason')\n        } else {\n          button.style.display = 'none' // Hide the button\n          button.setAttribute('data-hidden-reason', 'exceeds-data-range')\n        }\n      }\n    })\n  }\n\n  /**\n   * Called when container is created\n   */\n  protected onContainerCreated(container: HTMLElement): void {\n    // Ensure container allows pointer events for buttons\n    container.style.pointerEvents = 'auto'\n\n    // Set up mutation observer to detect data changes\n    this.setupDataChangeObserver()\n  }\n\n  /**\n   * Set up observer to detect chart data changes\n   */\n  private setupDataChangeObserver(): void {\n    if (!this.chart) return\n\n    // Use a timeout to periodically check for data changes during initial setup only\n    // This is more reliable than trying to intercept all possible data update events\n    const checkDataChanges = () => {\n      if (this.mounted && !this.initialVisibilitySetupComplete) {\n        const currentTimespan = this.getDataTimespan()\n        if (currentTimespan !== this.dataTimespan) {\n          this.updateRangeButtonVisibility()\n        }\n      }\n    }\n\n    // Check every 1 second for data changes (only during initial setup)\n    this.dataChangeIntervalId = setInterval(checkDataChanges, 1000)\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Add a new range\n   */\n  public addRange(range: RangeConfig): void {\n    this.config.ranges.push(range)\n    if (this.mounted) {\n      this.invalidateDataTimespan() // Clear cache when ranges change\n      this.renderContent() // Full re-render needed for new buttons\n    }\n  }\n\n  /**\n   * Remove a range by index\n   */\n  public removeRange(index: number): void {\n    if (index < 0 || index >= this.config.ranges.length) return\n\n    this.config.ranges.splice(index, 1)\n\n\n    if (this.mounted) {\n      this.renderContent()\n    }\n  }\n\n  /**\n   * Update ranges\n   */\n  public updateRanges(ranges: RangeConfig[]): void {\n    this.config.ranges = ranges\n\n    if (this.mounted) {\n      this.invalidateDataTimespan() // Clear cache when ranges change\n      this.renderContent() // Full re-render needed for new button set\n    }\n  }\n\n\n  /**\n   * Invalidate cached data timespan (call when data changes)\n   */\n  public invalidateDataTimespan(): void {\n    this.dataTimespan = null\n  }\n\n  /**\n   * Get the current data timespan in seconds\n   */\n  public getDataTimespanSeconds(): number | null {\n    return this.getDataTimespan()\n  }\n\n  /**\n   * Force update of range button visibility\n   * Useful when called externally after data changes\n   */\n  public updateButtonVisibility(): void {\n    if (this.mounted && !this.initialVisibilitySetupComplete) {\n      this.invalidateDataTimespan()\n      this.updateRangeButtonVisibility()\n    }\n  }\n\n  /**\n   * Get information about hidden ranges\n   */\n  public getHiddenRanges(): Array<{ range: RangeConfig; index: number; reason: string }> {\n    const hiddenRanges: Array<{ range: RangeConfig; index: number; reason: string }> = []\n\n    this.config.ranges.forEach((range, index) => {\n      if (!this.isRangeValidForData(range)) {\n        hiddenRanges.push({\n          range,\n          index,\n          reason: 'exceeds-data-range'\n        })\n      }\n    })\n\n    return hiddenRanges\n  }\n\n  /**\n   * Get information about visible ranges\n   */\n  public getVisibleRangeInfo(): Array<{ range: RangeConfig; index: number; dataTimespan: number | null }> {\n    const dataTimespan = this.getDataTimespan()\n\n    return this.config.ranges\n      .map((range, index) => ({ range, index, dataTimespan }))\n      .filter(({ range }) => this.isRangeValidForData(range))\n  }\n\n\n  /**\n   * Programmatically trigger range change\n   */\n  public triggerRangeChange(index: number): void {\n    this.handleRangeClick(index)\n  }\n}\n\n/**\n * Factory function to create range switcher primitives\n */\nexport function createRangeSwitcherPrimitive(\n  id: string,\n  config: Partial<RangeSwitcherPrimitiveConfig> & { ranges: RangeConfig[]; corner: any }\n): RangeSwitcherPrimitive {\n  return new RangeSwitcherPrimitive(id, config as RangeSwitcherPrimitiveConfig)\n}\n\n/**\n * Default range configurations using the new enum system\n * Easier to use and less error-prone than manual seconds configuration\n */\nexport const DefaultRangeConfigs = {\n  /**\n   * Standard trading ranges (using enum)\n   */\n  trading: [\n    { text: '1D', range: TimeRange.ONE_DAY },\n    { text: '7D', range: TimeRange.ONE_WEEK },\n    { text: '1M', range: TimeRange.ONE_MONTH },\n    { text: '3M', range: TimeRange.THREE_MONTHS },\n    { text: '1Y', range: TimeRange.ONE_YEAR },\n    { text: 'All', range: TimeRange.ALL }\n  ],\n\n  /**\n   * Short-term trading ranges (using enum)\n   */\n  shortTerm: [\n    { text: '5M', range: TimeRange.FIVE_MINUTES },\n    { text: '15M', range: TimeRange.FIFTEEN_MINUTES },\n    { text: '30M', range: TimeRange.THIRTY_MINUTES },\n    { text: '1H', range: TimeRange.ONE_HOUR },\n    { text: '4H', range: TimeRange.FOUR_HOURS },\n    { text: '1D', range: TimeRange.ONE_DAY },\n    { text: 'All', range: TimeRange.ALL }\n  ],\n\n  /**\n   * Long-term investment ranges (using enum)\n   */\n  longTerm: [\n    { text: '1M', range: TimeRange.ONE_MONTH },\n    { text: '3M', range: TimeRange.THREE_MONTHS },\n    { text: '6M', range: TimeRange.SIX_MONTHS },\n    { text: '1Y', range: TimeRange.ONE_YEAR },\n    { text: '2Y', range: TimeRange.TWO_YEARS },\n    { text: '5Y', range: TimeRange.FIVE_YEARS },\n    { text: 'All', range: TimeRange.ALL }\n  ],\n\n  /**\n   * Custom minimal ranges (using enum)\n   */\n  minimal: [\n    { text: '1D', range: TimeRange.ONE_DAY },\n    { text: '1W', range: TimeRange.ONE_WEEK },\n    { text: '1M', range: TimeRange.ONE_MONTH },\n    { text: 'All', range: TimeRange.ALL }\n  ],\n\n  /**\n   * @deprecated Legacy configurations (kept for backwards compatibility)\n   * Use the enum-based configurations above for new implementations\n   */\n  legacy: {\n    trading: [\n      { text: '1D', seconds: TimeRangeSeconds.ONE_DAY },\n      { text: '7D', seconds: TimeRangeSeconds.ONE_WEEK },\n      { text: '1M', seconds: TimeRangeSeconds.ONE_MONTH },\n      { text: '3M', seconds: TimeRangeSeconds.THREE_MONTHS },\n      { text: '1Y', seconds: TimeRangeSeconds.ONE_YEAR },\n      { text: 'All', seconds: null }\n    ],\n    shortTerm: [\n      { text: '5M', seconds: TimeRangeSeconds.FIVE_MINUTES },\n      { text: '15M', seconds: TimeRangeSeconds.FIFTEEN_MINUTES },\n      { text: '1H', seconds: TimeRangeSeconds.ONE_HOUR },\n      { text: '4H', seconds: TimeRangeSeconds.FOUR_HOURS },\n      { text: '1D', seconds: TimeRangeSeconds.ONE_DAY },\n      { text: 'All', seconds: null }\n    ],\n    longTerm: [\n      { text: '1M', seconds: TimeRangeSeconds.ONE_MONTH },\n      { text: '3M', seconds: TimeRangeSeconds.THREE_MONTHS },\n      { text: '6M', seconds: TimeRangeSeconds.SIX_MONTHS },\n      { text: '1Y', seconds: TimeRangeSeconds.ONE_YEAR },\n      { text: '5Y', seconds: TimeRangeSeconds.FIVE_YEARS },\n      { text: 'All', seconds: null }\n    ],\n    minimal: [\n      { text: '1D', seconds: TimeRangeSeconds.ONE_DAY },\n      { text: '1W', seconds: TimeRangeSeconds.ONE_WEEK },\n      { text: '1M', seconds: TimeRangeSeconds.ONE_MONTH },\n      { text: 'All', seconds: null }\n    ]\n  }\n} as const","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/primitives/SeriesConfigPrimitive.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/react-app-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/ChartCoordinateService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1520,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1520,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[42988,43049],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'paneId' is assigned a value but never used.","line":1742,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":1742,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized service for managing chart coordinate calculations\n * Provides consistent positioning across all chart features\n */\n\nimport {IChartApi, ISeriesApi, Time} from 'lightweight-charts'\nimport {\n  ChartCoordinates,\n  PaneCoordinates,\n  LegendCoordinates,\n  ElementPosition,\n  CoordinateOptions,\n  CoordinateCacheEntry,\n  BoundingBox,\n  ScaleDimensions,\n  ContainerDimensions,\n  Margins\n} from '../types/coordinates'\nimport {\n  validateChartCoordinates,\n  sanitizeCoordinates,\n  createBoundingBox,\n  areCoordinatesStale,\n  logValidationResult\n} from '../utils/coordinateValidation'\nimport {\n  DIMENSIONS,\n  TIMING,\n  Z_INDEX,\n  getFallback,\n  getMargins\n} from '../config/positioningConfig'\nimport {UniversalSpacing} from '../primitives/PrimitiveDefaults'\n\n/**\n * Configuration for chart dimensions validation\n */\nexport interface ChartDimensionsOptions {\n  minWidth?: number\n  minHeight?: number\n  maxAttempts?: number\n  baseDelay?: number\n}\n\n/**\n * Configuration for pane dimensions options\n */\nexport interface PaneDimensionsOptions {\n  includeMargins?: boolean\n  includeScales?: boolean\n  validateDimensions?: boolean\n}\n\n/**\n * Configuration for positioning calculations (from PositioningEngine)\n */\nexport interface PositioningConfig {\n  margins?: Partial<Margins>\n  dimensions?: {width?: number; height?: number}\n  zIndex?: number\n  alignment?: 'start' | 'center' | 'end'\n  offset?: {x?: number; y?: number}\n}\n\n/**\n * Tooltip positioning configuration (from PositioningEngine)\n */\nexport interface TooltipPosition {\n  x: number\n  y: number\n  anchor: 'top' | 'bottom' | 'left' | 'right'\n  offset: {x: number; y: number}\n}\n\n/**\n * Singleton service for chart coordinate management\n */\nexport class ChartCoordinateService {\n  private static instance: ChartCoordinateService\n  private coordinateCache = new Map<string, CoordinateCacheEntry>()\n  private paneDimensionsCache = new Map<\n    string,\n    {\n      dimensions: {[paneId: number]: {width: number; height: number}}\n      expiresAt: number\n    }\n  >()\n  private chartRegistry = new Map<string, IChartApi>()\n  private updateCallbacks = new Map<string, Set<() => void>>()\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): ChartCoordinateService {\n    if (!this.instance) {\n      this.instance = new ChartCoordinateService()\n    }\n    return this.instance\n  }\n\n  private constructor() {\n    // Private constructor for singleton\n    this.startCacheCleanup()\n  }\n\n  /**\n   * Register a chart for coordinate tracking\n   */\n  registerChart(chartId: string, chart: IChartApi): void {\n    this.chartRegistry.set(chartId, chart)\n    this.invalidateCache(chartId)\n  }\n\n  /**\n   * Unregister a chart\n   */\n  unregisterChart(chartId: string): void {\n    this.chartRegistry.delete(chartId)\n    this.coordinateCache.delete(chartId)\n    this.updateCallbacks.delete(chartId)\n  }\n\n  /**\n   * Get coordinates for a chart with caching and validation\n   */\n  async getCoordinates(\n    chart: IChartApi,\n    container: HTMLElement,\n    options: CoordinateOptions = {}\n  ): Promise<ChartCoordinates> {\n    const {\n      includeMargins = true,\n      useCache = true,\n      validateResult = true,\n      fallbackOnError = true\n    } = options\n\n    // Generate cache key\n    const cacheKey = this.generateCacheKey(chart, container)\n\n    // Check cache if enabled\n    if (useCache) {\n      const cached = this.coordinateCache.get(cacheKey)\n      if (cached && !areCoordinatesStale(cached, TIMING.cacheExpiration)) {\n        return cached\n      }\n    }\n\n    try {\n      // Calculate coordinates\n      const coordinates = await this.calculateCoordinates(chart, container, includeMargins)\n\n      // Validate if requested\n      if (validateResult) {\n        const validation = validateChartCoordinates(coordinates)\n        logValidationResult(validation, 'ChartCoordinateService')\n\n        if (!validation.isValid && fallbackOnError) {\n          return sanitizeCoordinates(coordinates)\n        }\n      }\n\n      // Cache the result\n      const cacheEntry: CoordinateCacheEntry = {\n        ...coordinates,\n        cacheKey,\n        expiresAt: Date.now() + TIMING.cacheExpiration\n      }\n      this.coordinateCache.set(cacheKey, cacheEntry)\n\n      // Notify listeners\n      this.notifyUpdateCallbacks(cacheKey)\n\n      return coordinates\n    } catch (error) {\n      if (fallbackOnError) {\n        return sanitizeCoordinates({})\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get full pane bounds including price scale areas (for collapse buttons)\n   */\n  getFullPaneBounds(chart: IChartApi, paneId: number): any | null {\n    try {\n      // Validate inputs\n      if (!chart || typeof paneId !== 'number' || paneId < 0) {\n        return null\n      }\n\n      // Get pane size from chart with error handling\n      let paneSize: any = null\n      try {\n        paneSize = chart.paneSize(paneId)\n      } catch (error) {\n        return null\n      }\n\n      if (!paneSize || typeof paneSize.height !== 'number' || typeof paneSize.width !== 'number') {\n        return null\n      }\n\n      // Calculate cumulative offset for this pane\n      let offsetY = 0\n      for (let i = 0; i < paneId; i++) {\n        try {\n          const size = chart.paneSize(i)\n          if (size && typeof size.height === 'number') {\n            offsetY += size.height\n          }\n        } catch (error) {\n          // Continue with other panes even if one fails\n        }\n      }\n\n      // Return full pane bounds including all price scale areas\n      const paneWidth = paneSize.width || getFallback('paneWidth')\n      return createBoundingBox(\n        0, // Full pane starts at 0\n        offsetY,\n        paneWidth, // Full pane width including price scales\n        paneSize.height\n      )\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get coordinates for a specific pane\n   */\n  getPaneCoordinates(chart: IChartApi, paneId: number): PaneCoordinates | null {\n    try {\n      // Validate inputs\n      if (!chart || typeof paneId !== 'number' || paneId < 0) {\n        return null\n      }\n\n      // Get pane size from chart with error handling\n      let paneSize: any = null\n      try {\n        paneSize = chart.paneSize(paneId)\n      } catch (error) {\n        return null\n      }\n\n      if (!paneSize || typeof paneSize.height !== 'number' || typeof paneSize.width !== 'number') {\n        return null\n      }\n\n      // Calculate cumulative offset for this pane\n      let offsetY = 0\n      for (let i = 0; i < paneId; i++) {\n        try {\n          const size = chart.paneSize(i)\n          if (size && typeof size.height === 'number') {\n            offsetY += size.height\n          }\n        } catch (error) {\n          // Continue with other panes even if one fails\n        }\n      }\n\n\n      // Get chart element for price scale width\n      // Get chart element (used for price scale width calculation)\n      const timeScaleHeight = this.getTimeScaleHeight(chart)\n\n      // Get both left and right price scale widths for proper legend positioning\n      const axisDimensions = this.getAxisDimensions(chart)\n\n      // For legend positioning, we need coordinates relative to the chart element itself\n      // The legend is appended to the chart element, so coordinates should be relative to it\n      const legendOffsetX = 0 // Legend is positioned relative to chart element\n      const legendOffsetY = offsetY // Y offset for multi-pane charts\n\n      // Calculate bounds relative to chart element (for pane primitive positioning)\n      // Pane primitives should get the full pane area without price scale adjustments\n      const paneWidth = paneSize.width || getFallback('paneWidth')\n\n      const bounds = createBoundingBox(\n        legendOffsetX,\n        legendOffsetY,\n        paneWidth,  // Use full pane width - no price scale adjustment\n        paneSize.height\n      )\n\n\n      // Calculate content area (excluding scales) relative to chart element\n      // This is where the actual chart content starts (after price scale)\n      // The left Y-axis (price scale) takes up priceScaleWidth pixels from the left\n      const contentArea = createBoundingBox(\n        axisDimensions.leftPriceScaleWidth, // Start after the left Y-axis (price scale)\n        legendOffsetY,\n        paneWidth - axisDimensions.leftPriceScaleWidth - axisDimensions.rightPriceScaleWidth, // Width excluding both price scales\n        paneSize.height - (paneId === 0 ? 0 : timeScaleHeight)\n      )\n\n      // Get margins\n      const margins = getMargins('pane')\n\n      // Debug logging for legend positioning\n      if (paneId === 0) {\n        // Main pane - coordinates calculated\n      }\n\n      return {\n        id: paneId,\n        index: paneId,\n        isMainPane: paneId === 0,\n        bounds,\n        contentArea,\n        margins\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get pane coordinates with enhanced fallback methods\n   */\n  async getPaneCoordinatesWithFallback(\n    chart: IChartApi,\n    paneId: number,\n    container: HTMLElement,\n    options: PaneDimensionsOptions & ChartDimensionsOptions = {}\n  ): Promise<PaneCoordinates | null> {\n    const {...paneOptions} = options\n\n    // Method 1: Try chart API first\n    let paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (paneCoords) {\n      return paneCoords\n    }\n\n    // Method 2: Single immediate retry without delay for resize performance\n    paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (paneCoords) {\n      return paneCoords\n    }\n\n    // Method 3: DOM fallback\n    return this.getPaneCoordinatesFromDOM(chart, container, paneId, paneOptions)\n  }\n\n  /**\n   * Get pane coordinates using DOM measurements (fallback method)\n   */\n  private getPaneCoordinatesFromDOM(\n    chart: IChartApi,\n    container: HTMLElement,\n    paneId: number,\n    options: PaneDimensionsOptions = {}\n  ): PaneCoordinates | null {\n    try {\n      // Find pane elements in DOM\n      const chartElement = chart.chartElement()\n      if (!chartElement) {\n        return null\n      }\n\n      const paneElements = chartElement.querySelectorAll('.tv-lightweight-charts-pane')\n      if (paneElements.length <= paneId) {\n        return null\n      }\n\n      const paneElement = paneElements[paneId] as HTMLElement\n      const paneRect = paneElement.getBoundingClientRect()\n      const chartRect = chartElement.getBoundingClientRect()\n\n      // Calculate relative position within the chart container\n      const offsetY = paneRect.top - chartRect.top\n      const width = paneRect.width\n      const height = paneRect.height\n\n      // Validate dimensions if requested\n      if (options.validateDimensions && (width < 10 || height < 10)) {\n        return null\n      }\n\n      // For legend positioning, coordinates should be relative to the chart element\n      // The legend is appended to the chart element, so we use 0 for x offset\n      const legendOffsetX = 0\n      const legendOffsetY = offsetY\n\n      // Calculate bounds relative to chart element (for legend positioning)\n      const bounds = createBoundingBox(legendOffsetX, legendOffsetY, width, height)\n\n      // Calculate content area (excluding scales) relative to chart element\n      const priceScaleWidth = this.getPriceScaleWidth(chart)\n      const timeScaleHeight = this.getTimeScaleHeight(chart)\n      // The left Y-axis (price scale) takes up priceScaleWidth pixels from the left\n      const contentArea = createBoundingBox(\n        priceScaleWidth, // Start after the left Y-axis (price scale)\n        legendOffsetY,\n        width - priceScaleWidth, // Width is the remaining area after price scale\n        height - (paneId === 0 ? 0 : timeScaleHeight)\n      )\n\n      // Get margins\n      const margins = getMargins('pane')\n\n      return {\n        id: paneId,\n        index: paneId,\n        isMainPane: paneId === 0,\n        bounds,\n        contentArea,\n        margins\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Check if a point is within a pane\n   */\n  isPointInPane(point: {x: number; y: number}, paneCoords: PaneCoordinates): boolean {\n    const {bounds} = paneCoords\n    return (\n      point.x >= bounds.left &&\n      point.x <= bounds.right &&\n      point.y >= bounds.top &&\n      point.y <= bounds.bottom\n    )\n  }\n\n  /**\n   * Check if chart dimensions are valid\n   */\n  areChartDimensionsValid(\n    dimensions: ChartCoordinates,\n    minWidth: number = 200,\n    minHeight: number = 200\n  ): boolean {\n    try {\n      const {container} = dimensions\n      return container.width >= minWidth && container.height >= minHeight\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Check if chart dimensions object is valid\n   */\n  areChartDimensionsObjectValid(\n    dimensions: {container: {width: number; height: number}},\n    minWidth: number = 200,\n    minHeight: number = 200\n  ): boolean {\n    try {\n      const {container} = dimensions\n      return container.width >= minWidth && container.height >= minHeight\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * Get validated chart coordinates\n   */\n  async getValidatedCoordinates(\n    chart: IChartApi,\n    container: HTMLElement,\n    options: ChartDimensionsOptions = {}\n  ): Promise<ChartCoordinates | null> {\n    try {\n      const coordinates = await this.getCoordinates(chart, container, {\n        validateResult: true\n      })\n\n      if (this.areChartDimensionsValid(coordinates, options.minWidth, options.minHeight)) {\n        return coordinates\n      } else {\n        return null\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get chart dimensions with multiple fallback methods\n   */\n  async getChartDimensionsWithFallback(\n    chart: IChartApi,\n    container: HTMLElement,\n    options: ChartDimensionsOptions = {}\n  ): Promise<{\n    container: {width: number; height: number}\n    timeScale: {x: number; y: number; width: number; height: number}\n    priceScale: {x: number; y: number; width: number; height: number}\n  }> {\n    const {minWidth = 200, minHeight = 200} = options\n\n    // Method 1: Try chart API first\n    try {\n      const chartElement = chart.chartElement()\n      if (chartElement) {\n        const chartRect = chartElement.getBoundingClientRect()\n        if (chartRect.width >= minWidth && chartRect.height >= minHeight) {\n          return this.getChartDimensionsFromAPI(chart, {\n            width: chartRect.width,\n            height: chartRect.height\n          })\n        }\n      }\n    } catch (error) {\n      // Chart API method failed, trying DOM fallback\n    }\n\n    // Method 2: DOM fallback\n    try {\n      const result = this.getChartDimensionsFromDOM(chart, container)\n      if (result.container.width >= minWidth && result.container.height >= minHeight) {\n        return result\n      }\n    } catch (error) {\n      // DOM method failed, using defaults\n    }\n\n    // Method 3: Default values\n    return this.getDefaultChartDimensions()\n  }\n\n  /**\n   * Get chart dimensions using chart API (most accurate)\n   */\n  private getChartDimensionsFromAPI(\n    chart: IChartApi,\n    chartSize: {width: number; height: number}\n  ): {\n    container: {width: number; height: number}\n    timeScale: {x: number; y: number; width: number; height: number}\n    priceScale: {x: number; y: number; width: number; height: number}\n  } {\n    try {\n      // Get time scale dimensions\n      let timeScaleHeight = 35\n      let timeScaleWidth = chartSize.width\n\n      try {\n        const timeScale = chart.timeScale()\n        timeScaleHeight = timeScale.height() || 35\n        timeScaleWidth = timeScale.width() || chartSize.width\n      } catch (error) {\n        // Time scale API failed, using defaults\n      }\n\n      // Get price scale width\n      let priceScaleWidth = 70\n\n      try {\n        const priceScale = chart.priceScale('left')\n        priceScaleWidth = priceScale.width() || 70\n      } catch (error) {\n        // Price scale API failed, using defaults\n      }\n\n      return {\n        timeScale: {\n          x: 0,\n          y: chartSize.height - timeScaleHeight,\n          height: timeScaleHeight,\n          width: timeScaleWidth\n        },\n        priceScale: {\n          x: 0,\n          y: 0,\n          height: chartSize.height - timeScaleHeight,\n          width: priceScaleWidth\n        },\n        container: chartSize\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  /**\n   * Get chart dimensions using DOM measurements (fallback method)\n   */\n  private getChartDimensionsFromDOM(\n    chart: IChartApi,\n    container: HTMLElement\n  ): {\n    container: {width: number; height: number}\n    timeScale: {x: number; y: number; width: number; height: number}\n    priceScale: {x: number; y: number; width: number; height: number}\n  } {\n    try {\n      // Get container dimensions with multiple fallback methods\n      let width = 0\n      let height = 0\n\n      // Method 1: getBoundingClientRect\n      try {\n        const rect = container.getBoundingClientRect()\n        width = rect.width\n        height = rect.height\n      } catch (error) {\n      }\n\n      // Method 2: offset dimensions\n      if (!width || !height) {\n        width = container.offsetWidth\n        height = container.offsetHeight\n      }\n\n      // Method 3: client dimensions\n      if (!width || !height) {\n        width = container.clientWidth\n        height = container.clientHeight\n      }\n\n      // Method 4: scroll dimensions\n      if (!width || !height) {\n        width = container.scrollWidth\n        height = container.scrollHeight\n      }\n\n      // Ensure minimum dimensions\n      width = Math.max(width || 800, 200)\n      height = Math.max(height || 600, 200)\n\n      // Get time scale dimensions\n      let timeScaleHeight = 35\n      let timeScaleWidth = width\n\n      try {\n        const timeScale = chart.timeScale()\n        timeScaleHeight = timeScale.height() || 35\n        timeScaleWidth = timeScale.width() || width\n      } catch (error) {\n      }\n\n      // Get price scale width\n      let priceScaleWidth = 70\n\n      try {\n        const priceScale = chart.priceScale('left')\n        priceScaleWidth = priceScale.width() || 70\n      } catch (error) {\n      }\n\n      return {\n        timeScale: {\n          x: 0,\n          y: height - timeScaleHeight,\n          height: timeScaleHeight,\n          width: timeScaleWidth\n        },\n        priceScale: {\n          x: 0,\n          y: 0,\n          height: height - timeScaleHeight,\n          width: priceScaleWidth\n        },\n        container: {width, height}\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  /**\n   * Get default chart dimensions (last resort)\n   */\n  private getDefaultChartDimensions(): {\n    container: {width: number; height: number}\n    timeScale: {x: number; y: number; width: number; height: number}\n    priceScale: {x: number; y: number; width: number; height: number}\n  } {\n    return {\n      timeScale: {\n        x: 0,\n        y: 565, // 600 - 35\n        height: 35,\n        width: 800\n      },\n      priceScale: {\n        x: 0,\n        y: 0,\n        height: 565, // 600 - 35\n        width: 70\n      },\n      container: {\n        width: 800,\n        height: 600\n      }\n    }\n  }\n\n  /**\n   * Get validated chart dimensions\n   */\n  async getValidatedChartDimensions(\n    chart: IChartApi,\n    container: HTMLElement,\n    options: ChartDimensionsOptions = {}\n  ): Promise<{\n    container: {width: number; height: number}\n    timeScale: {x: number; y: number; width: number; height: number}\n    priceScale: {x: number; y: number; width: number; height: number}\n  } | null> {\n    try {\n      const dimensions = await this.getChartDimensionsWithFallback(chart, container, options)\n\n      if (this.areChartDimensionsObjectValid(dimensions, options.minWidth, options.minHeight)) {\n        return dimensions\n      } else {\n        return null\n      }\n    } catch (error) {\n\n      return null\n    }\n  }\n\n  /**\n   * Calculate range switcher position for the entire chart\n   */\n  getRangeSwitcherPosition(\n    chart: IChartApi,\n    position: ElementPosition,\n    containerDimensions?: { width: number; height: number }\n  ): LegendCoordinates | null {\n    try {\n      // Get main pane coordinates (pane 0) for reference\n      const paneCoords = this.getPaneCoordinates(chart, 0)\n      if (!paneCoords) return null\n\n      // Get container dimensions\n      const chartElement = chart.chartElement()\n      const container = containerDimensions || {\n        width: chartElement.clientWidth || chartElement.offsetWidth || 800,\n        height: chartElement.clientHeight || chartElement.offsetHeight || 600\n      }\n\n      // Get chart layout to account for price scale and time scale dimensions\n      try {\n        chart.chartElement().querySelector('.tv-lightweight-charts')?.getBoundingClientRect()\n      } catch (e) {\n        // Layout check failed\n      }\n\n      // Get actual chart dimensions using lightweight-charts API\n      let actualTimeScaleHeight = 35 // Fallback\n      let actualPriceScaleWidth = 70 // Fallback\n\n      try {\n        // Get actual time scale height from chart API\n        actualTimeScaleHeight = chart.timeScale().height()\n\n        // Get actual price scale width - try right scale first, then left scale\n        const rightPriceScale = chart.priceScale('right')\n        if (rightPriceScale) {\n          actualPriceScaleWidth = rightPriceScale.width()\n        } else {\n          const leftPriceScale = chart.priceScale('left')\n          if (leftPriceScale) {\n            actualPriceScaleWidth = leftPriceScale.width()\n          }\n        }\n      } catch (e) {\n        // Use fallback values if API calls fail\n      }\n\n      const priceScaleLabelHeight = 20 // Estimated height for price scale labels (e.g., \"161.75\")\n\n      // Helper function to count total number of panes\n      const getTotalPaneCount = (): number => {\n        let paneCount = 0\n        try {\n          // Keep trying to get pane sizes until we find a non-existent pane\n          while (true) {\n            const paneSize = chart.paneSize(paneCount)\n            if (!paneSize || typeof paneSize.height !== 'number') {\n              break\n            }\n            paneCount++\n          }\n        } catch (error) {\n          // When paneSize() throws an error, we've reached the end\n        }\n        return paneCount\n      }\n\n      const totalPanes = getTotalPaneCount()\n\n      // Calculate position-specific margins\n      const getMarginForPosition = (pos: string) => {\n        const baseMargin = UniversalSpacing.EDGE_PADDING\n        const margins = {\n          top: baseMargin + priceScaleLabelHeight, // Add space for price scale labels at top\n          right: baseMargin + actualPriceScaleWidth, // Add space for price scale width\n          bottom: baseMargin, // Base margin for bottom\n          left: baseMargin\n        }\n\n        // Only add time scale height margin for bottom positions when:\n        // 1. It's a bottom position AND\n        // 2. There's only one pane (single-pane chart where X-axis is at bottom of pane 0)\n        // In multi-pane charts, the X-axis is only at the very bottom of the last pane, not pane 0\n        if (pos.includes('bottom') && totalPanes === 1) {\n          margins.bottom += actualTimeScaleHeight // X-axis height only for single-pane charts\n        }\n\n        return margins\n      }\n\n      const margins = getMarginForPosition(position)\n      const rangeSwitcherDimensions = { width: 200, height: 40 } // Estimated dimensions\n\n      let top = 0\n      let left: number | undefined = 0\n      let right: number | undefined\n      let bottom: number | undefined\n\n      // Calculate position based on alignment\n      // Range switcher only supports corner positions\n      // For bottom positions, position relative to pane 0 (main price chart)\n      // For top positions, position relative to entire chart container\n      switch (position) {\n        case 'top-left':\n          top = margins.top\n          left = margins.left\n          right = undefined\n          break\n\n        case 'top-right':\n          top = margins.top\n          left = undefined\n          right = margins.right\n          break\n\n        case 'bottom-left':\n          // Position at bottom of pane 0, not entire chart\n          // This ensures range switcher is positioned at the bottom of the main price chart pane\n          top = paneCoords.bounds.bottom - margins.bottom - rangeSwitcherDimensions.height\n          left = margins.left\n          right = undefined\n          bottom = undefined\n          break\n\n        case 'bottom-right':\n          // Position at bottom of pane 0, not entire chart\n          // This ensures range switcher is positioned at the bottom of the main price chart pane\n          top = paneCoords.bounds.bottom - margins.bottom - rangeSwitcherDimensions.height\n          left = undefined\n          right = margins.right\n          bottom = undefined\n          break\n\n        default:\n          // Default to bottom-right for range switcher\n          top = paneCoords.bounds.bottom - margins.bottom - rangeSwitcherDimensions.height\n          left = undefined\n          right = margins.right\n          break\n      }\n\n      // Convert bottom to top if needed\n      if (bottom !== undefined && top === 0) {\n        top = container.height - bottom - rangeSwitcherDimensions.height\n        bottom = undefined\n      }\n\n      return {\n        top,\n        left,\n        right,\n        bottom,\n        width: rangeSwitcherDimensions.width,\n        height: rangeSwitcherDimensions.height,\n        zIndex: 1000\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Calculate legend position within a pane\n   */\n  getLegendPosition(\n    chart: IChartApi,\n    paneId: number,\n    position: ElementPosition\n  ): LegendCoordinates | null {\n    const paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (!paneCoords) return null\n\n    const margins = getMargins('legend')\n    const legendDimensions = DIMENSIONS.legend\n\n    let top = 0\n    let left = 0\n    let right: number | undefined\n    let bottom: number | undefined\n\n    // Calculate position based on alignment\n    switch (position) {\n      case 'top-left':\n        top = paneCoords.contentArea.top + margins.top\n        left = paneCoords.contentArea.left + margins.left\n        break\n\n      case 'top-right':\n        top = paneCoords.contentArea.top + margins.top\n        right = margins.right\n        break\n\n      case 'top-center':\n        top = paneCoords.contentArea.top + margins.top\n        left = paneCoords.contentArea.left + (paneCoords.contentArea.width - legendDimensions.defaultWidth) / 2\n        break\n\n      case 'bottom-left':\n        bottom = margins.bottom\n        left = paneCoords.contentArea.left + margins.left\n        break\n\n      case 'bottom-right':\n        bottom = margins.bottom\n        right = margins.right\n        break\n\n      case 'bottom-center':\n        bottom = margins.bottom\n        left = paneCoords.contentArea.left + (paneCoords.contentArea.width - legendDimensions.defaultWidth) / 2\n        break\n\n      case 'center':\n        top =\n          paneCoords.contentArea.top +\n          (paneCoords.contentArea.height - legendDimensions.defaultHeight) / 2\n        left =\n          paneCoords.contentArea.left +\n          (paneCoords.contentArea.width - legendDimensions.defaultWidth) / 2\n        break\n    }\n\n    // Convert bottom to top if needed\n    if (bottom !== undefined && top === 0) {\n      top = bottom\n      bottom = undefined\n    }\n\n    return {\n      top,\n      left,\n      right,\n      bottom,\n      width: legendDimensions.defaultWidth,\n      height: legendDimensions.defaultHeight,\n      zIndex: Z_INDEX.legend\n    }\n  }\n\n  /**\n   * Subscribe to coordinate updates\n   */\n  onCoordinateUpdate(chartId: string, callback: () => void): () => void {\n    if (!this.updateCallbacks.has(chartId)) {\n      this.updateCallbacks.set(chartId, new Set())\n    }\n\n    this.updateCallbacks.get(chartId)!.add(callback)\n\n    // Return unsubscribe function\n    return () => {\n      const callbacks = this.updateCallbacks.get(chartId)\n      if (callbacks) {\n        callbacks.delete(callback)\n      }\n    }\n  }\n\n  /**\n   * Invalidate cache for a specific chart\n   */\n  invalidateCache(chartId?: string): void {\n    if (chartId) {\n      // Remove specific chart entries\n      const keysToDelete: string[] = []\n      this.coordinateCache.forEach((entry, key) => {\n        if (key.includes(chartId)) {\n          keysToDelete.push(key)\n        }\n      })\n      keysToDelete.forEach(key => this.coordinateCache.delete(key))\n    } else {\n      // Clear all cache\n      this.coordinateCache.clear()\n    }\n  }\n\n  /**\n   * Calculate coordinates for a chart\n   */\n  private async calculateCoordinates(\n    chart: IChartApi,\n    container: HTMLElement,\n    includeMargins: boolean\n  ): Promise<ChartCoordinates> {\n    return new Promise(resolve => {\n      // Use requestAnimationFrame for better performance\n      requestAnimationFrame(() => {\n        try {\n          // Get container dimensions\n          const containerDimensions = this.getContainerDimensions(container)\n\n          // Get scale dimensions\n          const timeScale = this.getTimeScaleDimensions(chart, containerDimensions)\n          const priceScaleLeft = this.getPriceScaleDimensions(chart, 'left', containerDimensions)\n          const priceScaleRight = this.getPriceScaleDimensions(chart, 'right', containerDimensions)\n\n          // Get all panes\n          const panes = this.getAllPaneCoordinates(chart)\n\n          // Calculate content area\n          const contentArea = this.calculateContentArea(\n            containerDimensions,\n            timeScale,\n            priceScaleLeft,\n            includeMargins\n          )\n\n          const coordinates: ChartCoordinates = {\n            container: containerDimensions,\n            timeScale,\n            priceScaleLeft,\n            priceScaleRight,\n            panes,\n            contentArea,\n            timestamp: Date.now(),\n            isValid: true\n          }\n\n          resolve(coordinates)\n        } catch (error) {\n          resolve(sanitizeCoordinates({}))\n        }\n      })\n    })\n  }\n\n  /**\n   * Get container dimensions\n   */\n  private getContainerDimensions(container: HTMLElement): ContainerDimensions {\n    const rect = container.getBoundingClientRect()\n    return {\n      width: rect.width || container.offsetWidth || getFallback('containerWidth'),\n      height: rect.height || container.offsetHeight || getFallback('containerHeight'),\n      offsetTop: container.offsetTop || 0,\n      offsetLeft: container.offsetLeft || 0\n    }\n  }\n\n  /**\n   * Get time scale dimensions\n   */\n  private getTimeScaleDimensions(\n    chart: IChartApi,\n    container: ContainerDimensions\n  ): ScaleDimensions {\n    try {\n      const timeScale = chart.timeScale()\n      const height = timeScale.height() || getFallback('timeScaleHeight')\n      const width = timeScale.width() || container.width\n\n      return {\n        x: 0,\n        y: container.height - height,\n        width,\n        height\n      }\n    } catch {\n      return {\n        x: 0,\n        y: container.height - getFallback('timeScaleHeight'),\n        width: container.width,\n        height: getFallback('timeScaleHeight')\n      }\n    }\n  }\n\n  /**\n   * Get price scale dimensions\n   */\n  private getPriceScaleDimensions(\n    chart: IChartApi,\n    side: 'left' | 'right',\n    container: ContainerDimensions\n  ): ScaleDimensions {\n    try {\n      const priceScale = chart.priceScale(side)\n      const width = priceScale.width() || (side === 'left' ? getFallback('priceScaleWidth') : 0)\n\n      return {\n        x: side === 'left' ? 0 : container.width - width,\n        y: 0,\n        width,\n        height: container.height - getFallback('timeScaleHeight')\n      }\n    } catch {\n      const defaultWidth = side === 'left' ? getFallback('priceScaleWidth') : 0\n      return {\n        x: side === 'left' ? 0 : container.width - defaultWidth,\n        y: 0,\n        width: defaultWidth,\n        height: container.height - getFallback('timeScaleHeight')\n      }\n    }\n  }\n\n  /**\n   * Get all pane coordinates\n   */\n  private getAllPaneCoordinates(chart: IChartApi): PaneCoordinates[] {\n    const panes: PaneCoordinates[] = []\n    let paneIndex = 0\n    // Track total height for future use (currently disabled)\n\n    // Try to get panes until we hit an invalid one\n    while (paneIndex < 10) {\n      // Safety limit\n      try {\n        const paneSize = chart.paneSize(paneIndex)\n        if (!paneSize) break\n\n        const paneCoords = this.getPaneCoordinates(chart, paneIndex)\n        if (paneCoords) {\n          panes.push(paneCoords)\n        }\n\n        // Track total height for future use\n        paneIndex++\n      } catch {\n        break\n      }\n    }\n\n    // Ensure we have at least one pane\n    if (panes.length === 0) {\n      panes.push({\n        id: 0,\n        index: 0,\n        isMainPane: true,\n        bounds: createBoundingBox(0, 0, getFallback('paneWidth'), getFallback('paneHeight')),\n        contentArea: createBoundingBox(\n          getFallback('priceScaleWidth'),\n          0,\n          getFallback('paneWidth') - getFallback('priceScaleWidth'),\n          getFallback('paneHeight') - getFallback('timeScaleHeight')\n        ),\n        margins: getMargins('pane')\n      })\n    }\n\n    return panes\n  }\n\n  /**\n   * Calculate content area\n   */\n  private calculateContentArea(\n    container: ContainerDimensions,\n    timeScale: ScaleDimensions,\n    priceScaleLeft: ScaleDimensions,\n    includeMargins: boolean\n  ): BoundingBox {\n    const margins = includeMargins ? getMargins('content') : {top: 0, right: 0, bottom: 0, left: 0}\n\n    const x = priceScaleLeft.width + margins.left\n    const y = margins.top\n    const width = container.width - priceScaleLeft.width - margins.left - margins.right\n    const height = container.height - timeScale.height - margins.top - margins.bottom\n\n    return createBoundingBox(x, y, width, height)\n  }\n\n  /**\n   * Get price scale width helper\n   */\n  private getPriceScaleWidth(chart: IChartApi, side: 'left' | 'right' = 'left'): number {\n    try {\n      const priceScale = chart.priceScale(side)\n      const width = priceScale.width()\n\n      // If width is 0 or undefined, the price scale is not visible\n      if (!width || width === 0) {\n        return 0\n      }\n\n      return width\n    } catch {\n      // If we can't access the price scale, assume it's not visible\n      return 0\n    }\n  }\n\n  /**\n   * Get time scale height helper\n   */\n  private getTimeScaleHeight(chart: IChartApi): number {\n    try {\n      const timeScale = chart.timeScale()\n      return timeScale.height() || getFallback('timeScaleHeight')\n    } catch {\n      return getFallback('timeScaleHeight')\n    }\n  }\n\n  /**\n   * Generate cache key\n   */\n  private generateCacheKey(chart: IChartApi, container: HTMLElement): string {\n    const chartId = chart?.chartElement?.()?.id || 'unknown'\n    const containerId = container?.id || 'unknown'\n    return `${chartId}-${containerId}`\n  }\n\n  /**\n   * Notify update callbacks\n   */\n  private notifyUpdateCallbacks(cacheKey: string): void {\n    const chartId = cacheKey.split('-')[0]\n    const callbacks = this.updateCallbacks.get(chartId)\n\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback()\n        } catch (error) {\n        }\n      })\n    }\n  }\n\n  /**\n   * Start cache cleanup timer\n   */\n  private startCacheCleanup(): void {\n    setInterval(() => {\n      const now = Date.now()\n      const keysToDelete: string[] = []\n      this.coordinateCache.forEach((entry, key) => {\n        if (entry.expiresAt < now) {\n          keysToDelete.push(key)\n        }\n      })\n      keysToDelete.forEach(key => this.coordinateCache.delete(key))\n    }, TIMING.cacheExpiration)\n  }\n\n  /**\n   * Get current pane dimensions for comparison\n   */\n  getCurrentPaneDimensions(chart: IChartApi): {\n    [paneId: number]: {width: number; height: number}\n  } {\n    const dimensions: {[paneId: number]: {width: number; height: number}} = {}\n    let paneIndex = 0\n\n    while (paneIndex < 10) {\n      // Safety limit\n      try {\n        const paneSize = chart.paneSize(paneIndex)\n        if (!paneSize) break\n\n        dimensions[paneIndex] = {\n          width: paneSize.width || 0,\n          height: paneSize.height || 0\n        }\n\n        paneIndex++\n      } catch {\n        break\n      }\n    }\n\n    return dimensions\n  }\n\n  /**\n   * Check if pane dimensions have changed and notify listeners\n   */\n  checkPaneSizeChanges(chart: IChartApi, chartId: string): boolean {\n    const currentDimensions = this.getCurrentPaneDimensions(chart)\n    const cacheKey = this.generateCacheKey(chart, chart.chartElement())\n\n    // Check if we have cached pane dimensions\n    const cachedPaneDimensions = this.paneDimensionsCache.get(cacheKey)\n\n    if (!cachedPaneDimensions) {\n      // First time checking, store current dimensions\n      this.paneDimensionsCache.set(cacheKey, {\n        dimensions: currentDimensions,\n        expiresAt: Date.now() + TIMING.cacheExpiration\n      })\n      return false\n    }\n\n    // Compare with cached dimensions\n    const hasChanges = this.hasPaneSizeChanges(cachedPaneDimensions.dimensions, currentDimensions)\n\n    if (hasChanges) {\n      // Update cached dimensions\n      cachedPaneDimensions.dimensions = currentDimensions\n      cachedPaneDimensions.expiresAt = Date.now() + TIMING.cacheExpiration\n      // Invalidate the coordinate cache to force recalculation\n      this.invalidateCache(chartId)\n      // Notify listeners about the change\n      this.notifyUpdateCallbacks(cacheKey)\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Enhanced pane size change detection with better performance\n   */\n  checkPaneSizeChangesOptimized(chart: IChartApi, chartId: string): boolean {\n    const currentDimensions = this.getCurrentPaneDimensions(chart)\n    const cacheKey = this.generateCacheKey(chart, chart.chartElement())\n\n    // Check if we have cached pane dimensions\n    const cachedPaneDimensions = this.paneDimensionsCache.get(cacheKey)\n\n    if (!cachedPaneDimensions) {\n      // First time checking, store current dimensions\n      this.paneDimensionsCache.set(cacheKey, {\n        dimensions: currentDimensions,\n        expiresAt: Date.now() + TIMING.cacheExpiration\n      })\n      return false\n    }\n\n    // Check if dimensions have changed\n    const hasChanges = this.hasPaneSizeChanges(cachedPaneDimensions.dimensions, currentDimensions)\n\n    if (hasChanges) {\n      // Update cached pane dimensions\n      cachedPaneDimensions.dimensions = currentDimensions\n      cachedPaneDimensions.expiresAt = Date.now() + TIMING.cacheExpiration\n\n      // Invalidate coordinate cache for this chart\n      this.invalidateCache(chartId)\n\n      // Notify listeners\n      this.notifyUpdateCallbacks(cacheKey)\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Force refresh of coordinates for a specific chart\n   * Useful when external changes affect chart layout\n   */\n  forceRefreshCoordinates(chartId: string): void {\n    // Clear all cache entries for this chart\n    const keysToDelete: string[] = []\n    this.coordinateCache.forEach((entry, key) => {\n      if (key.includes(chartId)) {\n        keysToDelete.push(key)\n      }\n    })\n    keysToDelete.forEach(key => this.coordinateCache.delete(key))\n\n    // Also clear pane dimensions cache\n    const paneKeysToDelete: string[] = []\n    this.paneDimensionsCache.forEach((entry, key) => {\n      if (key.includes(chartId)) {\n        paneKeysToDelete.push(key)\n      }\n    })\n    paneKeysToDelete.forEach(key => this.paneDimensionsCache.delete(key))\n\n    // Notify all listeners for this chart\n    this.updateCallbacks.forEach((callbacks, key) => {\n      if (key.includes(chartId)) {\n        callbacks.forEach(callback => {\n          try {\n            callback()\n          } catch (error) {\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Check if pane dimensions have changed\n   */\n  private hasPaneSizeChanges(\n    oldDimensions: {[paneId: number]: {width: number; height: number}},\n    newDimensions: {[paneId: number]: {width: number; height: number}}\n  ): boolean {\n    const oldKeys = Object.keys(oldDimensions)\n    const newKeys = Object.keys(newDimensions)\n\n    if (oldKeys.length !== newKeys.length) {\n      return true\n    }\n\n    for (const paneId of oldKeys) {\n      const oldDim = oldDimensions[parseInt(paneId)]\n      const newDim = newDimensions[parseInt(paneId)]\n\n      if (!oldDim || !newDim) {\n        return true\n      }\n\n      if (oldDim.width !== newDim.width || oldDim.height !== newDim.height) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Integration with CornerLayoutManager\n   * Get chart dimensions for layout manager\n   */\n  getChartDimensionsForLayout(chart: IChartApi): { width: number; height: number } | null {\n    try {\n      const chartElement = chart.chartElement()\n      if (!chartElement) return null\n\n      const rect = chartElement.getBoundingClientRect()\n      return {\n        width: rect.width || chartElement.offsetWidth || 800,\n        height: rect.height || chartElement.offsetHeight || 600\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get chart layout dimensions including axis information for layout manager\n   */\n  getChartLayoutDimensionsForManager(chart: IChartApi): any {\n    try {\n      const chartElement = chart.chartElement()\n      if (!chartElement) return null\n\n      const rect = chartElement.getBoundingClientRect()\n      const container = {\n        width: rect.width || chartElement.offsetWidth || 800,\n        height: rect.height || chartElement.offsetHeight || 600\n      }\n\n      // Get axis dimensions\n      let leftPriceScaleWidth = 0\n      let rightPriceScaleWidth = 0\n      let timeScaleHeight = 0\n\n      try {\n        // Get time scale height\n        const timeScale = chart.timeScale()\n        timeScaleHeight = timeScale.height() || 35\n\n        // Get left price scale width\n        const leftPriceScale = chart.priceScale('left')\n        if (leftPriceScale) {\n          leftPriceScaleWidth = leftPriceScale.width() || 0\n        }\n\n        // Get right price scale width\n        const rightPriceScale = chart.priceScale('right')\n        if (rightPriceScale) {\n          rightPriceScaleWidth = rightPriceScale.width() || 0\n        }\n\n        // If no price scales are visible, default to right scale\n        if (leftPriceScaleWidth === 0 && rightPriceScaleWidth === 0) {\n          rightPriceScaleWidth = 70 // Default right price scale width\n        }\n      } catch (scaleError) {\n        // Fallback values\n        rightPriceScaleWidth = 70\n        timeScaleHeight = 35\n      }\n\n      return {\n        container,\n        axis: {\n          priceScale: {\n            left: {\n              width: leftPriceScaleWidth,\n              height: container.height - timeScaleHeight\n            },\n            right: {\n              width: rightPriceScaleWidth,\n              height: container.height - timeScaleHeight\n            }\n          },\n          timeScale: {\n            width: container.width,\n            height: timeScaleHeight\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error getting chart layout dimensions:', error)\n      return {\n        container: { width: 800, height: 600 },\n        axis: {\n          priceScale: {\n            left: { width: 0, height: 565 },\n            right: { width: 70, height: 565 }\n          },\n          timeScale: { width: 800, height: 35 }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert ElementPosition to Corner for layout manager\n   */\n  positionToCorner(position: ElementPosition): string {\n    // Map supported positions to corners, with fallbacks for unsupported positions\n    switch (position) {\n      case 'top-left':\n        return 'top-left'\n      case 'top-right':\n        return 'top-right'\n      case 'bottom-left':\n        return 'bottom-left'\n      case 'bottom-right':\n        return 'bottom-right'\n      case 'top-center':\n        return 'top-right' // Fallback to top-right\n      case 'bottom-center':\n        return 'bottom-right' // Fallback to bottom-right\n      case 'center':\n        return 'top-right' // Fallback to top-right\n      default:\n        return 'top-right'\n    }\n  }\n\n  /**\n   * ================================\n   * POSITIONING ENGINE FUNCTIONALITY\n   * Absorbed from PositioningEngine to ensure single source of truth\n   * ================================\n   */\n\n  /**\n   * Calculate legend position with consistent logic\n   */\n  calculateLegendPosition(\n    chart: IChartApi,\n    paneId: number,\n    position: ElementPosition,\n    config?: PositioningConfig\n  ): LegendCoordinates | null {\n    // Use existing getPaneCoordinates method\n    const paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (!paneCoords) return null\n\n    // Merge configuration with defaults\n    const margins = {...getMargins('legend'), ...(config?.margins || {})}\n\n    // For initial positioning, use default dimensions\n    // The actual dimensions will be calculated when the element is rendered\n    const dimensions = {\n      width: config?.dimensions?.width || DIMENSIONS.legend.defaultWidth,\n      height: config?.dimensions?.height || DIMENSIONS.legend.defaultHeight\n    }\n\n    const zIndex = config?.zIndex || Z_INDEX.legend\n    const offset = config?.offset || {x: 0, y: 0}\n\n    // Calculate position based on alignment\n    // Use full pane bounds for legends to avoid time axis clipping\n    const coords = this.calculateElementPosition(\n      paneCoords.bounds,\n      dimensions,\n      position,\n      margins,\n      offset\n    )\n\n    return {\n      ...coords,\n      width: dimensions.width,\n      height: dimensions.height,\n      zIndex\n    }\n  }\n\n  /**\n   * Recalculate legend position with actual element dimensions\n   */\n  recalculateLegendPosition(\n    chart: IChartApi,\n    paneId: number,\n    position: ElementPosition,\n    legendElement: HTMLElement,\n    config?: PositioningConfig\n  ): LegendCoordinates | null {\n    // Use existing getPaneCoordinates method\n    const paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (!paneCoords) return null\n\n    // Get actual element dimensions with fallbacks\n    let actualDimensions = {\n      width: legendElement.offsetWidth || legendElement.scrollWidth || 0,\n      height: legendElement.offsetHeight || legendElement.scrollHeight || 0\n    }\n\n    // If dimensions are still 0, try to get them from computed styles\n    if (actualDimensions.width === 0 || actualDimensions.height === 0) {\n      const computedStyle = window.getComputedStyle(legendElement)\n      actualDimensions = {\n        width:\n          parseInt(computedStyle.width) ||\n          legendElement.clientWidth ||\n          DIMENSIONS.legend.defaultWidth,\n        height:\n          parseInt(computedStyle.height) ||\n          legendElement.clientHeight ||\n          DIMENSIONS.legend.defaultHeight\n      }\n    }\n\n    // Ensure minimum dimensions\n    actualDimensions.width = Math.max(actualDimensions.width, DIMENSIONS.legend.minWidth)\n    actualDimensions.height = Math.max(actualDimensions.height, DIMENSIONS.legend.minHeight)\n\n    // Merge configuration with defaults\n    const margins = {...getMargins('legend'), ...(config?.margins || {})}\n    const zIndex = config?.zIndex || Z_INDEX.legend\n    const offset = config?.offset || {x: 0, y: 0}\n\n    // Calculate position based on actual dimensions\n    // Use full pane bounds for legends to avoid time axis clipping\n    const coords = this.calculateElementPosition(\n      paneCoords.bounds,\n      actualDimensions,\n      position,\n      margins,\n      offset\n    )\n\n    return {\n      ...coords,\n      width: actualDimensions.width,\n      height: actualDimensions.height,\n      zIndex\n    }\n  }\n\n  /**\n   * Calculate tooltip position relative to cursor\n   */\n  calculateTooltipPosition(\n    cursorX: number,\n    cursorY: number,\n    tooltipWidth: number,\n    tooltipHeight: number,\n    containerBounds: BoundingBox,\n    preferredAnchor: 'top' | 'bottom' | 'left' | 'right' = 'top'\n  ): TooltipPosition {\n    const margins = getMargins('tooltip')\n    const offset = {x: 10, y: 10}\n\n    let x = cursorX\n    let y = cursorY\n    let anchor = preferredAnchor\n\n    // Calculate position based on preferred anchor\n    switch (preferredAnchor) {\n      case 'top':\n        x = cursorX - tooltipWidth / 2\n        y = cursorY - tooltipHeight - offset.y\n        break\n      case 'bottom':\n        x = cursorX - tooltipWidth / 2\n        y = cursorY + offset.y\n        break\n      case 'left':\n        x = cursorX - tooltipWidth - offset.x\n        y = cursorY - tooltipHeight / 2\n        break\n      case 'right':\n        x = cursorX + offset.x\n        y = cursorY - tooltipHeight / 2\n        break\n    }\n\n    // Adjust if tooltip goes outside container bounds\n    if (x < containerBounds.left + margins.left) {\n      x = containerBounds.left + margins.left\n      if (anchor === 'left') anchor = 'right'\n    }\n    if (x + tooltipWidth > containerBounds.right - margins.right) {\n      x = containerBounds.right - tooltipWidth - margins.right\n      if (anchor === 'right') anchor = 'left'\n    }\n    if (y < containerBounds.top + margins.top) {\n      y = containerBounds.top + margins.top\n      if (anchor === 'top') anchor = 'bottom'\n    }\n    if (y + tooltipHeight > containerBounds.bottom - margins.bottom) {\n      y = containerBounds.bottom - tooltipHeight - margins.bottom\n      if (anchor === 'bottom') anchor = 'top'\n    }\n\n    return {x, y, anchor, offset}\n  }\n\n  /**\n   * Calculate overlay position (for rectangles, annotations, etc.)\n   * Note: This requires a series to convert prices to coordinates\n   */\n  calculateOverlayPosition(\n    startTime: Time,\n    endTime: Time,\n    startPrice: number,\n    endPrice: number,\n    chart: IChartApi,\n    series?: ISeriesApi<any>,\n    paneId: number = 0\n  ): BoundingBox | null {\n    try {\n      const timeScale = chart.timeScale()\n\n      // Convert time to x coordinates\n      const x1 = timeScale.timeToCoordinate(startTime)\n      const x2 = timeScale.timeToCoordinate(endTime)\n\n      // Convert price to y coordinates (requires series)\n      let y1: number | null = null\n      let y2: number | null = null\n\n      if (series) {\n        y1 = series.priceToCoordinate(startPrice)\n        y2 = series.priceToCoordinate(endPrice)\n      } else {\n        // Fallback: estimate based on chart height\n        const chartElement = chart.chartElement()\n        if (chartElement) {\n          const height = chartElement.clientHeight\n          // Simple linear mapping (this is a rough approximation)\n          y1 = height * 0.3 // Default positions\n          y2 = height * 0.7\n        }\n      }\n\n      if (x1 === null || x2 === null || y1 === null || y2 === null) {\n        return null\n      }\n\n      // Calculate bounding box\n      const x = Math.min(x1, x2)\n      const y = Math.min(y1, y2)\n      const width = Math.abs(x2 - x1)\n      const height = Math.abs(y2 - y1)\n\n      return createBoundingBox(x, y, width, height)\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Calculate multi-pane layout positions\n   */\n  calculateMultiPaneLayout(\n    totalHeight: number,\n    paneHeights: number[] | 'equal' | {[key: number]: number}\n  ): {[paneId: number]: BoundingBox} {\n    const layout: {[paneId: number]: BoundingBox} = {}\n\n    if (paneHeights === 'equal') {\n      // Equal height distribution\n      const paneCount = Object.keys(layout).length || 1\n      const heightPerPane = totalHeight / paneCount\n\n      for (let i = 0; i < paneCount; i++) {\n        layout[i] = createBoundingBox(\n          0,\n          i * heightPerPane,\n          0, // Width will be set by chart\n          heightPerPane\n        )\n      }\n    } else if (Array.isArray(paneHeights)) {\n      // Specific heights for each pane\n      let currentY = 0\n      paneHeights.forEach((height, index) => {\n        layout[index] = createBoundingBox(\n          0,\n          currentY,\n          0, // Width will be set by chart\n          height\n        )\n        currentY += height\n      })\n    } else {\n      // Object with pane ID to height mapping\n      let currentY = 0\n      for (const [paneId, height] of Object.entries(paneHeights)) {\n        layout[Number(paneId)] = createBoundingBox(\n          0,\n          currentY,\n          0, // Width will be set by chart\n          height\n        )\n        currentY += height\n      }\n    }\n\n    return layout\n  }\n\n  /**\n   * Calculate crosshair label position\n   */\n  calculateCrosshairLabelPosition(\n    crosshairX: number,\n    crosshairY: number,\n    labelWidth: number,\n    labelHeight: number,\n    containerBounds: BoundingBox,\n    axis: 'x' | 'y'\n  ): {x: number; y: number} {\n    const margins = getMargins('content')\n\n    if (axis === 'x') {\n      // Time axis label\n      return {\n        x: Math.max(\n          containerBounds.left + margins.left,\n          Math.min(crosshairX - labelWidth / 2, containerBounds.right - labelWidth - margins.right)\n        ),\n        y: containerBounds.bottom - labelHeight - margins.bottom\n      }\n    } else {\n      // Price axis label\n      return {\n        x: containerBounds.right - labelWidth - margins.right,\n        y: Math.max(\n          containerBounds.top + margins.top,\n          Math.min(\n            crosshairY - labelHeight / 2,\n            containerBounds.bottom - labelHeight - margins.bottom\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * Calculate element position within bounds\n   */\n  private calculateElementPosition(\n    bounds: BoundingBox,\n    dimensions: {width: number; height: number},\n    position: ElementPosition,\n    margins: Margins,\n    offset: {x?: number; y?: number}\n  ): {top: number; left: number; right?: number; bottom?: number} {\n    const offsetX = offset.x || 0\n    const offsetY = offset.y || 0\n\n    switch (position) {\n      case 'top-left':\n        return {\n          top: bounds.top + margins.top + offsetY,\n          left: bounds.left + margins.left + offsetX\n        }\n\n      case 'top-right':\n        return {\n          top: bounds.top + margins.top + offsetY,\n          left: bounds.right - dimensions.width - margins.right - offsetX,\n          right: margins.right + offsetX\n        }\n\n      case 'bottom-left':\n        return {\n          top: bounds.bottom - dimensions.height - margins.bottom - offsetY,\n          left: bounds.left + margins.left + offsetX,\n          bottom: margins.bottom + offsetY\n        }\n\n      case 'bottom-right':\n        return {\n          top: bounds.bottom - dimensions.height - margins.bottom - offsetY,\n          left: bounds.right - dimensions.width - margins.right - offsetX,\n          right: margins.right + offsetX,\n          bottom: margins.bottom + offsetY\n        }\n\n      case 'center':\n        return {\n          top: bounds.top + (bounds.height - dimensions.height) / 2 + offsetY,\n          left: bounds.left + (bounds.width - dimensions.width) / 2 + offsetX\n        }\n\n      default:\n        return {\n          top: bounds.top + margins.top + offsetY,\n          left: bounds.left + margins.left + offsetX\n        }\n    }\n  }\n\n  /**\n   * Validate positioning constraints\n   */\n  validatePositioning(\n    element: BoundingBox,\n    container: BoundingBox\n  ): {isValid: boolean; adjustments: {x?: number; y?: number}} {\n    const adjustments: {x?: number; y?: number} = {}\n    let isValid = true\n\n    // Check if element fits within container\n    if (element.left < container.left) {\n      adjustments.x = container.left - element.left\n      isValid = false\n    } else if (element.right > container.right) {\n      adjustments.x = container.right - element.right\n      isValid = false\n    }\n\n    if (element.top < container.top) {\n      adjustments.y = container.top - element.top\n      isValid = false\n    } else if (element.bottom > container.bottom) {\n      adjustments.y = container.bottom - element.bottom\n      isValid = false\n    }\n\n    return {isValid, adjustments}\n  }\n\n  /**\n   * Apply positioning to DOM element\n   */\n  applyPositionToElement(\n    element: HTMLElement,\n    coordinates: LegendCoordinates | {top: number; left: number; right?: number; bottom?: number}\n  ): void {\n    // Reset all position properties\n    element.style.top = 'auto'\n    element.style.left = 'auto'\n    element.style.right = 'auto'\n    element.style.bottom = 'auto'\n\n    // Apply new position\n    if (coordinates.top !== undefined) {\n      element.style.top = `${coordinates.top}px`\n    }\n    if (coordinates.left !== undefined) {\n      element.style.left = `${coordinates.left}px`\n    }\n    if (coordinates.right !== undefined) {\n      element.style.right = `${coordinates.right}px`\n    }\n    if (coordinates.bottom !== undefined) {\n      element.style.bottom = `${coordinates.bottom}px`\n    }\n\n    // Apply z-index if available\n    if ('zIndex' in coordinates && coordinates.zIndex !== undefined) {\n      element.style.zIndex = String(coordinates.zIndex)\n    }\n\n    // Ensure position is absolute\n    if (!element.style.position || element.style.position === 'static') {\n      element.style.position = 'absolute'\n    }\n  }\n\n  /**\n   * Calculate responsive scaling factor\n   */\n  calculateScalingFactor(\n    currentWidth: number,\n    currentHeight: number,\n    baseWidth: number = DIMENSIONS.chart.defaultWidth,\n    baseHeight: number = DIMENSIONS.chart.defaultHeight\n  ): {x: number; y: number; uniform: number} {\n    const scaleX = currentWidth / baseWidth\n    const scaleY = currentHeight / baseHeight\n    const uniform = Math.min(scaleX, scaleY)\n\n    return {x: scaleX, y: scaleY, uniform}\n  }\n\n  /**\n   * Calculate widget stack position for layout manager support\n   */\n  calculateWidgetStackPosition(\n    chart: IChartApi,\n    paneId: number,\n    corner: string,\n    widgets: any[],\n    index: number\n  ): any {\n    // Get pane coordinates\n    const paneCoords = this.getPaneCoordinates(chart, paneId)\n    if (!paneCoords) return null\n\n    const isTopCorner = corner.startsWith('top')\n    const isRightCorner = corner.endsWith('right')\n\n    // Get actual axis dimensions from lightweight-charts APIs\n    const axisDimensions = this.getAxisDimensions(chart)\n\n    // Calculate cumulative offset from previous widgets\n    let cumulativeHeight = 0\n    for (let i = 0; i < index; i++) {\n      const prevWidget = widgets[i]\n      if (prevWidget && prevWidget.visible) {\n        const dims = prevWidget.getDimensions()\n\n        // If dimensions are 0, use a reasonable fallback for legends/buttons\n        let height = dims.height\n        if (height === 0) {\n          // Estimate height based on widget type\n          if (prevWidget.getContainerClassName && prevWidget.getContainerClassName().includes('legend')) {\n            height = 24 // Default legend height\n          } else if (prevWidget.getContainerClassName && prevWidget.getContainerClassName().includes('button')) {\n            height = 16 // Default button height\n          } else {\n            height = 20 // Generic fallback\n          }\n        }\n\n        cumulativeHeight += height + UniversalSpacing.WIDGET_GAP // Widget gap between stacked legends\n\n      }\n    }\n\n\n    const position: any = {\n      zIndex: 1000 + index\n    }\n\n    const edgePadding = UniversalSpacing.EDGE_PADDING\n\n    // Set horizontal position using actual Y-axis widths from price scale APIs\n    if (isRightCorner) {\n      // For right corners, account for right price scale width\n      position.right = edgePadding + axisDimensions.rightPriceScaleWidth\n    } else {\n      // For left corners, account for left price scale width\n      position.left = edgePadding + axisDimensions.leftPriceScaleWidth\n    }\n\n    // Set vertical position using actual X-axis height from time scale API\n    if (isTopCorner) {\n      position.top = paneCoords.bounds.top + edgePadding + cumulativeHeight\n    } else {\n      // For bottom positioning, account for X-axis height on the last pane\n      let bottomOffset = edgePadding + cumulativeHeight\n\n      const isLastPane = this.isLastPane(chart, paneId)\n      if (isLastPane) {\n        // Add actual X-axis height from time scale API\n        bottomOffset += axisDimensions.timeScaleHeight\n      }\n\n      position.bottom = bottomOffset\n    }\n\n    return position\n  }\n\n  /**\n   * Get actual axis dimensions from lightweight-charts APIs\n   */\n  private getAxisDimensions(chart: IChartApi): {\n    timeScaleHeight: number;\n    leftPriceScaleWidth: number;\n    rightPriceScaleWidth: number;\n  } {\n    let timeScaleHeight = 35 // Default fallback\n    let leftPriceScaleWidth = 0 // Default: no left scale\n    let rightPriceScaleWidth = 70 // Default fallback for right scale\n\n    try {\n      // Get X-axis (time scale) height using ITimeScaleApi\n      timeScaleHeight = chart.timeScale().height()\n    } catch (error) {\n      // Use fallback value\n    }\n\n    try {\n      // Get left Y-axis (price scale) width using IPriceScaleApi\n      const leftPriceScale = chart.priceScale('left')\n      if (leftPriceScale) {\n        leftPriceScaleWidth = leftPriceScale.width()\n      }\n    } catch (error) {\n      // Left scale doesn't exist or failed - keep default 0\n    }\n\n    try {\n      // Get right Y-axis (price scale) width using IPriceScaleApi\n      const rightPriceScale = chart.priceScale('right')\n      if (rightPriceScale) {\n        rightPriceScaleWidth = rightPriceScale.width()\n      }\n    } catch (error) {\n      // Use fallback value\n    }\n\n    return {\n      timeScaleHeight,\n      leftPriceScaleWidth,\n      rightPriceScaleWidth\n    }\n  }\n\n  /**\n   * Check if the given pane is the last pane in the chart\n   */\n  private isLastPane(chart: IChartApi, paneId: number): boolean {\n    try {\n      // Try to get the next pane - if it fails, this is the last pane\n      chart.paneSize(paneId + 1)\n      return false // If we get here, there's a next pane\n    } catch (error) {\n      return true // Error means no next pane exists\n    }\n  }\n\n  /**\n   * Calculate cumulative offset for widget stacking\n   */\n  calculateCumulativeOffset(widgets: any[], index: number, gap: number = 8): number {\n    let cumulativeHeight = 0\n    for (let i = 0; i < index; i++) {\n      const prevWidget = widgets[i]\n      if (prevWidget && prevWidget.visible) {\n        const dims = prevWidget.getDimensions()\n        cumulativeHeight += dims.height + gap\n      }\n    }\n    return cumulativeHeight\n  }\n\n  /**\n   * Validate stacking bounds for overflow detection\n   */\n  validateStackingBounds(\n    corner: string,\n    widgets: any[],\n    containerBounds: BoundingBox\n  ): {isValid: boolean; overflowingWidgets: any[]} {\n    const overflowing: any[] = []\n    const isTopCorner = corner.startsWith('top')\n    let cumulativeHeight = UniversalSpacing.EDGE_PADDING // Edge padding\n\n    for (const widget of widgets) {\n      if (!widget.visible) continue\n\n      const dims = widget.getDimensions()\n      const totalHeightRequired = cumulativeHeight + dims.height + UniversalSpacing.EDGE_PADDING // Edge padding\n\n      if (isTopCorner) {\n        if (totalHeightRequired > containerBounds.height) {\n          overflowing.push(widget)\n        }\n      } else {\n        if (totalHeightRequired > containerBounds.height) {\n          overflowing.push(widget)\n        }\n      }\n\n      cumulativeHeight += dims.height + UniversalSpacing.WIDGET_GAP // Widget gap\n    }\n\n    return {\n      isValid: overflowing.length === 0,\n      overflowingWidgets: overflowing\n    }\n  }\n\n  /**\n   * Setup automatic layout manager updates when chart dimensions change\n   */\n  setupLayoutManagerIntegration(chart: IChartApi, layoutManager: any): void {\n    const updateLayoutManager = () => {\n      const layoutDimensions = this.getChartLayoutDimensionsForManager(chart)\n      if (layoutDimensions) {\n        layoutManager.updateChartLayout(layoutDimensions)\n      }\n    }\n\n    // Fast synchronous update for resize events\n    const fastUpdateLayoutManager = () => {\n      // Use immediate dimension update for fast resize response\n      if (layoutManager.updateChartDimensionsFromElement) {\n        layoutManager.updateChartDimensionsFromElement()\n      } else {\n        // Fallback to async method\n        updateLayoutManager()\n      }\n    }\n\n    // Immediate setup for fast resize performance\n    updateLayoutManager()\n\n    // Single follow-up using requestAnimationFrame for smooth updates\n    requestAnimationFrame(() => {\n      updateLayoutManager()\n    })\n\n    // Watch for chart element resize and pane changes\n    try {\n      const chartElement = chart.chartElement()\n      if (chartElement && typeof ResizeObserver !== 'undefined') {\n        let lastLayoutUpdate = 0\n        const layoutThrottleDelay = 16 // ~60fps max to prevent X-axis lag\n        const resizeObserver = new ResizeObserver(() => {\n          // Throttle layout updates to prevent performance issues during pan/zoom\n          const now = Date.now()\n          if (now - lastLayoutUpdate >= layoutThrottleDelay) {\n            lastLayoutUpdate = now\n            fastUpdateLayoutManager()\n          }\n        })\n        resizeObserver.observe(chartElement)\n      }\n\n      // Watch for pane size changes using periodic checks\n      // This is necessary because LightweightCharts doesn't provide pane resize events\n      let lastPaneSizes: Array<{ width: number; height: number }> = []\n\n      const checkPaneChanges = () => {\n        try {\n          const currentPaneSizes: Array<{ width: number; height: number }> = []\n\n          // Get current pane sizes\n          for (let i = 0; i < 10; i++) { // Check up to 10 panes\n            try {\n              const paneSize = chart.paneSize(i)\n              if (paneSize) {\n                currentPaneSizes[i] = { width: paneSize.width, height: paneSize.height }\n              }\n            } catch {\n              break // No more panes\n            }\n          }\n\n          // Compare with last known sizes\n          let changed = currentPaneSizes.length !== lastPaneSizes.length\n          if (!changed) {\n            for (let i = 0; i < currentPaneSizes.length; i++) {\n              const current = currentPaneSizes[i]\n              const last = lastPaneSizes[i]\n              if (!last || current.width !== last.width || current.height !== last.height) {\n                changed = true\n                break\n              }\n            }\n          }\n\n          if (changed) {\n            lastPaneSizes = currentPaneSizes\n            updateLayoutManager()\n          }\n        } catch (error) {\n          // Ignore errors in pane change detection\n        }\n      }\n\n      // Check for pane changes every 250ms for responsive UI (reduced frequency to prevent X-axis lag)\n      const paneCheckInterval = setInterval(checkPaneChanges, 250)\n\n      // Clean up interval after a reasonable time\n      setTimeout(() => {\n        clearInterval(paneCheckInterval)\n      }, 300000) // 5 minutes\n\n    } catch (error) {\n      // Fallback to periodic checks if ResizeObserver not available\n      const intervalId = setInterval(updateLayoutManager, 1000)\n\n      // Clean up interval on chart destruction\n      setTimeout(() => {\n        clearInterval(intervalId)\n      }, 60000) // Clean up after 1 minute as fallback\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/ChartDimensionsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/ChartPrimitiveManager.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'ISeriesApi' is defined but never used.","line":1,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ISeriesApi' is defined but never used.","line":1,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'crosshairData' is defined but never used. Allowed unused args must match /^_/u.","line":176,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":176,"endColumn":62},{"ruleId":"no-unused-vars","severity":1,"message":"'primitiveId' is assigned a value but never used.","line":220,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":220,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'primitiveId' is assigned a value but never used.","line":220,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":220,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IChartApi, ISeriesApi } from 'lightweight-charts'\nimport { LegendPrimitive } from '../primitives/LegendPrimitive'\nimport { RangeSwitcherPrimitive, DefaultRangeConfigs } from '../primitives/RangeSwitcherPrimitive'\nimport { PrimitiveEventManager } from './PrimitiveEventManager'\nimport { CornerLayoutManager } from './CornerLayoutManager'\nimport { LegendConfig, RangeSwitcherConfig, PaneCollapseConfig } from '../types'\nimport { ExtendedSeriesApi, CrosshairEventData } from '../types/ChartInterfaces'\nimport { PrimitivePriority } from '../primitives/BasePanePrimitive'\nimport { PaneButtonPanelPlugin, createPaneButtonPanelPlugin } from '../plugins/chart/paneButtonPanelPlugin'\n\n/**\n * ChartPrimitiveManager - Centralized management for all chart primitives\n *\n * This service provides unified API for adding/removing primitives and replaces\n * the old ChartWidgetManager system with pure primitive-only approach.\n */\nexport class ChartPrimitiveManager {\n  private static instances: Map<string, ChartPrimitiveManager> = new Map()\n\n  private chart: IChartApi\n  private chartId: string\n  private eventManager: PrimitiveEventManager\n  private primitives: Map<string, LegendPrimitive | RangeSwitcherPrimitive | PaneButtonPanelPlugin> = new Map()\n  private legendCounter: number = 0\n\n  private constructor(chart: IChartApi, chartId: string) {\n    this.chart = chart\n    this.chartId = chartId\n    this.eventManager = PrimitiveEventManager.getInstance(chartId)\n    this.eventManager.initialize(chart)\n  }\n\n  /**\n   * Get or create primitive manager for a chart\n   */\n  public static getInstance(chart: IChartApi, chartId: string): ChartPrimitiveManager {\n    if (!ChartPrimitiveManager.instances.has(chartId)) {\n      ChartPrimitiveManager.instances.set(chartId, new ChartPrimitiveManager(chart, chartId))\n    }\n    return ChartPrimitiveManager.instances.get(chartId)!\n  }\n\n  /**\n   * Clean up primitive manager for a chart\n   */\n  public static cleanup(chartId: string): void {\n    const instance = ChartPrimitiveManager.instances.get(chartId)\n    if (instance) {\n      instance.destroy()\n      ChartPrimitiveManager.instances.delete(chartId)\n    }\n\n    // Also cleanup the layout manager and event manager for this chart\n    CornerLayoutManager.cleanup(chartId)\n    PrimitiveEventManager.cleanup(chartId)\n  }\n\n  /**\n   * Add range switcher primitive\n   */\n  public addRangeSwitcher(config: RangeSwitcherConfig): { destroy: () => void } {\n    const primitiveId = `range-switcher-${this.chartId}`\n\n    try {\n      const rangeSwitcher = new RangeSwitcherPrimitive(primitiveId, {\n        corner: config.position || 'top-right',\n        priority: PrimitivePriority.RANGE_SWITCHER,\n        ranges: config.ranges || [...DefaultRangeConfigs.trading],\n      })\n\n      // Attach to first pane (chart-level primitives go to pane 0)\n      const panes = this.chart.panes()\n      if (panes.length > 0) {\n        panes[0].attachPrimitive(rangeSwitcher)\n      }\n      this.primitives.set(primitiveId, rangeSwitcher)\n\n      return {\n        destroy: () => this.destroyPrimitive(primitiveId)\n      }\n    } catch (error) {\n      return { destroy: () => {} }\n    }\n  }\n\n  /**\n   * Add legend primitive\n   */\n  public addLegend(\n    config: LegendConfig,\n    isPanePrimitive: boolean = false,\n    paneId: number = 0,\n    seriesReference?: ExtendedSeriesApi\n  ): { destroy: () => void } {\n    const primitiveId = `legend-${this.chartId}-${++this.legendCounter}`\n\n    try {\n      const legend = new LegendPrimitive(primitiveId, {\n        corner: config.position || 'top-left',\n        priority: PrimitivePriority.LEGEND,\n        text: config.text || '$$value$$',\n        valueFormat: config.valueFormat || '.2f',\n        isPanePrimitive,\n        paneId,\n        style: {\n          backgroundColor: config.backgroundColor || 'rgba(0, 0, 0, 0.8)',\n          color: config.textColor || 'white'\n        }\n      })\n\n      // Attach to series if we have a series reference (preferred for legends)\n      if (seriesReference) {\n        try {\n          seriesReference.attachPrimitive(legend)\n        } catch (error) {\n          // Fallback to pane attachment if series attachment fails\n          this.attachToPaneAsFallback(legend, isPanePrimitive, paneId)\n        }\n      } else {\n        // Attach to appropriate level (chart or pane) when no series reference\n        this.attachToPaneAsFallback(legend, isPanePrimitive, paneId)\n      }\n\n      this.primitives.set(primitiveId, legend)\n\n      return {\n        destroy: () => this.destroyPrimitive(primitiveId)\n      }\n    } catch (error) {\n      return { destroy: () => {} }\n    }\n  }\n\n\n  /**\n   * Add button panel (gear + collapse buttons) primitive\n   */\n  public addButtonPanel(\n    paneId: number,\n    config: PaneCollapseConfig = {}\n  ): { destroy: () => void; plugin: PaneButtonPanelPlugin } {\n    const primitiveId = `button-panel-${this.chartId}-${paneId}`\n\n    try {\n      const buttonPanel = createPaneButtonPanelPlugin(paneId, config, this.chartId)\n\n      // Attach to appropriate pane\n      const panes = this.chart.panes()\n      if (panes.length > paneId) {\n        panes[paneId].attachPrimitive(buttonPanel)\n      } else {\n        // Fallback to first pane if pane doesn't exist\n        const fallbackPanes = this.chart.panes()\n        if (fallbackPanes.length > 0) {\n          fallbackPanes[0].attachPrimitive(buttonPanel)\n        }\n      }\n\n      this.primitives.set(primitiveId, buttonPanel)\n\n      return {\n        destroy: () => this.destroyPrimitive(primitiveId),\n        plugin: buttonPanel\n      }\n    } catch (error) {\n      return {\n        destroy: () => {},\n        plugin: createPaneButtonPanelPlugin(paneId, config, this.chartId)\n      }\n    }\n  }\n\n  /**\n   * Update legend values with crosshair data\n   */\n  public updateLegendValues(crosshairData: CrosshairEventData): void {\n    // The legend primitives automatically handle crosshair updates through the event system\n    // This method is kept for backward compatibility but functionality is now handled\n    // by the primitive event system and crosshair subscriptions in BasePanePrimitive\n  }\n\n  /**\n   * Destroy a specific primitive\n   */\n  private destroyPrimitive(primitiveId: string): void {\n    const primitive = this.primitives.get(primitiveId)\n    if (primitive) {\n      try {\n        // Detach from all panes (does nothing if not attached to that pane)\n        const panes = this.chart.panes()\n        panes.forEach(pane => {\n          pane.detachPrimitive(primitive)\n        })\n        this.primitives.delete(primitiveId)\n      } catch (error) {\n      }\n    }\n  }\n\n  /**\n   * Get primitive by ID\n   */\n  public getPrimitive(primitiveId: string): LegendPrimitive | RangeSwitcherPrimitive | PaneButtonPanelPlugin | undefined {\n    return this.primitives.get(primitiveId)\n  }\n\n  /**\n   * Get all primitives\n   */\n  public getAllPrimitives(): Map<string, LegendPrimitive | RangeSwitcherPrimitive | PaneButtonPanelPlugin> {\n    return new Map(this.primitives)\n  }\n\n\n  /**\n   * Destroy all primitives for this chart\n   */\n  public destroy(): void {\n    // Destroy all primitives\n    for (const [primitiveId, primitive] of this.primitives) {\n      try {\n        // Detach from all panes (does nothing if not attached to that pane)\n        const panes = this.chart.panes()\n        panes.forEach(pane => {\n          pane.detachPrimitive(primitive)\n        })\n      } catch (error) {\n      }\n    }\n\n    // Clear references\n    this.primitives.clear()\n  }\n\n  /**\n   * Get event manager instance (for advanced usage)\n   */\n  public getEventManager(): PrimitiveEventManager {\n    return this.eventManager\n  }\n\n  /**\n   * Get chart ID\n   */\n  public getChartId(): string {\n    return this.chartId\n  }\n\n  /**\n   * Helper method to attach primitive to pane as fallback\n   */\n  private attachToPaneAsFallback(primitive: LegendPrimitive | RangeSwitcherPrimitive | PaneButtonPanelPlugin, isPanePrimitive: boolean, paneId: number): void {\n    if (isPanePrimitive && paneId >= 0) {\n      // Get pane and attach to it\n      const panes = this.chart.panes()\n      if (panes.length > paneId) {\n        panes[paneId].attachPrimitive(primitive)\n      } else {\n        // Fallback to first pane if pane doesn't exist\n        const fallbackPanes = this.chart.panes()\n        if (fallbackPanes.length > 0) {\n          fallbackPanes[0].attachPrimitive(primitive)\n        }\n      }\n    } else {\n      // Attach to first pane (chart-level)\n      const panes = this.chart.panes()\n      if (panes.length > 0) {\n        panes[0].attachPrimitive(primitive)\n      }\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/CoordinateCacheManager.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'now' is assigned a value but never used.","line":169,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":169,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'now' is assigned a value but never used.","line":169,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":169,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cache manager for coordinate calculations\n * Extracted from ChartCoordinateService for better separation of concerns\n */\n\nimport { IChartApi } from 'lightweight-charts'\nimport { CoordinateCacheEntry } from '../types/coordinates'\nimport { areCoordinatesStale } from '../utils/coordinateValidation'\nimport { TIMING } from '../config/positioningConfig'\n\n/**\n * Manages coordinate caching with automatic cleanup\n */\nexport class CoordinateCacheManager {\n  private static instance: CoordinateCacheManager\n  private coordinateCache = new Map<string, CoordinateCacheEntry>()\n  private updateCallbacks = new Map<string, Set<() => void>>()\n  private cleanupInterval: NodeJS.Timeout | null = null\n\n  static getInstance(): CoordinateCacheManager {\n    if (!this.instance) {\n      this.instance = new CoordinateCacheManager()\n      this.instance.startCacheCleanup()\n    }\n    return this.instance\n  }\n\n  /**\n   * Generate a cache key for chart and container combination\n   */\n  generateCacheKey(chart: IChartApi, container: HTMLElement): string {\n    const chartElement = chart.chartElement()\n    const chartId = chartElement?.id || 'unnamed-chart'\n    const containerId = container.id || 'unnamed-container'\n    const timestamp = Math.floor(Date.now() / 1000) // Round to seconds for cache stability\n\n    return `${chartId}-${containerId}-${timestamp}`\n  }\n\n  /**\n   * Get cached coordinates if valid\n   */\n  getCachedCoordinates(cacheKey: string): CoordinateCacheEntry | null {\n    const cached = this.coordinateCache.get(cacheKey)\n    if (cached && !areCoordinatesStale(cached, TIMING.cacheExpiration)) {\n      return cached\n    }\n\n    // Remove stale cache entry\n    if (cached) {\n      this.coordinateCache.delete(cacheKey)\n    }\n\n    return null\n  }\n\n  /**\n   * Cache coordinates with timestamp\n   */\n  setCachedCoordinates(cacheKey: string, coordinates: unknown): void {\n    const cacheEntry: CoordinateCacheEntry = {\n      coordinates,\n      timestamp: Date.now(),\n      chartId: this.extractChartIdFromKey(cacheKey),\n      containerId: this.extractContainerIdFromKey(cacheKey)\n    }\n\n    this.coordinateCache.set(cacheKey, cacheEntry)\n  }\n\n  /**\n   * Check if coordinates exist in cache and are valid\n   */\n  hasCachedCoordinates(cacheKey: string): boolean {\n    return this.getCachedCoordinates(cacheKey) !== null\n  }\n\n  /**\n   * Invalidate cache for specific key\n   */\n  invalidateCache(cacheKey: string): void {\n    this.coordinateCache.delete(cacheKey)\n    this.notifyUpdateCallbacks(cacheKey)\n  }\n\n  /**\n   * Invalidate all cache entries for a chart\n   */\n  invalidateChartCache(chartId: string): void {\n    const keysToDelete: string[] = []\n\n    for (const [key, entry] of this.coordinateCache.entries()) {\n      if (entry.chartId === chartId) {\n        keysToDelete.push(key)\n      }\n    }\n\n    keysToDelete.forEach(key => {\n      this.coordinateCache.delete(key)\n      this.notifyUpdateCallbacks(key)\n    })\n  }\n\n  /**\n   * Register callback for cache updates\n   */\n  onCacheUpdate(cacheKey: string, callback: () => void): () => void {\n    if (!this.updateCallbacks.has(cacheKey)) {\n      this.updateCallbacks.set(cacheKey, new Set())\n    }\n\n    this.updateCallbacks.get(cacheKey)!.add(callback)\n\n    // Return unsubscribe function\n    return () => {\n      const callbacks = this.updateCallbacks.get(cacheKey)\n      if (callbacks) {\n        callbacks.delete(callback)\n        if (callbacks.size === 0) {\n          this.updateCallbacks.delete(cacheKey)\n        }\n      }\n    }\n  }\n\n  /**\n   * Notify all registered callbacks for cache key\n   */\n  private notifyUpdateCallbacks(cacheKey: string): void {\n    const callbacks = this.updateCallbacks.get(cacheKey)\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback()\n        } catch (error) {\n          // Ignore callback errors to prevent cache system failure\n        }\n      })\n    }\n  }\n\n  /**\n   * Start automatic cache cleanup\n   */\n  private startCacheCleanup(): void {\n    if (this.cleanupInterval) {\n      return\n    }\n\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpiredEntries()\n    }, TIMING.cacheCleanupInterval)\n  }\n\n  /**\n   * Stop automatic cache cleanup\n   */\n  stopCacheCleanup(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval)\n      this.cleanupInterval = null\n    }\n  }\n\n  /**\n   * Clean up expired cache entries\n   */\n  private cleanupExpiredEntries(): void {\n    const now = Date.now()\n    const keysToDelete: string[] = []\n\n    for (const [key, entry] of this.coordinateCache.entries()) {\n      if (areCoordinatesStale(entry, TIMING.cacheExpiration)) {\n        keysToDelete.push(key)\n      }\n    }\n\n    keysToDelete.forEach(key => {\n      this.coordinateCache.delete(key)\n    })\n\n    // Clean up empty callback sets\n    for (const [key, callbacks] of this.updateCallbacks.entries()) {\n      if (callbacks.size === 0) {\n        this.updateCallbacks.delete(key)\n      }\n    }\n  }\n\n  /**\n   * Extract chart ID from cache key\n   */\n  private extractChartIdFromKey(cacheKey: string): string {\n    return cacheKey.split('-')[0] || 'unknown'\n  }\n\n  /**\n   * Extract container ID from cache key\n   */\n  private extractContainerIdFromKey(cacheKey: string): string {\n    const parts = cacheKey.split('-')\n    return parts[1] || 'unknown'\n  }\n\n  /**\n   * Get cache statistics for debugging\n   */\n  getCacheStats(): {\n    totalEntries: number\n    staleEntries: number\n    activeCallbacks: number\n    memoryUsage: number\n  } {\n    let staleCount = 0\n    let totalCallbacks = 0\n\n    for (const entry of this.coordinateCache.values()) {\n      if (areCoordinatesStale(entry, TIMING.cacheExpiration)) {\n        staleCount++\n      }\n    }\n\n    for (const callbacks of this.updateCallbacks.values()) {\n      totalCallbacks += callbacks.size\n    }\n\n    return {\n      totalEntries: this.coordinateCache.size,\n      staleEntries: staleCount,\n      activeCallbacks: totalCallbacks,\n      memoryUsage: this.estimateMemoryUsage()\n    }\n  }\n\n  /**\n   * Estimate memory usage of cache (rough calculation)\n   */\n  private estimateMemoryUsage(): number {\n    let totalSize = 0\n\n    for (const [key, entry] of this.coordinateCache.entries()) {\n      // Rough estimation: key size + JSON serialized entry size\n      totalSize += key.length * 2 // UTF-16 chars\n      totalSize += JSON.stringify(entry).length * 2\n    }\n\n    return totalSize\n  }\n\n  /**\n   * Clear all cache data (for testing or memory management)\n   */\n  clearAll(): void {\n    this.coordinateCache.clear()\n    this.updateCallbacks.clear()\n  }\n\n  /**\n   * Cleanup on service destruction\n   */\n  destroy(): void {\n    this.stopCacheCleanup()\n    this.clearAll()\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/CornerLayoutManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/PaneCoordinatesService.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'UniversalSpacing' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UniversalSpacing' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'margins' is assigned a value but never used.","line":123,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'margins' is assigned a value but never used.","line":123,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":20},{"ruleId":"no-unused-vars","severity":1,"message":"'includeScales' is assigned a value but never used.","line":171,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'includeScales' is assigned a value but never used.","line":171,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service for managing pane-specific coordinate calculations\n * Extracted from ChartCoordinateService for better separation of concerns\n */\n\nimport { IChartApi } from 'lightweight-charts'\nimport { PaneCoordinates, BoundingBox, ElementPosition } from '../types/coordinates'\nimport { ChartDimensionsService, PaneDimensionsOptions } from './ChartDimensionsService'\nimport { createBoundingBox } from '../utils/coordinateValidation'\nimport { DIMENSIONS, getMargins } from '../config/positioningConfig'\nimport { UniversalSpacing } from '../primitives/PrimitiveDefaults'\n\n/**\n * Manages pane-specific coordinate calculations and positioning\n */\nexport class PaneCoordinatesService {\n  private static instance: PaneCoordinatesService\n  private dimensionsService: ChartDimensionsService\n\n  constructor() {\n    this.dimensionsService = ChartDimensionsService.getInstance()\n  }\n\n  static getInstance(): PaneCoordinatesService {\n    if (!this.instance) {\n      this.instance = new PaneCoordinatesService()\n    }\n    return this.instance\n  }\n\n  /**\n   * Get comprehensive pane coordinates\n   */\n  getPaneCoordinates(chart: IChartApi, paneId: number): PaneCoordinates | null {\n    try {\n      if (!chart || typeof paneId !== 'number' || paneId < 0) {\n        return null\n      }\n\n      const panes = chart.panes()\n      if (!panes || paneId >= panes.length) {\n        return null\n      }\n\n      const paneSize = panes[paneId].getSize()\n      if (!paneSize || typeof paneSize.height !== 'number' || typeof paneSize.width !== 'number') {\n        return null\n      }\n\n      // Calculate cumulative top offset from previous panes\n      let cumulativeTop = 0\n      for (let i = 0; i < paneId; i++) {\n        const size = panes[i]?.getSize()\n        if (size && typeof size.height === 'number') {\n          cumulativeTop += size.height\n        }\n      }\n\n      // Add time scale height for main pane\n      if (paneId === 0) {\n        const timeScaleDimensions = this.dimensionsService.getTimeScaleDimensions(chart)\n        cumulativeTop += timeScaleDimensions.height\n      }\n\n      // Get chart container for absolute positioning\n      const chartElement = chart.chartElement()\n      const containerRect = chartElement ? chartElement.getBoundingClientRect() : null\n\n      const margins = getMargins()\n      const contentArea = this.calculateContentArea(chart)\n\n      return {\n        paneId,\n        x: contentArea?.left || margins.left,\n        y: cumulativeTop + (contentArea?.top || margins.top),\n        width: paneSize.width,\n        height: paneSize.height,\n        absoluteX: (containerRect?.left || 0) + (contentArea?.left || margins.left),\n        absoluteY: (containerRect?.top || 0) + cumulativeTop + (contentArea?.top || margins.top),\n        contentArea: contentArea || {\n          top: margins.top,\n          left: margins.left,\n          width: paneSize.width,\n          height: paneSize.height\n        },\n        margins,\n        isMainPane: paneId === 0,\n        isLastPane: this.isLastPane(chart, paneId)\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get full pane bounds including all elements\n   */\n  getFullPaneBounds(chart: IChartApi, paneId: number): BoundingBox | null {\n    try {\n      if (!chart || typeof paneId !== 'number' || paneId < 0) {\n        return null\n      }\n\n      const panes = chart.panes()\n      if (!panes || paneId >= panes.length) {\n        return null\n      }\n\n      const paneSize = panes[paneId].getSize()\n      if (!paneSize || typeof paneSize.height !== 'number' || typeof paneSize.width !== 'number') {\n        return null\n      }\n\n      // Calculate cumulative top offset from previous panes\n      let cumulativeTop = 0\n      for (let i = 0; i < paneId; i++) {\n        const size = panes[i]?.getSize()\n        if (size && typeof size.height === 'number') {\n          cumulativeTop += size.height\n        }\n      }\n\n      const margins = getMargins()\n      const priceScaleWidth = this.dimensionsService.getPriceScaleDimensions(chart).width\n\n      return createBoundingBox({\n        top: cumulativeTop,\n        left: priceScaleWidth,\n        width: paneSize.width,\n        height: paneSize.height\n      })\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get coordinates for all panes in the chart\n   */\n  getAllPaneCoordinates(chart: IChartApi): PaneCoordinates[] {\n    const coordinates: PaneCoordinates[] = []\n\n    try {\n      const panes = chart.panes()\n      if (!panes) return coordinates\n\n      for (let i = 0; i < panes.length; i++) {\n        const paneCoords = this.getPaneCoordinates(chart, i)\n        if (paneCoords) {\n          coordinates.push(paneCoords)\n        }\n      }\n    } catch (error) {\n      // Return empty array on error\n    }\n\n    return coordinates\n  }\n\n  /**\n   * Get pane coordinates from DOM elements as fallback\n   */\n  getPaneCoordinatesFromDOM(\n    container: HTMLElement,\n    paneId: number,\n    options: PaneDimensionsOptions = {}\n  ): PaneCoordinates | null {\n    try {\n      const {\n        includeMargins = true,\n        includeScales = true,\n        validateDimensions = true\n      } = options\n\n      // Find pane elements in the DOM\n      const paneElements = container.querySelectorAll('[data-name=\"pane\"]')\n      if (!paneElements || paneId >= paneElements.length) {\n        return null\n      }\n\n      const paneElement = paneElements[paneId] as HTMLElement\n      if (!paneElement) {\n        return null\n      }\n\n      const rect = paneElement.getBoundingClientRect()\n      const containerRect = container.getBoundingClientRect()\n\n      const relativeX = rect.left - containerRect.left\n      const relativeY = rect.top - containerRect.top\n\n      const margins = includeMargins ? getMargins() : { top: 0, left: 0, right: 0, bottom: 0 }\n\n      const coordinates: PaneCoordinates = {\n        paneId,\n        x: Math.floor(relativeX),\n        y: Math.floor(relativeY),\n        width: Math.floor(rect.width),\n        height: Math.floor(rect.height),\n        absoluteX: Math.floor(rect.left),\n        absoluteY: Math.floor(rect.top),\n        contentArea: {\n          top: Math.floor(relativeY + margins.top),\n          left: Math.floor(relativeX + margins.left),\n          width: Math.floor(rect.width - margins.left - margins.right),\n          height: Math.floor(rect.height - margins.top - margins.bottom)\n        },\n        margins,\n        isMainPane: paneId === 0,\n        isLastPane: paneId === paneElements.length - 1\n      }\n\n      // Validate dimensions if requested\n      if (validateDimensions) {\n        if (coordinates.width < DIMENSIONS.minPaneWidth ||\n            coordinates.height < DIMENSIONS.minPaneHeight) {\n          return null\n        }\n      }\n\n      return coordinates\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Calculate element position within a pane\n   */\n  calculateElementPosition(\n    paneCoords: PaneCoordinates,\n    elementWidth: number,\n    elementHeight: number,\n    corner: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' = 'top-right',\n    offset: { x: number; y: number } = { x: 0, y: 0 }\n  ): ElementPosition {\n    const baseX = paneCoords.contentArea.left\n    const baseY = paneCoords.contentArea.top\n    const contentWidth = paneCoords.contentArea.width\n    const contentHeight = paneCoords.contentArea.height\n\n    let x: number\n    let y: number\n\n    switch (corner) {\n      case 'top-left':\n        x = baseX + offset.x\n        y = baseY + offset.y\n        break\n      case 'top-right':\n        x = baseX + contentWidth - elementWidth - offset.x\n        y = baseY + offset.y\n        break\n      case 'bottom-left':\n        x = baseX + offset.x\n        y = baseY + contentHeight - elementHeight - offset.y\n        break\n      case 'bottom-right':\n        x = baseX + contentWidth - elementWidth - offset.x\n        y = baseY + contentHeight - elementHeight - offset.y\n        break\n      default:\n        x = baseX + offset.x\n        y = baseY + offset.y\n    }\n\n    return {\n      x: Math.floor(x),\n      y: Math.floor(y),\n      width: elementWidth,\n      height: elementHeight,\n      corner,\n      offset\n    }\n  }\n\n  /**\n   * Check if pane size has changed significantly\n   */\n  hasPaneSizeChanges(\n    previousCoords: PaneCoordinates,\n    currentCoords: PaneCoordinates,\n    threshold: number = 5\n  ): boolean {\n    const widthDiff = Math.abs(previousCoords.width - currentCoords.width)\n    const heightDiff = Math.abs(previousCoords.height - currentCoords.height)\n\n    return widthDiff > threshold || heightDiff > threshold\n  }\n\n  /**\n   * Calculate the content area excluding scales and margins\n   */\n  private calculateContentArea(chart: IChartApi): {\n    top: number\n    left: number\n    width: number\n    height: number\n  } | null {\n    try {\n      const priceScaleWidth = this.dimensionsService.getPriceScaleDimensions(chart).width\n      const timeScaleHeight = this.dimensionsService.getTimeScaleDimensions(chart).height\n      const chartElement = chart.chartElement()\n\n      if (!chartElement) {\n        return null\n      }\n\n      const rect = chartElement.getBoundingClientRect()\n      const margins = getMargins()\n\n      return {\n        top: margins.top,\n        left: priceScaleWidth + margins.left,\n        width: rect.width - priceScaleWidth - margins.left - margins.right,\n        height: rect.height - timeScaleHeight - margins.top - margins.bottom\n      }\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Check if this is the last pane in the chart\n   */\n  private isLastPane(chart: IChartApi, paneId: number): boolean {\n    try {\n      const panes = chart.panes()\n      return panes ? paneId === panes.length - 1 : true\n    } catch (error) {\n      return true\n    }\n  }\n\n  /**\n   * Get axis dimensions for coordinate calculations\n   */\n  getAxisDimensions(chart: IChartApi): {\n    timeScale: { width: number; height: number }\n    priceScale: { width: number; height: number }\n  } {\n    return {\n      timeScale: this.dimensionsService.getTimeScaleDimensions(chart),\n      priceScale: this.dimensionsService.getPriceScaleDimensions(chart)\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/PrimitiveEventManager.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":87,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":205,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":205,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4483,4558],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":421,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":421,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9941,10004],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IChartApi, ISeriesApi } from 'lightweight-charts'\n\n/**\n * Event types for primitive interactions\n */\nexport interface PrimitiveEventTypes {\n  /**\n   * Crosshair position changed\n   */\n  crosshairMove: {\n    time: any\n    point: { x: number; y: number } | null\n    seriesData: Map<ISeriesApi<any>, any>\n  }\n\n  /**\n   * Chart data updated\n   */\n  dataUpdate: {\n    series: ISeriesApi<any>\n    data: any[]\n  }\n\n  /**\n   * Chart resize event\n   */\n  resize: {\n    width: number\n    height: number\n  }\n\n  /**\n   * Primitive visibility changed\n   */\n  visibilityChange: {\n    primitiveId: string\n    visible: boolean\n  }\n\n  /**\n   * Primitive configuration changed\n   */\n  configChange: {\n    primitiveId: string\n    config: any\n  }\n\n  /**\n   * Chart time scale visible range changed\n   */\n  timeScaleChange: {\n    from: any\n    to: any\n  }\n\n  /**\n   * Chart click event\n   */\n  click: {\n    time: any\n    point: { x: number; y: number }\n    seriesData: Map<ISeriesApi<any>, any>\n  }\n\n  /**\n   * Chart hover event\n   */\n  hover: {\n    time: any\n    point: { x: number; y: number }\n    seriesData: Map<ISeriesApi<any>, any>\n  }\n\n  /**\n   * Custom primitive events\n   */\n  custom: {\n    eventType: string\n    data: any\n  }\n}\n\n/**\n * Event listener type\n */\nexport type PrimitiveEventListener<K extends keyof PrimitiveEventTypes> = (\n  event: PrimitiveEventTypes[K]\n) => void\n\n/**\n * Event subscription interface\n */\nexport interface EventSubscription {\n  unsubscribe(): void\n}\n\n/**\n * PrimitiveEventManager - Centralized event management for primitives\n *\n * Provides unified event handling for chart interactions and primitive lifecycle.\n * Integrates with lightweight-charts event system and provides abstracted events\n * for primitive implementations.\n *\n * Following DRY principles - single source of truth for event management\n */\nexport class PrimitiveEventManager {\n  private static instances: Map<string, PrimitiveEventManager> = new Map()\n\n  private chart: IChartApi | null = null\n  private chartId: string\n  private eventListeners: Map<string, Set<Function>> = new Map()\n  private chartEventCleanup: Array<() => void> = []\n  private _isDestroyed: boolean = false\n\n  // Crosshair tracking\n  private lastCrosshairPosition: { time: any; point: { x: number; y: number } | null } | null = null\n\n  private constructor(chartId: string) {\n    this.chartId = chartId\n  }\n\n  /**\n   * Get or create event manager for a chart\n   */\n  public static getInstance(chartId: string): PrimitiveEventManager {\n    if (!PrimitiveEventManager.instances.has(chartId)) {\n      PrimitiveEventManager.instances.set(chartId, new PrimitiveEventManager(chartId))\n    }\n    return PrimitiveEventManager.instances.get(chartId)!\n  }\n\n  /**\n   * Clean up event manager for a chart\n   */\n  public static cleanup(chartId: string): void {\n    const instance = PrimitiveEventManager.instances.get(chartId)\n    if (instance) {\n      instance.destroy()\n      PrimitiveEventManager.instances.delete(chartId)\n    }\n  }\n\n  /**\n   * Initialize with chart API\n   */\n  public initialize(chart: IChartApi): void {\n    if (this._isDestroyed) {\n      throw new Error('Cannot initialize destroyed PrimitiveEventManager')\n    }\n\n    this.chart = chart\n    this.setupChartEventListeners()\n  }\n\n  /**\n   * Subscribe to primitive event\n   */\n  public subscribe<K extends keyof PrimitiveEventTypes>(\n    eventType: K,\n    listener: PrimitiveEventListener<K>\n  ): EventSubscription {\n    if (this._isDestroyed) {\n      throw new Error('Cannot subscribe to destroyed PrimitiveEventManager')\n    }\n\n    const eventKey = eventType as string\n    if (!this.eventListeners.has(eventKey)) {\n      this.eventListeners.set(eventKey, new Set())\n    }\n\n    this.eventListeners.get(eventKey)!.add(listener)\n\n    return {\n      unsubscribe: () => {\n        const listeners = this.eventListeners.get(eventKey)\n        if (listeners) {\n          listeners.delete(listener)\n          if (listeners.size === 0) {\n            this.eventListeners.delete(eventKey)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Emit event to subscribers\n   */\n  public emit<K extends keyof PrimitiveEventTypes>(\n    eventType: K,\n    event: PrimitiveEventTypes[K]\n  ): void {\n    if (this._isDestroyed) {\n      return\n    }\n\n    const eventKey = eventType as string\n    const listeners = this.eventListeners.get(eventKey)\n\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          listener(event)\n        } catch (error) {\n          console.error(`Error in primitive event listener for ${eventType}:`, error)\n        }\n      })\n    }\n  }\n\n  /**\n   * Setup chart event listeners\n   */\n  private setupChartEventListeners(): void {\n    if (!this.chart) return\n\n    // Crosshair move events with throttling to prevent performance issues during pan/zoom\n    let lastCrosshairUpdate = 0\n    const crosshairThrottleDelay = 16 // ~60fps max update rate\n    const crosshairMoveHandler = (param: any) => {\n      const now = Date.now()\n      if (now - lastCrosshairUpdate >= crosshairThrottleDelay) {\n        lastCrosshairUpdate = now\n        this.handleCrosshairMove(param)\n      }\n    }\n    this.chart.subscribeCrosshairMove(crosshairMoveHandler)\n    this.chartEventCleanup.push(() => this.chart!.unsubscribeCrosshairMove(crosshairMoveHandler))\n\n    // Chart click events\n    const clickHandler = (param: any) => {\n      this.handleChartClick(param)\n    }\n    this.chart.subscribeClick(clickHandler)\n    this.chartEventCleanup.push(() => this.chart!.unsubscribeClick(clickHandler))\n\n    // Time scale visible range changes with throttling to prevent X-axis lag\n    let lastTimeScaleUpdate = 0\n    const timeScaleThrottleDelay = 16 // ~60fps max update rate\n    const timeScaleHandler = () => {\n      const now = Date.now()\n      if (now - lastTimeScaleUpdate >= timeScaleThrottleDelay) {\n        lastTimeScaleUpdate = now\n        this.handleTimeScaleChange()\n      }\n    }\n    this.chart.timeScale().subscribeVisibleTimeRangeChange(timeScaleHandler)\n    this.chartEventCleanup.push(() => {\n      this.chart!.timeScale().unsubscribeVisibleTimeRangeChange(timeScaleHandler)\n    })\n\n    // Chart resize events\n    this.setupResizeObserver()\n  }\n\n  /**\n   * Handle crosshair move events\n   */\n  private handleCrosshairMove(param: any): void {\n    const time = param.time\n    const point = param.point\n\n    // Collect series data\n    const seriesData = new Map<ISeriesApi<any>, any>()\n    if (param.seriesData) {\n      param.seriesData.forEach((data: any, series: ISeriesApi<any>) => {\n        seriesData.set(series, data)\n      })\n    }\n\n    // Update last position\n    this.lastCrosshairPosition = { time, point }\n\n    // Emit crosshair move event\n    this.emit('crosshairMove', {\n      time,\n      point,\n      seriesData\n    })\n\n    // Emit hover event if point is valid\n    if (point && time) {\n      this.emit('hover', {\n        time,\n        point,\n        seriesData\n      })\n    }\n  }\n\n  /**\n   * Handle chart click events\n   */\n  private handleChartClick(param: any): void {\n    const time = param.time\n    const point = param.point\n\n    if (!point || !time) return\n\n    // Collect series data at click point\n    const seriesData = new Map<ISeriesApi<any>, any>()\n    if (param.seriesData) {\n      param.seriesData.forEach((data: any, series: ISeriesApi<any>) => {\n        seriesData.set(series, data)\n      })\n    }\n\n    this.emit('click', {\n      time,\n      point,\n      seriesData\n    })\n  }\n\n  /**\n   * Handle time scale changes\n   */\n  private handleTimeScaleChange(): void {\n    if (!this.chart) return\n\n    const visibleRange = this.chart.timeScale().getVisibleRange()\n    if (visibleRange) {\n      this.emit('timeScaleChange', {\n        from: visibleRange.from,\n        to: visibleRange.to\n      })\n    }\n  }\n\n  /**\n   * Setup resize observer for chart container\n   */\n  private setupResizeObserver(): void {\n    if (!this.chart) return\n\n    const chartElement = this.chart.chartElement()\n    if (!chartElement || !window.ResizeObserver) return\n\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect\n        this.emit('resize', { width, height })\n      }\n    })\n\n    resizeObserver.observe(chartElement)\n    this.chartEventCleanup.push(() => resizeObserver.disconnect())\n  }\n\n  /**\n   * Emit primitive visibility change event\n   */\n  public emitVisibilityChange(primitiveId: string, visible: boolean): void {\n    this.emit('visibilityChange', { primitiveId, visible })\n  }\n\n  /**\n   * Emit primitive configuration change event\n   */\n  public emitConfigChange(primitiveId: string, config: any): void {\n    this.emit('configChange', { primitiveId, config })\n  }\n\n  /**\n   * Emit custom primitive event\n   */\n  public emitCustomEvent(eventType: string, data: any): void {\n    this.emit('custom', { eventType, data })\n  }\n\n  /**\n   * Get current crosshair position\n   */\n  public getCurrentCrosshairPosition(): { time: any; point: { x: number; y: number } | null } | null {\n    return this.lastCrosshairPosition\n  }\n\n  /**\n   * Get chart API reference\n   */\n  public getChart(): IChartApi | null {\n    return this.chart\n  }\n\n  /**\n   * Get chart ID\n   */\n  public getChartId(): string {\n    return this.chartId\n  }\n\n  /**\n   * Check if event manager is destroyed\n   */\n  public isDestroyed(): boolean {\n    return this._isDestroyed\n  }\n\n  /**\n   * Get event listener count for debugging\n   */\n  public getEventListenerCount(): { [eventType: string]: number } {\n    const counts: { [eventType: string]: number } = {}\n    this.eventListeners.forEach((listeners, eventType) => {\n      counts[eventType] = listeners.size\n    })\n    return counts\n  }\n\n  /**\n   * Destroy event manager\n   */\n  public destroy(): void {\n    if (this._isDestroyed) return\n\n    // Clean up chart event listeners\n    this.chartEventCleanup.forEach(cleanup => {\n      try {\n        cleanup()\n      } catch (error) {\n        console.error('Error cleaning up chart event listener:', error)\n      }\n    })\n    this.chartEventCleanup = []\n\n    // Clear all event listeners\n    this.eventListeners.clear()\n\n    // Clear references\n    this.chart = null\n    this.lastCrosshairPosition = null\n\n    // Mark as destroyed\n    this._isDestroyed = true\n  }\n}\n\n/**\n * Event manager integration mixin for primitives\n */\nexport interface EventManagerIntegration {\n  /**\n   * Get event manager for this primitive\n   */\n  getEventManager(): PrimitiveEventManager | null\n\n  /**\n   * Subscribe to chart events\n   */\n  subscribeToEvents(): void\n\n  /**\n   * Unsubscribe from chart events\n   */\n  unsubscribeFromEvents(): void\n}\n\n/**\n * Helper function to create event manager integration\n */\nexport function createEventManagerIntegration(\n  chartId: string,\n  chart?: IChartApi\n): EventManagerIntegration {\n  let eventManager: PrimitiveEventManager | null = null\n  let subscriptions: EventSubscription[] = []\n\n  return {\n    getEventManager(): PrimitiveEventManager | null {\n      if (!eventManager) {\n        eventManager = PrimitiveEventManager.getInstance(chartId)\n        if (chart) {\n          eventManager.initialize(chart)\n        }\n      }\n      return eventManager\n    },\n\n    subscribeToEvents(): void {\n      // Override in implementation to add specific event subscriptions\n    },\n\n    unsubscribeFromEvents(): void {\n      subscriptions.forEach(sub => sub.unsubscribe())\n      subscriptions = []\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/SeriesConfigurationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/StreamlitSeriesConfigService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/TemplateEngine.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":311,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":311,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7950,8027],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":347,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":347,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[8864,8909],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Template processing engine for pane primitives\n *\n * Handles smart placeholder replacement with support for:\n * - Chart value placeholders: $$value$$, $$open$$, $$high$$, $$low$$, $$close$$\n * - Band/Ribbon placeholders: $$upper$$, $$middle$$, $$lower$$\n * - Volume placeholder: $$volume$$\n * - Time placeholder: $$time$$\n * - Custom placeholders: $$custom_key$$\n *\n * Following DRY principles - single source of truth for template processing\n */\n\nimport { UTCTimestamp } from 'lightweight-charts'\nimport { TemplateContext, TemplateFormatting } from '../types/ChartInterfaces'\n\n/**\n * Interface for series data used in template processing\n */\nexport interface SeriesDataValue {\n  time?: UTCTimestamp | string | number\n  value?: number\n  open?: number\n  high?: number\n  low?: number\n  close?: number\n  upper?: number\n  middle?: number\n  lower?: number\n  volume?: number\n  [key: string]: unknown\n}\n\n/**\n * Template processing options\n */\nexport interface TemplateOptions {\n  /**\n   * Whether to process placeholders (default: true)\n   */\n  processPlaceholders?: boolean\n\n  /**\n   * Whether to escape HTML (default: false)\n   */\n  escapeHtml?: boolean\n\n  /**\n   * Default value for missing placeholders\n   */\n  defaultValue?: string\n\n  /**\n   * Whether to throw on missing placeholder data (default: false)\n   */\n  strict?: boolean\n}\n\n/**\n * Template processing result\n */\nexport interface TemplateResult {\n  /**\n   * Processed template content\n   */\n  content: string\n\n  /**\n   * List of placeholders that were processed\n   */\n  processedPlaceholders: string[]\n\n  /**\n   * List of placeholders that had no data\n   */\n  missingPlaceholders: string[]\n\n  /**\n   * Whether errors occurred during processing\n   */\n  hasErrors: boolean\n\n  /**\n   * Error messages if errors occurred\n   */\n  errors: string[]\n}\n\n/**\n * TemplateEngine - Centralized template processing for primitives\n */\nexport class TemplateEngine {\n  private static instance: TemplateEngine | null = null\n\n  /**\n   * Singleton instance\n   */\n  public static getInstance(): TemplateEngine {\n    if (!TemplateEngine.instance) {\n      TemplateEngine.instance = new TemplateEngine()\n    }\n    return TemplateEngine.instance\n  }\n\n  private constructor() {\n    // Private constructor for singleton\n  }\n\n  /**\n   * Process template with given context and options\n   */\n  public processTemplate(\n    template: string,\n    context: TemplateContext = {},\n    options: TemplateOptions = {}\n  ): TemplateResult {\n    const result: TemplateResult = {\n      content: template,\n      processedPlaceholders: [],\n      missingPlaceholders: [],\n      hasErrors: false,\n      errors: []\n    }\n\n    // Early return if no processing needed\n    if (options.processPlaceholders === false) {\n      return result\n    }\n\n    try {\n      // Find all placeholders in template\n      const placeholderRegex = /\\$\\$([a-zA-Z_][a-zA-Z0-9_]*)\\$\\$/g\n      const placeholders = [...template.matchAll(placeholderRegex)]\n\n      // Process each placeholder\n      for (const match of placeholders) {\n        const fullPlaceholder = match[0] // e.g., \"$$value$$\"\n        const placeholderKey = match[1] // e.g., \"value\"\n\n        try {\n          const value = this.extractPlaceholderValue(placeholderKey, context)\n\n          if (value !== null && value !== undefined) {\n            // Format the value\n            const formattedValue = this.formatValue(value, placeholderKey, context.formatting)\n\n            // Replace in content\n            result.content = result.content.replace(\n              new RegExp(this.escapeRegex(fullPlaceholder), 'g'),\n              options.escapeHtml ? this.escapeHtml(formattedValue) : formattedValue\n            )\n\n            result.processedPlaceholders.push(fullPlaceholder)\n          } else {\n            // Handle missing value\n            const defaultValue = options.defaultValue || ''\n            result.content = result.content.replace(\n              new RegExp(this.escapeRegex(fullPlaceholder), 'g'),\n              defaultValue\n            )\n\n            result.missingPlaceholders.push(fullPlaceholder)\n\n            if (options.strict) {\n              throw new Error(`Missing data for placeholder: ${fullPlaceholder}`)\n            }\n          }\n        } catch (error) {\n          result.hasErrors = true\n          result.errors.push(`Error processing ${fullPlaceholder}: ${error}`)\n\n          if (options.strict) {\n            throw error\n          }\n        }\n      }\n    } catch (error) {\n      result.hasErrors = true\n      result.errors.push(`Template processing error: ${error}`)\n\n      if (options.strict) {\n        throw error\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Extract value for a specific placeholder key\n   */\n  private extractPlaceholderValue(key: string, context: TemplateContext): unknown {\n    const { seriesData, customData } = context\n\n    // Check custom data first\n    if (customData && customData.hasOwnProperty(key)) {\n      return customData[key]\n    }\n\n    // Check series data\n    if (seriesData) {\n      switch (key) {\n        case 'value':\n          return this.extractSmartValue(seriesData)\n        case 'open':\n          return seriesData.open\n        case 'high':\n          return seriesData.high\n        case 'low':\n          return seriesData.low\n        case 'close':\n          return seriesData.close\n        case 'upper':\n          return seriesData.upper\n        case 'middle':\n          return seriesData.middle\n        case 'lower':\n          return seriesData.lower\n        case 'volume':\n          return seriesData.volume\n        case 'time':\n          return seriesData.time\n        default:\n          // Check if key exists directly in series data\n          if (seriesData.hasOwnProperty(key)) {\n            return seriesData[key]\n          }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Smart value extraction for $$value$$ placeholder\n   * Falls back through different value types based on series data structure\n   */\n  private extractSmartValue(seriesData: SeriesDataValue): number | null {\n    // Priority order for value extraction:\n    // 1. close (for candlestick/OHLC series)\n    // 2. value (for line/area series)\n    // 3. middle (for band series)\n    // 4. average of upper/lower (for ribbon series)\n    // 5. high (fallback)\n\n    if (seriesData.close !== undefined) {\n      return seriesData.close\n    }\n\n    if (seriesData.value !== undefined) {\n      return seriesData.value\n    }\n\n    if (seriesData.middle !== undefined) {\n      return seriesData.middle\n    }\n\n    if (seriesData.upper !== undefined && seriesData.lower !== undefined) {\n      return (seriesData.upper + seriesData.lower) / 2\n    }\n\n    if (seriesData.high !== undefined) {\n      return seriesData.high\n    }\n\n    return null\n  }\n\n  /**\n   * Format value according to type and formatting options\n   */\n  private formatValue(value: unknown, key: string, formatting?: TemplateFormatting): string {\n    if (value === null || value === undefined) {\n      return ''\n    }\n\n    // Handle time formatting\n    if (key === 'time') {\n      return this.formatTime(value, formatting?.timeFormat)\n    }\n\n    // Handle numeric formatting\n    if (typeof value === 'number') {\n      return this.formatNumber(value, formatting?.valueFormat, formatting?.locale)\n    }\n\n    // Default to string conversion\n    return value.toString()\n  }\n\n  /**\n   * Format number according to format specification\n   */\n  private formatNumber(value: number, format?: string, locale?: string): string {\n    if (!format) {\n      return value.toFixed(2) // Default to 2 decimal places\n    }\n\n    // Parse format specification (e.g., '.2f', '.4f', etc.)\n    const formatMatch = format.match(/\\.(\\d+)f/)\n    if (formatMatch) {\n      const decimals = parseInt(formatMatch[1])\n      return value.toFixed(decimals)\n    }\n\n    // Handle locale-specific formatting if specified\n    if (locale) {\n      try {\n        return value.toLocaleString(locale)\n      } catch (error) {\n        console.warn(`Invalid locale: ${locale}, falling back to default formatting`)\n      }\n    }\n\n    return value.toFixed(2)\n  }\n\n  /**\n   * Format time value\n   */\n  private formatTime(time: UTCTimestamp | string | number | unknown, format?: string): string {\n    if (!time) return ''\n\n    try {\n      let date: Date\n\n      // Convert time to Date object\n      if (time instanceof Date) {\n        date = time\n      } else if (typeof time === 'number') {\n        // Assume Unix timestamp (seconds or milliseconds)\n        date = new Date(time > 1e10 ? time : time * 1000)\n      } else if (typeof time === 'string') {\n        date = new Date(time)\n      } else {\n        return time.toString()\n      }\n\n      // Apply format if specified\n      if (format) {\n        return this.formatDateWithCustomFormat(date, format)\n      }\n\n      // Default formatting\n      return date.toLocaleString()\n    } catch (error) {\n      console.warn('Error formatting time:', error)\n      return time.toString()\n    }\n  }\n\n  /**\n   * Format date with custom format string\n   */\n  private formatDateWithCustomFormat(date: Date, format: string): string {\n    const formatMap: { [key: string]: string } = {\n      'YYYY': date.getFullYear().toString(),\n      'MM': (date.getMonth() + 1).toString().padStart(2, '0'),\n      'DD': date.getDate().toString().padStart(2, '0'),\n      'HH': date.getHours().toString().padStart(2, '0'),\n      'mm': date.getMinutes().toString().padStart(2, '0'),\n      'ss': date.getSeconds().toString().padStart(2, '0')\n    }\n\n    let result = format\n    for (const [placeholder, value] of Object.entries(formatMap)) {\n      result = result.replace(new RegExp(placeholder, 'g'), value)\n    }\n\n    return result\n  }\n\n  /**\n   * Escape special regex characters\n   */\n  private escapeRegex(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  }\n\n  /**\n   * Escape HTML characters\n   */\n  private escapeHtml(str: string): string {\n    const escapeMap: { [key: string]: string } = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    }\n\n    return str.replace(/[&<>\"']/g, (match) => escapeMap[match])\n  }\n\n  /**\n   * Validate template syntax\n   */\n  public validateTemplate(template: string): { isValid: boolean; errors: string[] } {\n    const errors: string[] = []\n\n    try {\n      // Check for malformed placeholders\n      const placeholderRegex = /\\$\\$([a-zA-Z_][a-zA-Z0-9_]*)\\$\\$/g\n      const invalidPlaceholderRegex = /\\$\\$[^$]*\\$\\$/g\n\n      const validPlaceholders = [...template.matchAll(placeholderRegex)]\n      const allDollarPairs = [...template.matchAll(invalidPlaceholderRegex)]\n\n      if (allDollarPairs.length !== validPlaceholders.length) {\n        errors.push('Template contains malformed placeholders')\n      }\n\n      // Check for unmatched $$ pairs\n      const dollarCount = (template.match(/\\$/g) || []).length\n      if (dollarCount % 4 !== 0) {\n        errors.push('Template contains unmatched $$ pairs')\n      }\n\n    } catch (error) {\n      errors.push(`Template validation error: ${error}`)\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    }\n  }\n\n  /**\n   * Get list of placeholders in template\n   */\n  public getPlaceholders(template: string): string[] {\n    const placeholderRegex = /\\$\\$([a-zA-Z_][a-zA-Z0-9_]*)\\$\\$/g\n    const matches = [...template.matchAll(placeholderRegex)]\n    return matches.map(match => match[0])\n  }\n\n  /**\n   * Create template context from series data\n   */\n  public createContextFromSeriesData(\n    seriesData: SeriesDataValue,\n    customData?: Record<string, unknown>,\n    formatting?: TemplateContext['formatting']\n  ): TemplateContext {\n    return {\n      seriesData,\n      customData,\n      formatting\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/annotationSystem.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":56,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {Annotation, AnnotationLayer} from '../types'\nimport {UTCTimestamp, SeriesMarker, Time} from 'lightweight-charts'\n\nexport interface AnnotationVisualElements {\n  markers: any[]\n  shapes: any[]\n  texts: any[]\n}\n\nexport const createAnnotationVisualElements = (\n  annotations: Annotation[]\n): AnnotationVisualElements => {\n  const markers: SeriesMarker<Time>[] = []\n  const shapes: any[] = []\n  const texts: any[] = []\n\n  // Immediate return if annotations is null, undefined, or not an object\n  if (!annotations || typeof annotations !== 'object') {\n    return {markers, shapes, texts}\n  }\n\n  // Wrap the entire function in a try-catch to prevent any errors\n  try {\n    // Validate that annotations is an array\n    if (!Array.isArray(annotations)) {\n\n      return {markers, shapes, texts}\n    }\n\n    // Additional safety check - ensure annotations is actually an array\n    try {\n      if (typeof annotations.forEach !== 'function') {\n        return {markers, shapes, texts}\n      }\n    } catch (error) {\n\n      return {markers, shapes, texts}\n    }\n\n    // Convert to array if it's not already (defensive programming)\n    let annotationsArray: Annotation[]\n    try {\n      annotationsArray = Array.from(annotations)\n    } catch (error) {\n\n      return {markers, shapes, texts}\n    }\n\n    // Final safety check\n    if (!Array.isArray(annotationsArray) || typeof annotationsArray.forEach !== 'function') {\n      return {markers, shapes, texts}\n    }\n\n    // Use try-catch around the entire forEach operation\n    try {\n      annotationsArray.forEach((annotation, index) => {\n        try {\n          // Validate annotation object\n          if (!annotation || typeof annotation !== 'object') {\n\n            return\n          }\n\n          // Create marker based on annotation type\n          if (\n            annotation.type === 'arrow' ||\n            annotation.type === 'shape' ||\n            annotation.type === 'circle'\n          ) {\n            const marker: SeriesMarker<Time> = {\n              time: parseTime(annotation.time),\n              position: annotation.position === 'above' ? 'aboveBar' : 'belowBar',\n              color: annotation.color || '#2196F3',\n              shape: annotation.type === 'arrow' ? 'arrowUp' : 'circle',\n              text: annotation.text || '',\n              size: annotation.fontSize || 1\n            }\n            markers.push(marker)\n          }\n\n          // Create shape if specified\n          if (annotation.type === 'rectangle' || annotation.type === 'line') {\n            const shape = {\n              time: parseTime(annotation.time),\n              price: annotation.price,\n              type: annotation.type,\n              color: annotation.color || '#2196F3',\n              borderColor: annotation.borderColor || '#2196F3',\n              borderWidth: annotation.borderWidth || 1,\n              borderStyle: annotation.lineStyle || 'solid',\n              size: annotation.fontSize || 1,\n              text: annotation.text || ''\n            }\n            shapes.push(shape)\n          }\n\n          // Create text annotation if specified\n          if (annotation.type === 'text') {\n            const text = {\n              time: parseTime(annotation.time),\n              price: annotation.price,\n              text: annotation.text,\n              color: annotation.textColor || '#131722',\n              backgroundColor: annotation.backgroundColor || 'rgba(255, 255, 255, 0.9)',\n              fontSize: annotation.fontSize || 12,\n              fontFamily: 'Arial',\n              position: annotation.position === 'above' ? 'aboveBar' : 'belowBar'\n            }\n            texts.push(text)\n          }\n        } catch (error) {\n\n        }\n      })\n    } catch (forEachError) {\n\n    }\n  } catch (outerError) {\n\n  }\n\n  return {markers, shapes, texts}\n}\n\nfunction parseTime(timeStr: string): UTCTimestamp {\n  // Convert string time to UTC timestamp\n  const date = new Date(timeStr)\n  return Math.floor(date.getTime() / 1000) as UTCTimestamp\n}\n\n// Utility functions for annotation management\nexport function filterAnnotationsByTimeRange(\n  annotations: Annotation[],\n  startTime: string,\n  endTime: string\n): Annotation[] {\n  const start = parseTime(startTime)\n  const end = parseTime(endTime)\n\n  return annotations.filter(annotation => {\n    const time = parseTime(annotation.time)\n    return time >= start && time <= end\n  })\n}\n\nexport function filterAnnotationsByPriceRange(\n  annotations: Annotation[],\n  minPrice: number,\n  maxPrice: number\n): Annotation[] {\n  return annotations.filter(annotation => {\n    return annotation.price >= minPrice && annotation.price <= maxPrice\n  })\n}\n\nexport function createAnnotationLayer(\n  name: string,\n  annotations: Annotation[] = []\n): AnnotationLayer {\n  return {\n    name,\n    annotations,\n    visible: true,\n    opacity: 1.0\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/services/tradeVisualization.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":122,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":122,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":211,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":211,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'priceScaleId' is defined but never used. Allowed unused args must match /^_/u.","line":296,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":296,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'tradeRectangles' is defined but never used. Allowed unused args must match /^_/u.","line":443,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":443,"endColumn":40},{"ruleId":"no-unused-vars","severity":1,"message":"'chart' is defined but never used. Allowed unused args must match /^_/u.","line":444,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":444,"endColumn":14},{"ruleId":"no-unused-vars","severity":1,"message":"'series' is defined but never used. Allowed unused args must match /^_/u.","line":445,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":445,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {UTCTimestamp, SeriesMarker, Time} from 'lightweight-charts'\nimport {TradeConfig, TradeVisualizationOptions} from '../types'\nimport {UniversalSpacing} from '../primitives/PrimitiveDefaults'\n\n// CRITICAL: Timezone-agnostic parsing functions\n/**\n * Parse time value to UTC timestamp without timezone conversion\n * Handles both string dates and numeric timestamps\n */\nfunction parseTime(time: string | number): UTCTimestamp | null {\n  try {\n    // If it's already a number (Unix timestamp), convert to seconds if needed\n    if (typeof time === 'number') {\n      // If timestamp is in milliseconds, convert to seconds\n      if (time > 1000000000000) {\n        return Math.floor(time / 1000) as UTCTimestamp\n      }\n      return Math.floor(time) as UTCTimestamp\n    }\n\n    // If it's a string, try to parse as date\n    if (typeof time === 'string') {\n      // First try to parse as Unix timestamp string\n      const timestamp = parseInt(time, 10)\n      if (!isNaN(timestamp)) {\n        // It's a numeric string (Unix timestamp)\n        if (timestamp > 1000000000000) {\n          return Math.floor(timestamp / 1000) as UTCTimestamp\n        }\n        return Math.floor(timestamp) as UTCTimestamp\n      }\n\n      // Try to parse as ISO date string - CRITICAL: No timezone conversion\n      if (time.includes('T') || time.includes('Z') || time.includes('+')) {\n        // ISO format - parse directly to avoid local timezone conversion\n        const date = new Date(time)\n        if (isNaN(date.getTime())) {\n\n          return null\n        }\n        // Use UTC timestamp directly - no timezone conversion\n        return Math.floor(date.getTime() / 1000) as UTCTimestamp\n      }\n\n      // Regular date string parsing as fallback\n      const date = new Date(time)\n      if (isNaN(date.getTime())) {\n\n        return null\n      }\n      return Math.floor(date.getTime() / 1000) as UTCTimestamp\n    }\n\n    return null\n  } catch (error) {\n\n    return null\n  }\n}\n\n/**\n * Find nearest available timestamp in chart data\n */\nfunction findNearestTime(targetTime: UTCTimestamp, chartData: any[]): UTCTimestamp | null {\n  if (!chartData || chartData.length === 0) {\n    return null\n  }\n\n  let nearestTime: UTCTimestamp | null = null\n  let minDiff = Infinity\n\n  for (const item of chartData) {\n    if (!item.time) continue\n\n    let itemTime: UTCTimestamp | null = null\n\n    if (typeof item.time === 'number') {\n      itemTime =\n        item.time > 1000000000000\n          ? (Math.floor(item.time / 1000) as UTCTimestamp)\n          : (item.time as UTCTimestamp)\n    } else if (typeof item.time === 'string') {\n      itemTime = parseTime(item.time)\n    }\n\n    if (itemTime === null) continue\n\n    const diff = Math.abs(itemTime - targetTime)\n    if (diff < minDiff) {\n      minDiff = diff\n      nearestTime = itemTime\n    }\n  }\n\n  return nearestTime\n}\n\n// Trade rectangle data interface (for data creation only)\nexport interface TradeRectangleData {\n  time1: UTCTimestamp\n  time2: UTCTimestamp\n  price1: number\n  price2: number\n  fillColor: string\n  borderColor: string\n  borderWidth: number\n  borderStyle: 'solid' | 'dashed' | 'dotted'\n  opacity: number\n  priceScaleId?: string\n}\n\n// Create trade rectangles from trade data\nfunction createTradeRectangles(\n  trades: TradeConfig[],\n  options: TradeVisualizationOptions,\n  chartData?: any[]\n): TradeRectangleData[] {\n  const rectangles: TradeRectangleData[] = []\n\n  // Enhanced validation using coordinate service\n\n  trades.forEach((trade, index) => {\n    // Validate trade data - allow exitTime to be null for open trades\n    if (\n      !trade.entryTime ||\n      typeof trade.entryPrice !== 'number' ||\n      typeof trade.exitPrice !== 'number'\n    ) {\n      return\n    }\n\n    // Parse entry time\n    const time1 = parseTime(trade.entryTime)\n    if (time1 === null) {\n      return\n    }\n\n    // Handle exit time - can be null for open trades\n    let time2: UTCTimestamp | null = null\n    if (trade.exitTime) {\n      time2 = parseTime(trade.exitTime)\n      if (time2 === null) {\n        return\n      }\n    } else {\n      // For open trades, use the last available time from chart data\n      if (chartData && chartData.length > 0) {\n        const lastTime = chartData[chartData.length - 1]?.time\n        if (lastTime) {\n          time2 = parseTime(lastTime)\n        }\n      }\n\n      // If still no exit time, skip this trade\n      if (time2 === null) {\n        return\n      }\n    }\n\n    // Find nearest available times in chart data if provided\n    let adjustedTime1 = time1\n    let adjustedTime2 = time2\n\n    if (chartData && chartData.length > 0) {\n      const nearestTime1 = findNearestTime(time1, chartData)\n      const nearestTime2 = findNearestTime(time2, chartData)\n\n      if (nearestTime1) adjustedTime1 = nearestTime1\n      if (nearestTime2) adjustedTime2 = nearestTime2\n    }\n\n    // Validate prices\n    if (trade.entryPrice <= 0 || trade.exitPrice <= 0) {\n      return\n    }\n\n    const color = trade.isProfitable\n      ? options.rectangleColorProfit || '#4CAF50'\n      : options.rectangleColorLoss || '#F44336'\n\n    const opacity = options.rectangleFillOpacity || 1.0\n\n    const rectangle: TradeRectangleData = {\n      time1: Math.min(adjustedTime1, adjustedTime2) as UTCTimestamp,\n      price1: Math.min(trade.entryPrice, trade.exitPrice),\n      time2: Math.max(adjustedTime1, adjustedTime2) as UTCTimestamp,\n      price2: Math.max(trade.entryPrice, trade.exitPrice),\n      fillColor: color,\n      borderColor: color,\n      borderWidth: options.rectangleBorderWidth || 3,\n      borderStyle: 'solid' as const,\n      opacity: opacity\n    }\n\n    rectangles.push(rectangle)\n  })\n\n  return rectangles\n}\n\n// Create trade markers\nfunction createTradeMarkers(\n  trades: TradeConfig[],\n  options: TradeVisualizationOptions,\n  chartData?: any[]\n): SeriesMarker<Time>[] {\n  const markers: SeriesMarker<Time>[] = []\n\n  // Enhanced validation using coordinate service\n\n  trades.forEach((trade, index) => {\n    // Validate trade data - allow exitTime to be null for open trades\n    if (\n      !trade.entryTime ||\n      typeof trade.entryPrice !== 'number' ||\n      typeof trade.exitPrice !== 'number'\n    ) {\n      return\n    }\n\n    // Parse entry time\n    const entryTime = parseTime(trade.entryTime)\n    if (!entryTime) {\n      return\n    }\n\n    // Handle exit time - can be null for open trades\n    let exitTime: UTCTimestamp | null = null\n    if (trade.exitTime) {\n      exitTime = parseTime(trade.exitTime)\n      if (!exitTime) {\n        return\n      }\n    }\n\n    // Find nearest available times in chart data if provided\n    let adjustedEntryTime = entryTime\n    let adjustedExitTime = exitTime\n\n    if (chartData && chartData.length > 0) {\n      const nearestEntryTime = findNearestTime(entryTime, chartData)\n      if (nearestEntryTime) adjustedEntryTime = nearestEntryTime\n\n      if (exitTime) {\n        const nearestExitTime = findNearestTime(exitTime, chartData)\n        if (nearestExitTime) adjustedExitTime = nearestExitTime\n      }\n    }\n\n    // Entry marker\n    const entryColor =\n      trade.tradeType === 'long'\n        ? options.entryMarkerColorLong || '#2196F3'\n        : options.entryMarkerColorShort || '#FF9800'\n\n    const entryMarker: SeriesMarker<Time> = {\n      time: adjustedEntryTime,\n      position: trade.tradeType === 'long' ? 'belowBar' : 'aboveBar',\n      color: entryColor,\n      shape: trade.tradeType === 'long' ? 'arrowUp' : 'arrowDown',\n      text:\n        options.showPnlInMarkers && trade.text\n          ? trade.text\n          : `Entry: $${trade.entryPrice.toFixed(2)}`\n    }\n    markers.push(entryMarker)\n\n    // Exit marker - only create if trade has been closed\n    if (adjustedExitTime) {\n      const exitColor = trade.isProfitable\n        ? options.exitMarkerColorProfit || '#4CAF50'\n        : options.exitMarkerColorLoss || '#F44336'\n\n      const exitMarker: SeriesMarker<Time> = {\n        time: adjustedExitTime,\n        position: trade.tradeType === 'long' ? 'aboveBar' : 'belowBar',\n        color: exitColor,\n        shape: trade.tradeType === 'long' ? 'arrowDown' : 'arrowUp',\n        text:\n          options.showPnlInMarkers && trade.text\n            ? trade.text\n            : `Exit: $${trade.exitPrice.toFixed(2)}`\n      }\n      markers.push(exitMarker)\n    }\n  })\n\n  return markers\n}\n\n// Main function to create trade visual elements\nexport function createTradeVisualElements(\n  trades: TradeConfig[],\n  options: TradeVisualizationOptions,\n  chartData?: any[],\n  priceScaleId?: string\n): {\n  markers: SeriesMarker<Time>[]\n  rectangles: TradeRectangleData[]\n  annotations: any[]\n} {\n  const markers: SeriesMarker<Time>[] = []\n  const rectangles: TradeRectangleData[] = []\n  const annotations: any[] = []\n\n  if (!trades || trades.length === 0) {\n    return {markers, rectangles, annotations}\n  }\n\n  // Create markers if enabled\n  if (options && (options.style === 'markers' || options.style === 'both')) {\n    markers.push(...createTradeMarkers(trades, options, chartData))\n  }\n\n  // Create rectangles if enabled - these will be handled by RectanglePlugin\n  if (options && (options.style === 'rectangles' || options.style === 'both')) {\n    const newRectangles = createTradeRectangles(trades, options, chartData)\n    rectangles.push(...newRectangles)\n  }\n\n  // Create annotations if enabled\n  if (options.showAnnotations) {\n    trades.forEach(trade => {\n      const textParts: string[] = []\n\n      if (options.showTradeId && trade.id) {\n        textParts.push(`#${trade.id}`)\n      }\n\n      if (options.showTradeType) {\n        textParts.push(trade.tradeType.toUpperCase())\n      }\n\n      if (options.showQuantity) {\n        textParts.push(`Qty: ${trade.quantity}`)\n      }\n\n      if (trade.pnlPercentage !== undefined) {\n        textParts.push(`P&L: ${trade.pnlPercentage.toFixed(1)}%`)\n      }\n\n      // Calculate midpoint for annotation position\n      const entryTime = parseTime(trade.entryTime)\n      const exitTime = parseTime(trade.exitTime)\n\n      if (entryTime === null || exitTime === null) {\n        return\n      }\n\n      const midTime = (entryTime + exitTime) / 2\n      const midPrice = (trade.entryPrice + trade.exitPrice) / 2\n\n      annotations.push({\n        type: 'text',\n        time: midTime,\n        price: midPrice,\n        text: textParts.join(' | '),\n        fontSize: options.annotationFontSize || 12,\n        backgroundColor: options.annotationBackground || 'rgba(255, 255, 255, 0.8)',\n        color: '#000000',\n        padding: UniversalSpacing.DEFAULT_PADDING\n      })\n    })\n  }\n\n  return {markers, rectangles, annotations}\n}\n\n/**\n * Convert trade rectangle data to RectanglePlugin format\n * This bridges the gap between trade data and the RectanglePlugin\n */\nexport function convertTradeRectanglesToPluginFormat(\n  tradeRectangles: TradeRectangleData[],\n  chart: any,\n  series?: any\n): any[] {\n  if (!chart || !series) {\n    return []\n  }\n\n  // Check if chart scales are ready\n  const timeScale = chart.timeScale()\n  const timeScaleWidth = timeScale.width()\n\n  if (timeScaleWidth === 0) {\n    return []\n  }\n\n  // Import ChartCoordinateService dynamically to avoid circular dependencies\n  const {ChartCoordinateService} = require('../services/ChartCoordinateService')\n  const coordinateService = ChartCoordinateService.getInstance()\n\n  return tradeRectangles\n    .map((rect, index) => {\n      try {\n        // Use ChartCoordinateService to calculate proper overlay position\n        const boundingBox = coordinateService.calculateOverlayPosition(\n          rect.time1,\n          rect.time2,\n          rect.price1,\n          rect.price2,\n          chart,\n          series,\n          0 // paneId\n        )\n\n        if (!boundingBox) {\n          return null\n        }\n\n        const pluginRect = {\n          id: `trade-rect-${index}`,\n          x1: boundingBox.x,\n          y1: boundingBox.y,\n          x2: boundingBox.x + boundingBox.width,\n          y2: boundingBox.y + boundingBox.height,\n          color: rect.fillColor,\n          borderColor: rect.borderColor,\n          borderWidth: rect.borderWidth,\n          fillOpacity: rect.opacity,\n          borderOpacity: 1.0,\n          label: `Trade ${index + 1}`,\n          labelColor: '#000000',\n          labelFontSize: 12,\n          labelBackground: 'rgba(255, 255, 255, 0.8)',\n          labelPadding: 4,\n          zIndex: 10\n        }\n\n        return pluginRect\n      } catch (error) {\n        return null\n      }\n    })\n    .filter(rect => rect !== null) // Remove null entries\n}\n\n/**\n * @deprecated - This function is no longer used. Use createTradeRectanglePrimitives from TradeRectanglePrimitive instead.\n */\nexport function createTradeRectanglePrimitives(\n  tradeRectangles: TradeRectangleData[],\n  chart?: any,\n  series?: any\n): any[] {\n\n  return []\n}\n\n/**\n * Convert trade rectangles to plugin format after ensuring chart is ready\n */\nexport async function convertTradeRectanglesToPluginFormatWhenReady(\n  tradeRectangles: TradeRectangleData[],\n  chart: any,\n  series?: any\n): Promise<any[]> {\n  if (!chart || !series) {\n    return []\n  }\n\n  // Import ChartReadyDetector dynamically to avoid circular dependencies\n  const {ChartReadyDetector} = await import('../utils/chartReadyDetection')\n\n  try {\n    // Wait for chart to be ready with proper dimensions\n    const container = chart.chartElement()\n    if (!container) {\n      return []\n    }\n\n    const isReady = await ChartReadyDetector.waitForChartReady(chart, container, {\n      minWidth: 200,\n      minHeight: 200,\n      maxAttempts: 10,\n      baseDelay: 200\n    })\n\n    if (!isReady) {\n    }\n\n    // Now convert coordinates\n    return convertTradeRectanglesToPluginFormat(tradeRectangles, chart, series)\n  } catch (error) {\n    // Fallback to immediate conversion\n    return convertTradeRectanglesToPluginFormat(tradeRectangles, chart, series)\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/setupTests.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// jest-dom adds custom jest matchers for asserting on DOM nodes.\nimport '@testing-library/jest-dom'\n\n// Mock ResizeObserver before any other imports\nglobal.ResizeObserver = jest.fn().mockImplementation(callback => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Use real lightweight-charts library in tests\n\njest.mock('streamlit-component-lib', () => ({\n  Streamlit: {\n    setComponentValue: () => {},\n    setFrameHeight: () => {},\n    setComponentReady: () => {},\n    RENDER_EVENT: 'streamlit:render',\n    SET_FRAME_HEIGHT_EVENT: 'streamlit:setFrameHeight'\n  }\n}))\n\njest.mock('streamlit-component-lib-react-hooks', () => ({\n  useStreamlit: () => ({\n    theme: {\n      base: 'light',\n      primaryColor: '#ff4b4b',\n      backgroundColor: '#ffffff',\n      secondaryBackgroundColor: '#f0f2f6',\n      textColor: '#262730'\n    },\n    args: {},\n    disabled: false,\n    height: 400,\n    width: 800\n  }),\n  useRenderData: () => ({\n    args: {\n      config: {\n        charts: [\n          {\n            chartId: 'test-chart',\n            chart: {\n              height: 400,\n              autoSize: true,\n              layout: {\n                color: '#ffffff',\n                textColor: '#000000'\n              }\n            },\n            series: [],\n            annotations: {\n              layers: {}\n            }\n          }\n        ],\n        sync: {\n          enabled: false,\n          crosshair: false,\n          timeRange: false\n        }\n      },\n      height: 400,\n      width: null\n    },\n    disabled: false,\n    height: 400,\n    width: 800,\n    theme: {\n      base: 'light',\n      primaryColor: '#ff4b4b',\n      backgroundColor: '#ffffff',\n      secondaryBackgroundColor: '#f0f2f6',\n      textColor: '#262730'\n    }\n  }),\n  StreamlitProvider: ({children}) => {\n    const React = require('react')\n    return React.createElement('div', {}, children)\n  }\n}))\n\n// Mock browser APIs - ResizeObserver\nclass MockResizeObserver {\n  constructor(callback) {\n    this.callback = callback\n  }\n  observe(element) {\n    // Mock implementation that doesn't throw\n    if (this.callback) {\n      // Simulate a resize event\n      setTimeout(() => {\n        this.callback([\n          {\n            target: element,\n            contentRect: {\n              width: 800,\n              height: 600,\n              top: 0,\n              left: 0,\n              right: 800,\n              bottom: 600\n            }\n          }\n        ])\n      }, 0)\n    }\n  }\n  unobserve() {}\n  disconnect() {}\n}\n\n// Set up ResizeObserver mock in all possible contexts\nglobal.ResizeObserver = MockResizeObserver\n\n// Also mock ResizeObserver on window object and ensure it's available everywhere\nif (typeof window !== 'undefined') {\n  window.ResizeObserver = MockResizeObserver\n}\n\n// Mock ResizeObserver in all possible contexts\nObject.defineProperty(global, 'ResizeObserver', {\n  value: MockResizeObserver,\n  writable: true,\n  configurable: true\n})\n\n// Ensure ResizeObserver is available in the global scope\nif (typeof globalThis !== 'undefined') {\n  globalThis.ResizeObserver = MockResizeObserver\n}\n\n// Additional mock setup to ensure it's available everywhere\nObject.defineProperty(window, 'ResizeObserver', {\n  value: MockResizeObserver,\n  writable: true,\n  configurable: true\n})\n\nglobal.IntersectionObserver = class IntersectionObserver {\n  constructor(callback) {\n    this.callback = callback\n  }\n  observe(element) {\n    // Mock implementation that doesn't throw\n    if (this.callback) {\n      // Simulate intersection\n      setTimeout(() => {\n        this.callback([\n          {\n            target: element,\n            isIntersecting: true,\n            intersectionRatio: 1.0,\n            boundingClientRect: {\n              width: 800,\n              height: 600,\n              top: 0,\n              left: 0,\n              right: 800,\n              bottom: 600\n            }\n          }\n        ])\n      }, 0)\n    }\n  }\n  unobserve() {}\n  disconnect() {}\n}\n\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: () => Date.now(),\n    mark: () => {},\n    measure: () => {},\n    getEntriesByType: () => []\n  },\n  writable: true\n})\n\nglobal.requestAnimationFrame = callback => {\n  setTimeout(callback, 0)\n  return 1\n}\n\nglobal.cancelAnimationFrame = () => {}\n\n// Mock DOM methods\nObject.defineProperty(window, 'getComputedStyle', {\n  value: () => ({\n    getPropertyValue: () => ''\n  })\n})\n\nElement.prototype.getBoundingClientRect = () => ({\n  width: 800,\n  height: 600,\n  top: 0,\n  left: 0,\n  right: 800,\n  bottom: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'scrollHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetHeight', {\n  configurable: true,\n  value: 600\n})\n\nObject.defineProperty(HTMLElement.prototype, 'offsetWidth', {\n  configurable: true,\n  value: 800\n})\n\n// Mock HTMLCanvasElement.getContext\nObject.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n  value: jest.fn(contextType => {\n    if (contextType === '2d') {\n      return {\n        canvas: {\n          width: 800,\n          height: 600\n        },\n        clearRect: jest.fn(),\n        fillRect: jest.fn(),\n        strokeRect: jest.fn(),\n        beginPath: jest.fn(),\n        closePath: jest.fn(),\n        moveTo: jest.fn(),\n        lineTo: jest.fn(),\n        arc: jest.fn(),\n        fill: jest.fn(),\n        stroke: jest.fn(),\n        fillStyle: '#000000',\n        strokeStyle: '#000000',\n        lineWidth: 1,\n        save: jest.fn(),\n        restore: jest.fn(),\n        translate: jest.fn(),\n        rotate: jest.fn(),\n        scale: jest.fn(),\n        setTransform: jest.fn(),\n        getImageData: jest.fn(() => ({data: new Uint8ClampedArray(4)})),\n        putImageData: jest.fn(),\n        createImageData: jest.fn(() => ({data: new Uint8ClampedArray(4)})),\n        drawImage: jest.fn(),\n        measureText: jest.fn(() => ({width: 100})),\n        setLineDash: jest.fn(),\n        getLineDash: jest.fn(() => []),\n        lineDashOffset: 0,\n        font: '10px sans-serif',\n        textAlign: 'start',\n        textBaseline: 'alphabetic',\n        direction: 'ltr',\n        globalAlpha: 1,\n        globalCompositeOperation: 'source-over',\n        imageSmoothingEnabled: true,\n        imageSmoothingQuality: 'low',\n        shadowBlur: 0,\n        shadowColor: 'rgba(0, 0, 0, 0)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 0\n      }\n    }\n    return null\n  }),\n  writable: true,\n  configurable: true\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/types.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'paneId' is defined but never used. Allowed unused args must match /^_/u.","line":123,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":35},{"ruleId":"no-unused-vars","severity":1,"message":"'isCollapsed' is defined but never used. Allowed unused args must match /^_/u.","line":123,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":57},{"ruleId":"no-unused-vars","severity":1,"message":"'paneId' is defined but never used. Allowed unused args must match /^_/u.","line":124,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":33},{"ruleId":"no-unused-vars","severity":1,"message":"'isCollapsed' is defined but never used. Allowed unused args must match /^_/u.","line":124,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":55},{"ruleId":"no-unused-vars","severity":1,"message":"'paneId' is defined but never used. Allowed unused args must match /^_/u.","line":125,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":41},{"ruleId":"no-unused-vars","severity":1,"message":"'seriesId' is defined but never used. Allowed unused args must match /^_/u.","line":125,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":59},{"ruleId":"no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":125,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":92},{"ruleId":"no-unused-vars","severity":1,"message":"'price' is defined but never used. Allowed unused args must match /^_/u.","line":267,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":267,"endColumn":38},{"ruleId":"no-unused-vars","severity":1,"message":"'time' is defined but never used. Allowed unused args must match /^_/u.","line":268,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":268,"endColumn":34},{"ruleId":"import/first","severity":2,"message":"Import in body of module; reorder to top.","line":330,"column":1,"nodeType":"ImportDeclaration","endLine":330,"endColumn":94,"fix":{"range":[0,9671],"text":"import {Time, SeriesMarker} from 'lightweight-charts'\nimport { SeriesDataPoint, SeriesOptionsConfig, PriceScaleConfig, LegendData } from './types/ChartInterfaces'\n\n// Range Switcher Configuration\n// Import the improved RangeConfig and TimeRange from RangeSwitcherPrimitive\nimport type { RangeConfig as ImportedRangeConfig } from './primitives/RangeSwitcherPrimitive'\n\n// Enhanced Trade Configuration\nexport interface TradeConfig {\n  entryTime: string | number\n  entryPrice: number\n  exitTime: string | number\n  exitPrice: number\n  quantity: number\n  tradeType: 'long' | 'short'\n  id?: string\n  notes?: string\n  text?: string // Custom tooltip text\n  pnl?: number\n  pnlPercentage?: number\n  isProfitable?: boolean\n}\n\n// Trade Visualization Options\nexport interface TradeVisualizationOptions {\n  style: 'markers' | 'rectangles' | 'both' | 'lines' | 'arrows' | 'zones'\n\n  // Marker options\n  entryMarkerColorLong?: string\n  entryMarkerColorShort?: string\n  exitMarkerColorProfit?: string\n  exitMarkerColorLoss?: string\n  markerSize?: number\n  showPnlInMarkers?: boolean\n\n  // Rectangle options\n  rectangleFillOpacity?: number\n  rectangleBorderWidth?: number\n  rectangleColorProfit?: string\n  rectangleColorLoss?: string\n  rectangleShowText?: boolean\n  rectangleTextPosition?: 'inside' | 'above' | 'below'\n  rectangleTextFontSize?: number\n  rectangleTextColor?: string\n  rectangleTextBackground?: string\n\n  // Line options\n  lineWidth?: number\n  lineStyle?: string\n  lineColorProfit?: string\n  lineColorLoss?: string\n\n  // Arrow options\n  arrowSize?: number\n  arrowColorProfit?: string\n  arrowColorLoss?: string\n\n  // Zone options\n  zoneOpacity?: number\n  zoneColorLong?: string\n  zoneColorShort?: string\n  zoneExtendBars?: number\n\n  // Annotation options\n  showTradeId?: boolean\n  showQuantity?: boolean\n  showTradeType?: boolean\n  showAnnotations?: boolean\n  annotationFontSize?: number\n  annotationBackground?: string\n}\n\n// Annotation System\nexport interface Annotation {\n  time: string\n  price: number\n  text: string\n  type: 'text' | 'arrow' | 'shape' | 'line' | 'rectangle' | 'circle'\n  position: 'above' | 'below' | 'inline'\n  color?: string\n  backgroundColor?: string\n  fontSize?: number\n  fontWeight?: string\n  textColor?: string\n  borderColor?: string\n  borderWidth?: number\n  opacity?: number\n  showTime?: boolean\n  tooltip?: string\n  lineStyle?: string // <-- added for build fix\n}\n\nexport interface AnnotationLayer {\n  name: string\n  visible: boolean\n  opacity: number\n  annotations: Annotation[]\n}\n\nexport interface AnnotationManager {\n  layers: {[key: string]: AnnotationLayer}\n}\n\n// Pane Height Configuration\nexport interface PaneHeightOptions {\n  factor: number\n}\n\n// Pane Collapse Configuration\nexport interface PaneCollapseConfig {\n  enabled?: boolean // Defaults to true - set to false to disable\n  buttonSize?: number\n  buttonColor?: string\n  buttonHoverColor?: string\n  buttonBackground?: string\n  buttonHoverBackground?: string\n  buttonBorderRadius?: number\n  position?: string // Corner position for the collapse button\n  zIndex?: number // Z-index for button positioning\n  showTooltip?: boolean\n  tooltipText?: {\n    collapse?: string\n    expand?: string\n  }\n  showCollapseButton?: boolean\n  legendConfig?: LegendData // Legend configuration for this pane\n  onPaneCollapse?: (paneId: number, isCollapsed: boolean) => void\n  onPaneExpand?: (paneId: number, isCollapsed: boolean) => void\n  onSeriesConfigChange?: (paneId: number, seriesId: string, config: Record<string, unknown>) => void\n}\n\n// Signal Series Configuration\nexport interface SignalData {\n  time: string\n  value: number\n}\n\n// Line Options Configuration\nexport interface LineOptions {\n  color?: string\n  lineStyle?: number\n  lineWidth?: number\n  lineType?: number\n  lineVisible?: boolean\n  pointMarkersVisible?: boolean\n  pointMarkersRadius?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  lastPriceAnimation?: number\n}\n\n// Enhanced Series Configuration\nexport interface SeriesConfig {\n  type:\n    | 'Area'\n    | 'Band'\n    | 'Baseline'\n    | 'Histogram'\n    | 'Line'\n    | 'Bar'\n    | 'Candlestick'\n    | 'signal'\n    | 'trend_fill'\n    | 'ribbon'\n  data: SeriesDataPoint[]\n  options?: SeriesOptionsConfig\n  name?: string\n  priceScale?: PriceScaleConfig\n  priceScaleId?: string // Add priceScaleId support for overlay price scales\n  lastValueVisible?: boolean // Add lastValueVisible support for series\n  lastPriceAnimation?: number // Add lastPriceAnimation support for series\n  markers?: SeriesMarker<Time>[]\n  priceLines?: Array<{\n    price: number\n    color?: string\n    lineWidth?: number\n    lineStyle?: number\n    axisLabelVisible?: boolean\n    title?: string\n  }> // Add price lines to series\n  trades?: TradeConfig[] // Add trades to series\n  tradeVisualizationOptions?: TradeVisualizationOptions\n  annotations?: Annotation[] // Add annotations to series\n  shapes?: Array<{\n    type: string\n    points: Array<{ time: Time; price: number }>\n    color?: string\n    fillColor?: string\n  }> // Add shapes support\n  tooltip?: TooltipConfig // Add tooltip configuration\n  legend?: LegendData | null // Add series-level legend support\n  paneId?: number // Add support for multi-pane charts\n  // Signal series support\n  signalData?: SignalData[]\n\n  // Line options support\n  lineOptions?: LineOptions\n  // Line series specific options (for backward compatibility)\n  lineStyle?: number\n  line_style?: Record<string, unknown> // Support for line_style property\n  lineType?: number\n  lineVisible?: boolean\n  pointMarkersVisible?: boolean\n  pointMarkersRadius?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  // Area series specific options\n  relativeGradient?: boolean\n  invertFilledArea?: boolean\n  // Price line properties\n  priceLineVisible?: boolean\n  priceLineSource?: 'lastBar' | 'lastVisible'\n  priceLineWidth?: number\n  priceLineColor?: string\n  priceLineStyle?: number\n}\n\n// Chart Position Configuration\nexport interface ChartPosition {\n  x?: number | string // CSS position: left value (px or %)\n  y?: number | string // CSS position: top value (px or %)\n  width?: number | string // CSS width (px or %)\n  height?: number | string // CSS height (px or %)\n  zIndex?: number // CSS z-index\n  position?: 'absolute' | 'relative' | 'fixed' | 'static' // CSS position type\n  display?: 'block' | 'inline-block' | 'flex' | 'grid' // CSS display type\n  margin?: string // CSS margin shorthand\n  padding?: string // CSS padding shorthand\n  border?: string // CSS border shorthand\n  borderRadius?: string // CSS border-radius\n  boxShadow?: string // CSS box-shadow\n  backgroundColor?: string // CSS background-color\n}\n\n// Enhanced Chart Configuration\nexport interface ChartConfig {\n  chart: {\n    layout?: {\n      backgroundColor?: string\n      textColor?: string\n      fontSize?: number\n      fontFamily?: string\n    }\n    grid?: {\n      vertLines?: { color?: string; style?: number; visible?: boolean }\n      horzLines?: { color?: string; style?: number; visible?: boolean }\n    }\n    crosshair?: {\n      mode?: number\n      vertLine?: { color?: string; width?: number; style?: number; visible?: boolean }\n      horzLine?: { color?: string; width?: number; style?: number; visible?: boolean }\n    }\n    timeScale?: {\n      rightOffset?: number\n      barSpacing?: number\n      minBarSpacing?: number\n      fixLeftEdge?: boolean\n      fixRightEdge?: boolean\n    }\n    rightPriceScale?: PriceScaleConfig\n    leftPriceScale?: PriceScaleConfig\n    overlayPriceScales?: Record<string, PriceScaleConfig>\n    localization?: {\n      locale?: string\n      priceFormatter?: (price: number) => string\n      timeFormatter?: (time: Time) => string\n    }\n    handleScroll?: {\n      mouseWheel?: boolean\n      pressedMouseMove?: boolean\n      horzTouchDrag?: boolean\n      vertTouchDrag?: boolean\n    }\n    handleScale?: {\n      axisPressedMouseMove?: {\n        time?: boolean\n        price?: boolean\n      }\n      axisDoubleClickReset?: {\n        time?: boolean\n        price?: boolean\n      }\n      mouseWheel?: boolean\n      pinch?: boolean\n    }\n    kineticScroll?: {\n      mouse?: boolean\n      touch?: boolean\n    }\n    trackingMode?: {\n      exitMode?: number\n    }\n  }\n  series: SeriesConfig[]\n  priceLines?: Array<{\n    price: number\n    color?: string\n    lineWidth?: number\n    lineStyle?: number\n    axisLabelVisible?: boolean\n    title?: string\n  }>\n  trades?: TradeConfig[]\n  annotations?: Annotation[] // Add chart-level annotations\n  annotationLayers?: AnnotationLayer[] // Add layer management\n  chartId?: string\n  chartGroupId?: number // Add chart group ID for synchronization\n  containerId?: string // Add containerId for DOM element identification\n  chartOptions?: Record<string, unknown> // Add chartOptions for processed chart configuration\n  rangeSwitcher?: RangeSwitcherConfig\n  tooltip?: TooltipConfig // Add chart-level tooltip configuration\n  tooltipConfigs?: Record<string, TooltipConfig> // Add multiple tooltip configurations\n  tradeVisualizationOptions?: TradeVisualizationOptions // Add chart-level trade visualization options\n  paneCollapse?: PaneCollapseConfig // Add pane collapse/expand functionality\n  autoSize?: boolean\n  autoWidth?: boolean\n  autoHeight?: boolean\n  minWidth?: number\n  minHeight?: number\n  maxWidth?: number\n  maxHeight?: number\n  position?: ChartPosition // Add positioning configuration\n  // paneHeights is now accessed from chart.layout.paneHeights\n}"}},{"ruleId":"no-unused-vars","severity":1,"message":"'value' is defined but never used. Allowed unused args must match /^_/u.","line":383,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":383,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import {Time, SeriesMarker} from 'lightweight-charts'\nimport { SeriesDataPoint, SeriesOptionsConfig, PriceScaleConfig, LegendData } from './types/ChartInterfaces'\n\n// Enhanced Trade Configuration\nexport interface TradeConfig {\n  entryTime: string | number\n  entryPrice: number\n  exitTime: string | number\n  exitPrice: number\n  quantity: number\n  tradeType: 'long' | 'short'\n  id?: string\n  notes?: string\n  text?: string // Custom tooltip text\n  pnl?: number\n  pnlPercentage?: number\n  isProfitable?: boolean\n}\n\n// Trade Visualization Options\nexport interface TradeVisualizationOptions {\n  style: 'markers' | 'rectangles' | 'both' | 'lines' | 'arrows' | 'zones'\n\n  // Marker options\n  entryMarkerColorLong?: string\n  entryMarkerColorShort?: string\n  exitMarkerColorProfit?: string\n  exitMarkerColorLoss?: string\n  markerSize?: number\n  showPnlInMarkers?: boolean\n\n  // Rectangle options\n  rectangleFillOpacity?: number\n  rectangleBorderWidth?: number\n  rectangleColorProfit?: string\n  rectangleColorLoss?: string\n  rectangleShowText?: boolean\n  rectangleTextPosition?: 'inside' | 'above' | 'below'\n  rectangleTextFontSize?: number\n  rectangleTextColor?: string\n  rectangleTextBackground?: string\n\n  // Line options\n  lineWidth?: number\n  lineStyle?: string\n  lineColorProfit?: string\n  lineColorLoss?: string\n\n  // Arrow options\n  arrowSize?: number\n  arrowColorProfit?: string\n  arrowColorLoss?: string\n\n  // Zone options\n  zoneOpacity?: number\n  zoneColorLong?: string\n  zoneColorShort?: string\n  zoneExtendBars?: number\n\n  // Annotation options\n  showTradeId?: boolean\n  showQuantity?: boolean\n  showTradeType?: boolean\n  showAnnotations?: boolean\n  annotationFontSize?: number\n  annotationBackground?: string\n}\n\n// Annotation System\nexport interface Annotation {\n  time: string\n  price: number\n  text: string\n  type: 'text' | 'arrow' | 'shape' | 'line' | 'rectangle' | 'circle'\n  position: 'above' | 'below' | 'inline'\n  color?: string\n  backgroundColor?: string\n  fontSize?: number\n  fontWeight?: string\n  textColor?: string\n  borderColor?: string\n  borderWidth?: number\n  opacity?: number\n  showTime?: boolean\n  tooltip?: string\n  lineStyle?: string // <-- added for build fix\n}\n\nexport interface AnnotationLayer {\n  name: string\n  visible: boolean\n  opacity: number\n  annotations: Annotation[]\n}\n\nexport interface AnnotationManager {\n  layers: {[key: string]: AnnotationLayer}\n}\n\n// Pane Height Configuration\nexport interface PaneHeightOptions {\n  factor: number\n}\n\n// Pane Collapse Configuration\nexport interface PaneCollapseConfig {\n  enabled?: boolean // Defaults to true - set to false to disable\n  buttonSize?: number\n  buttonColor?: string\n  buttonHoverColor?: string\n  buttonBackground?: string\n  buttonHoverBackground?: string\n  buttonBorderRadius?: number\n  position?: string // Corner position for the collapse button\n  zIndex?: number // Z-index for button positioning\n  showTooltip?: boolean\n  tooltipText?: {\n    collapse?: string\n    expand?: string\n  }\n  showCollapseButton?: boolean\n  legendConfig?: LegendData // Legend configuration for this pane\n  onPaneCollapse?: (paneId: number, isCollapsed: boolean) => void\n  onPaneExpand?: (paneId: number, isCollapsed: boolean) => void\n  onSeriesConfigChange?: (paneId: number, seriesId: string, config: Record<string, unknown>) => void\n}\n\n// Signal Series Configuration\nexport interface SignalData {\n  time: string\n  value: number\n}\n\n// Line Options Configuration\nexport interface LineOptions {\n  color?: string\n  lineStyle?: number\n  lineWidth?: number\n  lineType?: number\n  lineVisible?: boolean\n  pointMarkersVisible?: boolean\n  pointMarkersRadius?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  lastPriceAnimation?: number\n}\n\n// Enhanced Series Configuration\nexport interface SeriesConfig {\n  type:\n    | 'Area'\n    | 'Band'\n    | 'Baseline'\n    | 'Histogram'\n    | 'Line'\n    | 'Bar'\n    | 'Candlestick'\n    | 'signal'\n    | 'trend_fill'\n    | 'ribbon'\n  data: SeriesDataPoint[]\n  options?: SeriesOptionsConfig\n  name?: string\n  priceScale?: PriceScaleConfig\n  priceScaleId?: string // Add priceScaleId support for overlay price scales\n  lastValueVisible?: boolean // Add lastValueVisible support for series\n  lastPriceAnimation?: number // Add lastPriceAnimation support for series\n  markers?: SeriesMarker<Time>[]\n  priceLines?: Array<{\n    price: number\n    color?: string\n    lineWidth?: number\n    lineStyle?: number\n    axisLabelVisible?: boolean\n    title?: string\n  }> // Add price lines to series\n  trades?: TradeConfig[] // Add trades to series\n  tradeVisualizationOptions?: TradeVisualizationOptions\n  annotations?: Annotation[] // Add annotations to series\n  shapes?: Array<{\n    type: string\n    points: Array<{ time: Time; price: number }>\n    color?: string\n    fillColor?: string\n  }> // Add shapes support\n  tooltip?: TooltipConfig // Add tooltip configuration\n  legend?: LegendData | null // Add series-level legend support\n  paneId?: number // Add support for multi-pane charts\n  // Signal series support\n  signalData?: SignalData[]\n\n  // Line options support\n  lineOptions?: LineOptions\n  // Line series specific options (for backward compatibility)\n  lineStyle?: number\n  line_style?: Record<string, unknown> // Support for line_style property\n  lineType?: number\n  lineVisible?: boolean\n  pointMarkersVisible?: boolean\n  pointMarkersRadius?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  // Area series specific options\n  relativeGradient?: boolean\n  invertFilledArea?: boolean\n  // Price line properties\n  priceLineVisible?: boolean\n  priceLineSource?: 'lastBar' | 'lastVisible'\n  priceLineWidth?: number\n  priceLineColor?: string\n  priceLineStyle?: number\n}\n\n// Chart Position Configuration\nexport interface ChartPosition {\n  x?: number | string // CSS position: left value (px or %)\n  y?: number | string // CSS position: top value (px or %)\n  width?: number | string // CSS width (px or %)\n  height?: number | string // CSS height (px or %)\n  zIndex?: number // CSS z-index\n  position?: 'absolute' | 'relative' | 'fixed' | 'static' // CSS position type\n  display?: 'block' | 'inline-block' | 'flex' | 'grid' // CSS display type\n  margin?: string // CSS margin shorthand\n  padding?: string // CSS padding shorthand\n  border?: string // CSS border shorthand\n  borderRadius?: string // CSS border-radius\n  boxShadow?: string // CSS box-shadow\n  backgroundColor?: string // CSS background-color\n}\n\n// Enhanced Chart Configuration\nexport interface ChartConfig {\n  chart: {\n    layout?: {\n      backgroundColor?: string\n      textColor?: string\n      fontSize?: number\n      fontFamily?: string\n    }\n    grid?: {\n      vertLines?: { color?: string; style?: number; visible?: boolean }\n      horzLines?: { color?: string; style?: number; visible?: boolean }\n    }\n    crosshair?: {\n      mode?: number\n      vertLine?: { color?: string; width?: number; style?: number; visible?: boolean }\n      horzLine?: { color?: string; width?: number; style?: number; visible?: boolean }\n    }\n    timeScale?: {\n      rightOffset?: number\n      barSpacing?: number\n      minBarSpacing?: number\n      fixLeftEdge?: boolean\n      fixRightEdge?: boolean\n    }\n    rightPriceScale?: PriceScaleConfig\n    leftPriceScale?: PriceScaleConfig\n    overlayPriceScales?: Record<string, PriceScaleConfig>\n    localization?: {\n      locale?: string\n      priceFormatter?: (price: number) => string\n      timeFormatter?: (time: Time) => string\n    }\n    handleScroll?: {\n      mouseWheel?: boolean\n      pressedMouseMove?: boolean\n      horzTouchDrag?: boolean\n      vertTouchDrag?: boolean\n    }\n    handleScale?: {\n      axisPressedMouseMove?: {\n        time?: boolean\n        price?: boolean\n      }\n      axisDoubleClickReset?: {\n        time?: boolean\n        price?: boolean\n      }\n      mouseWheel?: boolean\n      pinch?: boolean\n    }\n    kineticScroll?: {\n      mouse?: boolean\n      touch?: boolean\n    }\n    trackingMode?: {\n      exitMode?: number\n    }\n  }\n  series: SeriesConfig[]\n  priceLines?: Array<{\n    price: number\n    color?: string\n    lineWidth?: number\n    lineStyle?: number\n    axisLabelVisible?: boolean\n    title?: string\n  }>\n  trades?: TradeConfig[]\n  annotations?: Annotation[] // Add chart-level annotations\n  annotationLayers?: AnnotationLayer[] // Add layer management\n  chartId?: string\n  chartGroupId?: number // Add chart group ID for synchronization\n  containerId?: string // Add containerId for DOM element identification\n  chartOptions?: Record<string, unknown> // Add chartOptions for processed chart configuration\n  rangeSwitcher?: RangeSwitcherConfig\n  tooltip?: TooltipConfig // Add chart-level tooltip configuration\n  tooltipConfigs?: Record<string, TooltipConfig> // Add multiple tooltip configurations\n  tradeVisualizationOptions?: TradeVisualizationOptions // Add chart-level trade visualization options\n  paneCollapse?: PaneCollapseConfig // Add pane collapse/expand functionality\n  autoSize?: boolean\n  autoWidth?: boolean\n  autoHeight?: boolean\n  minWidth?: number\n  minHeight?: number\n  maxWidth?: number\n  maxHeight?: number\n  position?: ChartPosition // Add positioning configuration\n  // paneHeights is now accessed from chart.layout.paneHeights\n}\n\n// Range Switcher Configuration\n// Import the improved RangeConfig and TimeRange from RangeSwitcherPrimitive\nimport type { RangeConfig as ImportedRangeConfig } from './primitives/RangeSwitcherPrimitive'\nexport type { RangeConfig } from './primitives/RangeSwitcherPrimitive'\nexport { TimeRange } from './primitives/RangeSwitcherPrimitive'\n\nexport interface RangeSwitcherConfig {\n  ranges: ImportedRangeConfig[]\n  position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  visible: boolean\n  defaultRange?: string\n  interval?: string // Data interval (e.g., '1m', '5m', '1h', '1d') for accurate range calculations\n}\n\n// Legend Configuration\nexport interface LegendConfig {\n  visible?: boolean\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  symbolName?: string\n  textColor?: string\n  backgroundColor?: string\n  borderColor?: string\n  borderWidth?: number\n  borderRadius?: number\n  padding?: number\n  margin?: number\n  zIndex?: number\n  priceFormat?: string\n  text?: string\n  width?: number\n  height?: number\n  showValues?: boolean\n  valueFormat?: string\n  updateOnCrosshair?: boolean\n}\n\n// Sync Configuration\nexport interface SyncConfig {\n  enabled: boolean\n  crosshair: boolean\n  timeRange: boolean\n  groups?: {[groupId: string]: SyncConfig} // Group-specific sync configurations\n}\n\n// Component Configuration\nexport interface ComponentConfig {\n  charts: ChartConfig[]\n  syncConfig: SyncConfig\n  callbacks?: string[]\n}\n\n// Modular Tooltip System\nexport interface TooltipField {\n  label: string\n  valueKey: string\n  formatter?: (value: unknown) => string\n  color?: string\n  fontSize?: number\n  fontWeight?: string\n}\n\nexport interface TooltipConfig {\n  enabled: boolean\n  type: 'ohlc' | 'single' | 'multi' | 'custom'\n  fields: TooltipField[]\n  position?: 'cursor' | 'fixed' | 'auto'\n  offset?: {x: number; y: number}\n  style?: {\n    backgroundColor?: string\n    borderColor?: string\n    borderWidth?: number\n    borderRadius?: number\n    padding?: number\n    fontSize?: number\n    fontFamily?: string\n    color?: string\n    boxShadow?: string\n    zIndex?: number\n  }\n  showDate?: boolean\n  dateFormat?: string\n  showTime?: boolean\n  timeFormat?: string\n}\n\n// Extend Window interface for chart plugins\ndeclare global {\n  interface Window {\n    chartPlugins?: Map<string, unknown>\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/types/ChartInterfaces.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Time' is defined but never used.","line":6,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Time' is defined but never used.","line":6,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":51},{"ruleId":"no-unused-vars","severity":1,"message":"'shape' is defined but never used. Allowed unused args must match /^_/u.","line":36,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'shapes' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":35},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":249,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":249,"endColumn":31},{"ruleId":"no-unused-vars","severity":1,"message":"'time' is defined but never used. Allowed unused args must match /^_/u.","line":452,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":452,"endColumn":42},{"ruleId":"no-unused-vars","severity":1,"message":"'tickMarkType' is defined but never used. Allowed unused args must match /^_/u.","line":452,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":452,"endColumn":64},{"ruleId":"no-unused-vars","severity":1,"message":"'locale' is defined but never used. Allowed unused args must match /^_/u.","line":452,"column":66,"nodeType":"Identifier","messageId":"unusedVar","endLine":452,"endColumn":80},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":490,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":490,"endColumn":50},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":495,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":495,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive TypeScript interfaces to replace any types\n * Provides proper typing for chart APIs, series data, and template contexts\n */\n\nimport { IChartApi, ISeriesApi, UTCTimestamp, Time } from 'lightweight-charts'\n\n// =============================================================================\n// CHART API INTERFACES\n// =============================================================================\n\n/**\n * Extended chart API with commonly used properties\n */\nexport interface ExtendedChartApi extends IChartApi {\n  _storageListenerAdded?: boolean\n  _timeRangeStorageListenerAdded?: boolean\n  _isExternalSync?: boolean\n  _isExternalTimeRangeSync?: boolean\n  _pendingTradeRectangles?: Array<{\n    series: ISeriesApi<any>\n    trade: TradeData\n    rectangleConfig: RectangleConfig\n  }>\n  _userHasInteracted?: boolean\n}\n\n/**\n * Extended series API with commonly used properties\n */\nexport interface ExtendedSeriesApi<TData = any> extends ISeriesApi<TData> {\n  paneId?: number\n  legendConfig?: LegendData\n  seriesId?: string\n  assignedPaneId?: number\n  addShape?: (shape: ShapeData) => void\n  setShapes?: (shapes: ShapeData[]) => void\n}\n\n// =============================================================================\n// SERIES DATA INTERFACES\n// =============================================================================\n\n/**\n * Base data point interface\n */\nexport interface BaseDataPoint {\n  time: UTCTimestamp | string | number\n  value?: number\n  color?: string\n}\n\n/**\n * OHLC data point\n */\nexport interface OHLCDataPoint extends BaseDataPoint {\n  open: number\n  high: number\n  low: number\n  close: number\n}\n\n/**\n * Area/Line data point\n */\nexport interface LineDataPoint extends BaseDataPoint {\n  value: number\n}\n\n/**\n * Histogram data point\n */\nexport interface HistogramDataPoint extends BaseDataPoint {\n  value: number\n  color?: string\n}\n\n/**\n * Baseline data point\n */\nexport interface BaselineDataPoint extends BaseDataPoint {\n  value: number\n  topLineColor?: string\n  topFillColor1?: string\n  topFillColor2?: string\n  bottomLineColor?: string\n  bottomFillColor1?: string\n  bottomFillColor2?: string\n}\n\n/**\n * Band series data point\n */\nexport interface BandDataPoint extends BaseDataPoint {\n  upper: number\n  lower: number\n}\n\n/**\n * Generic series data type union\n */\nexport type SeriesDataPoint =\n  | OHLCDataPoint\n  | LineDataPoint\n  | HistogramDataPoint\n  | BaselineDataPoint\n  | BandDataPoint\n\n// =============================================================================\n// TRADE AND VISUALIZATION INTERFACES\n// =============================================================================\n\n/**\n * Trade data structure\n */\nexport interface TradeData {\n  id?: string\n  entryTime: UTCTimestamp | string | number\n  exitTime: UTCTimestamp | string | number\n  entryPrice: number\n  exitPrice: number\n  quantity?: number\n  side: 'long' | 'short'\n  pnl?: number\n  pnlPercentage?: number\n  series_id?: string\n  series_index?: number\n}\n\n/**\n * Rectangle configuration\n */\nexport interface RectangleConfig {\n  time1: UTCTimestamp\n  time2: UTCTimestamp\n  price1: number\n  price2: number\n  color?: string\n  fillColor?: string\n  borderColor?: string\n  borderWidth?: number\n  fillOpacity?: number\n  text?: string\n  textColor?: string\n  textBackground?: string\n}\n\n/**\n * Shape data for series\n */\nexport interface ShapeData {\n  type: 'rectangle' | 'line' | 'arrow' | 'circle'\n  points: Array<{ time: UTCTimestamp; price: number }>\n  color?: string\n  fillColor?: string\n  borderWidth?: number\n  text?: string\n}\n\n// =============================================================================\n// TEMPLATE AND CONTEXT INTERFACES\n// =============================================================================\n\n/**\n * Template formatting options\n */\nexport interface TemplateFormatting {\n  price?: {\n    precision?: number\n    currency?: string\n    symbol?: string\n  }\n  time?: {\n    format?: string\n    timezone?: string\n  }\n  percentage?: {\n    precision?: number\n    showSign?: boolean\n  }\n  number?: {\n    precision?: number\n    thousandsSeparator?: string\n    decimalSeparator?: string\n  }\n}\n\n/**\n * Template context for string interpolation\n */\nexport interface TemplateContext {\n  price?: number\n  open?: number\n  high?: number\n  low?: number\n  close?: number\n  volume?: number\n  time?: UTCTimestamp | string | number\n  value?: number\n  change?: number\n  changePercent?: number\n  symbol?: string\n  seriesName?: string\n  paneId?: number\n  formatting?: TemplateFormatting\n  customData?: Record<string, unknown>\n}\n\n// =============================================================================\n// LEGEND AND UI INTERFACES\n// =============================================================================\n\n/**\n * Legend data structure\n */\nexport interface LegendData {\n  visible?: boolean\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  text?: string\n  symbolName?: string\n  textColor?: string\n  backgroundColor?: string\n  borderColor?: string\n  borderWidth?: number\n  borderRadius?: number\n  padding?: number\n  margin?: number\n  zIndex?: number\n  width?: number\n  height?: number\n  showValues?: boolean\n  valueFormat?: string\n  updateOnCrosshair?: boolean\n  priceFormat?: string\n}\n\n/**\n * Corner position type\n */\nexport type CornerPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n\n/**\n * Button configuration\n */\nexport interface ButtonConfig {\n  id: string\n  content: string\n  corner: CornerPosition\n  onClick?: (event: MouseEvent) => void\n  style?: Partial<CSSStyleDeclaration>\n  className?: string\n  disabled?: boolean\n  visible?: boolean\n}\n\n// =============================================================================\n// COORDINATE AND DIMENSION INTERFACES\n// =============================================================================\n\n/**\n * Coordinate point\n */\nexport interface CoordinatePoint {\n  x: number\n  y: number\n}\n\n/**\n * Bounding box\n */\nexport interface BoundingBox {\n  top: number\n  left: number\n  width: number\n  height: number\n  right: number\n  bottom: number\n}\n\n/**\n * Element positioning\n */\nexport interface ElementPosition {\n  x: number\n  y: number\n  width: number\n  height: number\n  corner: CornerPosition\n  offset: CoordinatePoint\n}\n\n/**\n * Pane coordinates\n */\nexport interface PaneCoordinates {\n  paneId: number\n  x: number\n  y: number\n  width: number\n  height: number\n  absoluteX: number\n  absoluteY: number\n  contentArea: {\n    top: number\n    left: number\n    width: number\n    height: number\n  }\n  margins: {\n    top: number\n    left: number\n    right: number\n    bottom: number\n  }\n  isMainPane: boolean\n  isLastPane: boolean\n}\n\n// =============================================================================\n// EVENT AND CALLBACK INTERFACES\n// =============================================================================\n\n/**\n * Crosshair event data\n */\nexport interface CrosshairEventData {\n  time: UTCTimestamp | null\n  point: CoordinatePoint | null\n  seriesData: Map<ExtendedSeriesApi, SeriesDataPoint | null>\n}\n\n/**\n * Chart click event data\n */\nexport interface ChartClickEventData {\n  time: UTCTimestamp | null\n  point: CoordinatePoint | null\n  seriesData: Map<ExtendedSeriesApi, SeriesDataPoint | null>\n}\n\n/**\n * Series configuration change event\n */\nexport interface SeriesConfigChangeEvent {\n  seriesId: string\n  paneId: number\n  config: Record<string, unknown>\n  field: string\n  oldValue: unknown\n  newValue: unknown\n}\n\n/**\n * Pane collapse event\n */\nexport interface PaneCollapseEvent {\n  paneId: number\n  isCollapsed: boolean\n  trigger: 'user' | 'api'\n}\n\n// =============================================================================\n// CONFIGURATION INTERFACES\n// =============================================================================\n\n/**\n * Series options configuration\n */\nexport interface SeriesOptionsConfig {\n  title?: string\n  visible?: boolean\n  lastValueVisible?: boolean\n  priceLineVisible?: boolean\n  priceLineSource?: 'lastBar' | 'lastVisible'\n  priceLineWidth?: number\n  priceLineColor?: string\n  priceLineStyle?: number\n  baseLineVisible?: boolean\n  baseLineColor?: string\n  baseLineWidth?: number\n  baseLineStyle?: number\n  // Line-specific options\n  lineColor?: string\n  lineStyle?: number\n  lineWidth?: number\n  lineType?: number\n  lineVisible?: boolean\n  pointMarkersVisible?: boolean\n  pointMarkersRadius?: number\n  crosshairMarkerVisible?: boolean\n  crosshairMarkerRadius?: number\n  crosshairMarkerBorderColor?: string\n  crosshairMarkerBackgroundColor?: string\n  crosshairMarkerBorderWidth?: number\n  // Area-specific options\n  topColor?: string\n  bottomColor?: string\n  invertFilledArea?: boolean\n  // Histogram-specific options\n  color?: string\n  base?: number\n}\n\n/**\n * Chart layout configuration\n */\nexport interface ChartLayoutConfig {\n  backgroundColor?: string\n  textColor?: string\n  fontSize?: number\n  fontFamily?: string\n  attributionLogo?: boolean\n}\n\n/**\n * Price scale configuration\n */\nexport interface PriceScaleConfig {\n  position?: 'left' | 'right' | 'none'\n  mode?: number\n  autoScale?: boolean\n  invertScale?: boolean\n  alignLabels?: boolean\n  borderVisible?: boolean\n  borderColor?: string\n  entireTextOnly?: boolean\n  visible?: boolean\n  ticksVisible?: boolean\n  scaleMargins?: {\n    top?: number\n    bottom?: number\n  }\n}\n\n/**\n * Time scale configuration\n */\nexport interface TimeScaleConfig {\n  rightOffset?: number\n  barSpacing?: number\n  minBarSpacing?: number\n  fixLeftEdge?: boolean\n  fixRightEdge?: boolean\n  lockVisibleTimeRangeOnResize?: boolean\n  rightBarStaysOnScroll?: boolean\n  borderVisible?: boolean\n  borderColor?: string\n  visible?: boolean\n  timeVisible?: boolean\n  secondsVisible?: boolean\n  shiftVisibleRangeOnNewBar?: boolean\n  tickMarkFormatter?: (time: UTCTimestamp, tickMarkType: number, locale: string) => string\n}\n\n// =============================================================================\n// WINDOW EXTENSIONS\n// =============================================================================\n\n/**\n * Global window extensions for chart management\n */\ndeclare global {\n  interface Window {\n    chartInstances?: Record<string, ExtendedChartApi>\n    chartApiMap?: Record<string, ExtendedChartApi>\n    chartGroupMap?: Record<string, number>\n    seriesRefsMap?: Record<string, ExtendedSeriesApi[]>\n    paneWrappers?: Record<string, Record<string, unknown>>\n    paneButtonPanelWidgets?: Record<string, unknown[]>\n    chartResizeObservers?: Record<string, ResizeObserver>\n    paneLegendManagers?: Record<string, Record<number, unknown>>\n    chartPlugins?: Map<string, unknown>\n  }\n}\n\n// =============================================================================\n// UTILITY TYPES\n// =============================================================================\n\n/**\n * Make all properties optional recursively\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\n/**\n * Extract function parameter types\n */\nexport type ParameterType<T> = T extends (...args: infer P) => any ? P : never\n\n/**\n * Extract function return type\n */\nexport type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never\n\n/**\n * Non-nullable type utility\n */\nexport type NonNullable<T> = T extends null | undefined ? never : T\n\n/**\n * Value of a record/object\n */\nexport type ValueOf<T> = T[keyof T]","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/types/SeriesTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/types/coordinates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/types/layout.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'position' is defined but never used. Allowed unused args must match /^_/u.","line":53,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'corner' is defined but never used. Allowed unused args must match /^_/u.","line":69,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":35},{"ruleId":"no-unused-vars","severity":1,"message":"'widgets' is defined but never used. Allowed unused args must match /^_/u.","line":69,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":67},{"ruleId":"no-unused-vars","severity":1,"message":"'corner' is defined but never used. Allowed unused args must match /^_/u.","line":70,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":30},{"ruleId":"no-unused-vars","severity":1,"message":"'overflowingWidgets' is defined but never used. Allowed unused args must match /^_/u.","line":70,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Layout and positioning types for the chart widget management system\n */\n\nexport type Corner = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n\nexport interface Dimensions {\n  width: number\n  height: number\n}\n\nexport interface AxisDimensions {\n  priceScale: {\n    left: {\n      width: number // Left Y-axis width\n      height: number\n    }\n    right: {\n      width: number // Right Y-axis width\n      height: number\n    }\n  }\n  timeScale: {\n    width: number\n    height: number // X-axis height (bottom)\n  }\n}\n\nexport interface ChartLayoutDimensions {\n  container: Dimensions\n  axis: AxisDimensions\n}\n\nexport interface Position {\n  top?: number\n  right?: number\n  bottom?: number\n  left?: number\n  zIndex: number\n}\n\nexport interface WidgetDimensions {\n  width: number\n  height: number\n}\n\nexport interface IPositionableWidget {\n  id: string\n  corner: Corner\n  priority: number\n  visible: boolean\n  getDimensions(): WidgetDimensions\n  updatePosition(position: Position): void\n}\n\nexport interface LayoutConfig {\n  edgePadding: number // Distance from chart edges\n  widgetGap: number   // Gap between stacked widgets\n  baseZIndex: number  // Starting z-index for widgets\n}\n\nexport interface CornerLayoutState {\n  widgets: IPositionableWidget[]\n  totalHeight: number\n  totalWidth: number\n}\n\nexport interface LayoutManagerEvents {\n  onLayoutChanged: (corner: Corner, widgets: IPositionableWidget[]) => void\n  onOverflow: (corner: Corner, overflowingWidgets: IPositionableWidget[]) => void\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/__tests__/performance.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalConsole' is assigned a value but never used.","line":19,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  perfLogFn as perfLog,\n  getCachedDOMElementForTesting as getCachedDOMElement,\n  createOptimizedStyles\n} from '../performance'\n\n// Mock performance API\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: jest.fn(() => Date.now()),\n    mark: jest.fn(),\n    measure: jest.fn(),\n    getEntriesByType: jest.fn(() => [])\n  },\n  writable: true\n})\n\n// Mock console methods\nconst originalConsole = {...console}\nbeforeEach(() => {\n\n\n\n})\n\nafterEach(() => {\n\n\n\n})\n\ndescribe('performance', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('perfLog', () => {\n    it('should log performance metrics when enabled', () => {\n      const mockPerformance = {\n        now: jest.fn(() => 1000),\n        mark: jest.fn(),\n        measure: jest.fn(),\n        getEntriesByType: jest.fn(() => [])\n      }\n      Object.defineProperty(window, 'performance', {\n        value: mockPerformance,\n        writable: true\n      })\n\n      perfLog('test-operation', () => {\n        // Simulate some work\n        return 'result'\n      })\n\n      expect(mockPerformance.now).toHaveBeenCalled()\n\n    })\n\n    it('should handle errors gracefully', () => {\n      const mockPerformance = {\n        now: jest.fn(() => 1000),\n        mark: jest.fn(),\n        measure: jest.fn(),\n        getEntriesByType: jest.fn(() => [])\n      }\n      Object.defineProperty(window, 'performance', {\n        value: mockPerformance,\n        writable: true\n      })\n\n      const errorFn = () => {\n        throw new Error('Test error')\n      }\n\n      expect(() => {\n        perfLog('error-operation', errorFn)\n      }).toThrow('Test error')\n\n      expect(mockPerformance.now).toHaveBeenCalled()\n    })\n\n    it('should work with async functions', async () => {\n      const mockPerformance = {\n        now: jest.fn(() => 1000),\n        mark: jest.fn(),\n        measure: jest.fn(),\n        getEntriesByType: jest.fn(() => [])\n      }\n      Object.defineProperty(window, 'performance', {\n        value: mockPerformance,\n        writable: true\n      })\n\n      const asyncFn = async () => {\n        await new Promise(resolve => setTimeout(resolve, 10))\n        return 'async result'\n      }\n\n      const result = await perfLog('async-operation', asyncFn)\n\n      expect(result).toBe('async result')\n      expect(mockPerformance.now).toHaveBeenCalled()\n    })\n\n    it('should handle performance API not available', () => {\n      Object.defineProperty(window, 'performance', {\n        value: undefined,\n        writable: true\n      })\n\n      const result = perfLog('no-performance', () => 'result')\n\n      expect(result).toBe('result')\n\n    })\n  })\n\n  describe('getCachedDOMElement', () => {\n    it('should return cached element when available', () => {\n      const mockElement = document.createElement('div')\n      const cache = new Map()\n      cache.set('test-id', mockElement)\n\n      const result = getCachedDOMElement('test-id', cache, () => document.createElement('span'))\n\n      expect(result).toBe(mockElement)\n    })\n\n    it('should create and cache new element when not available', () => {\n      const cache = new Map()\n      const createFn = jest.fn(() => document.createElement('div'))\n\n      const result = getCachedDOMElement('new-id', cache, createFn)\n\n      expect(result).toBeInstanceOf(HTMLDivElement)\n      expect(createFn).toHaveBeenCalledWith('new-id')\n      expect(cache.get('new-id')).toBe(result)\n    })\n\n    it('should handle null create function', () => {\n      const cache = new Map()\n\n      const result = getCachedDOMElement('test-id', cache, null)\n\n      expect(result).toBeNull()\n    })\n\n    it('should handle create function returning null', () => {\n      const cache = new Map()\n      const createFn = jest.fn(() => null)\n\n      const result = getCachedDOMElement('test-id', cache, createFn)\n\n      expect(result).toBeNull()\n      expect(createFn).toHaveBeenCalledWith('test-id')\n    })\n\n    it('should handle multiple calls with same ID', () => {\n      const cache = new Map()\n      const createFn = jest.fn(() => document.createElement('div'))\n\n      const result1 = getCachedDOMElement('same-id', cache, createFn)\n      const result2 = getCachedDOMElement('same-id', cache, createFn)\n\n      expect(result1).toBe(result2)\n      expect(createFn).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('createOptimizedStyles', () => {\n    it('should create optimized styles object', () => {\n      const styles = createOptimizedStyles({\n        width: '100%',\n        height: '400px',\n        backgroundColor: '#ffffff'\n      })\n\n      expect(styles).toEqual({\n        width: '100%',\n        height: '400px',\n        backgroundColor: '#ffffff'\n      })\n    })\n\n    it('should handle empty styles object', () => {\n      const styles = createOptimizedStyles({})\n\n      expect(styles).toEqual({})\n    })\n\n    it('should handle null styles', () => {\n      const styles = createOptimizedStyles(null)\n\n      expect(styles).toEqual({})\n    })\n\n    it('should handle undefined styles', () => {\n      const styles = createOptimizedStyles(undefined)\n\n      expect(styles).toEqual({})\n    })\n\n    it('should handle complex style objects', () => {\n      const styles = createOptimizedStyles({\n        width: '100%',\n        height: '400px',\n        backgroundColor: '#ffffff',\n        border: '1px solid #ccc',\n        borderRadius: '4px',\n        padding: '10px',\n        margin: '0',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center'\n      })\n\n      expect(styles).toEqual({\n        width: '100%',\n        height: '400px',\n        backgroundColor: '#ffffff',\n        border: '1px solid #ccc',\n        borderRadius: '4px',\n        padding: '10px',\n        margin: '0',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center'\n      })\n    })\n\n    it('should handle numeric values', () => {\n      const styles = createOptimizedStyles({\n        width: 800,\n        height: 600,\n        opacity: 0.8,\n        zIndex: 1000\n      })\n\n      expect(styles).toEqual({\n        width: 800,\n        height: 600,\n        opacity: 0.8,\n        zIndex: 1000\n      })\n    })\n\n    it('should handle mixed value types', () => {\n      const styles = createOptimizedStyles({\n        width: '100%',\n        height: 400,\n        opacity: 0.8,\n        color: '#000000',\n        fontSize: '14px',\n        fontWeight: 500\n      })\n\n      expect(styles).toEqual({\n        width: '100%',\n        height: 400,\n        opacity: 0.8,\n        color: '#000000',\n        fontSize: '14px',\n        fontWeight: 500\n      })\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/__tests__/seriesFactory.test.ts","messages":[{"ruleId":"import/first","severity":2,"message":"Import in body of module; reorder to top.","line":263,"column":1,"nodeType":"ImportDeclaration","endLine":263,"endColumn":47,"fix":{"range":[0,8477],"text":"import {createSeries} from '../seriesFactory'\n\nimport {createChart} from 'lightweight-charts'\n\n// Mock lightweight-charts\njest.mock('lightweight-charts', () => {\n  const mockChart = {\n    addSeries: jest.fn().mockImplementation((seriesType, options, paneId) => {\n      return {\n        setData: jest.fn(),\n        update: jest.fn(),\n        applyOptions: jest.fn(),\n        priceFormatter: jest.fn().mockReturnValue(value => value.toFixed(2)),\n        priceToCoordinate: jest.fn().mockReturnValue(100),\n        coordinateToPrice: jest.fn().mockReturnValue(50),\n        barsInLogicalRange: jest.fn().mockReturnValue({barsBefore: 0, barsAfter: 0}),\n        data: jest.fn().mockReturnValue([]),\n        dataByIndex: jest.fn().mockReturnValue(null),\n        subscribeDataChanged: jest.fn(),\n        unsubscribeDataChanged: jest.fn(),\n        seriesType: jest.fn().mockReturnValue('Line'),\n        attachPrimitive: jest.fn(),\n        detachPrimitive: jest.fn(),\n        getPane: jest.fn().mockReturnValue({\n          getHeight: jest.fn().mockReturnValue(400),\n          setHeight: jest.fn(),\n          getStretchFactor: jest.fn().mockReturnValue(1),\n          setStretchFactor: jest.fn(),\n          paneIndex: jest.fn().mockReturnValue(0),\n          moveTo: jest.fn(),\n          getSeries: jest.fn().mockReturnValue([]),\n          getHTMLElement: jest.fn().mockReturnValue({}),\n          attachPrimitive: jest.fn(),\n          detachPrimitive: jest.fn(),\n          priceScale: jest.fn().mockReturnValue({\n            applyOptions: jest.fn(),\n            options: jest.fn().mockReturnValue({}),\n            width: jest.fn().mockReturnValue(100),\n            setVisibleRange: jest.fn(),\n            getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n            setAutoScale: jest.fn()\n          }),\n          setPreserveEmptyPane: jest.fn(),\n          preserveEmptyPane: jest.fn().mockReturnValue(false),\n          addCustomSeries: jest.fn(),\n          addSeries: jest.fn()\n        }),\n        moveToPane: jest.fn(),\n        seriesOrder: jest.fn().mockReturnValue(0),\n        setSeriesOrder: jest.fn(),\n        createPriceLine: jest.fn().mockReturnValue({\n          applyOptions: jest.fn(),\n          options: jest.fn().mockReturnValue({}),\n          remove: jest.fn()\n        }),\n        removePriceLine: jest.fn(),\n        priceLines: jest.fn().mockReturnValue([])\n      }\n    }),\n    removeSeries: jest.fn(),\n    addCustomSeries: jest.fn().mockReturnValue({\n      setData: jest.fn(),\n      update: jest.fn(),\n      applyOptions: jest.fn(),\n      seriesType: jest.fn().mockReturnValue('Custom')\n    }),\n    remove: jest.fn(),\n    resize: jest.fn(),\n    applyOptions: jest.fn(),\n    options: jest.fn().mockReturnValue({\n      layout: {\n        background: {type: 'solid', color: '#FFFFFF'},\n        textColor: '#191919',\n        fontSize: 12,\n        fontFamily: 'Arial'\n      },\n      crosshair: {\n        mode: 1,\n        vertLine: {visible: true},\n        horzLine: {visible: true}\n      },\n      grid: {\n        vertLines: {visible: true},\n        horzLines: {visible: true}\n      },\n      timeScale: {\n        visible: true,\n        timeVisible: false,\n        secondsVisible: false\n      },\n      rightPriceScale: {\n        visible: true,\n        autoScale: true\n      },\n      leftPriceScale: {\n        visible: false,\n        autoScale: true\n      }\n    }),\n    timeScale: jest.fn().mockReturnValue({\n      scrollPosition: jest.fn().mockReturnValue(0),\n      scrollToPosition: jest.fn(),\n      scrollToRealTime: jest.fn(),\n      getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setVisibleRange: jest.fn(),\n      getVisibleLogicalRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setVisibleLogicalRange: jest.fn(),\n      resetTimeScale: jest.fn(),\n      fitContent: jest.fn(),\n      logicalToCoordinate: jest.fn().mockReturnValue(100),\n      coordinateToLogical: jest.fn().mockReturnValue(0),\n      timeToIndex: jest.fn().mockReturnValue(0),\n      timeToCoordinate: jest.fn().mockReturnValue(100),\n      coordinateToTime: jest.fn().mockReturnValue(0),\n      width: jest.fn().mockReturnValue(800),\n      height: jest.fn().mockReturnValue(400),\n      subscribeVisibleTimeRangeChange: jest.fn(),\n      unsubscribeVisibleTimeRangeChange: jest.fn(),\n      subscribeVisibleLogicalRangeChange: jest.fn(),\n      unsubscribeVisibleLogicalRangeChange: jest.fn(),\n      subscribeSizeChange: jest.fn(),\n      unsubscribeSizeChange: jest.fn(),\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({\n        barSpacing: 6,\n        rightOffset: 0\n      })\n    }),\n    priceScale: jest.fn().mockReturnValue({\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({}),\n      width: jest.fn().mockReturnValue(100),\n      setVisibleRange: jest.fn(),\n      getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setAutoScale: jest.fn()\n    }),\n    subscribeClick: jest.fn(),\n    unsubscribeClick: jest.fn(),\n    subscribeCrosshairMove: jest.fn(),\n    unsubscribeCrosshairMove: jest.fn(),\n    subscribeDblClick: jest.fn(),\n    unsubscribeDblClick: jest.fn(),\n    takeScreenshot: jest.fn().mockReturnValue({}),\n    addPane: jest.fn().mockReturnValue({\n      getHeight: jest.fn().mockReturnValue(400),\n      setHeight: jest.fn(),\n      getStretchFactor: jest.fn().mockReturnValue(1),\n      setStretchFactor: jest.fn(),\n      paneIndex: jest.fn().mockReturnValue(0),\n      moveTo: jest.fn(),\n      getSeries: jest.fn().mockReturnValue([]),\n      getHTMLElement: jest.fn().mockReturnValue({}),\n      attachPrimitive: jest.fn(),\n      detachPrimitive: jest.fn(),\n      priceScale: jest.fn().mockReturnValue({\n        applyOptions: jest.fn(),\n        options: jest.fn().mockReturnValue({}),\n        width: jest.fn().mockReturnValue(100),\n        setVisibleRange: jest.fn(),\n        getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n        setAutoScale: jest.fn()\n      }),\n      setPreserveEmptyPane: jest.fn(),\n      preserveEmptyPane: jest.fn().mockReturnValue(false),\n      addCustomSeries: jest.fn(),\n      addSeries: jest.fn()\n    }),\n    removePane: jest.fn(),\n    swapPanes: jest.fn(),\n    autoSizeActive: jest.fn().mockReturnValue(false),\n    chartElement: jest.fn().mockReturnValue({}),\n    panes: jest.fn().mockReturnValue([]),\n    paneSize: jest.fn().mockReturnValue({width: 800, height: 400}),\n    setCrosshairPosition: jest.fn(),\n    clearCrosshairPosition: jest.fn(),\n    horzBehaviour: jest.fn().mockReturnValue({\n      options: jest.fn().mockReturnValue({}),\n      setOptions: jest.fn()\n    })\n  }\n\n  return {\n    createChart: (container, options) => {\n      return mockChart\n    },\n    createChartEx: jest.fn().mockImplementation((container, horzScaleBehavior, options) => {\n      return mockChart\n    }),\n    createSeries: jest.fn().mockImplementation((chart, seriesType, options) => {\n      return mockChart.addSeries(seriesType, options)\n    }),\n    isBusinessDay: jest.fn().mockImplementation(time => {\n      return typeof time === 'object' && time.year && time.month && time.day\n    }),\n    isUTCTimestamp: jest.fn().mockImplementation(time => {\n      return typeof time === 'number' && time > 0\n    }),\n    ColorType: {\n      Solid: 'solid',\n      VerticalGradient: 'gradient'\n    },\n    CrosshairMode: {\n      Normal: 0,\n      Hidden: 1\n    },\n    LineStyle: {\n      Solid: 0,\n      Dotted: 1,\n      Dashed: 2,\n      LargeDashed: 3,\n      SparseDotted: 4\n    },\n    LineType: {\n      Simple: 0,\n      WithSteps: 1,\n      Curved: 2\n    },\n    PriceScaleMode: {\n      Normal: 0,\n      Logarithmic: 1,\n      Percentage: 2,\n      IndexedTo100: 3\n    },\n    TickMarkType: {\n      Year: 0,\n      Month: 1,\n      DayOfMonth: 2,\n      Time: 3,\n      TimeWithSeconds: 4\n    },\n    TrackingModeExitMode: {\n      OnTouchEnd: 0,\n      OnMouseLeave: 1\n    },\n    LastPriceAnimationMode: {\n      Disabled: 0,\n      Continuous: 1,\n      OnDataUpdate: 2\n    },\n    PriceLineSource: {\n      LastBar: 0,\n      LastVisible: 1\n    },\n    MismatchDirection: {\n      NearestLeft: 0,\n      NearestRight: 1\n    },\n    AreaSeries: 'Area',\n    BarSeries: 'Bar',\n    BaselineSeries: 'Baseline',\n    CandlestickSeries: 'Candlestick',\n    HistogramSeries: 'Histogram',\n    LineSeries: 'Line',\n    customSeriesDefaultOptions: {\n      color: '#2196f3'\n    },\n    version: '5.0.8',\n    defaultHorzScaleBehavior: {\n      options: jest.fn().mockReturnValue({}),\n      setOptions: jest.fn()\n    }\n  }\n})"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockChart' is assigned a value but never used.","line":266,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":266,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'testChart' is assigned a value but never used.","line":397,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":397,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import {createSeries} from '../seriesFactory'\n\n// Mock lightweight-charts\njest.mock('lightweight-charts', () => {\n  const mockChart = {\n    addSeries: jest.fn().mockImplementation((seriesType, options, paneId) => {\n      return {\n        setData: jest.fn(),\n        update: jest.fn(),\n        applyOptions: jest.fn(),\n        priceFormatter: jest.fn().mockReturnValue(value => value.toFixed(2)),\n        priceToCoordinate: jest.fn().mockReturnValue(100),\n        coordinateToPrice: jest.fn().mockReturnValue(50),\n        barsInLogicalRange: jest.fn().mockReturnValue({barsBefore: 0, barsAfter: 0}),\n        data: jest.fn().mockReturnValue([]),\n        dataByIndex: jest.fn().mockReturnValue(null),\n        subscribeDataChanged: jest.fn(),\n        unsubscribeDataChanged: jest.fn(),\n        seriesType: jest.fn().mockReturnValue('Line'),\n        attachPrimitive: jest.fn(),\n        detachPrimitive: jest.fn(),\n        getPane: jest.fn().mockReturnValue({\n          getHeight: jest.fn().mockReturnValue(400),\n          setHeight: jest.fn(),\n          getStretchFactor: jest.fn().mockReturnValue(1),\n          setStretchFactor: jest.fn(),\n          paneIndex: jest.fn().mockReturnValue(0),\n          moveTo: jest.fn(),\n          getSeries: jest.fn().mockReturnValue([]),\n          getHTMLElement: jest.fn().mockReturnValue({}),\n          attachPrimitive: jest.fn(),\n          detachPrimitive: jest.fn(),\n          priceScale: jest.fn().mockReturnValue({\n            applyOptions: jest.fn(),\n            options: jest.fn().mockReturnValue({}),\n            width: jest.fn().mockReturnValue(100),\n            setVisibleRange: jest.fn(),\n            getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n            setAutoScale: jest.fn()\n          }),\n          setPreserveEmptyPane: jest.fn(),\n          preserveEmptyPane: jest.fn().mockReturnValue(false),\n          addCustomSeries: jest.fn(),\n          addSeries: jest.fn()\n        }),\n        moveToPane: jest.fn(),\n        seriesOrder: jest.fn().mockReturnValue(0),\n        setSeriesOrder: jest.fn(),\n        createPriceLine: jest.fn().mockReturnValue({\n          applyOptions: jest.fn(),\n          options: jest.fn().mockReturnValue({}),\n          remove: jest.fn()\n        }),\n        removePriceLine: jest.fn(),\n        priceLines: jest.fn().mockReturnValue([])\n      }\n    }),\n    removeSeries: jest.fn(),\n    addCustomSeries: jest.fn().mockReturnValue({\n      setData: jest.fn(),\n      update: jest.fn(),\n      applyOptions: jest.fn(),\n      seriesType: jest.fn().mockReturnValue('Custom')\n    }),\n    remove: jest.fn(),\n    resize: jest.fn(),\n    applyOptions: jest.fn(),\n    options: jest.fn().mockReturnValue({\n      layout: {\n        background: {type: 'solid', color: '#FFFFFF'},\n        textColor: '#191919',\n        fontSize: 12,\n        fontFamily: 'Arial'\n      },\n      crosshair: {\n        mode: 1,\n        vertLine: {visible: true},\n        horzLine: {visible: true}\n      },\n      grid: {\n        vertLines: {visible: true},\n        horzLines: {visible: true}\n      },\n      timeScale: {\n        visible: true,\n        timeVisible: false,\n        secondsVisible: false\n      },\n      rightPriceScale: {\n        visible: true,\n        autoScale: true\n      },\n      leftPriceScale: {\n        visible: false,\n        autoScale: true\n      }\n    }),\n    timeScale: jest.fn().mockReturnValue({\n      scrollPosition: jest.fn().mockReturnValue(0),\n      scrollToPosition: jest.fn(),\n      scrollToRealTime: jest.fn(),\n      getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setVisibleRange: jest.fn(),\n      getVisibleLogicalRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setVisibleLogicalRange: jest.fn(),\n      resetTimeScale: jest.fn(),\n      fitContent: jest.fn(),\n      logicalToCoordinate: jest.fn().mockReturnValue(100),\n      coordinateToLogical: jest.fn().mockReturnValue(0),\n      timeToIndex: jest.fn().mockReturnValue(0),\n      timeToCoordinate: jest.fn().mockReturnValue(100),\n      coordinateToTime: jest.fn().mockReturnValue(0),\n      width: jest.fn().mockReturnValue(800),\n      height: jest.fn().mockReturnValue(400),\n      subscribeVisibleTimeRangeChange: jest.fn(),\n      unsubscribeVisibleTimeRangeChange: jest.fn(),\n      subscribeVisibleLogicalRangeChange: jest.fn(),\n      unsubscribeVisibleLogicalRangeChange: jest.fn(),\n      subscribeSizeChange: jest.fn(),\n      unsubscribeSizeChange: jest.fn(),\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({\n        barSpacing: 6,\n        rightOffset: 0\n      })\n    }),\n    priceScale: jest.fn().mockReturnValue({\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({}),\n      width: jest.fn().mockReturnValue(100),\n      setVisibleRange: jest.fn(),\n      getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setAutoScale: jest.fn()\n    }),\n    subscribeClick: jest.fn(),\n    unsubscribeClick: jest.fn(),\n    subscribeCrosshairMove: jest.fn(),\n    unsubscribeCrosshairMove: jest.fn(),\n    subscribeDblClick: jest.fn(),\n    unsubscribeDblClick: jest.fn(),\n    takeScreenshot: jest.fn().mockReturnValue({}),\n    addPane: jest.fn().mockReturnValue({\n      getHeight: jest.fn().mockReturnValue(400),\n      setHeight: jest.fn(),\n      getStretchFactor: jest.fn().mockReturnValue(1),\n      setStretchFactor: jest.fn(),\n      paneIndex: jest.fn().mockReturnValue(0),\n      moveTo: jest.fn(),\n      getSeries: jest.fn().mockReturnValue([]),\n      getHTMLElement: jest.fn().mockReturnValue({}),\n      attachPrimitive: jest.fn(),\n      detachPrimitive: jest.fn(),\n      priceScale: jest.fn().mockReturnValue({\n        applyOptions: jest.fn(),\n        options: jest.fn().mockReturnValue({}),\n        width: jest.fn().mockReturnValue(100),\n        setVisibleRange: jest.fn(),\n        getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n        setAutoScale: jest.fn()\n      }),\n      setPreserveEmptyPane: jest.fn(),\n      preserveEmptyPane: jest.fn().mockReturnValue(false),\n      addCustomSeries: jest.fn(),\n      addSeries: jest.fn()\n    }),\n    removePane: jest.fn(),\n    swapPanes: jest.fn(),\n    autoSizeActive: jest.fn().mockReturnValue(false),\n    chartElement: jest.fn().mockReturnValue({}),\n    panes: jest.fn().mockReturnValue([]),\n    paneSize: jest.fn().mockReturnValue({width: 800, height: 400}),\n    setCrosshairPosition: jest.fn(),\n    clearCrosshairPosition: jest.fn(),\n    horzBehaviour: jest.fn().mockReturnValue({\n      options: jest.fn().mockReturnValue({}),\n      setOptions: jest.fn()\n    })\n  }\n\n  return {\n    createChart: (container, options) => {\n      return mockChart\n    },\n    createChartEx: jest.fn().mockImplementation((container, horzScaleBehavior, options) => {\n      return mockChart\n    }),\n    createSeries: jest.fn().mockImplementation((chart, seriesType, options) => {\n      return mockChart.addSeries(seriesType, options)\n    }),\n    isBusinessDay: jest.fn().mockImplementation(time => {\n      return typeof time === 'object' && time.year && time.month && time.day\n    }),\n    isUTCTimestamp: jest.fn().mockImplementation(time => {\n      return typeof time === 'number' && time > 0\n    }),\n    ColorType: {\n      Solid: 'solid',\n      VerticalGradient: 'gradient'\n    },\n    CrosshairMode: {\n      Normal: 0,\n      Hidden: 1\n    },\n    LineStyle: {\n      Solid: 0,\n      Dotted: 1,\n      Dashed: 2,\n      LargeDashed: 3,\n      SparseDotted: 4\n    },\n    LineType: {\n      Simple: 0,\n      WithSteps: 1,\n      Curved: 2\n    },\n    PriceScaleMode: {\n      Normal: 0,\n      Logarithmic: 1,\n      Percentage: 2,\n      IndexedTo100: 3\n    },\n    TickMarkType: {\n      Year: 0,\n      Month: 1,\n      DayOfMonth: 2,\n      Time: 3,\n      TimeWithSeconds: 4\n    },\n    TrackingModeExitMode: {\n      OnTouchEnd: 0,\n      OnMouseLeave: 1\n    },\n    LastPriceAnimationMode: {\n      Disabled: 0,\n      Continuous: 1,\n      OnDataUpdate: 2\n    },\n    PriceLineSource: {\n      LastBar: 0,\n      LastVisible: 1\n    },\n    MismatchDirection: {\n      NearestLeft: 0,\n      NearestRight: 1\n    },\n    AreaSeries: 'Area',\n    BarSeries: 'Bar',\n    BaselineSeries: 'Baseline',\n    CandlestickSeries: 'Candlestick',\n    HistogramSeries: 'Histogram',\n    LineSeries: 'Line',\n    customSeriesDefaultOptions: {\n      color: '#2196f3'\n    },\n    version: '5.0.8',\n    defaultHorzScaleBehavior: {\n      options: jest.fn().mockReturnValue({}),\n      setOptions: jest.fn()\n    }\n  }\n})\n\nimport {createChart} from 'lightweight-charts'\n\n// Create a simple mock chart object\nconst mockChart = {\n  addSeries: jest.fn().mockReturnValue({\n    setData: jest.fn(),\n    update: jest.fn(),\n    applyOptions: jest.fn(),\n    options: jest.fn().mockReturnValue({}),\n    priceFormatter: jest.fn().mockReturnValue(value => value.toFixed(2)),\n    priceToCoordinate: jest.fn().mockReturnValue(50),\n    coordinateToPrice: jest.fn().mockReturnValue(100),\n    barsInLogicalRange: jest.fn().mockReturnValue({barsBefore: 0, barsAfter: 0}),\n    dataByIndex: jest.fn().mockReturnValue({time: '2024-01-01', value: 100}),\n    data: jest.fn().mockReturnValue([]),\n    subscribeDataChanged: jest.fn(),\n    unsubscribeDataChanged: jest.fn(),\n    createPriceLine: jest.fn().mockReturnValue({\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({}),\n      remove: jest.fn()\n    }),\n    removePriceLine: jest.fn(),\n    priceLines: jest.fn().mockReturnValue([]),\n    seriesType: jest.fn().mockReturnValue('Line'),\n    attachPrimitive: jest.fn(),\n    detachPrimitive: jest.fn(),\n    getPane: jest.fn().mockReturnValue({\n      getHeight: jest.fn().mockReturnValue(400),\n      setHeight: jest.fn(),\n      getStretchFactor: jest.fn().mockReturnValue(1),\n      setStretchFactor: jest.fn(),\n      paneIndex: jest.fn().mockReturnValue(0),\n      moveTo: jest.fn(),\n      getSeries: jest.fn().mockReturnValue([]),\n      getHTMLElement: jest.fn().mockReturnValue({}),\n      attachPrimitive: jest.fn(),\n      detachPrimitive: jest.fn(),\n      priceScale: jest.fn().mockReturnValue({\n        applyOptions: jest.fn(),\n        options: jest.fn().mockReturnValue({}),\n        width: jest.fn().mockReturnValue(100),\n        setVisibleRange: jest.fn(),\n        getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n        setAutoScale: jest.fn()\n      }),\n      setPreserveEmptyPane: jest.fn(),\n      preserveEmptyPane: jest.fn().mockReturnValue(false),\n      addCustomSeries: jest.fn(),\n      addSeries: jest.fn()\n    }),\n    moveToPane: jest.fn(),\n    seriesOrder: jest.fn().mockReturnValue(0),\n    setSeriesOrder: jest.fn()\n  }),\n  remove: jest.fn(),\n  resize: jest.fn(),\n  applyOptions: jest.fn(),\n  options: jest.fn().mockReturnValue({}),\n  takeScreenshot: jest.fn().mockReturnValue({}),\n  addPane: jest.fn().mockReturnValue({\n    getHeight: jest.fn().mockReturnValue(400),\n    setHeight: jest.fn(),\n    getStretchFactor: jest.fn().mockReturnValue(1),\n    setStretchFactor: jest.fn(),\n    paneIndex: jest.fn().mockReturnValue(0),\n    moveTo: jest.fn(),\n    getSeries: jest.fn().mockReturnValue([]),\n    getHTMLElement: jest.fn().mockReturnValue({}),\n    attachPrimitive: jest.fn(),\n    detachPrimitive: jest.fn(),\n    priceScale: jest.fn().mockReturnValue({\n      applyOptions: jest.fn(),\n      options: jest.fn().mockReturnValue({}),\n      width: jest.fn().mockReturnValue(100),\n      setVisibleRange: jest.fn(),\n      getVisibleRange: jest.fn().mockReturnValue({from: 0, to: 100}),\n      setAutoScale: jest.fn()\n    }),\n    setPreserveEmptyPane: jest.fn(),\n    preserveEmptyPane: jest.fn().mockReturnValue(false),\n    addCustomSeries: jest.fn(),\n    addSeries: jest.fn()\n  }),\n  removePane: jest.fn(),\n  swapPanes: jest.fn(),\n  autoSizeActive: jest.fn().mockReturnValue(false),\n  chartElement: jest.fn().mockReturnValue({}),\n  panes: jest.fn().mockReturnValue([]),\n  paneSize: jest.fn().mockReturnValue({height: 400, width: 800}),\n  setCrosshairPosition: jest.fn(),\n  clearCrosshairPosition: jest.fn(),\n  horzBehaviour: jest.fn().mockReturnValue({})\n}\n\n// Create a real chart instance for testing\nconst createTestChart = () => {\n  const container = document.createElement('div')\n  container.style.width = '800px'\n  container.style.height = '400px'\n  document.body.appendChild(container)\n\n  const chart = createChart(container, {\n    layout: {\n      attributionLogo: false\n    }\n  })\n\n  return {chart, container}\n}\n\ndescribe('Series Factory', () => {\n  let chart: any\n  let container: HTMLElement\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    const testChart = createTestChart()\n    chart = testChart.chart\n    container = testChart.container\n  })\n\n  afterEach(() => {\n    if (chart) {\n      chart.remove()\n    }\n    if (container && container.parentNode) {\n      container.parentNode.removeChild(container)\n    }\n  })\n\n  describe('Line Series', () => {\n    it('should create line series with basic data', () => {\n      // First test if the mock is working\n      const testChart = createChart(document.createElement('div'), {})\n\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110},\n          {time: '2024-01-03', value: 105}\n        ],\n        options: {\n          color: '#ff0000',\n          lineWidth: 2\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create line series with custom options', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          color: '#00ff00',\n          lineWidth: 3,\n          lineStyle: 1, // Dashed\n          crosshairMarkerVisible: true,\n          lastValueVisible: true,\n          priceLineVisible: true\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle empty line series data', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [],\n        options: {}\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Candlestick Series', () => {\n    it('should create candlestick series with OHLC data', () => {\n      const seriesConfig = {\n        type: 'Candlestick' as const,\n        data: [\n          {\n            time: '2024-01-01',\n            open: 100,\n            high: 110,\n            low: 95,\n            close: 105\n          },\n          {\n            time: '2024-01-02',\n            open: 105,\n            high: 115,\n            low: 100,\n            close: 110\n          }\n        ],\n        options: {\n          upColor: '#00ff00',\n          downColor: '#ff0000',\n          borderVisible: true,\n          wickVisible: true\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create candlestick series with custom styling', () => {\n      const seriesConfig = {\n        type: 'Candlestick' as const,\n        data: [\n          {\n            time: '2024-01-01',\n            open: 100,\n            high: 110,\n            low: 95,\n            close: 105\n          }\n        ],\n        options: {\n          upColor: '#00ff00',\n          downColor: '#ff0000',\n          borderUpColor: '#008000',\n          borderDownColor: '#800000',\n          wickUpColor: '#00ff00',\n          wickDownColor: '#ff0000'\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Area Series', () => {\n    it('should create area series with basic data', () => {\n      const seriesConfig = {\n        type: 'Area' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110},\n          {time: '2024-01-03', value: 105}\n        ],\n        options: {\n          topColor: 'rgba(255, 0, 0, 0.5)',\n          bottomColor: 'rgba(255, 0, 0, 0.1)',\n          lineColor: '#ff0000',\n          lineWidth: 2\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create area series with gradient', () => {\n      const seriesConfig = {\n        type: 'Area' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          topColor: 'rgba(0, 255, 0, 0.8)',\n          bottomColor: 'rgba(0, 255, 0, 0.2)',\n          lineColor: '#00ff00',\n          lineWidth: 1,\n          crosshairMarkerVisible: true\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Histogram Series', () => {\n    it('should create histogram series with volume data', () => {\n      const seriesConfig = {\n        type: 'Histogram' as const,\n        data: [\n          {time: '2024-01-01', value: 1000000, color: '#00ff00'},\n          {time: '2024-01-02', value: 1500000, color: '#ff0000'},\n          {time: '2024-01-03', value: 800000, color: '#00ff00'}\n        ],\n        options: {\n          color: '#888888',\n          priceFormat: {\n            type: 'volume'\n          },\n          priceScaleId: 'volume'\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create histogram series with custom colors', () => {\n      const seriesConfig = {\n        type: 'Histogram' as const,\n        data: [\n          {time: '2024-01-01', value: 1000000, color: '#00ff00'},\n          {time: '2024-01-02', value: 1500000, color: '#ff0000'}\n        ],\n        options: {\n          color: '#888888',\n          priceFormat: {\n            type: 'volume'\n          },\n          priceScaleId: 'volume',\n          scaleMargins: {\n            top: 0.8,\n            bottom: 0\n          }\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Baseline Series', () => {\n    it('should create baseline series with reference data', () => {\n      const seriesConfig = {\n        type: 'Baseline' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110},\n          {time: '2024-01-03', value: 105}\n        ],\n        options: {\n          baseValue: {price: 100},\n          topFillColor: 'rgba(0, 255, 0, 0.3)',\n          bottomFillColor: 'rgba(255, 0, 0, 0.3)',\n          topLineColor: '#00ff00',\n          bottomLineColor: '#ff0000',\n          lineWidth: 2\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create baseline series with custom baseline', () => {\n      const seriesConfig = {\n        type: 'Baseline' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          baseValue: {price: 105},\n          topFillColor: 'rgba(0, 255, 0, 0.5)',\n          bottomFillColor: 'rgba(255, 0, 0, 0.5)',\n          topLineColor: '#00ff00',\n          bottomLineColor: '#ff0000',\n          lineWidth: 1\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Band Series', () => {\n    it('should create band series with upper and lower data', () => {\n      const seriesConfig = {\n        type: 'Band' as const,\n        data: [\n          {\n            time: '2024-01-01',\n            upper: 110,\n            lower: 90\n          },\n          {\n            time: '2024-01-02',\n            upper: 115,\n            lower: 95\n          }\n        ],\n        options: {\n          upperColor: 'rgba(0, 255, 0, 0.3)',\n          lowerColor: 'rgba(255, 0, 0, 0.3)',\n          lineColor: '#888888',\n          lineWidth: 1\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should create band series with custom styling', () => {\n      const seriesConfig = {\n        type: 'Band' as const,\n        data: [\n          {\n            time: '2024-01-01',\n            upper: 110,\n            lower: 90\n          }\n        ],\n        options: {\n          upperColor: 'rgba(0, 255, 0, 0.5)',\n          lowerColor: 'rgba(255, 0, 0, 0.5)',\n          lineColor: '#888888',\n          lineWidth: 2,\n          crosshairMarkerVisible: true\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Series Configuration', () => {\n    it('should handle series with price scale configuration', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          color: '#ff0000',\n          priceScaleId: 'right'\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle series with time scale configuration', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          color: '#ff0000',\n          timeScaleId: 'time'\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle series with autoscale info', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01', value: 100},\n          {time: '2024-01-02', value: 110}\n        ],\n        options: {\n          color: '#ff0000',\n          autoscaleInfoProvider: () => ({\n            priceRange: {minValue: 90, maxValue: 120},\n            margins: {above: 0.1, below: 0.1}\n          })\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Data Validation', () => {\n    it('should handle invalid series type', () => {\n      const seriesConfig = {\n        type: 'invalid' as any,\n        data: [{time: '2024-01-01', value: 100}],\n        options: {}\n      }\n\n      expect(() => {\n        createSeries(chart, seriesConfig)\n      }).toThrow()\n    })\n\n    it('should handle null data', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: null,\n        options: {}\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle undefined data', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: undefined,\n        options: {}\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle malformed data', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [\n          {time: '2024-01-01'}, // Missing value\n          {value: 100}, // Missing time\n          {time: '2024-01-03', value: 'invalid'} // Invalid value\n        ],\n        options: {}\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n  })\n\n  describe('Performance', () => {\n    it('should handle large datasets efficiently', () => {\n      const largeData = Array.from({length: 10000}, (_, i) => ({\n        time: `2024-01-${String(i + 1).padStart(2, '0')}`,\n        value: 100 + Math.random() * 20\n      }))\n\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: largeData,\n        options: {\n          color: '#ff0000'\n        }\n      }\n\n      const series = createSeries(chart, seriesConfig)\n      expect(series).toBeDefined()\n    })\n\n    it('should handle multiple series creation', () => {\n      const seriesConfigs = [\n        {\n          type: 'Line' as const,\n          data: [\n            {time: '2024-01-01', value: 100},\n            {time: '2024-01-02', value: 110}\n          ],\n          options: {color: '#ff0000'}\n        },\n        {\n          type: 'Area' as const,\n          data: [\n            {time: '2024-01-01', value: 90},\n            {time: '2024-01-02', value: 100}\n          ],\n          options: {color: '#00ff00'}\n        },\n        {\n          type: 'Histogram' as const,\n          data: [\n            {time: '2024-01-01', value: 1000000},\n            {time: '2024-01-02', value: 1500000}\n          ],\n          options: {color: '#0000ff'}\n        }\n      ]\n\n      seriesConfigs.forEach(config => {\n        const series = createSeries(chart, config)\n        expect(series).toBeDefined()\n      })\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle missing chart', () => {\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [{time: '2024-01-01', value: 100}],\n        options: {}\n      }\n\n      expect(() => {\n        createSeries(null as any, seriesConfig)\n      }).toThrow()\n    })\n\n    it('should handle missing series configuration', () => {\n      expect(() => {\n        createSeries(chart, null as any)\n      }).toThrow()\n    })\n\n    it('should handle missing series type', () => {\n      const seriesConfig = {\n        data: [{time: '2024-01-01', value: 100}],\n        options: {}\n      } as any\n\n      expect(() => {\n        createSeries(chart, seriesConfig)\n      }).toThrow()\n    })\n\n    it('should handle chart without required methods', () => {\n      const invalidChart = {\n        // Missing required methods\n      }\n\n      const seriesConfig = {\n        type: 'Line' as const,\n        data: [{time: '2024-01-01', value: 100}],\n        options: {}\n      }\n\n      expect(() => {\n        createSeries(invalidChart as any, seriesConfig)\n      }).toThrow()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/chartReadyDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/codeSplitting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/coordinateValidation.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'context' is assigned a value but never used.","line":297,"column":63,"nodeType":"Identifier","messageId":"unusedVar","endLine":297,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Validation utilities for coordinate calculations\n * Ensures coordinate data integrity and provides helpful debugging\n */\n\nimport {\n  ChartCoordinates,\n  PaneCoordinates,\n  ValidationResult,\n  BoundingBox,\n  ScaleDimensions\n  // ContainerDimensions is used in type imports\n} from '../types/coordinates'\nimport {DIMENSIONS, FALLBACKS} from '../config/positioningConfig'\n\n/**\n * Validates complete chart coordinates\n */\nexport function validateChartCoordinates(coordinates: ChartCoordinates): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  // Validate container dimensions\n  if (!coordinates.container) {\n    errors.push('Missing container dimensions')\n  } else {\n    if (coordinates.container.width <= 0) {\n      errors.push(`Invalid container width: ${coordinates.container.width}`)\n    }\n    if (coordinates.container.height <= 0) {\n      errors.push(`Invalid container height: ${coordinates.container.height}`)\n    }\n    if (coordinates.container.width < DIMENSIONS.chart.minWidth) {\n      warnings.push(\n        `Container width (${coordinates.container.width}) is below recommended minimum (${DIMENSIONS.chart.minWidth})`\n      )\n    }\n    if (coordinates.container.height < DIMENSIONS.chart.minHeight) {\n      warnings.push(\n        `Container height (${coordinates.container.height}) is below recommended minimum (${DIMENSIONS.chart.minHeight})`\n      )\n    }\n  }\n\n  // Validate time scale\n  if (!coordinates.timeScale) {\n    errors.push('Missing time scale dimensions')\n  } else {\n    const timeScaleErrors = validateScaleDimensions(coordinates.timeScale, 'timeScale')\n    errors.push(...timeScaleErrors.errors)\n    warnings.push(...timeScaleErrors.warnings)\n\n    if (coordinates.timeScale.height < DIMENSIONS.timeAxis.minHeight) {\n      warnings.push(\n        `Time scale height (${coordinates.timeScale.height}) is below minimum (${DIMENSIONS.timeAxis.minHeight})`\n      )\n    }\n    if (coordinates.timeScale.height > DIMENSIONS.timeAxis.maxHeight) {\n      warnings.push(\n        `Time scale height (${coordinates.timeScale.height}) exceeds maximum (${DIMENSIONS.timeAxis.maxHeight})`\n      )\n    }\n  }\n\n  // Validate price scales\n  if (!coordinates.priceScaleLeft) {\n    warnings.push('Missing left price scale dimensions')\n  } else {\n    const priceScaleErrors = validateScaleDimensions(coordinates.priceScaleLeft, 'priceScaleLeft')\n    errors.push(...priceScaleErrors.errors)\n    warnings.push(...priceScaleErrors.warnings)\n  }\n\n  if (coordinates.priceScaleRight) {\n    const priceScaleErrors = validateScaleDimensions(coordinates.priceScaleRight, 'priceScaleRight')\n    errors.push(...priceScaleErrors.errors)\n    warnings.push(...priceScaleErrors.warnings)\n  }\n\n  // Validate panes\n  if (!coordinates.panes || coordinates.panes.length === 0) {\n    errors.push('No panes defined')\n  } else {\n    coordinates.panes.forEach((pane, index) => {\n      const paneErrors = validatePaneCoordinates(pane)\n      errors.push(...paneErrors.errors.map(e => `Pane ${index}: ${e}`))\n      warnings.push(...paneErrors.warnings.map(w => `Pane ${index}: ${w}`))\n    })\n  }\n\n  // Validate content area\n  if (!coordinates.contentArea) {\n    errors.push('Missing content area dimensions')\n  } else {\n    const contentErrors = validateBoundingBox(coordinates.contentArea, 'contentArea')\n    errors.push(...contentErrors.errors)\n    warnings.push(...contentErrors.warnings)\n  }\n\n  // Check timestamp\n  if (!coordinates.timestamp || coordinates.timestamp <= 0) {\n    warnings.push('Invalid or missing timestamp')\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  }\n}\n\n/**\n * Validates scale dimensions\n */\nexport function validateScaleDimensions(scale: ScaleDimensions, name: string): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  if (scale.width < 0 || scale.height < 0) {\n    errors.push(`${name} has negative dimensions`)\n  }\n\n  if (scale.x < 0 || scale.y < 0) {\n    warnings.push(`${name} has negative position`)\n  }\n\n  return {isValid: errors.length === 0, errors, warnings}\n}\n\n/**\n * Validates pane coordinates\n */\nexport function validatePaneCoordinates(pane: PaneCoordinates): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  if (pane.id < 0) {\n    errors.push('Invalid pane ID')\n  }\n\n  if (!pane.bounds) {\n    errors.push('Missing pane bounds')\n  } else {\n    const boundsErrors = validateBoundingBox(pane.bounds, 'bounds')\n    errors.push(...boundsErrors.errors)\n    warnings.push(...boundsErrors.warnings)\n  }\n\n  if (!pane.contentArea) {\n    errors.push('Missing pane content area')\n  } else {\n    const contentErrors = validateBoundingBox(pane.contentArea, 'contentArea')\n    errors.push(...contentErrors.errors)\n    warnings.push(...contentErrors.warnings)\n  }\n\n  if (pane.bounds && pane.contentArea) {\n    if (pane.contentArea.width > pane.bounds.width) {\n      errors.push('Content area width exceeds pane bounds')\n    }\n    if (pane.contentArea.height > pane.bounds.height) {\n      errors.push('Content area height exceeds pane bounds')\n    }\n  }\n\n  return {isValid: errors.length === 0, errors, warnings}\n}\n\n/**\n * Validates a bounding box\n */\nexport function validateBoundingBox(box: Partial<BoundingBox>, name: string): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  if (box.width !== undefined && box.width <= 0) {\n    errors.push(`${name} has invalid width: ${box.width}`)\n  }\n\n  if (box.height !== undefined && box.height <= 0) {\n    errors.push(`${name} has invalid height: ${box.height}`)\n  }\n\n  if (box.x !== undefined && box.x < 0) {\n    warnings.push(`${name} has negative x position: ${box.x}`)\n  }\n\n  if (box.y !== undefined && box.y < 0) {\n    warnings.push(`${name} has negative y position: ${box.y}`)\n  }\n\n  // Check consistency between position and bounds\n  if (box.x !== undefined && box.width !== undefined) {\n    if (box.right !== undefined && Math.abs(box.x + box.width - box.right) > 1) {\n      warnings.push(`${name} has inconsistent right bound`)\n    }\n  }\n\n  if (box.y !== undefined && box.height !== undefined) {\n    if (box.bottom !== undefined && Math.abs(box.y + box.height - box.bottom) > 1) {\n      warnings.push(`${name} has inconsistent bottom bound`)\n    }\n  }\n\n  return {isValid: errors.length === 0, errors, warnings}\n}\n\n/**\n * Sanitizes coordinates by applying fallbacks for invalid values\n */\nexport function sanitizeCoordinates(coordinates: Partial<ChartCoordinates>): ChartCoordinates {\n  const now = Date.now()\n\n  return {\n    container: coordinates.container || {\n      width: FALLBACKS.containerWidth,\n      height: FALLBACKS.containerHeight,\n      offsetTop: 0,\n      offsetLeft: 0\n    },\n    timeScale: coordinates.timeScale || {\n      x: 0,\n      y: FALLBACKS.containerHeight - FALLBACKS.timeScaleHeight,\n      width: FALLBACKS.containerWidth,\n      height: FALLBACKS.timeScaleHeight\n    },\n    priceScaleLeft: coordinates.priceScaleLeft || {\n      x: 0,\n      y: 0,\n      width: FALLBACKS.priceScaleWidth,\n      height: FALLBACKS.containerHeight - FALLBACKS.timeScaleHeight\n    },\n    priceScaleRight: coordinates.priceScaleRight || {\n      x: FALLBACKS.containerWidth - DIMENSIONS.priceScale.rightScaleDefaultWidth,\n      y: 0,\n      width: DIMENSIONS.priceScale.rightScaleDefaultWidth,\n      height: FALLBACKS.containerHeight - FALLBACKS.timeScaleHeight\n    },\n    panes: coordinates.panes || [\n      {\n        id: 0,\n        index: 0,\n        isMainPane: true,\n        bounds: createBoundingBox(0, 0, FALLBACKS.paneWidth, FALLBACKS.paneHeight),\n        contentArea: createBoundingBox(\n          FALLBACKS.priceScaleWidth,\n          0,\n          FALLBACKS.paneWidth - FALLBACKS.priceScaleWidth,\n          FALLBACKS.paneHeight - FALLBACKS.timeScaleHeight\n        ),\n        margins: {top: 10, right: 10, bottom: 10, left: 10}\n      }\n    ],\n    contentArea: coordinates.contentArea || {\n      x: FALLBACKS.priceScaleWidth,\n      y: 0,\n      width: FALLBACKS.containerWidth - FALLBACKS.priceScaleWidth,\n      height: FALLBACKS.containerHeight - FALLBACKS.timeScaleHeight\n    },\n    timestamp: coordinates.timestamp || now,\n    isValid: false // Mark as invalid since we had to apply fallbacks\n  }\n}\n\n/**\n * Creates a properly formed bounding box\n */\nexport function createBoundingBox(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): BoundingBox {\n  return {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height\n  }\n}\n\n/**\n * Checks if coordinates are stale based on timestamp\n */\nexport function areCoordinatesStale(coordinates: ChartCoordinates, maxAge: number = 5000): boolean {\n  const now = Date.now()\n  return now - coordinates.timestamp > maxAge\n}\n\n/**\n * Debug helper to log coordinate validation results\n */\nexport function logValidationResult(result: ValidationResult, context: string = ''): void {\n  if (process.env.NODE_ENV !== 'development') return\n\n  // const prefix = context ? `[${context}] ` : ''\n\n  if (!result.isValid) {\n\n\n  }\n\n  if (result.warnings.length > 0) {\n\n\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/lazyLoading.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":17,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":17,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[505,554],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":30,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lazy loading utilities for better performance and code splitting\n * Reduces initial bundle size by loading components and services on demand\n */\n\nimport { ComponentType, lazy, LazyExoticComponent } from 'react'\n\n/**\n * Lazy load a React component with error boundary\n */\nexport function lazyComponent<T extends ComponentType<any>>(\n  importFunc: () => Promise<{ default: T }>,\n  fallback?: React.ComponentType\n): LazyExoticComponent<T> {\n  return lazy(() =>\n    importFunc().catch(error => {\n      console.error('Failed to load component:', error)\n      // Return a fallback component on error\n      return {\n        default: fallback || (() => null) as T\n      }\n    })\n  )\n}\n\n/**\n * Lazy load a service class with singleton pattern\n */\nexport function lazyService<T>(\n  importFunc: () => Promise<{ default: new (...args: any[]) => T }>,\n  ...args: any[]\n): Promise<T> {\n  return importFunc().then(module => {\n    const ServiceClass = module.default\n    return new ServiceClass(...args)\n  })\n}\n\n/**\n * Lazy load a singleton service\n */\nexport function lazySingleton<T>(\n  importFunc: () => Promise<{ [key: string]: { getInstance(): T } }>,\n  serviceName: string\n): Promise<T> {\n  return importFunc().then(module => {\n    const ServiceClass = module[serviceName]\n    if (!ServiceClass || typeof ServiceClass.getInstance !== 'function') {\n      throw new Error(`Service ${serviceName} does not have getInstance method`)\n    }\n    return ServiceClass.getInstance()\n  })\n}\n\n/**\n * Lazy load utility functions\n */\nexport function lazyUtil<T>(\n  importFunc: () => Promise<T>\n): Promise<T> {\n  return importFunc()\n}\n\n/**\n * Preload resources for better UX\n */\nexport class ResourcePreloader {\n  private static preloadedModules = new Map<string, Promise<any>>()\n\n  /**\n   * Preload a module without executing it\n   */\n  static preload<T>(\n    key: string,\n    importFunc: () => Promise<T>\n  ): void {\n    if (!this.preloadedModules.has(key)) {\n      this.preloadedModules.set(key, importFunc())\n    }\n  }\n\n  /**\n   * Get preloaded module or load it\n   */\n  static async get<T>(\n    key: string,\n    importFunc: () => Promise<T>\n  ): Promise<T> {\n    if (this.preloadedModules.has(key)) {\n      return this.preloadedModules.get(key)\n    }\n\n    const modulePromise = importFunc()\n    this.preloadedModules.set(key, modulePromise)\n    return modulePromise\n  }\n\n  /**\n   * Clear preloaded modules to free memory\n   */\n  static clear(): void {\n    this.preloadedModules.clear()\n  }\n\n  /**\n   * Get preload status\n   */\n  static getStatus(): {\n    preloadedCount: number\n    keys: string[]\n  } {\n    return {\n      preloadedCount: this.preloadedModules.size,\n      keys: Array.from(this.preloadedModules.keys())\n    }\n  }\n}\n\n/**\n * Lazy load chart services with preloading\n */\nexport const ChartServices = {\n  dimensions: () => lazySingleton(\n    () => import('../services/ChartDimensionsService'),\n    'ChartDimensionsService'\n  ),\n\n  coordinates: () => lazySingleton(\n    () => import('../services/PaneCoordinatesService'),\n    'PaneCoordinatesService'\n  ),\n\n  cache: () => lazySingleton(\n    () => import('../services/CoordinateCacheManager'),\n    'CoordinateCacheManager'\n  ),\n\n  primitiveManager: () => lazySingleton(\n    () => import('../services/ChartPrimitiveManager'),\n    'ChartPrimitiveManager'\n  )\n}\n\n/**\n * Lazy load chart components\n */\nexport const ChartComponents = {\n  SeriesConfigDialog: lazyComponent(\n    () => import('../components/SeriesConfigDialog'),\n    () => null\n  ),\n\n  ButtonPanelComponent: lazyComponent(\n    () => import('../components/ButtonPanelComponent'),\n    () => null\n  )\n}\n\n/**\n * Lazy load chart plugins\n */\nexport const ChartPlugins = {\n  tooltipPlugin: () => lazyUtil(\n    () => import('../plugins/chart/tooltipPlugin')\n  ),\n\n  rectanglePlugin: () => lazyUtil(\n    () => import('../plugins/overlay/rectanglePlugin')\n  ),\n\n  signalSeriesPlugin: () => lazyUtil(\n    () => import('../plugins/series/signalSeriesPlugin')\n  ),\n\n  trendFillSeriesPlugin: () => lazyUtil(\n    () => import('../plugins/series/trendFillSeriesPlugin')\n  )\n}\n\n/**\n * Bundle optimization utilities\n */\nexport const BundleOptimization = {\n  /**\n   * Dynamically import large libraries only when needed\n   */\n  loadLightweightCharts: () => lazyUtil(\n    () => import('lightweight-charts')\n  ),\n\n  /**\n   * Load testing utilities only in development\n   */\n  loadTestingUtils: () => {\n    if (process.env.NODE_ENV === 'development') {\n      return lazyUtil(\n        () => import('@testing-library/react')\n      )\n    }\n    return Promise.resolve(null)\n  },\n\n  /**\n   * Load performance monitoring only in production\n   */\n  loadPerformanceMonitoring: () => {\n    if (process.env.NODE_ENV === 'production') {\n      return lazyUtil(\n        () => import('../utils/performance')\n      )\n    }\n    return Promise.resolve(null)\n  }\n}\n\n/**\n * Preload critical services on app initialization\n */\nexport function preloadCriticalServices(): void {\n  // Preload the most commonly used services\n  ResourcePreloader.preload('dimensions', () =>\n    import('../services/ChartDimensionsService')\n  )\n\n  ResourcePreloader.preload('cache', () =>\n    import('../services/CoordinateCacheManager')\n  )\n}\n\n/**\n * Preload services when user interaction is detected\n */\nexport function preloadOnInteraction(): void {\n  const preloadAll = () => {\n    ResourcePreloader.preload('coordinates', () =>\n      import('../services/PaneCoordinatesService')\n    )\n\n    ResourcePreloader.preload('primitiveManager', () =>\n      import('../services/ChartPrimitiveManager')\n    )\n\n    ResourcePreloader.preload('tooltipPlugin', () =>\n      import('../plugins/chart/tooltipPlugin')\n    )\n  }\n\n  // Preload on first user interaction\n  const events = ['mousedown', 'touchstart', 'keydown']\n  const handler = () => {\n    preloadAll()\n    events.forEach(event => {\n      document.removeEventListener(event, handler, { capture: true })\n    })\n  }\n\n  events.forEach(event => {\n    document.addEventListener(event, handler, { capture: true, once: true })\n  })\n}\n\n/**\n * Performance monitoring for lazy loading\n */\nexport const LazyLoadingMetrics = {\n  loadTimes: new Map<string, number>(),\n\n  startMeasure(key: string): void {\n    this.loadTimes.set(`${key}_start`, performance.now())\n  },\n\n  endMeasure(key: string): number {\n    const startTime = this.loadTimes.get(`${key}_start`)\n    if (startTime) {\n      const duration = performance.now() - startTime\n      this.loadTimes.set(`${key}_duration`, duration)\n      return duration\n    }\n    return 0\n  },\n\n  getMetrics(): Record<string, number> {\n    const metrics: Record<string, number> = {}\n    for (const [key, value] of this.loadTimes.entries()) {\n      if (key.endsWith('_duration')) {\n        metrics[key.replace('_duration', '')] = value\n      }\n    }\n    return metrics\n  }\n}","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/lineStyle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/logger.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'DEBUG' is defined but never used.","line":7,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":8},{"ruleId":"no-unused-vars","severity":1,"message":"'INFO' is defined but never used.","line":8,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":7},{"ruleId":"no-unused-vars","severity":1,"message":"'WARN' is defined but never used.","line":9,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":7},{"ruleId":"no-unused-vars","severity":1,"message":"'ERROR' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":8},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[1298,1336],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[1386,1423],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":62,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":62,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[1473,1510],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[1561,1599],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized logging utility for the frontend application\n * Replaces direct console statements with structured logging\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  context?: string;\n  data?: any;\n  timestamp: Date;\n}\n\nclass Logger {\n  private isDevelopment: boolean;\n  private logLevel: LogLevel;\n\n  constructor() {\n    this.isDevelopment = process.env.NODE_ENV === 'development';\n    this.logLevel = this.isDevelopment ? LogLevel.DEBUG : LogLevel.WARN;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return level >= this.logLevel;\n  }\n\n  private formatMessage(entry: LogEntry): string {\n    const timestamp = entry.timestamp.toISOString();\n    const levelName = LogLevel[entry.level];\n    const context = entry.context ? `[${entry.context}] ` : '';\n    return `${timestamp} ${levelName} ${context}${entry.message}`;\n  }\n\n  private log(level: LogLevel, message: string, context?: string, data?: any): void {\n    if (!this.shouldLog(level)) return;\n\n    const entry: LogEntry = {\n      level,\n      message,\n      context,\n      data,\n      timestamp: new Date(),\n    };\n\n    const formattedMessage = this.formatMessage(entry);\n\n    switch (level) {\n      case LogLevel.DEBUG:\n        console.debug(formattedMessage, data);\n        break;\n      case LogLevel.INFO:\n        console.info(formattedMessage, data);\n        break;\n      case LogLevel.WARN:\n        console.warn(formattedMessage, data);\n        break;\n      case LogLevel.ERROR:\n        console.error(formattedMessage, data);\n        break;\n    }\n  }\n\n  debug(message: string, context?: string, data?: any): void {\n    this.log(LogLevel.DEBUG, message, context, data);\n  }\n\n  info(message: string, context?: string, data?: any): void {\n    this.log(LogLevel.INFO, message, context, data);\n  }\n\n  warn(message: string, context?: string, data?: any): void {\n    this.log(LogLevel.WARN, message, context, data);\n  }\n\n  error(message: string, context?: string, data?: any): void {\n    this.log(LogLevel.ERROR, message, context, data);\n  }\n\n  // Specialized methods for common contexts\n  chartError(message: string, error?: Error): void {\n    this.error(message, 'Chart', error);\n  }\n\n  primitiveError(message: string, primitiveId: string, error?: Error): void {\n    this.error(message, `Primitive:${primitiveId}`, error);\n  }\n\n  performanceWarn(message: string, data?: any): void {\n    this.warn(message, 'Performance', data);\n  }\n\n  renderDebug(message: string, componentName: string, data?: any): void {\n    this.debug(message, `Render:${componentName}`, data);\n  }\n}\n\n// Export singleton instance\nexport const logger = new Logger();\n\n// Export convenience methods for common patterns\nexport const chartLog = {\n  debug: (message: string, data?: any) => logger.debug(message, 'Chart', data),\n  info: (message: string, data?: any) => logger.info(message, 'Chart', data),\n  warn: (message: string, data?: any) => logger.warn(message, 'Chart', data),\n  error: (message: string, error?: Error) => logger.chartError(message, error),\n};\n\nexport const primitiveLog = {\n  debug: (message: string, primitiveId: string, data?: any) =>\n    logger.debug(message, `Primitive:${primitiveId}`, data),\n  error: (message: string, primitiveId: string, error?: Error) =>\n    logger.primitiveError(message, primitiveId, error),\n};\n\nexport const perfLog = {\n  warn: (message: string, data?: any) => logger.performanceWarn(message, data),\n  debug: (message: string, data?: any) => logger.debug(message, 'Performance', data),\n};\n\nexport default logger;","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/performance.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":9,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":16},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":14,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":18},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":91,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":110,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":110,"endColumn":44},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":114,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":114,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":133,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":44},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":136,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":149,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":149,"endColumn":43},{"ruleId":"no-unused-vars","severity":1,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":151,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":151,"endColumn":22},{"ruleId":"no-unused-vars","severity":1,"message":"'entries' is defined but never used. Allowed unused args must match /^_/u.","line":303,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance optimization utilities for the chart component\n */\n\n// Production logging control\nconst isDevelopment = process.env.NODE_ENV === 'development'\n\nexport const perfLog = {\n  log: (...args: any[]) => {\n    if (isDevelopment) {\n      // Performance logging disabled in production\n    }\n  },\n  warn: (...args: any[]) => {\n    if (isDevelopment) {\n\n    }\n  },\n  error: (...args: any[]) => {\n    // Always log errors, even in production\n\n  }\n}\n\n// Performance logging function for timing operations\nexport function perfLogFn(operationName: string, fn: () => any): any {\n  try {\n    const result = fn()\n    // Performance measurement completed (logging removed for production)\n    return result\n  } catch (error) {\n    if ((isDevelopment || process.env.NODE_ENV === 'test') && performance?.now) {\n      // Performance measurement failed\n    }\n    throw error\n  }\n}\n\n// Optimized deep comparison without JSON.stringify\nexport function deepCompare(objA: any, objB: any): boolean {\n  if (objA === objB) return true\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) return false\n\n  for (const key of keysA) {\n    if (!objB.hasOwnProperty(key)) return false\n\n    const valA = objA[key]\n    const valB = objB[key]\n\n    if (typeof valA === 'object' && typeof valB === 'object') {\n      if (!deepCompare(valA, valB)) return false\n    } else if (valA !== valB) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Optimized DOM query with caching\nconst domQueryCache = new Map<string, HTMLElement | null>()\n\nexport function getCachedDOMElement(selector: string): HTMLElement | null {\n  if (domQueryCache.has(selector)) {\n    return domQueryCache.get(selector) || null\n  }\n\n  const element = document.querySelector(selector) as HTMLElement | null\n  domQueryCache.set(selector, element)\n\n  // Clear cache after a delay to allow for DOM changes\n  setTimeout(() => {\n    domQueryCache.delete(selector)\n  }, 5000)\n\n  return element\n}\n\n// Alternative implementation for testing\nexport function getCachedDOMElementForTesting(\n  id: string,\n  cache: Map<string, HTMLElement>,\n  createFn: (id: string) => HTMLElement | null\n): HTMLElement | null {\n  if (cache.has(id)) {\n    return cache.get(id) || null\n  }\n\n  if (!createFn || typeof createFn !== 'function') {\n    return null\n  }\n\n  const element = createFn(id)\n  if (element) {\n    cache.set(id, element)\n  }\n\n  return element\n}\n\n// Debounce function with improved performance\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n  immediate = false\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null\n      if (!immediate) func(...args)\n    }\n\n    const callNow = immediate && !timeout\n\n    if (timeout) clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n\n    if (callNow) func(...args)\n  }\n}\n\n// Throttle function for performance-critical operations\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean\n\n  return function executedFunction(...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args)\n      inThrottle = true\n      setTimeout(() => (inThrottle = false), limit)\n    }\n  }\n}\n\n// Memoization utility for expensive calculations\nexport function memoize<T extends (...args: any[]) => any>(\n  func: T,\n  resolver?: (...args: Parameters<T>) => string\n): T {\n  const cache = new Map<string, ReturnType<T>>()\n\n  return ((...args: Parameters<T>) => {\n    const key = resolver ? resolver(...args) : JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key)\n    }\n\n    const result = func(...args)\n    cache.set(key, result)\n    return result\n  }) as T\n}\n\n// Batch DOM updates for better performance\nexport function batchDOMUpdates(updates: (() => void)[]): void {\n  if (typeof window !== 'undefined') {\n    requestAnimationFrame(() => {\n      updates.forEach(update => update())\n    })\n  } else {\n    updates.forEach(update => update())\n  }\n}\n\n// Efficient dimension calculation with caching\nexport const getCachedDimensions = memoize(\n  (element: HTMLElement) => {\n    const rect = element.getBoundingClientRect()\n    return {\n      width: rect.width,\n      height: rect.height,\n      top: rect.top,\n      left: rect.left\n    }\n  },\n  (element: HTMLElement) => `${element.offsetWidth}-${element.offsetHeight}`\n)\n\n// Performance monitoring utility\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor\n  private metrics: Map<string, number[]> = new Map()\n\n  static getInstance(): PerformanceMonitor {\n    if (!PerformanceMonitor.instance) {\n      PerformanceMonitor.instance = new PerformanceMonitor()\n    }\n    return PerformanceMonitor.instance\n  }\n\n  startTimer(name: string): () => void {\n    const start = performance.now()\n    return () => {\n      const duration = performance.now() - start\n      if (!this.metrics.has(name)) {\n        this.metrics.set(name, [])\n      }\n      this.metrics.get(name)!.push(duration)\n\n      // Log slow operations in development\n      if (isDevelopment && duration > 16) {\n        perfLog.warn(`Slow operation detected: ${name} took ${duration.toFixed(2)}ms`)\n      }\n    }\n  }\n\n  getMetrics(\n    name?: string\n  ): Record<string, {avg: number; min: number; max: number; count: number}> {\n    const result: Record<string, {avg: number; min: number; max: number; count: number}> = {}\n\n    if (name) {\n      const values = this.metrics.get(name)\n      if (values && values.length > 0) {\n        result[name] = {\n          avg: values.reduce((a, b) => a + b, 0) / values.length,\n          min: Math.min(...values),\n          max: Math.max(...values),\n          count: values.length\n        }\n      }\n    } else {\n      this.metrics.forEach((values, key) => {\n        if (values.length > 0) {\n          result[key] = {\n            avg: values.reduce((a, b) => a + b, 0) / values.length,\n            min: Math.min(...values),\n            max: Math.max(...values),\n            count: values.length\n          }\n        }\n      })\n    }\n\n    return result\n  }\n\n  clearMetrics(): void {\n    this.metrics.clear()\n  }\n}\n\n// Efficient object comparison for React dependencies\nexport function shallowEqual(objA: any, objB: any): boolean {\n  if (objA === objB) return true\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) return false\n\n  for (const key of keysA) {\n    if (!objB.hasOwnProperty(key) || objA[key] !== objB[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Deep comparison for complex objects (use sparingly)\nexport function deepEqual(objA: any, objB: any): boolean {\n  return deepCompare(objA, objB)\n}\n\n// Efficient array operations\nexport function arrayEquals<T>(a: T[], b: T[]): boolean {\n  if (a.length !== b.length) return false\n  return a.every((val, index) => val === b[index])\n}\n\n// Memory-efficient object cloning\nexport function shallowClone<T>(obj: T): T {\n  if (Array.isArray(obj)) {\n    return [...obj] as T\n  }\n  if (obj && typeof obj === 'object') {\n    return {...obj}\n  }\n  return obj\n}\n\n// Intersection Observer for lazy loading\nexport function createIntersectionObserver(\n  callback: (entries: IntersectionObserverEntry[]) => void,\n  options: IntersectionObserverInit = {}\n): IntersectionObserver {\n  return new IntersectionObserver(callback, {\n    rootMargin: '50px',\n    threshold: 0.1,\n    ...options\n  })\n}\n\n// Efficient event listener management\nexport class EventManager {\n  private listeners: Map<string, Set<EventListener>> = new Map()\n\n  addEventListener(element: EventTarget, event: string, listener: EventListener): void {\n    const key = `${element}-${event}`\n    if (!this.listeners.has(key)) {\n      this.listeners.set(key, new Set())\n    }\n    this.listeners.get(key)!.add(listener)\n    element.addEventListener(event, listener)\n  }\n\n  removeEventListener(element: EventTarget, event: string, listener: EventListener): void {\n    const key = `${element}-${event}`\n    const listeners = this.listeners.get(key)\n    if (listeners) {\n      listeners.delete(listener)\n      element.removeEventListener(event, listener)\n      if (listeners.size === 0) {\n        this.listeners.delete(key)\n      }\n    }\n  }\n\n  removeAllListeners(): void {\n    this.listeners.forEach(listeners => {\n      listeners.forEach(() => {\n        // Note: This is a simplified version - in practice you'd need to store the actual element reference\n        perfLog.warn('EventManager: removeAllListeners called but element reference not available')\n      })\n    })\n    this.listeners.clear()\n  }\n}\n\n// Global event manager instance\nexport const globalEventManager = new EventManager()\n\n// Simple style creation for testing\nexport function createOptimizedStyles(styles: any): any {\n  if (styles === null || styles === undefined) {\n    return {}\n  }\n  return styles\n}\n\n// Style optimization utilities\nexport const createOptimizedStylesAdvanced = memoize(\n  (\n    width: number | null,\n    height: number | null,\n    shouldAutoSize: boolean,\n    chartOptions: any = {}\n  ) => {\n    return {\n      container: {\n        position: 'relative' as const,\n        border: 'none',\n        borderRadius: '0px',\n        padding: '0px',\n        width:\n          shouldAutoSize || width === null\n            ? '100%'\n            : typeof width === 'number'\n              ? `${width}px`\n              : width || '100%',\n        height: shouldAutoSize\n          ? '100%'\n          : typeof height === 'number'\n            ? `${height}px`\n            : height || '100%',\n        minWidth: chartOptions.minWidth || (shouldAutoSize ? 200 : undefined),\n        minHeight: chartOptions.minHeight || (shouldAutoSize ? 200 : undefined),\n        maxWidth: chartOptions.maxWidth,\n        maxHeight: chartOptions.maxHeight\n      },\n      chartContainer: {\n        width:\n          shouldAutoSize || width === null\n            ? '100%'\n            : typeof width === 'number'\n              ? `${width}px`\n              : width || '100%',\n        height: shouldAutoSize\n          ? '100%'\n          : typeof height === 'number'\n            ? `${height}px`\n            : height || '100%',\n        position: 'relative' as const\n      }\n    }\n  },\n  (width, height, shouldAutoSize, chartOptions) =>\n    `${width}-${height}-${shouldAutoSize}-${JSON.stringify(chartOptions)}`\n)\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/performanceMonitoring.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has missing dependencies: 'componentName' and 'monitor'. Either include them or remove the dependency array.","line":371,"column":6,"nodeType":"ArrayExpression","endLine":371,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [componentName, monitor]","fix":{"range":[9382,9384],"text":"[componentName, monitor]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance monitoring utilities for production optimization\n * Tracks bundle size, loading times, and runtime performance\n */\n\ninterface PerformanceMetric {\n  name: string\n  value: number\n  timestamp: number\n  category: 'bundle' | 'runtime' | 'loading' | 'memory'\n}\n\ninterface BundleMetrics {\n  initialBundleSize: number\n  chunkSizes: Record<string, number>\n  loadTime: number\n  cacheHitRate: number\n}\n\ninterface RuntimeMetrics {\n  componentRenderTime: Record<string, number>\n  chartInitTime: number\n  seriesCreationTime: number\n  memoryUsage: number\n}\n\n/**\n * Performance monitoring manager\n */\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor\n  private metrics: PerformanceMetric[] = []\n  private observers: PerformanceObserver[] = []\n  private enabled: boolean = false\n\n  static getInstance(): PerformanceMonitor {\n    if (!this.instance) {\n      this.instance = new PerformanceMonitor()\n    }\n    return this.instance\n  }\n\n  /**\n   * Enable performance monitoring\n   */\n  enable(): void {\n    if (this.enabled) return\n\n    this.enabled = true\n    this.setupObservers()\n    this.startMonitoring()\n  }\n\n  /**\n   * Disable performance monitoring\n   */\n  disable(): void {\n    this.enabled = false\n    this.observers.forEach(observer => observer.disconnect())\n    this.observers = []\n  }\n\n  /**\n   * Record a performance metric\n   */\n  recordMetric(\n    name: string,\n    value: number,\n    category: PerformanceMetric['category'] = 'runtime'\n  ): void {\n    if (!this.enabled) return\n\n    this.metrics.push({\n      name,\n      value,\n      timestamp: performance.now(),\n      category\n    })\n\n    // Keep only last 1000 metrics to prevent memory issues\n    if (this.metrics.length > 1000) {\n      this.metrics = this.metrics.slice(-1000)\n    }\n  }\n\n  /**\n   * Start timing a process\n   */\n  startTiming(name: string): () => void {\n    if (!this.enabled) return () => {}\n\n    const startTime = performance.now()\n    return () => {\n      const duration = performance.now() - startTime\n      this.recordMetric(name, duration, 'runtime')\n    }\n  }\n\n  /**\n   * Measure component render time\n   */\n  measureComponentRender<T>(\n    componentName: string,\n    renderFunction: () => T\n  ): T {\n    if (!this.enabled) return renderFunction()\n\n    const endTiming = this.startTiming(`${componentName}.render`)\n    const result = renderFunction()\n    endTiming()\n    return result\n  }\n\n  /**\n   * Get bundle size metrics\n   */\n  getBundleMetrics(): BundleMetrics {\n    const metrics: BundleMetrics = {\n      initialBundleSize: 0,\n      chunkSizes: {},\n      loadTime: 0,\n      cacheHitRate: 0\n    }\n\n    try {\n      // Get initial bundle size from performance entries\n      const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n      if (navigationEntry) {\n        metrics.loadTime = navigationEntry.loadEventEnd - navigationEntry.fetchStart\n      }\n\n      // Get resource sizes\n      const resourceEntries = performance.getEntriesByType('resource') as PerformanceResourceTiming[]\n      let totalSize = 0\n      let cacheHits = 0\n\n      resourceEntries.forEach(entry => {\n        if (entry.name.includes('.js') || entry.name.includes('.css')) {\n          const size = entry.transferSize || 0\n          totalSize += size\n\n          // Determine if it was cached\n          if (entry.transferSize === 0 && entry.decodedBodySize > 0) {\n            cacheHits++\n          }\n\n          // Extract chunk name from URL\n          const chunkMatch = entry.name.match(/(\\w+)\\.[a-f0-9]+\\.(js|css)$/)\n          if (chunkMatch) {\n            metrics.chunkSizes[chunkMatch[1]] = size\n          }\n        }\n      })\n\n      metrics.initialBundleSize = totalSize\n      metrics.cacheHitRate = resourceEntries.length > 0 ? cacheHits / resourceEntries.length : 0\n    } catch (error) {\n      // Ignore errors in metrics collection\n    }\n\n    return metrics\n  }\n\n  /**\n   * Get runtime performance metrics\n   */\n  getRuntimeMetrics(): RuntimeMetrics {\n    const componentRenderTimes: Record<string, number> = {}\n    let chartInitTime = 0\n    let seriesCreationTime = 0\n    let memoryUsage = 0\n\n    // Aggregate component render times\n    this.metrics\n      .filter(m => m.category === 'runtime' && m.name.includes('.render'))\n      .forEach(metric => {\n        const componentName = metric.name.replace('.render', '')\n        if (!componentRenderTimes[componentName]) {\n          componentRenderTimes[componentName] = 0\n        }\n        componentRenderTimes[componentName] += metric.value\n      })\n\n    // Get specific timing metrics\n    const chartInitMetric = this.metrics\n      .filter(m => m.name === 'chartInit')\n      .slice(-1)[0]\n    if (chartInitMetric) {\n      chartInitTime = chartInitMetric.value\n    }\n\n    const seriesMetric = this.metrics\n      .filter(m => m.name === 'seriesCreation')\n      .slice(-1)[0]\n    if (seriesMetric) {\n      seriesCreationTime = seriesMetric.value\n    }\n\n    // Get memory usage\n    try {\n      const memInfo = (performance as any).memory\n      if (memInfo) {\n        memoryUsage = memInfo.usedJSHeapSize\n      }\n    } catch (error) {\n      // Memory API not available\n    }\n\n    return {\n      componentRenderTime: componentRenderTimes,\n      chartInitTime,\n      seriesCreationTime,\n      memoryUsage\n    }\n  }\n\n  /**\n   * Get performance summary\n   */\n  getSummary(): {\n    bundle: BundleMetrics\n    runtime: RuntimeMetrics\n    recommendations: string[]\n  } {\n    const bundle = this.getBundleMetrics()\n    const runtime = this.getRuntimeMetrics()\n    const recommendations: string[] = []\n\n    // Generate recommendations based on metrics\n    if (bundle.initialBundleSize > 1024 * 1024) { // > 1MB\n      recommendations.push('Consider code splitting to reduce initial bundle size')\n    }\n\n    if (bundle.cacheHitRate < 0.5) {\n      recommendations.push('Improve caching strategy for better performance')\n    }\n\n    if (runtime.chartInitTime > 1000) { // > 1 second\n      recommendations.push('Chart initialization is slow, consider lazy loading')\n    }\n\n    if (runtime.memoryUsage > 50 * 1024 * 1024) { // > 50MB\n      recommendations.push('High memory usage detected, check for memory leaks')\n    }\n\n    const avgRenderTime = Object.values(runtime.componentRenderTime)\n      .reduce((sum, time) => sum + time, 0) / Object.keys(runtime.componentRenderTime).length\n\n    if (avgRenderTime > 16) { // > 16ms (60fps threshold)\n      recommendations.push('Component render times are slow, consider optimization')\n    }\n\n    return {\n      bundle,\n      runtime,\n      recommendations\n    }\n  }\n\n  /**\n   * Setup performance observers\n   */\n  private setupObservers(): void {\n    try {\n      // Observe long tasks\n      if ('PerformanceObserver' in window) {\n        const longTaskObserver = new PerformanceObserver(list => {\n          list.getEntries().forEach(entry => {\n            this.recordMetric('longTask', entry.duration, 'runtime')\n          })\n        })\n        longTaskObserver.observe({ entryTypes: ['longtask'] })\n        this.observers.push(longTaskObserver)\n\n        // Observe layout shifts\n        const layoutShiftObserver = new PerformanceObserver(list => {\n          list.getEntries().forEach(entry => {\n            this.recordMetric('layoutShift', (entry as any).value, 'runtime')\n          })\n        })\n        layoutShiftObserver.observe({ entryTypes: ['layout-shift'] })\n        this.observers.push(layoutShiftObserver)\n      }\n    } catch (error) {\n      // Observers not supported\n    }\n  }\n\n  /**\n   * Start periodic monitoring\n   */\n  private startMonitoring(): void {\n    // Monitor memory usage periodically\n    const monitorMemory = () => {\n      try {\n        const memInfo = (performance as any).memory\n        if (memInfo) {\n          this.recordMetric('memoryUsage', memInfo.usedJSHeapSize, 'memory')\n        }\n      } catch (error) {\n        // Memory API not available\n      }\n    }\n\n    // Run every 30 seconds\n    setInterval(monitorMemory, 30000)\n    monitorMemory() // Initial measurement\n  }\n\n  /**\n   * Export metrics for analysis\n   */\n  exportMetrics(): string {\n    return JSON.stringify({\n      timestamp: Date.now(),\n      metrics: this.metrics,\n      summary: this.getSummary()\n    }, null, 2)\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clearMetrics(): void {\n    this.metrics = []\n  }\n}\n\n/**\n * Decorator for measuring function execution time\n */\nexport function measureExecutionTime(\n  target: any,\n  propertyName: string,\n  descriptor: PropertyDescriptor\n): PropertyDescriptor {\n  const method = descriptor.value\n\n  descriptor.value = function (...args: any[]) {\n    const monitor = PerformanceMonitor.getInstance()\n    const endTiming = monitor.startTiming(`${target.constructor.name}.${propertyName}`)\n\n    try {\n      const result = method.apply(this, args)\n\n      // Handle async functions\n      if (result && typeof result.then === 'function') {\n        return result.finally(() => endTiming())\n      }\n\n      endTiming()\n      return result\n    } catch (error) {\n      endTiming()\n      throw error\n    }\n  }\n\n  return descriptor\n}\n\n/**\n * Hook for measuring React component performance\n */\nexport function usePerformanceMonitoring(componentName: string) {\n  const monitor = PerformanceMonitor.getInstance()\n\n  React.useEffect(() => {\n    const endTiming = monitor.startTiming(`${componentName}.mount`)\n    return endTiming\n  }, [])\n\n  const measureRender = React.useCallback((renderFn: () => any) => {\n    return monitor.measureComponentRender(componentName, renderFn)\n  }, [componentName, monitor])\n\n  return { measureRender }\n}\n\n// Initialize monitoring in production\nif (process.env.NODE_ENV === 'production') {\n  PerformanceMonitor.getInstance().enable()\n}\n\nexport default PerformanceMonitor","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/resizeObserverManager.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'entry' is defined but never used. Allowed unused args must match /^_/u.","line":8,"column":6,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":56},{"ruleId":"no-unused-vars","severity":1,"message":"'entry' is defined but never used. Allowed unused args must match /^_/u.","line":17,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":66},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":107,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":107,"endColumn":41},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":130,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":41},{"ruleId":"no-unused-vars","severity":1,"message":"'observer' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":143,"endColumn":37},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":143,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Utility class for managing ResizeObservers with automatic cleanup\n */\nexport class ResizeObserverManager {\n  private observers = new Map<string, ResizeObserver>()\n  private callbacks = new Map<\n    string,\n    (entry: ResizeObserverEntry | ResizeObserverEntry[]) => void\n  >()\n\n  /**\n   * Add a resize observer for a specific target\n   */\n  addObserver(\n    id: string,\n    target: Element,\n    callback: (entry: ResizeObserverEntry | ResizeObserverEntry[]) => void,\n    options: {\n      throttleMs?: number\n      debounceMs?: number\n    } = {}\n  ): void {\n    // Remove existing observer if it exists\n    this.removeObserver(id)\n\n    const {throttleMs = 100, debounceMs = 0} = options\n\n    // Create throttled/debounced callback\n    let timeoutId: NodeJS.Timeout | null = null\n    let lastCallTime = 0\n\n    const wrappedCallback = (entry: ResizeObserverEntry) => {\n      const now = Date.now()\n\n      // Throttling\n      if (now - lastCallTime < throttleMs) {\n        return\n      }\n\n      // Debouncing\n      if (debounceMs > 0) {\n        if (timeoutId) {\n          clearTimeout(timeoutId)\n        }\n        timeoutId = setTimeout(() => {\n          callback(entry)\n          timeoutId = null\n        }, debounceMs)\n      } else {\n        callback(entry)\n        lastCallTime = now\n      }\n    }\n\n    try {\n      const observer = new ResizeObserver(entries => {\n        // Handle both single entry and array of entries\n        if (entries.length === 1) {\n          wrappedCallback(entries[0])\n        } else {\n          entries.forEach(wrappedCallback)\n        }\n      })\n\n      observer.observe(target)\n      this.observers.set(id, observer)\n      this.callbacks.set(id, callback)\n    } catch (error) {\n\n    }\n  }\n\n  /**\n   * Remove a specific observer\n   */\n  removeObserver(id: string): void {\n    const observer = this.observers.get(id)\n    if (observer) {\n      try {\n        observer.disconnect()\n        this.observers.delete(id)\n        this.callbacks.delete(id)\n      } catch (error) {\n\n      }\n    }\n  }\n\n  /**\n   * Check if an observer exists\n   */\n  hasObserver(id: string): boolean {\n    return this.observers.has(id)\n  }\n\n  /**\n   * Get the number of active observers\n   */\n  getObserverCount(): number {\n    return this.observers.size\n  }\n\n  /**\n   * Cleanup all observers\n   */\n  cleanup(): void {\n    this.observers.forEach((observer, id) => {\n      try {\n        observer.disconnect()\n      } catch (error) {\n\n      }\n    })\n\n    this.observers.clear()\n    this.callbacks.clear()\n  }\n\n  /**\n   * Get all observer IDs\n   */\n  getObserverIds(): string[] {\n    return Array.from(this.observers.keys())\n  }\n\n  /**\n   * Pause all observers temporarily\n   */\n  pauseAll(): void {\n    this.observers.forEach((observer, id) => {\n      try {\n        observer.disconnect()\n      } catch (error) {\n\n      }\n    })\n  }\n\n  /**\n   * Resume all observers\n   */\n  resumeAll(): void {\n    this.observers.forEach((observer, id) => {})\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]},{"filePath":"/Users/nandkapadia/streamlit-lightweight-charts-pro/streamlit_lightweight_charts_pro/frontend/src/utils/seriesFactory.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":422,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":422,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[15497,15551],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":429,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":429,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[15731,15786],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":436,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":436,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[15972,16030],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":450,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":450,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[16372,16429],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":651,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":651,"endColumn":67},{"ruleId":"no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":761,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":761,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {MutableRefObject} from 'react'\nimport {\n  IChartApi,\n  ISeriesApi,\n  AreaSeries,\n  LineSeries,\n  BarSeries,\n  CandlestickSeries,\n  HistogramSeries,\n  BaselineSeries,\n  createSeriesMarkers\n} from 'lightweight-charts'\nimport {SeriesConfig} from '../types'\nimport {createBandSeries, BandData} from '../plugins/series/bandSeriesPlugin'\nimport {SignalSeries, createSignalSeriesPlugin} from '../plugins/series/signalSeriesPlugin'\nimport {RibbonSeries} from '../plugins/series/ribbonSeriesPlugin'\nimport {createGradientRibbonSeries, GradientRibbonData} from '../plugins/series/gradientRibbonSeriesPlugin'\nimport {cleanLineStyleOptions} from './lineStyle'\nimport {createTradeVisualElements} from '../services/tradeVisualization'\n\ninterface SeriesFactoryContext {\n  signalPluginRefs?: MutableRefObject<{[key: string]: SignalSeries}>\n}\n\nexport function createSeries(\n  chart: IChartApi,\n  seriesConfig: SeriesConfig,\n  context: SeriesFactoryContext = {},\n  chartId?: string,\n  seriesIndex?: number\n): ISeriesApi<any> | null {\n  const {signalPluginRefs} = context\n\n  // Validate inputs - throw errors for invalid inputs\n  if (!chart) {\n    throw new Error('Chart is required')\n  }\n\n  if (!seriesConfig) {\n    throw new Error('Series configuration is required')\n  }\n\n  if (!seriesConfig.type) {\n    throw new Error('Series type is required')\n  }\n\n  // Check if chart has addSeries method\n  if (typeof chart.addSeries !== 'function') {\n    throw new Error('Chart does not have addSeries method')\n  }\n\n  const {\n    type,\n    data,\n    options = {},\n    priceScale,\n    lastValueVisible: topLevelLastValueVisible,\n    lastPriceAnimation,\n    priceLineVisible: topLevelPriceLineVisible,\n    priceLineSource: topLevelPriceLineSource,\n    priceLineWidth: topLevelPriceLineWidth,\n    priceLineColor: topLevelPriceLineColor,\n    priceLineStyle: topLevelPriceLineStyle,\n    priceScaleId: topLevelPriceScaleId\n  } = seriesConfig\n\n  const lastValueVisible =\n    topLevelLastValueVisible !== undefined ? topLevelLastValueVisible : options.lastValueVisible\n  const priceLineVisible =\n    topLevelPriceLineVisible !== undefined ? topLevelPriceLineVisible : options.priceLineVisible\n  const priceLineSource =\n    topLevelPriceLineSource !== undefined ? topLevelPriceLineSource : options.priceLineSource\n  const priceLineWidth =\n    topLevelPriceLineWidth !== undefined ? topLevelPriceLineWidth : options.priceLineWidth\n  const priceLineColor =\n    topLevelPriceLineColor !== undefined ? topLevelPriceLineColor : options.priceLineColor\n  const priceLineStyle =\n    topLevelPriceLineStyle !== undefined ? topLevelPriceLineStyle : options.priceLineStyle\n  const priceScaleId =\n    topLevelPriceScaleId !== undefined ? topLevelPriceScaleId : options.priceScaleId\n\n  // Extract paneId from seriesConfig and ensure it has a default value\n  const finalPaneId = seriesConfig.paneId !== undefined ? seriesConfig.paneId : 0\n\n  let series: ISeriesApi<any>\n  const normalizedType = type?.toLowerCase()\n  const {priceFormat, ...otherOptions} = options\n  const cleanedOptions = cleanLineStyleOptions(otherOptions)\n\n  // No Z-index needed - using Z-order system for primitives\n\n  switch (normalizedType) {\n    case 'area': {\n      const areaOptions: any = {\n        ...cleanedOptions,\n        lineColor: cleanedOptions.color || '#2196F3',\n        topColor: cleanedOptions.topColor || 'rgba(33, 150, 243, 0.4)',\n        bottomColor: cleanedOptions.bottomColor || 'rgba(33, 150, 243, 0.0)',\n        lineWidth: cleanedOptions.lineWidth || 2,\n        relativeGradient: cleanedOptions.relativeGradient || false,\n        invertFilledArea: cleanedOptions.invertFilledArea || false,\n        priceScaleId: priceScaleId || '',\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        lastPriceAnimation: lastPriceAnimation !== undefined ? lastPriceAnimation : 0,\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        areaOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(AreaSeries, areaOptions, finalPaneId)\n      try {\n        if (lastValueVisible === false) {\n          series.applyOptions({lastValueVisible: false})\n        }\n      } catch {\n        // ignore\n      }\n      break\n    }\n    case 'band': {\n      try {\n        const bandSeriesOptions: any = {\n          upperLine: cleanedOptions.upperLine || {\n            color: '#4CAF50',\n            lineStyle: 0,\n            lineWidth: 2,\n            lineVisible: true\n          },\n          middleLine: cleanedOptions.middleLine || {\n            color: '#2196F3',\n            lineStyle: 0,\n            lineWidth: 2,\n            lineVisible: true\n          },\n          lowerLine: cleanedOptions.lowerLine || {\n            color: '#F44336',\n            lineStyle: 0,\n            lineWidth: 2,\n            lineVisible: true\n          },\n          upperFillColor: cleanedOptions.upperFillColor || 'rgba(76, 175, 80, 0.1)',\n          lowerFillColor: cleanedOptions.lowerFillColor || 'rgba(244, 67, 54, 0.1)',\n          upperFill: cleanedOptions.upperFill !== undefined ? cleanedOptions.upperFill : true,\n          lowerFill: cleanedOptions.lowerFill !== undefined ? cleanedOptions.lowerFill : true,\n          priceScaleId: priceScaleId || 'right',\n          visible: cleanedOptions.visible !== false,\n          lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n          priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n          priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n          priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n          priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n          priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n        }\n        const bandSeries = createBandSeries(chart, bandSeriesOptions)\n        if (data && data.length > 0) {\n          bandSeries.setData(data as BandData[])\n        }\n        return {\n          setData: (newData: any[]) => {\n            try {\n              bandSeries.setData(newData as BandData[])\n            } catch {}\n          },\n          update: (newData: any) => {\n            try {\n              bandSeries.update(newData as BandData)\n            } catch {}\n          },\n          applyOptions: (options: any) => {\n            try {\n              bandSeries.setOptions(cleanLineStyleOptions(options))\n            } catch {}\n          },\n          priceScale: () => {\n            try {\n              return chart.priceScale(priceScaleId || 'right')\n            } catch {\n              return null\n            }\n          },\n          remove: () => {\n            try {\n              bandSeries.remove()\n            } catch {}\n          }\n        } as unknown as ISeriesApi<any>\n      } catch {\n        return null\n      }\n    }\n    case 'ribbon': {\n      try {\n        const ribbonSeriesOptions: any = {\n          upperLine: cleanedOptions.upperLine || {\n            color: '#4CAF50',\n            lineStyle: 0,\n            lineWidth: 2,\n            lineVisible: true\n          },\n          lowerLine: cleanedOptions.lowerLine || {\n            color: '#F44336',\n            lineStyle: 0,\n            lineWidth: 2,\n            lineVisible: true\n          },\n          fill: cleanedOptions.fill || 'rgba(76, 175, 80, 0.1)',\n          fillVisible: cleanedOptions.fillVisible !== false,\n          priceScaleId: priceScaleId || 'right',\n          visible: cleanedOptions.visible !== false,\n          lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n          priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n          priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n          priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n          priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n          priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n        }\n\n        const ribbonSeries = new RibbonSeries(chart, ribbonSeriesOptions)\n        if (data && data.length > 0) {\n          ribbonSeries.setData(data)\n        }\n\n        return {\n          setData: (newData: any[]) => {\n            try {\n              ribbonSeries.setData(newData)\n            } catch {}\n          },\n          update: (newData: any) => {\n            try {\n              // For ribbon, update the entire dataset\n              ribbonSeries.setData([newData])\n            } catch {}\n          },\n          applyOptions: (options: any) => {\n            try {\n              ribbonSeries.setOptions(cleanLineStyleOptions(options))\n            } catch {}\n          },\n          priceScale: () => {\n            try {\n              return chart.priceScale(priceScaleId || 'right')\n            } catch {\n              return null\n            }\n          },\n          remove: () => {\n            try {\n              // For primitives, we need to detach from the series\n              // The series will handle cleanup when removed\n            } catch {}\n          }\n        } as unknown as ISeriesApi<any>\n      } catch (error) {\n        return null\n      }\n    }\n    case 'gradient_ribbon': {\n      try {\n        // Map backend property names to frontend expected names\n        const mapLineOptions = (lineOpts: any, defaultColor: string = '#4CAF50') => {\n          if (!lineOpts) return {\n            color: defaultColor,\n            lineStyle: 0,\n            lineWidth: 2,\n            visible: true\n          }\n          return {\n            color: lineOpts.color || defaultColor,\n            lineStyle: lineOpts.lineStyle !== undefined ? lineOpts.lineStyle : (lineOpts.lineType || 0),\n            lineWidth: lineOpts.lineWidth || 2,\n            visible: lineOpts.visible !== undefined ? lineOpts.visible : (lineOpts.lineVisible !== false)\n          }\n        }\n\n        const gradientRibbonSeriesOptions: any = {\n          upperLine: mapLineOptions(cleanedOptions.upperLine, '#4CAF50'),\n          lowerLine: mapLineOptions(cleanedOptions.lowerLine, '#F44336'),\n          fill: cleanedOptions.fill || 'rgba(76, 175, 80, 0.3)',\n          fillVisible: cleanedOptions.fillVisible !== false,\n          gradientStartColor: cleanedOptions.gradientStartColor || '#4CAF50',\n          gradientEndColor: cleanedOptions.gradientEndColor || '#F44336',\n          normalizeGradients: cleanedOptions.normalizeGradients || false,\n          priceScaleId: priceScaleId || 'right',\n          visible: cleanedOptions.visible !== false,\n          zIndex: cleanedOptions.zIndex || 100\n        }\n\n        const gradientRibbonSeries = createGradientRibbonSeries(chart, gradientRibbonSeriesOptions)\n        if (data && data.length > 0) {\n          gradientRibbonSeries.setData(data as GradientRibbonData[])\n        }\n\n        return {\n          setData: (newData: any[]) => {\n            try {\n              gradientRibbonSeries.setData(newData as GradientRibbonData[])\n            } catch {}\n          },\n          update: (newData: any) => {\n            try {\n              gradientRibbonSeries.updateData([newData])\n            } catch {}\n          },\n          applyOptions: (options: any) => {\n            try {\n              gradientRibbonSeries.applyOptions(cleanLineStyleOptions(options))\n            } catch {}\n          },\n          priceScale: () => {\n            try {\n              return chart.priceScale(priceScaleId || 'right')\n            } catch {\n              return null\n            }\n          },\n          remove: () => {\n            try {\n              gradientRibbonSeries.destroy()\n            } catch {}\n          }\n        } as unknown as ISeriesApi<any>\n      } catch (error) {\n        return null\n      }\n    }\n    case 'signal': {\n      try {\n        const signalSeries = createSignalSeriesPlugin(chart, {\n          type: 'signal',\n          data: data || [],\n          options: {\n            neutralColor: cleanedOptions.neutralColor || '#f0f0f0',\n            signalColor: cleanedOptions.signalColor || '#ff0000',\n            alertColor: cleanedOptions.alertColor,\n            visible: cleanedOptions.visible !== false\n          },\n          paneId: finalPaneId\n        })\n        if (signalPluginRefs && chartId !== undefined && seriesIndex !== undefined) {\n          signalPluginRefs.current[`${chartId}-${seriesIndex}`] = signalSeries\n        }\n        return {\n          setData: (newData: any[]) => {\n            try {\n              signalSeries.updateData(newData)\n            } catch {}\n          },\n          update: (newData: any) => {\n            try {\n              signalSeries.updateData([newData])\n            } catch {}\n          },\n          applyOptions: (options: any) => {\n            try {\n              signalSeries.updateOptions({\n                neutralColor: options.neutralColor || '#f0f0f0',\n                signalColor: options.signalColor || '#ff0000',\n                alertColor: options.alertColor,\n                visible: options.visible !== false\n              })\n            } catch {}\n          },\n          priceScale: () => {\n            try {\n              return chart.priceScale(priceScaleId || 'right')\n            } catch {\n              return null\n            }\n          },\n          remove: () => {\n            try {\n              signalSeries.destroy()\n              if (signalPluginRefs && chartId !== undefined && seriesIndex !== undefined) {\n                delete signalPluginRefs.current[`${chartId}-${seriesIndex}`]\n              }\n            } catch {}\n          }\n        } as unknown as ISeriesApi<any>\n      } catch {\n        return null\n      }\n    }\n    case 'trend_fill': {\n      try {\n        // Create the trend fill series directly (following band series pattern)\n        const trendFillOptions = {\n          uptrendFillColor: cleanedOptions.uptrendFillColor || 'rgba(76, 175, 80, 0.3)',\n          downtrendFillColor: cleanedOptions.downtrendFillColor || 'rgba(244, 67, 54, 0.3)',\n          trendLine: {\n            color: cleanedOptions.trendLine?.color || '#4CAF50',\n            lineWidth: cleanedOptions.trendLine?.lineWidth || 2,\n            lineStyle: cleanedOptions.trendLine?.lineStyle || 0,\n            visible: cleanedOptions.trendLine?.visible !== false\n          },\n          baseLine: {\n            color: cleanedOptions.baseLine?.color || '#666666',\n            lineWidth: cleanedOptions.baseLine?.lineWidth || 1,\n            lineStyle: cleanedOptions.baseLine?.lineStyle || 1,\n            visible: cleanedOptions.baseLine?.visible !== false\n          },\n          visible: cleanedOptions.visible !== false,\n          priceScaleId: cleanedOptions.priceScaleId || 'right'\n        }\n\n        // Create the primitive series directly (no dummy series needed)\n        const { TrendFillSeries } = require('../plugins/series/trendFillSeriesPlugin')\n        const trendFillSeries = new TrendFillSeries(chart, trendFillOptions, 0)\n\n        // Set the data\n        trendFillSeries.setData(data || [])\n\n        return {\n          setData: (newData: any[]) => {\n            try {\n              trendFillSeries.setData(newData)\n            } catch (error) {\n              console.error('Error setting trend fill data:', error)\n            }\n          },\n          update: (newData: any) => {\n            try {\n              trendFillSeries.updateData([newData])\n            } catch (error) {\n              console.error('Error updating trend fill data:', error)\n            }\n          },\n          applyOptions: (options: any) => {\n            try {\n              trendFillSeries.applyOptions(options)\n            } catch (error) {\n              console.error('Error applying trend fill options:', error)\n            }\n          },\n          priceScale: () => {\n            try {\n              return chart.priceScale(priceScaleId || 'right')\n            } catch {\n              return null\n            }\n          },\n          remove: () => {\n            try {\n              trendFillSeries.destroy()\n            } catch (error) {\n              console.error('Error removing trend fill series:', error)\n            }\n          }\n        } as unknown as ISeriesApi<any>\n      } catch (error) {\n        return null\n      }\n    }\n    case 'baseline': {\n      const baselineOptions: any = {\n        ...cleanedOptions,\n        baseValue: cleanedOptions.baseValue || {price: 0},\n        topLineColor: cleanedOptions.topLineColor || 'rgba(76, 175, 80, 0.4)',\n        topFillColor1: cleanedOptions.topFillColor1 || 'rgba(76, 175, 80, 0.0)',\n        topFillColor2: cleanedOptions.topFillColor2 || 'rgba(76, 175, 80, 0.4)',\n        bottomLineColor: cleanedOptions.bottomLineColor || 'rgba(255, 82, 82, 0.4)',\n        bottomFillColor1: cleanedOptions.bottomFillColor1 || 'rgba(255, 82, 82, 0.4)',\n        bottomFillColor2: cleanedOptions.bottomFillColor2 || 'rgba(255, 82, 82, 0.0)',\n        lineWidth: cleanedOptions.lineWidth || 2,\n        priceScaleId: priceScaleId || '',\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        baselineOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(BaselineSeries, baselineOptions, finalPaneId)\n      break\n    }\n    case 'histogram': {\n      // Check if data contains individual colors - FIXED VERSION\n      const hasIndividualColors =\n        seriesConfig.data && seriesConfig.data.some((point: any) => point.color)\n\n      const histogramOptions: any = {\n        ...cleanedOptions,\n        priceFormat: priceFormat || {\n          type: 'volume'\n        },\n        priceScaleId: priceScaleId || '',\n        scaleMargins: cleanedOptions.scaleMargins || {\n          top: 0.75,\n          bottom: 0\n        },\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        // Only set static color if no individual colors are present in data\n        color: hasIndividualColors ? undefined : cleanedOptions.color || '#2196F3',\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        histogramOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(HistogramSeries, histogramOptions, finalPaneId)\n      break\n    }\n    case 'line': {\n      // Process lineOptions if provided\n      const lineSpecificOptions = seriesConfig.lineOptions || {}\n\n      const lineOptions: any = {\n        ...cleanedOptions,\n        // Apply line-specific options from lineOptions object\n        lineStyle:\n          lineSpecificOptions.lineStyle !== undefined\n            ? lineSpecificOptions.lineStyle\n            : cleanedOptions.lineStyle,\n        lineType:\n          lineSpecificOptions.lineType !== undefined\n            ? lineSpecificOptions.lineType\n            : cleanedOptions.lineType,\n        lineVisible:\n          lineSpecificOptions.lineVisible !== undefined\n            ? lineSpecificOptions.lineVisible\n            : cleanedOptions.lineVisible,\n        pointMarkersVisible:\n          lineSpecificOptions.pointMarkersVisible !== undefined\n            ? lineSpecificOptions.pointMarkersVisible\n            : cleanedOptions.pointMarkersVisible,\n        pointMarkersRadius:\n          lineSpecificOptions.pointMarkersRadius !== undefined\n            ? lineSpecificOptions.pointMarkersRadius\n            : cleanedOptions.crosshairMarkerRadius,\n        crosshairMarkerVisible:\n          lineSpecificOptions.crosshairMarkerVisible !== undefined\n            ? lineSpecificOptions.crosshairMarkerVisible\n            : cleanedOptions.crosshairMarkerVisible,\n        crosshairMarkerRadius:\n          lineSpecificOptions.crosshairMarkerRadius !== undefined\n            ? lineSpecificOptions.crosshairMarkerRadius\n            : cleanedOptions.crosshairMarkerRadius,\n        crosshairMarkerBorderColor:\n          lineSpecificOptions.crosshairMarkerBorderColor !== undefined\n            ? lineSpecificOptions.crosshairMarkerBorderColor\n            : cleanedOptions.crosshairMarkerBorderColor,\n        crosshairMarkerBackgroundColor:\n          lineSpecificOptions.crosshairMarkerBackgroundColor !== undefined\n            ? lineSpecificOptions.crosshairMarkerBackgroundColor\n            : cleanedOptions.crosshairMarkerBackgroundColor,\n        crosshairMarkerBorderWidth:\n          lineSpecificOptions.crosshairMarkerBorderWidth !== undefined\n            ? lineSpecificOptions.crosshairMarkerBorderWidth\n            : cleanedOptions.crosshairMarkerBorderWidth,\n        lastPriceAnimation:\n          lineSpecificOptions.lastPriceAnimation !== undefined\n            ? lineSpecificOptions.lastPriceAnimation\n            : lastPriceAnimation,\n        // Default values\n        color: cleanedOptions.color || '#2196F3', // Restore original default color\n        lineWidth: cleanedOptions.lineWidth || 2,\n        crossHairMarkerVisible:\n          lineSpecificOptions.crosshairMarkerVisible !== undefined\n            ? lineSpecificOptions.crosshairMarkerVisible\n            : cleanedOptions.crossHairMarkerVisible !== undefined\n              ? cleanedOptions.crossHairMarkerVisible\n              : true,\n        priceScaleId: priceScaleId || '',\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        lineOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(LineSeries, lineOptions, finalPaneId)\n\n      // Apply lastValueVisible: false after series creation if needed\n      try {\n        if (lastValueVisible === false) {\n          series.applyOptions({lastValueVisible: false})\n        }\n      } catch {\n        // ignore\n      }\n      break\n    }\n    case 'bar': {\n      const barOptions: any = {\n        ...cleanedOptions,\n        upColor: cleanedOptions.upColor || '#4CAF50',\n        downColor: cleanedOptions.downColor || '#F44336',\n        openVisible: cleanedOptions.openVisible || false,\n        priceScaleId: priceScaleId || '',\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        barOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(BarSeries, barOptions, finalPaneId)\n      break\n    }\n    case 'candlestick': {\n      const candlestickOptions: any = {\n        ...cleanedOptions,\n        upColor: cleanedOptions.upColor || '#4CAF50',\n        downColor: cleanedOptions.downColor || '#F44336',\n        borderVisible: cleanedOptions.borderVisible !== false,\n        wickUpColor: cleanedOptions.wickUpColor || '#4CAF50',\n        wickDownColor: cleanedOptions.wickDownColor || '#F44336',\n        priceScaleId: priceScaleId || '',\n        lastValueVisible: lastValueVisible !== undefined ? lastValueVisible : true,\n        priceLineVisible: priceLineVisible !== undefined ? priceLineVisible : true,\n        priceLineSource: priceLineSource !== undefined ? priceLineSource : 'lastBar',\n        priceLineWidth: priceLineWidth !== undefined ? priceLineWidth : 1,\n        priceLineColor: priceLineColor !== undefined ? priceLineColor : '',\n        priceLineStyle: priceLineStyle !== undefined ? priceLineStyle : 2\n      }\n      if (priceFormat) {\n        candlestickOptions.priceFormat = priceFormat\n      }\n      series = chart.addSeries(CandlestickSeries, candlestickOptions, finalPaneId)\n      break\n    }\n    default:\n      throw new Error(`Invalid series type: ${type}`)\n  }\n\n  if (priceScale) {\n    series.priceScale().applyOptions(cleanLineStyleOptions(priceScale))\n  }\n\n  if (data && data.length > 0) {\n    series.setData(data)\n  }\n\n  if (seriesConfig.priceLines && Array.isArray(seriesConfig.priceLines)) {\n    seriesConfig.priceLines.forEach((priceLine: any, index: number) => {\n      try {\n        series.createPriceLine(priceLine)\n      } catch (error) {\n        // Failed to create price line\n      }\n    })\n  }\n\n  if (seriesConfig.markers && Array.isArray(seriesConfig.markers)) {\n    try {\n      // Apply timestamp snapping to all markers (like trade visualization)\n      const snappedMarkers = applyTimestampSnapping(seriesConfig.markers, data)\n      createSeriesMarkers(series, snappedMarkers)\n    } catch (error) {\n      // Error handling\n    }\n  }\n\n  // Store paneId as a property on the series object for legend functionality\n  if (finalPaneId !== undefined) {\n    ;(series as any).paneId = finalPaneId\n  }\n\n  // Handle series legend if configured - add directly to the correct PaneLegendManager\n  if (seriesConfig.legend && seriesConfig.legend.visible) {\n    const seriesId = `${chartId || 'default'}-series-${seriesIndex || 0}`\n\n    // Store legend config on the series for reference\n    ;(series as any).legendConfig = seriesConfig.legend\n    ;(series as any).seriesId = seriesId\n\n    // Add legend directly to the correct PaneLegendManager\n    try {\n      const legendManager = (window as any).paneLegendManagers?.[chartId]?.[finalPaneId]\n      if (legendManager) {\n        legendManager.addSeriesLegend(seriesId, seriesConfig)\n      }\n    } catch (error) {\n      // Error adding legend\n    }\n  }\n\n  // Add trade visualization if configured for this series\n  if (\n    seriesConfig.trades &&\n    seriesConfig.tradeVisualizationOptions &&\n    seriesConfig.trades.length > 0\n  ) {\n    try {\n      // Create trade visual elements (markers, rectangles, annotations)\n      const tradeOptions = seriesConfig.tradeVisualizationOptions\n      const visualElements = createTradeVisualElements(seriesConfig.trades, tradeOptions, data)\n\n      // Add trade markers to the series\n      if (visualElements.markers && visualElements.markers.length > 0) {\n        createSeriesMarkers(series, visualElements.markers)\n      }\n\n      // Store rectangle data for later processing by the chart component\n      if (visualElements.rectangles && visualElements.rectangles.length > 0) {\n        // Store the rectangle data in the chart for later processing\n        if (!(chart as any)._pendingTradeRectangles) {\n          ;(chart as any)._pendingTradeRectangles = []\n        }\n        ;(chart as any)._pendingTradeRectangles.push({\n          rectangles: visualElements.rectangles,\n          series: series,\n          chartId: chartId\n        })\n      }\n    } catch (error) {\n      // Error processing trades\n    }\n  }\n\n  return series\n}\n\n/**\n * Apply timestamp snapping to markers to ensure they align with chart data.\n * This function implements the same logic as the trade visualization system\n * but applies it to all markers, not just trade markers.\n *\n * @param markers Array of markers to snap\n * @param chartData Chart data for timestamp reference\n * @returns Array of markers with snapped timestamps\n */\nfunction applyTimestampSnapping(markers: any[], chartData?: any[]): any[] {\n  if (!chartData || chartData.length === 0) {\n    return markers\n  }\n\n  // Extract available timestamps from chart data\n  const availableTimes = chartData\n    .map(item => {\n      if (typeof item.time === 'number') {\n        return item.time\n      } else if (typeof item.time === 'string') {\n        return Math.floor(new Date(item.time).getTime() / 1000)\n      }\n      return null\n    })\n    .filter(time => time !== null)\n\n  if (availableTimes.length === 0) {\n    return markers\n  }\n\n  // Apply timestamp snapping to each marker\n  const snappedMarkers = markers.map((marker, index) => {\n    if (marker.time && typeof marker.time === 'number') {\n      // Find nearest available timestamp\n      const nearestTime = availableTimes.reduce((nearest, current) => {\n        const currentDiff = Math.abs(current - marker.time)\n        const nearestDiff = Math.abs(nearest - marker.time)\n        return currentDiff < nearestDiff ? current : nearest\n      })\n\n      // Return marker with snapped timestamp\n      return {\n        ...marker,\n        time: nearestTime\n      }\n    } else {\n      return marker\n    }\n  })\n\n  return snappedMarkers\n}\n","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]}]